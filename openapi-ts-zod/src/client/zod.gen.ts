// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

export const zRoot = z.object({
    current_user_url: z.string(),
    current_user_authorizations_html_url: z.string(),
    authorizations_url: z.string(),
    code_search_url: z.string(),
    commit_search_url: z.string(),
    emails_url: z.string(),
    emojis_url: z.string(),
    events_url: z.string(),
    feeds_url: z.string(),
    followers_url: z.string(),
    following_url: z.string(),
    gists_url: z.string(),
    hub_url: z.optional(z.string()),
    issue_search_url: z.string(),
    issues_url: z.string(),
    keys_url: z.string(),
    label_search_url: z.string(),
    notifications_url: z.string(),
    organization_url: z.string(),
    organization_repositories_url: z.string(),
    organization_teams_url: z.string(),
    public_gists_url: z.string(),
    rate_limit_url: z.string(),
    repository_url: z.string(),
    repository_search_url: z.string(),
    current_user_repositories_url: z.string(),
    starred_url: z.string(),
    starred_gists_url: z.string(),
    topic_search_url: z.optional(z.string()),
    user_url: z.string(),
    user_organizations_url: z.string(),
    user_repositories_url: z.string(),
    user_search_url: z.string()
});

/**
 * The package's language or package management ecosystem.
 */
export const zSecurityAdvisoryEcosystems = z.enum([
    'rubygems',
    'npm',
    'pip',
    'maven',
    'nuget',
    'composer',
    'go',
    'rust',
    'erlang',
    'actions',
    'pub',
    'other',
    'swift'
]);

/**
 * A vulnerability describing the product and its affected versions within a GitHub Security Advisory.
 */
export const zVulnerability = z.object({
    package: z.union([
        z.object({
            ecosystem: zSecurityAdvisoryEcosystems,
            name: z.union([
                z.string(),
                z.null()
            ])
        }),
        z.null()
    ]),
    vulnerable_version_range: z.union([
        z.string(),
        z.null()
    ]),
    first_patched_version: z.union([
        z.string(),
        z.null()
    ]),
    vulnerable_functions: z.union([
        z.array(z.string()).readonly(),
        z.null()
    ]).readonly()
});

export const zCvssSeverities = z.union([
    z.object({
        cvss_v3: z.optional(z.union([
            z.object({
                vector_string: z.union([
                    z.string(),
                    z.null()
                ]),
                score: z.union([
                    z.number().gte(0).lte(10).readonly(),
                    z.null()
                ]).readonly()
            }),
            z.null()
        ])),
        cvss_v4: z.optional(z.union([
            z.object({
                vector_string: z.union([
                    z.string(),
                    z.null()
                ]),
                score: z.union([
                    z.number().gte(0).lte(10).readonly(),
                    z.null()
                ]).readonly()
            }),
            z.null()
        ]))
    }),
    z.null()
]);

/**
 * The EPSS scores as calculated by the [Exploit Prediction Scoring System](https://www.first.org/epss).
 */
export const zSecurityAdvisoryEpss = z.union([
    z.object({
        percentage: z.optional(z.number().gte(0).lte(100)),
        percentile: z.optional(z.number().gte(0).lte(100))
    }).readonly(),
    z.null()
]).readonly();

/**
 * Simple User
 *
 * A GitHub user.
 */
export const zSimpleUser = z.object({
    name: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    email: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    login: z.string(),
    id: z.coerce.bigint(),
    node_id: z.string(),
    avatar_url: z.url(),
    gravatar_id: z.union([
        z.string(),
        z.null()
    ]),
    url: z.url(),
    html_url: z.url(),
    followers_url: z.url(),
    following_url: z.string(),
    gists_url: z.string(),
    starred_url: z.string(),
    subscriptions_url: z.url(),
    organizations_url: z.url(),
    repos_url: z.url(),
    events_url: z.string(),
    received_events_url: z.url(),
    type: z.string(),
    site_admin: z.boolean(),
    starred_at: z.optional(z.string()),
    user_view_type: z.optional(z.string())
});

/**
 * The type of credit the user is receiving.
 */
export const zSecurityAdvisoryCreditTypes = z.enum([
    'analyst',
    'finder',
    'reporter',
    'coordinator',
    'remediation_developer',
    'remediation_reviewer',
    'remediation_verifier',
    'tool',
    'sponsor',
    'other'
]);

/**
 * A GitHub Security Advisory.
 */
export const zGlobalAdvisory = z.object({
    ghsa_id: z.string().readonly(),
    cve_id: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    url: z.string().readonly(),
    html_url: z.url().readonly(),
    repository_advisory_url: z.union([
        z.url().readonly(),
        z.null()
    ]).readonly(),
    summary: z.string().max(1024),
    description: z.union([
        z.string().max(65535),
        z.null()
    ]),
    type: z.enum([
        'reviewed',
        'unreviewed',
        'malware'
    ]),
    severity: z.enum([
        'critical',
        'high',
        'medium',
        'low',
        'unknown'
    ]),
    source_code_location: z.union([
        z.url(),
        z.null()
    ]),
    identifiers: z.union([
        z.array(z.object({
            type: z.enum([
                'CVE',
                'GHSA'
            ]),
            value: z.string()
        })).readonly(),
        z.null()
    ]).readonly(),
    references: z.union([
        z.array(z.string()),
        z.null()
    ]),
    published_at: z.iso.datetime().readonly(),
    updated_at: z.iso.datetime().readonly(),
    github_reviewed_at: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    nvd_published_at: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    withdrawn_at: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    vulnerabilities: z.union([
        z.array(zVulnerability),
        z.null()
    ]),
    cvss: z.union([
        z.object({
            vector_string: z.union([
                z.string(),
                z.null()
            ]),
            score: z.union([
                z.number().gte(0).lte(10).readonly(),
                z.null()
            ]).readonly()
        }),
        z.null()
    ]),
    cvss_severities: z.optional(zCvssSeverities),
    epss: z.optional(zSecurityAdvisoryEpss),
    cwes: z.union([
        z.array(z.object({
            cwe_id: z.string(),
            name: z.string().readonly()
        })),
        z.null()
    ]),
    credits: z.union([
        z.array(z.object({
            user: zSimpleUser,
            type: zSecurityAdvisoryCreditTypes
        })).readonly(),
        z.null()
    ]).readonly()
});

/**
 * Basic Error
 *
 * Basic Error
 */
export const zBasicError = z.object({
    message: z.optional(z.string()),
    documentation_url: z.optional(z.string()),
    url: z.optional(z.string()),
    status: z.optional(z.string())
});

/**
 * Validation Error Simple
 *
 * Validation Error Simple
 */
export const zValidationErrorSimple = z.object({
    message: z.string(),
    documentation_url: z.string(),
    errors: z.optional(z.array(z.string()))
});

/**
 * Enterprise
 *
 * An enterprise on GitHub.
 */
export const zEnterprise = z.object({
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    html_url: z.url(),
    website_url: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    id: z.int(),
    node_id: z.string(),
    name: z.string(),
    slug: z.string(),
    created_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    updated_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    avatar_url: z.url()
});

/**
 * GitHub app
 *
 * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
 */
export const zIntegration = z.union([
    z.object({
        id: z.int(),
        slug: z.optional(z.string()),
        node_id: z.string(),
        client_id: z.optional(z.string()),
        owner: z.union([
            zSimpleUser,
            zEnterprise
        ]),
        name: z.string(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        external_url: z.url(),
        html_url: z.url(),
        created_at: z.iso.datetime(),
        updated_at: z.iso.datetime(),
        permissions: z.object({
            issues: z.optional(z.string()),
            checks: z.optional(z.string()),
            metadata: z.optional(z.string()),
            contents: z.optional(z.string()),
            deployments: z.optional(z.string())
        }),
        events: z.array(z.string()),
        installations_count: z.optional(z.int())
    }),
    z.null()
]);

/**
 * The URL to which the payloads will be delivered.
 */
export const zWebhookConfigUrl = z.url();

/**
 * The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
 */
export const zWebhookConfigContentType = z.string();

/**
 * If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).
 */
export const zWebhookConfigSecret = z.string();

export const zWebhookConfigInsecureSsl = z.union([
    z.string(),
    z.number()
]);

/**
 * Webhook Configuration
 *
 * Configuration object of the webhook
 */
export const zWebhookConfig = z.object({
    url: z.optional(zWebhookConfigUrl),
    content_type: z.optional(zWebhookConfigContentType),
    secret: z.optional(zWebhookConfigSecret),
    insecure_ssl: z.optional(zWebhookConfigInsecureSsl)
});

/**
 * Simple webhook delivery
 *
 * Delivery made by a webhook, without request and response information.
 */
export const zHookDeliveryItem = z.object({
    id: z.coerce.bigint(),
    guid: z.string(),
    delivered_at: z.iso.datetime(),
    redelivery: z.boolean(),
    duration: z.number(),
    status: z.string(),
    status_code: z.int(),
    event: z.string(),
    action: z.union([
        z.string(),
        z.null()
    ]),
    installation_id: z.union([
        z.coerce.bigint(),
        z.null()
    ]),
    repository_id: z.union([
        z.coerce.bigint(),
        z.null()
    ]),
    throttled_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ]))
});

/**
 * Scim Error
 *
 * Scim Error
 */
export const zScimError = z.object({
    message: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    documentation_url: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    detail: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    status: z.optional(z.int()),
    scimType: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    schemas: z.optional(z.array(z.string()))
});

/**
 * Validation Error
 *
 * Validation Error
 */
export const zValidationError = z.object({
    message: z.string(),
    documentation_url: z.string(),
    errors: z.optional(z.array(z.object({
        resource: z.optional(z.string()),
        field: z.optional(z.string()),
        message: z.optional(z.string()),
        code: z.string(),
        index: z.optional(z.int()),
        value: z.optional(z.union([
            z.string(),
            z.null(),
            z.int(),
            z.array(z.string())
        ]))
    })))
});

/**
 * Webhook delivery
 *
 * Delivery made by a webhook.
 */
export const zHookDelivery = z.object({
    id: z.int(),
    guid: z.string(),
    delivered_at: z.iso.datetime(),
    redelivery: z.boolean(),
    duration: z.number(),
    status: z.string(),
    status_code: z.int(),
    event: z.string(),
    action: z.union([
        z.string(),
        z.null()
    ]),
    installation_id: z.union([
        z.int(),
        z.null()
    ]),
    repository_id: z.union([
        z.int(),
        z.null()
    ]),
    throttled_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    url: z.optional(z.string()),
    request: z.object({
        headers: z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]),
        payload: z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ])
    }),
    response: z.object({
        headers: z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]),
        payload: z.union([
            z.string(),
            z.null()
        ])
    })
});

/**
 * Integration Installation Request
 *
 * Request to install an integration on a target
 */
export const zIntegrationInstallationRequest = z.object({
    id: z.int(),
    node_id: z.optional(z.string()),
    account: z.union([
        zSimpleUser,
        zEnterprise
    ]),
    requester: zSimpleUser,
    created_at: z.iso.datetime()
});

/**
 * App Permissions
 *
 * The permissions granted to the user access token.
 */
export const zAppPermissions = z.object({
    actions: z.optional(z.enum([
        'read',
        'write'
    ])),
    administration: z.optional(z.enum([
        'read',
        'write'
    ])),
    checks: z.optional(z.enum([
        'read',
        'write'
    ])),
    codespaces: z.optional(z.enum([
        'read',
        'write'
    ])),
    contents: z.optional(z.enum([
        'read',
        'write'
    ])),
    dependabot_secrets: z.optional(z.enum([
        'read',
        'write'
    ])),
    deployments: z.optional(z.enum([
        'read',
        'write'
    ])),
    environments: z.optional(z.enum([
        'read',
        'write'
    ])),
    issues: z.optional(z.enum([
        'read',
        'write'
    ])),
    metadata: z.optional(z.enum([
        'read',
        'write'
    ])),
    packages: z.optional(z.enum([
        'read',
        'write'
    ])),
    pages: z.optional(z.enum([
        'read',
        'write'
    ])),
    pull_requests: z.optional(z.enum([
        'read',
        'write'
    ])),
    repository_custom_properties: z.optional(z.enum([
        'read',
        'write'
    ])),
    repository_hooks: z.optional(z.enum([
        'read',
        'write'
    ])),
    repository_projects: z.optional(z.enum([
        'read',
        'write',
        'admin'
    ])),
    secret_scanning_alerts: z.optional(z.enum([
        'read',
        'write'
    ])),
    secrets: z.optional(z.enum([
        'read',
        'write'
    ])),
    security_events: z.optional(z.enum([
        'read',
        'write'
    ])),
    single_file: z.optional(z.enum([
        'read',
        'write'
    ])),
    statuses: z.optional(z.enum([
        'read',
        'write'
    ])),
    vulnerability_alerts: z.optional(z.enum([
        'read',
        'write'
    ])),
    workflows: z.optional(z.enum([
        'write'
    ])),
    custom_properties_for_organizations: z.optional(z.enum([
        'read',
        'write'
    ])),
    members: z.optional(z.enum([
        'read',
        'write'
    ])),
    organization_administration: z.optional(z.enum([
        'read',
        'write'
    ])),
    organization_custom_roles: z.optional(z.enum([
        'read',
        'write'
    ])),
    organization_custom_org_roles: z.optional(z.enum([
        'read',
        'write'
    ])),
    organization_custom_properties: z.optional(z.enum([
        'read',
        'write',
        'admin'
    ])),
    organization_copilot_seat_management: z.optional(z.enum([
        'write'
    ])),
    organization_announcement_banners: z.optional(z.enum([
        'read',
        'write'
    ])),
    organization_events: z.optional(z.enum([
        'read'
    ])),
    organization_hooks: z.optional(z.enum([
        'read',
        'write'
    ])),
    organization_personal_access_tokens: z.optional(z.enum([
        'read',
        'write'
    ])),
    organization_personal_access_token_requests: z.optional(z.enum([
        'read',
        'write'
    ])),
    organization_plan: z.optional(z.enum([
        'read'
    ])),
    organization_projects: z.optional(z.enum([
        'read',
        'write',
        'admin'
    ])),
    organization_packages: z.optional(z.enum([
        'read',
        'write'
    ])),
    organization_secrets: z.optional(z.enum([
        'read',
        'write'
    ])),
    organization_self_hosted_runners: z.optional(z.enum([
        'read',
        'write'
    ])),
    organization_user_blocking: z.optional(z.enum([
        'read',
        'write'
    ])),
    team_discussions: z.optional(z.enum([
        'read',
        'write'
    ])),
    email_addresses: z.optional(z.enum([
        'read',
        'write'
    ])),
    followers: z.optional(z.enum([
        'read',
        'write'
    ])),
    git_ssh_keys: z.optional(z.enum([
        'read',
        'write'
    ])),
    gpg_keys: z.optional(z.enum([
        'read',
        'write'
    ])),
    interaction_limits: z.optional(z.enum([
        'read',
        'write'
    ])),
    profile: z.optional(z.enum([
        'write'
    ])),
    starring: z.optional(z.enum([
        'read',
        'write'
    ])),
    enterprise_custom_properties_for_organizations: z.optional(z.enum([
        'read',
        'write',
        'admin'
    ]))
});

/**
 * Simple User
 *
 * A GitHub user.
 */
export const zNullableSimpleUser = z.union([
    z.object({
        name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        email: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        login: z.string(),
        id: z.coerce.bigint(),
        node_id: z.string(),
        avatar_url: z.url(),
        gravatar_id: z.union([
            z.string(),
            z.null()
        ]),
        url: z.url(),
        html_url: z.url(),
        followers_url: z.url(),
        following_url: z.string(),
        gists_url: z.string(),
        starred_url: z.string(),
        subscriptions_url: z.url(),
        organizations_url: z.url(),
        repos_url: z.url(),
        events_url: z.string(),
        received_events_url: z.url(),
        type: z.string(),
        site_admin: z.boolean(),
        starred_at: z.optional(z.string()),
        user_view_type: z.optional(z.string())
    }),
    z.null()
]);

/**
 * Installation
 *
 * Installation
 */
export const zInstallation = z.object({
    id: z.int(),
    account: z.union([
        zSimpleUser,
        zEnterprise,
        z.null()
    ]),
    repository_selection: z.enum([
        'all',
        'selected'
    ]),
    access_tokens_url: z.url(),
    repositories_url: z.url(),
    html_url: z.url(),
    app_id: z.int(),
    client_id: z.optional(z.string()),
    target_id: z.int(),
    target_type: z.string(),
    permissions: zAppPermissions,
    events: z.array(z.string()),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    single_file_name: z.union([
        z.string(),
        z.null()
    ]),
    has_multiple_single_files: z.optional(z.boolean()),
    single_file_paths: z.optional(z.array(z.string())),
    app_slug: z.string(),
    suspended_by: zNullableSimpleUser,
    suspended_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    contact_email: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

/**
 * License Simple
 *
 * License Simple
 */
export const zNullableLicenseSimple = z.union([
    z.object({
        key: z.string(),
        name: z.string(),
        url: z.union([
            z.url(),
            z.null()
        ]),
        spdx_id: z.union([
            z.string(),
            z.null()
        ]),
        node_id: z.string(),
        html_url: z.optional(z.url())
    }),
    z.null()
]);

/**
 * Repository
 *
 * A repository on GitHub.
 */
export const zRepository = z.object({
    id: z.coerce.bigint(),
    node_id: z.string(),
    name: z.string(),
    full_name: z.string(),
    license: zNullableLicenseSimple,
    forks: z.int(),
    permissions: z.optional(z.object({
        admin: z.boolean(),
        pull: z.boolean(),
        triage: z.optional(z.boolean()),
        push: z.boolean(),
        maintain: z.optional(z.boolean())
    })),
    owner: zSimpleUser,
    private: z.boolean().default(false),
    html_url: z.url(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    fork: z.boolean(),
    url: z.url(),
    archive_url: z.string(),
    assignees_url: z.string(),
    blobs_url: z.string(),
    branches_url: z.string(),
    collaborators_url: z.string(),
    comments_url: z.string(),
    commits_url: z.string(),
    compare_url: z.string(),
    contents_url: z.string(),
    contributors_url: z.url(),
    deployments_url: z.url(),
    downloads_url: z.url(),
    events_url: z.url(),
    forks_url: z.url(),
    git_commits_url: z.string(),
    git_refs_url: z.string(),
    git_tags_url: z.string(),
    git_url: z.string(),
    issue_comment_url: z.string(),
    issue_events_url: z.string(),
    issues_url: z.string(),
    keys_url: z.string(),
    labels_url: z.string(),
    languages_url: z.url(),
    merges_url: z.url(),
    milestones_url: z.string(),
    notifications_url: z.string(),
    pulls_url: z.string(),
    releases_url: z.string(),
    ssh_url: z.string(),
    stargazers_url: z.url(),
    statuses_url: z.string(),
    subscribers_url: z.url(),
    subscription_url: z.url(),
    tags_url: z.url(),
    teams_url: z.url(),
    trees_url: z.string(),
    clone_url: z.string(),
    mirror_url: z.union([
        z.url(),
        z.null()
    ]),
    hooks_url: z.url(),
    svn_url: z.url(),
    homepage: z.union([
        z.url(),
        z.null()
    ]),
    language: z.union([
        z.string(),
        z.null()
    ]),
    forks_count: z.int(),
    stargazers_count: z.int(),
    watchers_count: z.int(),
    size: z.int(),
    default_branch: z.string(),
    open_issues_count: z.int(),
    is_template: z.optional(z.boolean()).default(false),
    topics: z.optional(z.array(z.string())),
    has_issues: z.boolean().default(true),
    has_projects: z.boolean().default(true),
    has_wiki: z.boolean().default(true),
    has_pages: z.boolean(),
    has_downloads: z.boolean().default(true),
    has_discussions: z.optional(z.boolean()).default(false),
    archived: z.boolean().default(false),
    disabled: z.boolean(),
    visibility: z.optional(z.string()).default('public'),
    pushed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    created_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    updated_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    allow_rebase_merge: z.optional(z.boolean()).default(true),
    temp_clone_token: z.optional(z.string()),
    allow_squash_merge: z.optional(z.boolean()).default(true),
    allow_auto_merge: z.optional(z.boolean()).default(false),
    delete_branch_on_merge: z.optional(z.boolean()).default(false),
    allow_update_branch: z.optional(z.boolean()).default(false),
    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
    squash_merge_commit_title: z.optional(z.enum([
        'PR_TITLE',
        'COMMIT_OR_PR_TITLE'
    ])),
    squash_merge_commit_message: z.optional(z.enum([
        'PR_BODY',
        'COMMIT_MESSAGES',
        'BLANK'
    ])),
    merge_commit_title: z.optional(z.enum([
        'PR_TITLE',
        'MERGE_MESSAGE'
    ])),
    merge_commit_message: z.optional(z.enum([
        'PR_BODY',
        'PR_TITLE',
        'BLANK'
    ])),
    allow_merge_commit: z.optional(z.boolean()).default(true),
    allow_forking: z.optional(z.boolean()),
    web_commit_signoff_required: z.optional(z.boolean()).default(false),
    open_issues: z.int(),
    watchers: z.int(),
    master_branch: z.optional(z.string()),
    starred_at: z.optional(z.string()),
    anonymous_access_enabled: z.optional(z.boolean()),
    code_search_index_status: z.optional(z.object({
        lexical_search_ok: z.optional(z.boolean()),
        lexical_commit_sha: z.optional(z.string())
    }))
});

/**
 * Installation Token
 *
 * Authentication token for a GitHub App installed on a user or org.
 */
export const zInstallationToken = z.object({
    token: z.string(),
    expires_at: z.string(),
    permissions: z.optional(zAppPermissions),
    repository_selection: z.optional(z.enum([
        'all',
        'selected'
    ])),
    repositories: z.optional(z.array(zRepository)),
    single_file: z.optional(z.string()),
    has_multiple_single_files: z.optional(z.boolean()),
    single_file_paths: z.optional(z.array(z.string()))
});

/**
 * Scoped Installation
 */
export const zNullableScopedInstallation = z.union([
    z.object({
        permissions: zAppPermissions,
        repository_selection: z.enum([
            'all',
            'selected'
        ]),
        single_file_name: z.union([
            z.string(),
            z.null()
        ]),
        has_multiple_single_files: z.optional(z.boolean()),
        single_file_paths: z.optional(z.array(z.string())),
        repositories_url: z.url(),
        account: zSimpleUser
    }),
    z.null()
]);

/**
 * Authorization
 *
 * The authorization for an OAuth app, GitHub App, or a Personal Access Token.
 */
export const zAuthorization = z.object({
    id: z.coerce.bigint(),
    url: z.url(),
    scopes: z.union([
        z.array(z.string()),
        z.null()
    ]),
    token: z.string(),
    token_last_eight: z.union([
        z.string(),
        z.null()
    ]),
    hashed_token: z.union([
        z.string(),
        z.null()
    ]),
    app: z.object({
        client_id: z.string(),
        name: z.string(),
        url: z.url()
    }),
    note: z.union([
        z.string(),
        z.null()
    ]),
    note_url: z.union([
        z.url(),
        z.null()
    ]),
    updated_at: z.iso.datetime(),
    created_at: z.iso.datetime(),
    fingerprint: z.union([
        z.string(),
        z.null()
    ]),
    user: z.optional(zNullableSimpleUser),
    installation: z.optional(zNullableScopedInstallation),
    expires_at: z.union([
        z.iso.datetime(),
        z.null()
    ])
});

/**
 * Simple Classroom Repository
 *
 * A GitHub repository view for Classroom
 */
export const zSimpleClassroomRepository = z.object({
    id: z.int(),
    full_name: z.string(),
    html_url: z.url(),
    node_id: z.string(),
    private: z.boolean(),
    default_branch: z.string()
});

/**
 * Organization Simple for Classroom
 *
 * A GitHub organization.
 */
export const zSimpleClassroomOrganization = z.object({
    id: z.int(),
    login: z.string(),
    node_id: z.string(),
    html_url: z.url(),
    name: z.union([
        z.string(),
        z.null()
    ]),
    avatar_url: z.string()
});

/**
 * Classroom
 *
 * A GitHub Classroom classroom
 */
export const zClassroom = z.object({
    id: z.int(),
    name: z.string(),
    archived: z.boolean(),
    organization: zSimpleClassroomOrganization,
    url: z.string()
});

/**
 * Classroom Assignment
 *
 * A GitHub Classroom assignment
 */
export const zClassroomAssignment = z.object({
    id: z.int(),
    public_repo: z.boolean(),
    title: z.string(),
    type: z.enum([
        'individual',
        'group'
    ]),
    invite_link: z.string(),
    invitations_enabled: z.boolean(),
    slug: z.string(),
    students_are_repo_admins: z.boolean(),
    feedback_pull_requests_enabled: z.boolean(),
    max_teams: z.union([
        z.int(),
        z.null()
    ]),
    max_members: z.union([
        z.int(),
        z.null()
    ]),
    editor: z.string(),
    accepted: z.int(),
    submitted: z.int(),
    passing: z.int(),
    language: z.string(),
    deadline: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    starter_code_repository: zSimpleClassroomRepository,
    classroom: zClassroom
});

/**
 * Simple Classroom User
 *
 * A GitHub user simplified for Classroom.
 */
export const zSimpleClassroomUser = z.object({
    id: z.int(),
    login: z.string(),
    avatar_url: z.url(),
    html_url: z.url()
});

/**
 * Simple Classroom
 *
 * A GitHub Classroom classroom
 */
export const zSimpleClassroom = z.object({
    id: z.int(),
    name: z.string(),
    archived: z.boolean(),
    url: z.string()
});

/**
 * Simple Classroom Assignment
 *
 * A GitHub Classroom assignment
 */
export const zSimpleClassroomAssignment = z.object({
    id: z.int(),
    public_repo: z.boolean(),
    title: z.string(),
    type: z.enum([
        'individual',
        'group'
    ]),
    invite_link: z.string(),
    invitations_enabled: z.boolean(),
    slug: z.string(),
    students_are_repo_admins: z.boolean(),
    feedback_pull_requests_enabled: z.boolean(),
    max_teams: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    max_members: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    editor: z.string(),
    accepted: z.int(),
    submitted: z.int(),
    passing: z.int(),
    language: z.string(),
    deadline: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    classroom: zSimpleClassroom
});

/**
 * Classroom Accepted Assignment
 *
 * A GitHub Classroom accepted assignment
 */
export const zClassroomAcceptedAssignment = z.object({
    id: z.int(),
    submitted: z.boolean(),
    passing: z.boolean(),
    commit_count: z.int(),
    grade: z.string(),
    students: z.array(zSimpleClassroomUser),
    repository: zSimpleClassroomRepository,
    assignment: zSimpleClassroomAssignment
});

/**
 * Classroom Assignment Grade
 *
 * Grade for a student or groups GitHub Classroom assignment
 */
export const zClassroomAssignmentGrade = z.object({
    assignment_name: z.string(),
    assignment_url: z.string(),
    starter_code_url: z.string(),
    github_username: z.string(),
    roster_identifier: z.string(),
    student_repository_name: z.string(),
    student_repository_url: z.string(),
    submission_timestamp: z.string(),
    points_awarded: z.int(),
    points_available: z.int(),
    group_name: z.optional(z.string())
});

/**
 * Code Of Conduct
 *
 * Code Of Conduct
 */
export const zCodeOfConduct = z.object({
    key: z.string(),
    name: z.string(),
    url: z.url(),
    body: z.optional(z.string()),
    html_url: z.union([
        z.url(),
        z.null()
    ])
});

/**
 * A code security configuration
 */
export const zCodeSecurityConfiguration = z.object({
    id: z.optional(z.int()),
    name: z.optional(z.string()),
    target_type: z.optional(z.enum([
        'global',
        'organization',
        'enterprise'
    ])),
    description: z.optional(z.string()),
    advanced_security: z.optional(z.enum([
        'enabled',
        'disabled',
        'code_security',
        'secret_protection'
    ])),
    dependency_graph: z.optional(z.enum([
        'enabled',
        'disabled',
        'not_set'
    ])),
    dependency_graph_autosubmit_action: z.optional(z.enum([
        'enabled',
        'disabled',
        'not_set'
    ])),
    dependency_graph_autosubmit_action_options: z.optional(z.object({
        labeled_runners: z.optional(z.boolean())
    })),
    dependabot_alerts: z.optional(z.enum([
        'enabled',
        'disabled',
        'not_set'
    ])),
    dependabot_security_updates: z.optional(z.enum([
        'enabled',
        'disabled',
        'not_set'
    ])),
    code_scanning_options: z.optional(z.union([
        z.object({
            allow_advanced: z.optional(z.union([
                z.boolean(),
                z.null()
            ]))
        }),
        z.null()
    ])),
    code_scanning_default_setup: z.optional(z.enum([
        'enabled',
        'disabled',
        'not_set'
    ])),
    code_scanning_default_setup_options: z.optional(z.union([
        z.object({
            runner_type: z.optional(z.enum([
                'standard',
                'labeled',
                'not_set'
            ])),
            runner_label: z.optional(z.union([
                z.string(),
                z.null()
            ]))
        }),
        z.null()
    ])),
    code_scanning_delegated_alert_dismissal: z.optional(z.enum([
        'enabled',
        'disabled',
        'not_set'
    ])),
    secret_scanning: z.optional(z.enum([
        'enabled',
        'disabled',
        'not_set'
    ])),
    secret_scanning_push_protection: z.optional(z.enum([
        'enabled',
        'disabled',
        'not_set'
    ])),
    secret_scanning_delegated_bypass: z.optional(z.enum([
        'enabled',
        'disabled',
        'not_set'
    ])),
    secret_scanning_delegated_bypass_options: z.optional(z.object({
        reviewers: z.optional(z.array(z.object({
            reviewer_id: z.int(),
            reviewer_type: z.enum([
                'TEAM',
                'ROLE'
            ])
        })))
    })),
    secret_scanning_validity_checks: z.optional(z.enum([
        'enabled',
        'disabled',
        'not_set'
    ])),
    secret_scanning_non_provider_patterns: z.optional(z.enum([
        'enabled',
        'disabled',
        'not_set'
    ])),
    secret_scanning_generic_secrets: z.optional(z.enum([
        'enabled',
        'disabled',
        'not_set'
    ])),
    secret_scanning_delegated_alert_dismissal: z.optional(z.enum([
        'enabled',
        'disabled',
        'not_set'
    ])),
    private_vulnerability_reporting: z.optional(z.enum([
        'enabled',
        'disabled',
        'not_set'
    ])),
    enforcement: z.optional(z.enum([
        'enforced',
        'unenforced'
    ])),
    url: z.optional(z.url()),
    html_url: z.optional(z.url()),
    created_at: z.optional(z.iso.datetime()),
    updated_at: z.optional(z.iso.datetime())
});

/**
 * Security Configuration feature options for code scanning
 */
export const zCodeScanningOptions = z.union([
    z.object({
        allow_advanced: z.optional(z.union([
            z.boolean(),
            z.null()
        ]))
    }),
    z.null()
]);

/**
 * Feature options for code scanning default setup
 */
export const zCodeScanningDefaultSetupOptions = z.union([
    z.object({
        runner_type: z.optional(z.enum([
            'standard',
            'labeled',
            'not_set'
        ])),
        runner_label: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    }),
    z.null()
]);

/**
 * A list of default code security configurations
 */
export const zCodeSecurityDefaultConfigurations = z.array(z.object({
    default_for_new_repos: z.optional(z.enum([
        'public',
        'private_and_internal',
        'all'
    ])),
    configuration: z.optional(zCodeSecurityConfiguration)
}));

/**
 * Simple Repository
 *
 * A GitHub repository.
 */
export const zSimpleRepository = z.object({
    id: z.coerce.bigint(),
    node_id: z.string(),
    name: z.string(),
    full_name: z.string(),
    owner: zSimpleUser,
    private: z.boolean(),
    html_url: z.url(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    fork: z.boolean(),
    url: z.url(),
    archive_url: z.string(),
    assignees_url: z.string(),
    blobs_url: z.string(),
    branches_url: z.string(),
    collaborators_url: z.string(),
    comments_url: z.string(),
    commits_url: z.string(),
    compare_url: z.string(),
    contents_url: z.string(),
    contributors_url: z.url(),
    deployments_url: z.url(),
    downloads_url: z.url(),
    events_url: z.url(),
    forks_url: z.url(),
    git_commits_url: z.string(),
    git_refs_url: z.string(),
    git_tags_url: z.string(),
    issue_comment_url: z.string(),
    issue_events_url: z.string(),
    issues_url: z.string(),
    keys_url: z.string(),
    labels_url: z.string(),
    languages_url: z.url(),
    merges_url: z.url(),
    milestones_url: z.string(),
    notifications_url: z.string(),
    pulls_url: z.string(),
    releases_url: z.string(),
    stargazers_url: z.url(),
    statuses_url: z.string(),
    subscribers_url: z.url(),
    subscription_url: z.url(),
    tags_url: z.url(),
    teams_url: z.url(),
    trees_url: z.string(),
    hooks_url: z.url()
});

/**
 * Repositories associated with a code security configuration and attachment status
 */
export const zCodeSecurityConfigurationRepositories = z.object({
    status: z.optional(z.enum([
        'attached',
        'attaching',
        'detached',
        'removed',
        'enforced',
        'failed',
        'updating',
        'removed_by_enterprise'
    ])),
    repository: z.optional(zSimpleRepository)
});

/**
 * The security alert number.
 */
export const zAlertNumber = z.int().readonly();

/**
 * Details for the vulnerable package.
 */
export const zDependabotAlertPackage = z.object({
    ecosystem: z.string().readonly(),
    name: z.string().readonly()
}).readonly();

/**
 * Details pertaining to one vulnerable version range for the advisory.
 */
export const zDependabotAlertSecurityVulnerability = z.object({
    package: zDependabotAlertPackage,
    severity: z.enum([
        'low',
        'medium',
        'high',
        'critical'
    ]),
    vulnerable_version_range: z.string().readonly(),
    first_patched_version: z.union([
        z.object({
            identifier: z.string().readonly()
        }).readonly(),
        z.null()
    ]).readonly()
}).readonly();

/**
 * Details for the GitHub Security Advisory.
 */
export const zDependabotAlertSecurityAdvisory = z.object({
    ghsa_id: z.string().readonly(),
    cve_id: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    summary: z.string().max(1024).readonly(),
    description: z.string().readonly(),
    vulnerabilities: z.array(zDependabotAlertSecurityVulnerability).readonly(),
    severity: z.enum([
        'low',
        'medium',
        'high',
        'critical'
    ]),
    cvss: z.object({
        score: z.number().gte(0).lte(10).readonly(),
        vector_string: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()
    }).readonly(),
    cvss_severities: z.optional(zCvssSeverities),
    epss: z.optional(zSecurityAdvisoryEpss),
    cwes: z.array(z.object({
        cwe_id: z.string().readonly(),
        name: z.string().readonly()
    }).readonly()).readonly(),
    identifiers: z.array(z.object({
        type: z.enum([
            'CVE',
            'GHSA'
        ]),
        value: z.string().readonly()
    }).readonly()).readonly(),
    references: z.array(z.object({
        url: z.url().readonly()
    }).readonly()).readonly(),
    published_at: z.iso.datetime().readonly(),
    updated_at: z.iso.datetime().readonly(),
    withdrawn_at: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly()
}).readonly();

/**
 * The REST API URL of the alert resource.
 */
export const zAlertUrl = z.url().readonly();

/**
 * The GitHub URL of the alert resource.
 */
export const zAlertHtmlUrl = z.url().readonly();

/**
 * The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const zAlertCreatedAt = z.iso.datetime().readonly();

/**
 * The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const zAlertUpdatedAt = z.iso.datetime().readonly();

/**
 * The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const zAlertDismissedAt = z.union([
    z.iso.datetime().readonly(),
    z.null()
]).readonly();

/**
 * The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const zAlertFixedAt = z.union([
    z.iso.datetime().readonly(),
    z.null()
]).readonly();

/**
 * The time that the alert was auto-dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const zAlertAutoDismissedAt = z.union([
    z.iso.datetime().readonly(),
    z.null()
]).readonly();

/**
 * A Dependabot alert.
 */
export const zDependabotAlertWithRepository = z.object({
    number: zAlertNumber,
    state: z.enum([
        'auto_dismissed',
        'dismissed',
        'fixed',
        'open'
    ]),
    dependency: z.object({
        package: z.optional(zDependabotAlertPackage),
        manifest_path: z.optional(z.string().readonly()),
        scope: z.optional(z.enum([
            'development',
            'runtime'
        ])),
        relationship: z.optional(z.enum([
            'unknown',
            'direct',
            'transitive'
        ]))
    }).readonly(),
    security_advisory: zDependabotAlertSecurityAdvisory,
    security_vulnerability: zDependabotAlertSecurityVulnerability,
    url: zAlertUrl,
    html_url: zAlertHtmlUrl,
    created_at: zAlertCreatedAt,
    updated_at: zAlertUpdatedAt,
    dismissed_at: zAlertDismissedAt,
    dismissed_by: zNullableSimpleUser,
    dismissed_reason: z.enum([
        'fix_started',
        'inaccurate',
        'no_bandwidth',
        'not_used',
        'tolerable_risk'
    ]),
    dismissed_comment: z.union([
        z.string().max(280),
        z.null()
    ]),
    fixed_at: zAlertFixedAt,
    auto_dismissed_at: z.optional(zAlertAutoDismissedAt),
    repository: zSimpleRepository
});

/**
 * Enterprise Team
 *
 * Group of enterprise owners and/or members
 */
export const zEnterpriseTeam = z.object({
    id: z.coerce.bigint(),
    name: z.string(),
    description: z.optional(z.string()),
    slug: z.string(),
    url: z.url(),
    sync_to_organizations: z.optional(z.string()),
    organization_selection_type: z.optional(z.string()),
    group_id: z.union([
        z.string(),
        z.null()
    ]),
    group_name: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    html_url: z.url(),
    members_url: z.string(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime()
});

/**
 * Organization Simple
 *
 * A GitHub organization.
 */
export const zOrganizationSimple = z.object({
    login: z.string(),
    id: z.int(),
    node_id: z.string(),
    url: z.url(),
    repos_url: z.url(),
    events_url: z.url(),
    hooks_url: z.string(),
    issues_url: z.string(),
    members_url: z.string(),
    public_members_url: z.string(),
    avatar_url: z.string(),
    description: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Actor
 *
 * Actor
 */
export const zActor = z.object({
    id: z.int(),
    login: z.string(),
    display_login: z.optional(z.string()),
    gravatar_id: z.union([
        z.string(),
        z.null()
    ]),
    url: z.url(),
    avatar_url: z.url()
});

/**
 * Milestone
 *
 * A collection of related issues and pull requests.
 */
export const zNullableMilestone = z.union([
    z.object({
        url: z.url(),
        html_url: z.url(),
        labels_url: z.url(),
        id: z.int(),
        node_id: z.string(),
        number: z.int(),
        state: z.enum([
            'open',
            'closed'
        ]),
        title: z.string(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        creator: zNullableSimpleUser,
        open_issues: z.int(),
        closed_issues: z.int(),
        created_at: z.iso.datetime(),
        updated_at: z.iso.datetime(),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        due_on: z.union([
            z.iso.datetime(),
            z.null()
        ])
    }),
    z.null()
]);

/**
 * Issue Type
 *
 * The type of issue.
 */
export const zIssueType = z.union([
    z.object({
        id: z.int(),
        node_id: z.string(),
        name: z.string(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        color: z.optional(z.enum([
            'gray',
            'blue',
            'green',
            'yellow',
            'orange',
            'red',
            'pink',
            'purple'
        ])),
        created_at: z.optional(z.iso.datetime()),
        updated_at: z.optional(z.iso.datetime()),
        is_enabled: z.optional(z.boolean())
    }),
    z.null()
]);

/**
 * GitHub app
 *
 * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
 */
export const zNullableIntegration = z.union([
    z.object({
        id: z.int(),
        slug: z.optional(z.string()),
        node_id: z.string(),
        client_id: z.optional(z.string()),
        owner: z.union([
            zSimpleUser,
            zEnterprise
        ]),
        name: z.string(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        external_url: z.url(),
        html_url: z.url(),
        created_at: z.iso.datetime(),
        updated_at: z.iso.datetime(),
        permissions: z.object({
            issues: z.optional(z.string()),
            checks: z.optional(z.string()),
            metadata: z.optional(z.string()),
            contents: z.optional(z.string()),
            deployments: z.optional(z.string())
        }),
        events: z.array(z.string()),
        installations_count: z.optional(z.int())
    }),
    z.null()
]);

/**
 * author_association
 *
 * How the author is associated with the repository.
 */
export const zAuthorAssociation = z.enum([
    'COLLABORATOR',
    'CONTRIBUTOR',
    'FIRST_TIMER',
    'FIRST_TIME_CONTRIBUTOR',
    'MANNEQUIN',
    'MEMBER',
    'NONE',
    'OWNER'
]);

/**
 * Reaction Rollup
 */
export const zReactionRollup = z.object({
    url: z.url(),
    total_count: z.int(),
    '+1': z.int(),
    '-1': z.int(),
    laugh: z.int(),
    confused: z.int(),
    heart: z.int(),
    hooray: z.int(),
    eyes: z.int(),
    rocket: z.int()
});

/**
 * Sub-issues Summary
 */
export const zSubIssuesSummary = z.object({
    total: z.int(),
    completed: z.int(),
    percent_completed: z.int()
});

/**
 * Issue Dependencies Summary
 */
export const zIssueDependenciesSummary = z.object({
    blocked_by: z.int(),
    blocking: z.int(),
    total_blocked_by: z.int(),
    total_blocking: z.int()
});

/**
 * Issue Field Value
 *
 * A value assigned to an issue field
 */
export const zIssueFieldValue = z.object({
    issue_field_id: z.coerce.bigint(),
    node_id: z.string(),
    data_type: z.enum([
        'text',
        'single_select',
        'number',
        'date'
    ]),
    value: z.union([
        z.string(),
        z.number(),
        z.int(),
        z.null()
    ]),
    single_select_option: z.optional(z.union([
        z.object({
            id: z.coerce.bigint(),
            name: z.string(),
            color: z.string()
        }),
        z.null()
    ]))
});

/**
 * Issue
 *
 * Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
 */
export const zIssue = z.object({
    id: z.coerce.bigint(),
    node_id: z.string(),
    url: z.url(),
    repository_url: z.url(),
    labels_url: z.string(),
    comments_url: z.url(),
    events_url: z.url(),
    html_url: z.url(),
    number: z.int(),
    state: z.string(),
    state_reason: z.optional(z.enum([
        'completed',
        'reopened',
        'not_planned',
        'duplicate'
    ])),
    title: z.string(),
    body: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    user: zNullableSimpleUser,
    labels: z.array(z.union([
        z.string(),
        z.object({
            id: z.optional(z.coerce.bigint()),
            node_id: z.optional(z.string()),
            url: z.optional(z.url()),
            name: z.optional(z.string()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            color: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            default: z.optional(z.boolean())
        })
    ])),
    assignee: zNullableSimpleUser,
    assignees: z.optional(z.union([
        z.array(zSimpleUser),
        z.null()
    ])),
    milestone: zNullableMilestone,
    locked: z.boolean(),
    active_lock_reason: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    comments: z.int(),
    pull_request: z.optional(z.object({
        merged_at: z.optional(z.union([
            z.iso.datetime(),
            z.null()
        ])),
        diff_url: z.union([
            z.url(),
            z.null()
        ]),
        html_url: z.union([
            z.url(),
            z.null()
        ]),
        patch_url: z.union([
            z.url(),
            z.null()
        ]),
        url: z.union([
            z.url(),
            z.null()
        ])
    })),
    closed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    draft: z.optional(z.boolean()),
    closed_by: z.optional(zNullableSimpleUser),
    body_html: z.optional(z.string()),
    body_text: z.optional(z.string()),
    timeline_url: z.optional(z.url()),
    type: z.optional(zIssueType),
    repository: z.optional(zRepository),
    performed_via_github_app: z.optional(zNullableIntegration),
    author_association: z.optional(zAuthorAssociation),
    reactions: z.optional(zReactionRollup),
    sub_issues_summary: z.optional(zSubIssuesSummary),
    parent_issue_url: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
    issue_field_values: z.optional(z.array(zIssueFieldValue))
});

/**
 * Issue Comment
 *
 * Comments provide a way for people to collaborate on an issue.
 */
export const zIssueComment = z.object({
    id: z.coerce.bigint(),
    node_id: z.string(),
    url: z.url(),
    body: z.optional(z.string()),
    body_text: z.optional(z.string()),
    body_html: z.optional(z.string()),
    html_url: z.url(),
    user: zNullableSimpleUser,
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    issue_url: z.url(),
    author_association: zAuthorAssociation,
    performed_via_github_app: z.optional(zNullableIntegration),
    reactions: z.optional(zReactionRollup)
});

/**
 * Event
 *
 * Event
 */
export const zEvent = z.object({
    id: z.string(),
    type: z.union([
        z.string(),
        z.null()
    ]),
    actor: zActor,
    repo: z.object({
        id: z.int(),
        name: z.string(),
        url: z.url()
    }),
    org: z.optional(zActor),
    payload: z.object({
        action: z.optional(z.string()),
        issue: z.optional(zIssue),
        comment: z.optional(zIssueComment),
        pages: z.optional(z.array(z.object({
            page_name: z.optional(z.string()),
            title: z.optional(z.string()),
            summary: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            action: z.optional(z.string()),
            sha: z.optional(z.string()),
            html_url: z.optional(z.string())
        })))
    }),
    public: z.boolean(),
    created_at: z.union([
        z.iso.datetime(),
        z.null()
    ])
});

/**
 * Link With Type
 *
 * Hypermedia Link with Type
 */
export const zLinkWithType = z.object({
    href: z.string(),
    type: z.string()
});

/**
 * Feed
 *
 * Feed
 */
export const zFeed = z.object({
    timeline_url: z.string(),
    user_url: z.string(),
    current_user_public_url: z.optional(z.string()),
    current_user_url: z.optional(z.string()),
    current_user_actor_url: z.optional(z.string()),
    current_user_organization_url: z.optional(z.string()),
    current_user_organization_urls: z.optional(z.array(z.url())),
    security_advisories_url: z.optional(z.string()),
    repository_discussions_url: z.optional(z.string()),
    repository_discussions_category_url: z.optional(z.string()),
    _links: z.object({
        timeline: zLinkWithType,
        user: zLinkWithType,
        security_advisories: z.optional(zLinkWithType),
        current_user: z.optional(zLinkWithType),
        current_user_public: z.optional(zLinkWithType),
        current_user_actor: z.optional(zLinkWithType),
        current_user_organization: z.optional(zLinkWithType),
        current_user_organizations: z.optional(z.array(zLinkWithType)),
        repository_discussions: z.optional(zLinkWithType),
        repository_discussions_category: z.optional(zLinkWithType)
    })
});

/**
 * Base Gist
 *
 * Base Gist
 */
export const zBaseGist = z.object({
    url: z.url(),
    forks_url: z.url(),
    commits_url: z.url(),
    id: z.string(),
    node_id: z.string(),
    git_pull_url: z.url(),
    git_push_url: z.url(),
    html_url: z.url(),
    files: z.record(z.string(), z.object({
        filename: z.optional(z.string()),
        type: z.optional(z.string()),
        language: z.optional(z.string()),
        raw_url: z.optional(z.string()),
        size: z.optional(z.int()),
        encoding: z.optional(z.string()).default('utf-8')
    })),
    public: z.boolean(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    comments: z.int(),
    comments_enabled: z.optional(z.boolean()),
    user: zNullableSimpleUser,
    comments_url: z.url(),
    owner: z.optional(zSimpleUser),
    truncated: z.optional(z.boolean()),
    forks: z.optional(z.array(z.unknown())),
    history: z.optional(z.array(z.unknown()))
});

/**
 * Public User
 *
 * Public User
 */
export const zPublicUser = z.object({
    login: z.string(),
    id: z.coerce.bigint(),
    user_view_type: z.optional(z.string()),
    node_id: z.string(),
    avatar_url: z.url(),
    gravatar_id: z.union([
        z.string(),
        z.null()
    ]),
    url: z.url(),
    html_url: z.url(),
    followers_url: z.url(),
    following_url: z.string(),
    gists_url: z.string(),
    starred_url: z.string(),
    subscriptions_url: z.url(),
    organizations_url: z.url(),
    repos_url: z.url(),
    events_url: z.string(),
    received_events_url: z.url(),
    type: z.string(),
    site_admin: z.boolean(),
    name: z.union([
        z.string(),
        z.null()
    ]),
    company: z.union([
        z.string(),
        z.null()
    ]),
    blog: z.union([
        z.string(),
        z.null()
    ]),
    location: z.union([
        z.string(),
        z.null()
    ]),
    email: z.union([
        z.email(),
        z.null()
    ]),
    notification_email: z.optional(z.union([
        z.email(),
        z.null()
    ])),
    hireable: z.union([
        z.boolean(),
        z.null()
    ]),
    bio: z.union([
        z.string(),
        z.null()
    ]),
    twitter_username: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    public_repos: z.int(),
    public_gists: z.int(),
    followers: z.int(),
    following: z.int(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    plan: z.optional(z.object({
        collaborators: z.int(),
        name: z.string(),
        space: z.int(),
        private_repos: z.int()
    })),
    private_gists: z.optional(z.int()),
    total_private_repos: z.optional(z.int()),
    owned_private_repos: z.optional(z.int()),
    disk_usage: z.optional(z.int()),
    collaborators: z.optional(z.int())
});

/**
 * Gist History
 *
 * Gist History
 */
export const zGistHistory = z.object({
    user: z.optional(zNullableSimpleUser),
    version: z.optional(z.string()),
    committed_at: z.optional(z.iso.datetime()),
    change_status: z.optional(z.object({
        total: z.optional(z.int()),
        additions: z.optional(z.int()),
        deletions: z.optional(z.int())
    })),
    url: z.optional(z.url())
});

/**
 * Gist Simple
 *
 * Gist Simple
 */
export const zGistSimple = z.object({
    forks: z.optional(z.union([
        z.array(z.object({
            id: z.optional(z.string()),
            url: z.optional(z.url()),
            user: z.optional(zPublicUser),
            created_at: z.optional(z.iso.datetime()),
            updated_at: z.optional(z.iso.datetime())
        })),
        z.null()
    ])),
    history: z.optional(z.union([
        z.array(zGistHistory),
        z.null()
    ])),
    fork_of: z.optional(z.union([
        z.object({
            url: z.url(),
            forks_url: z.url(),
            commits_url: z.url(),
            id: z.string(),
            node_id: z.string(),
            git_pull_url: z.url(),
            git_push_url: z.url(),
            html_url: z.url(),
            files: z.record(z.string(), z.object({
                filename: z.optional(z.string()),
                type: z.optional(z.string()),
                language: z.optional(z.string()),
                raw_url: z.optional(z.string()),
                size: z.optional(z.int())
            })),
            public: z.boolean(),
            created_at: z.iso.datetime(),
            updated_at: z.iso.datetime(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            comments: z.int(),
            comments_enabled: z.optional(z.boolean()),
            user: zNullableSimpleUser,
            comments_url: z.url(),
            owner: z.optional(zNullableSimpleUser),
            truncated: z.optional(z.boolean()),
            forks: z.optional(z.array(z.unknown())),
            history: z.optional(z.array(z.unknown()))
        }),
        z.null()
    ])),
    url: z.optional(z.string()),
    forks_url: z.optional(z.string()),
    commits_url: z.optional(z.string()),
    id: z.optional(z.string()),
    node_id: z.optional(z.string()),
    git_pull_url: z.optional(z.string()),
    git_push_url: z.optional(z.string()),
    html_url: z.optional(z.string()),
    files: z.optional(z.record(z.string(), z.union([
        z.object({
            filename: z.optional(z.string()),
            type: z.optional(z.string()),
            language: z.optional(z.string()),
            raw_url: z.optional(z.string()),
            size: z.optional(z.int()),
            truncated: z.optional(z.boolean()),
            content: z.optional(z.string()),
            encoding: z.optional(z.string()).default('utf-8')
        }),
        z.null()
    ]))),
    public: z.optional(z.boolean()),
    created_at: z.optional(z.string()),
    updated_at: z.optional(z.string()),
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    comments: z.optional(z.int()),
    comments_enabled: z.optional(z.boolean()),
    user: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    comments_url: z.optional(z.string()),
    owner: z.optional(zSimpleUser),
    truncated: z.optional(z.boolean())
});

/**
 * Gist Comment
 *
 * A comment made to a gist.
 */
export const zGistComment = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.url(),
    body: z.string().max(65535),
    user: zNullableSimpleUser,
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    author_association: zAuthorAssociation
});

/**
 * Gist Commit
 *
 * Gist Commit
 */
export const zGistCommit = z.object({
    url: z.url(),
    version: z.string(),
    user: zNullableSimpleUser,
    change_status: z.object({
        total: z.optional(z.int()),
        additions: z.optional(z.int()),
        deletions: z.optional(z.int())
    }),
    committed_at: z.iso.datetime()
});

/**
 * Gitignore Template
 *
 * Gitignore Template
 */
export const zGitignoreTemplate = z.object({
    name: z.string(),
    source: z.string()
});

/**
 * License Simple
 *
 * License Simple
 */
export const zLicenseSimple = z.object({
    key: z.string(),
    name: z.string(),
    url: z.union([
        z.url(),
        z.null()
    ]),
    spdx_id: z.union([
        z.string(),
        z.null()
    ]),
    node_id: z.string(),
    html_url: z.optional(z.url())
});

/**
 * License
 *
 * License
 */
export const zLicense = z.object({
    key: z.string(),
    name: z.string(),
    spdx_id: z.union([
        z.string(),
        z.null()
    ]),
    url: z.union([
        z.url(),
        z.null()
    ]),
    node_id: z.string(),
    html_url: z.url(),
    description: z.string(),
    implementation: z.string(),
    permissions: z.array(z.string()),
    conditions: z.array(z.string()),
    limitations: z.array(z.string()),
    body: z.string(),
    featured: z.boolean()
});

/**
 * Marketplace Listing Plan
 *
 * Marketplace Listing Plan
 */
export const zMarketplaceListingPlan = z.object({
    url: z.url(),
    accounts_url: z.url(),
    id: z.int(),
    number: z.int(),
    name: z.string(),
    description: z.string(),
    monthly_price_in_cents: z.int(),
    yearly_price_in_cents: z.int(),
    price_model: z.enum([
        'FREE',
        'FLAT_RATE',
        'PER_UNIT'
    ]),
    has_free_trial: z.boolean(),
    unit_name: z.union([
        z.string(),
        z.null()
    ]),
    state: z.string(),
    bullets: z.array(z.string())
});

/**
 * Marketplace Purchase
 *
 * Marketplace Purchase
 */
export const zMarketplacePurchase = z.object({
    url: z.string(),
    type: z.string(),
    id: z.int(),
    login: z.string(),
    organization_billing_email: z.optional(z.string()),
    email: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    marketplace_pending_change: z.optional(z.union([
        z.object({
            is_installed: z.optional(z.boolean()),
            effective_date: z.optional(z.string()),
            unit_count: z.optional(z.union([
                z.int(),
                z.null()
            ])),
            id: z.optional(z.int()),
            plan: z.optional(zMarketplaceListingPlan)
        }),
        z.null()
    ])),
    marketplace_purchase: z.object({
        billing_cycle: z.optional(z.string()),
        next_billing_date: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        is_installed: z.optional(z.boolean()),
        unit_count: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        on_free_trial: z.optional(z.boolean()),
        free_trial_ends_on: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        updated_at: z.optional(z.string()),
        plan: z.optional(zMarketplaceListingPlan)
    })
});

/**
 * Api Overview
 *
 * Api Overview
 */
export const zApiOverview = z.object({
    verifiable_password_authentication: z.boolean(),
    ssh_key_fingerprints: z.optional(z.object({
        SHA256_RSA: z.optional(z.string()),
        SHA256_DSA: z.optional(z.string()),
        SHA256_ECDSA: z.optional(z.string()),
        SHA256_ED25519: z.optional(z.string())
    })),
    ssh_keys: z.optional(z.array(z.string())),
    hooks: z.optional(z.array(z.string())),
    github_enterprise_importer: z.optional(z.array(z.string())),
    web: z.optional(z.array(z.string())),
    api: z.optional(z.array(z.string())),
    git: z.optional(z.array(z.string())),
    packages: z.optional(z.array(z.string())),
    pages: z.optional(z.array(z.string())),
    importer: z.optional(z.array(z.string())),
    actions: z.optional(z.array(z.string())),
    actions_macos: z.optional(z.array(z.string())),
    codespaces: z.optional(z.array(z.string())),
    dependabot: z.optional(z.array(z.string())),
    copilot: z.optional(z.array(z.string())),
    domains: z.optional(z.object({
        website: z.optional(z.array(z.string())),
        codespaces: z.optional(z.array(z.string())),
        copilot: z.optional(z.array(z.string())),
        packages: z.optional(z.array(z.string())),
        actions: z.optional(z.array(z.string())),
        actions_inbound: z.optional(z.object({
            full_domains: z.optional(z.array(z.string())),
            wildcard_domains: z.optional(z.array(z.string()))
        })),
        artifact_attestations: z.optional(z.object({
            trust_domain: z.optional(z.string()),
            services: z.optional(z.array(z.string()))
        }))
    }))
});

export const zSecurityAndAnalysis = z.union([
    z.object({
        advanced_security: z.optional(z.object({
            status: z.optional(z.enum([
                'enabled',
                'disabled'
            ]))
        })),
        code_security: z.optional(z.object({
            status: z.optional(z.enum([
                'enabled',
                'disabled'
            ]))
        })),
        dependabot_security_updates: z.optional(z.object({
            status: z.optional(z.enum([
                'enabled',
                'disabled'
            ]))
        })),
        secret_scanning: z.optional(z.object({
            status: z.optional(z.enum([
                'enabled',
                'disabled'
            ]))
        })),
        secret_scanning_push_protection: z.optional(z.object({
            status: z.optional(z.enum([
                'enabled',
                'disabled'
            ]))
        })),
        secret_scanning_non_provider_patterns: z.optional(z.object({
            status: z.optional(z.enum([
                'enabled',
                'disabled'
            ]))
        })),
        secret_scanning_ai_detection: z.optional(z.object({
            status: z.optional(z.enum([
                'enabled',
                'disabled'
            ]))
        }))
    }),
    z.null()
]);

/**
 * Minimal Repository
 *
 * Minimal Repository
 */
export const zMinimalRepository = z.object({
    id: z.coerce.bigint(),
    node_id: z.string(),
    name: z.string(),
    full_name: z.string(),
    owner: zSimpleUser,
    private: z.boolean(),
    html_url: z.url(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    fork: z.boolean(),
    url: z.url(),
    archive_url: z.string(),
    assignees_url: z.string(),
    blobs_url: z.string(),
    branches_url: z.string(),
    collaborators_url: z.string(),
    comments_url: z.string(),
    commits_url: z.string(),
    compare_url: z.string(),
    contents_url: z.string(),
    contributors_url: z.url(),
    deployments_url: z.url(),
    downloads_url: z.url(),
    events_url: z.url(),
    forks_url: z.url(),
    git_commits_url: z.string(),
    git_refs_url: z.string(),
    git_tags_url: z.string(),
    git_url: z.optional(z.string()),
    issue_comment_url: z.string(),
    issue_events_url: z.string(),
    issues_url: z.string(),
    keys_url: z.string(),
    labels_url: z.string(),
    languages_url: z.url(),
    merges_url: z.url(),
    milestones_url: z.string(),
    notifications_url: z.string(),
    pulls_url: z.string(),
    releases_url: z.string(),
    ssh_url: z.optional(z.string()),
    stargazers_url: z.url(),
    statuses_url: z.string(),
    subscribers_url: z.url(),
    subscription_url: z.url(),
    tags_url: z.url(),
    teams_url: z.url(),
    trees_url: z.string(),
    clone_url: z.optional(z.string()),
    mirror_url: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    hooks_url: z.url(),
    svn_url: z.optional(z.string()),
    homepage: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    language: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    forks_count: z.optional(z.int()),
    stargazers_count: z.optional(z.int()),
    watchers_count: z.optional(z.int()),
    size: z.optional(z.int()),
    default_branch: z.optional(z.string()),
    open_issues_count: z.optional(z.int()),
    is_template: z.optional(z.boolean()),
    topics: z.optional(z.array(z.string())),
    has_issues: z.optional(z.boolean()),
    has_projects: z.optional(z.boolean()),
    has_wiki: z.optional(z.boolean()),
    has_pages: z.optional(z.boolean()),
    has_downloads: z.optional(z.boolean()),
    has_discussions: z.optional(z.boolean()),
    archived: z.optional(z.boolean()),
    disabled: z.optional(z.boolean()),
    visibility: z.optional(z.string()),
    pushed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    created_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    updated_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    permissions: z.optional(z.object({
        admin: z.optional(z.boolean()),
        maintain: z.optional(z.boolean()),
        push: z.optional(z.boolean()),
        triage: z.optional(z.boolean()),
        pull: z.optional(z.boolean())
    })),
    role_name: z.optional(z.string()),
    temp_clone_token: z.optional(z.string()),
    delete_branch_on_merge: z.optional(z.boolean()),
    subscribers_count: z.optional(z.int()),
    network_count: z.optional(z.int()),
    code_of_conduct: z.optional(zCodeOfConduct),
    license: z.optional(z.union([
        z.object({
            key: z.optional(z.string()),
            name: z.optional(z.string()),
            spdx_id: z.optional(z.string()),
            url: z.optional(z.string()),
            node_id: z.optional(z.string())
        }),
        z.null()
    ])),
    forks: z.optional(z.int()),
    open_issues: z.optional(z.int()),
    watchers: z.optional(z.int()),
    allow_forking: z.optional(z.boolean()),
    web_commit_signoff_required: z.optional(z.boolean()),
    security_and_analysis: z.optional(zSecurityAndAnalysis),
    custom_properties: z.optional(z.record(z.string(), z.unknown()))
});

/**
 * Thread
 *
 * Thread
 */
export const zThread = z.object({
    id: z.string(),
    repository: zMinimalRepository,
    subject: z.object({
        title: z.string(),
        url: z.string(),
        latest_comment_url: z.string(),
        type: z.string()
    }),
    reason: z.string(),
    unread: z.boolean(),
    updated_at: z.string(),
    last_read_at: z.union([
        z.string(),
        z.null()
    ]),
    url: z.string(),
    subscription_url: z.string()
});

/**
 * Thread Subscription
 *
 * Thread Subscription
 */
export const zThreadSubscription = z.object({
    subscribed: z.boolean(),
    ignored: z.boolean(),
    reason: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    url: z.url(),
    thread_url: z.optional(z.url()),
    repository_url: z.optional(z.url())
});

/**
 * Simple Repository
 *
 * A GitHub repository.
 */
export const zNullableSimpleRepository = z.union([
    z.object({
        id: z.coerce.bigint(),
        node_id: z.string(),
        name: z.string(),
        full_name: z.string(),
        owner: zSimpleUser,
        private: z.boolean(),
        html_url: z.url(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        fork: z.boolean(),
        url: z.url(),
        archive_url: z.string(),
        assignees_url: z.string(),
        blobs_url: z.string(),
        branches_url: z.string(),
        collaborators_url: z.string(),
        comments_url: z.string(),
        commits_url: z.string(),
        compare_url: z.string(),
        contents_url: z.string(),
        contributors_url: z.url(),
        deployments_url: z.url(),
        downloads_url: z.url(),
        events_url: z.url(),
        forks_url: z.url(),
        git_commits_url: z.string(),
        git_refs_url: z.string(),
        git_tags_url: z.string(),
        issue_comment_url: z.string(),
        issue_events_url: z.string(),
        issues_url: z.string(),
        keys_url: z.string(),
        labels_url: z.string(),
        languages_url: z.url(),
        merges_url: z.url(),
        milestones_url: z.string(),
        notifications_url: z.string(),
        pulls_url: z.string(),
        releases_url: z.string(),
        stargazers_url: z.url(),
        statuses_url: z.string(),
        subscribers_url: z.url(),
        subscription_url: z.url(),
        tags_url: z.url(),
        teams_url: z.url(),
        trees_url: z.string(),
        hooks_url: z.url()
    }),
    z.null()
]);

/**
 * Dependabot Repository Access Details
 *
 * Information about repositories that Dependabot is able to access in an organization
 */
export const zDependabotRepositoryAccessDetails = z.object({
    default_level: z.optional(z.enum([
        'public',
        'internal'
    ])),
    accessible_repositories: z.optional(z.array(zNullableSimpleRepository))
});

/**
 * Custom Property Value
 *
 * Custom property name and associated value
 */
export const zCustomPropertyValue = z.object({
    property_name: z.string(),
    value: z.union([
        z.string(),
        z.array(z.string()),
        z.null()
    ])
});

export const zBillingPremiumRequestUsageReportOrg = z.object({
    timePeriod: z.object({
        year: z.int(),
        month: z.optional(z.int()),
        day: z.optional(z.int())
    }),
    organization: z.string(),
    user: z.optional(z.string()),
    product: z.optional(z.string()),
    model: z.optional(z.string()),
    usageItems: z.array(z.object({
        product: z.string(),
        sku: z.string(),
        model: z.string(),
        unitType: z.string(),
        pricePerUnit: z.number(),
        grossQuantity: z.number(),
        grossAmount: z.number(),
        discountQuantity: z.number(),
        discountAmount: z.number(),
        netQuantity: z.number(),
        netAmount: z.number()
    }))
});

export const zBillingUsageReport = z.object({
    usageItems: z.optional(z.array(z.object({
        date: z.string(),
        product: z.string(),
        sku: z.string(),
        quantity: z.int(),
        unitType: z.string(),
        pricePerUnit: z.number(),
        grossAmount: z.number(),
        discountAmount: z.number(),
        netAmount: z.number(),
        organizationName: z.string(),
        repositoryName: z.optional(z.string())
    })))
});

/**
 * Organization Full
 *
 * Organization Full
 */
export const zOrganizationFull = z.object({
    login: z.string(),
    id: z.int(),
    node_id: z.string(),
    url: z.url(),
    repos_url: z.url(),
    events_url: z.url(),
    hooks_url: z.string(),
    issues_url: z.string(),
    members_url: z.string(),
    public_members_url: z.string(),
    avatar_url: z.string(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    name: z.optional(z.string()),
    company: z.optional(z.string()),
    blog: z.optional(z.url()),
    location: z.optional(z.string()),
    email: z.optional(z.email()),
    twitter_username: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    is_verified: z.optional(z.boolean()),
    has_organization_projects: z.boolean(),
    has_repository_projects: z.boolean(),
    public_repos: z.int(),
    public_gists: z.int(),
    followers: z.int(),
    following: z.int(),
    html_url: z.url(),
    type: z.string(),
    total_private_repos: z.optional(z.int()),
    owned_private_repos: z.optional(z.int()),
    private_gists: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    disk_usage: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    collaborators: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    billing_email: z.optional(z.union([
        z.email(),
        z.null()
    ])),
    plan: z.optional(z.object({
        name: z.string(),
        space: z.int(),
        private_repos: z.int(),
        filled_seats: z.optional(z.int()),
        seats: z.optional(z.int())
    })),
    default_repository_permission: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    default_repository_branch: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    members_can_create_repositories: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    two_factor_requirement_enabled: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    members_allowed_repository_creation_type: z.optional(z.string()),
    members_can_create_public_repositories: z.optional(z.boolean()),
    members_can_create_private_repositories: z.optional(z.boolean()),
    members_can_create_internal_repositories: z.optional(z.boolean()),
    members_can_create_pages: z.optional(z.boolean()),
    members_can_create_public_pages: z.optional(z.boolean()),
    members_can_create_private_pages: z.optional(z.boolean()),
    members_can_delete_repositories: z.optional(z.boolean()),
    members_can_change_repo_visibility: z.optional(z.boolean()),
    members_can_invite_outside_collaborators: z.optional(z.boolean()),
    members_can_delete_issues: z.optional(z.boolean()),
    display_commenter_full_name_setting_enabled: z.optional(z.boolean()),
    readers_can_create_discussions: z.optional(z.boolean()),
    members_can_create_teams: z.optional(z.boolean()),
    members_can_view_dependency_insights: z.optional(z.boolean()),
    members_can_fork_private_repositories: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    web_commit_signoff_required: z.optional(z.boolean()),
    advanced_security_enabled_for_new_repositories: z.optional(z.boolean()),
    dependabot_alerts_enabled_for_new_repositories: z.optional(z.boolean()),
    dependabot_security_updates_enabled_for_new_repositories: z.optional(z.boolean()),
    dependency_graph_enabled_for_new_repositories: z.optional(z.boolean()),
    secret_scanning_enabled_for_new_repositories: z.optional(z.boolean()),
    secret_scanning_push_protection_enabled_for_new_repositories: z.optional(z.boolean()),
    secret_scanning_push_protection_custom_link_enabled: z.optional(z.boolean()),
    secret_scanning_push_protection_custom_link: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    archived_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    deploy_keys_enabled_for_repositories: z.optional(z.boolean())
});

export const zActionsCacheUsageOrgEnterprise = z.object({
    total_active_caches_count: z.int(),
    total_active_caches_size_in_bytes: z.int()
});

/**
 * Actions Cache Usage by repository
 *
 * GitHub Actions Cache Usage by repository.
 */
export const zActionsCacheUsageByRepository = z.object({
    full_name: z.string(),
    active_caches_size_in_bytes: z.int(),
    active_caches_count: z.int()
});

/**
 * GitHub-hosted runner image details.
 *
 * Provides details of a hosted runner image
 */
export const zNullableActionsHostedRunnerPoolImage = z.union([
    z.object({
        id: z.string(),
        size_gb: z.int(),
        display_name: z.string(),
        source: z.enum([
            'github',
            'partner',
            'custom'
        ]),
        version: z.optional(z.string())
    }),
    z.null()
]);

/**
 * Github-owned VM details.
 *
 * Provides details of a particular machine spec.
 */
export const zActionsHostedRunnerMachineSpec = z.object({
    id: z.string(),
    cpu_cores: z.int(),
    memory_gb: z.int(),
    storage_gb: z.int()
});

/**
 * Public IP for a GitHub-hosted larger runners.
 *
 * Provides details of Public IP for a GitHub-hosted larger runners
 */
export const zPublicIp = z.object({
    enabled: z.optional(z.boolean()),
    prefix: z.optional(z.string()),
    length: z.optional(z.int())
});

/**
 * GitHub-hosted hosted runner
 *
 * A Github-hosted hosted runner.
 */
export const zActionsHostedRunner = z.object({
    id: z.int(),
    name: z.string(),
    runner_group_id: z.optional(z.int()),
    image_details: zNullableActionsHostedRunnerPoolImage,
    machine_size_details: zActionsHostedRunnerMachineSpec,
    status: z.enum([
        'Ready',
        'Provisioning',
        'Shutdown',
        'Deleting',
        'Stuck'
    ]),
    platform: z.string(),
    maximum_runners: z.optional(z.int()).default(10),
    public_ip_enabled: z.boolean(),
    public_ips: z.optional(z.array(zPublicIp)),
    last_active_on: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    image_gen: z.optional(z.boolean())
});

/**
 * GitHub-hosted runner custom image details
 *
 * Provides details of a custom runner image
 */
export const zActionsHostedRunnerCustomImage = z.object({
    id: z.int(),
    platform: z.string(),
    total_versions_size: z.int(),
    name: z.string(),
    source: z.string(),
    versions_count: z.int(),
    latest_version: z.string(),
    state: z.string()
});

/**
 * GitHub-hosted runner custom image version details.
 *
 * Provides details of a hosted runner custom image version
 */
export const zActionsHostedRunnerCustomImageVersion = z.object({
    version: z.string(),
    state: z.string(),
    size_gb: z.int(),
    created_on: z.string(),
    state_details: z.string()
});

/**
 * GitHub-hosted runner image details.
 *
 * Provides details of a hosted runner image
 */
export const zActionsHostedRunnerCuratedImage = z.object({
    id: z.string(),
    platform: z.string(),
    size_gb: z.int(),
    display_name: z.string(),
    source: z.enum([
        'github',
        'partner',
        'custom'
    ])
});

export const zActionsHostedRunnerLimits = z.object({
    public_ips: z.object({
        maximum: z.int(),
        current_usage: z.int()
    })
});

/**
 * Actions OIDC Subject customization
 *
 * Actions OIDC Subject customization
 */
export const zOidcCustomSub = z.object({
    include_claim_keys: z.array(z.string())
});

/**
 * Empty Object
 *
 * An object without any properties.
 */
export const zEmptyObject = z.record(z.string(), z.never());

/**
 * The policy that controls the repositories in the organization that are allowed to run GitHub Actions.
 */
export const zEnabledRepositories = z.enum([
    'all',
    'none',
    'selected'
]);

/**
 * The permissions policy that controls the actions and reusable workflows that are allowed to run.
 */
export const zAllowedActions = z.enum([
    'all',
    'local_only',
    'selected'
]);

/**
 * The API URL to use to get or set the actions and reusable workflows that are allowed to run, when `allowed_actions` is set to `selected`.
 */
export const zSelectedActionsUrl = z.string();

/**
 * Whether actions must be pinned to a full-length commit SHA.
 */
export const zShaPinningRequired = z.boolean();

export const zActionsOrganizationPermissions = z.object({
    enabled_repositories: zEnabledRepositories,
    selected_repositories_url: z.optional(z.string()),
    allowed_actions: z.optional(zAllowedActions),
    selected_actions_url: z.optional(zSelectedActionsUrl),
    sha_pinning_required: z.optional(zShaPinningRequired)
});

export const zActionsArtifactAndLogRetentionResponse = z.object({
    days: z.int(),
    maximum_allowed_days: z.int()
});

export const zActionsArtifactAndLogRetention = z.object({
    days: z.int()
});

export const zActionsForkPrContributorApproval = z.object({
    approval_policy: z.enum([
        'first_time_contributors_new_to_github',
        'first_time_contributors',
        'all_external_contributors'
    ])
});

export const zActionsForkPrWorkflowsPrivateRepos = z.object({
    run_workflows_from_fork_pull_requests: z.boolean(),
    send_write_tokens_to_workflows: z.boolean(),
    send_secrets_and_variables: z.boolean(),
    require_approval_for_fork_pr_workflows: z.boolean()
});

export const zActionsForkPrWorkflowsPrivateReposRequest = z.object({
    run_workflows_from_fork_pull_requests: z.boolean(),
    send_write_tokens_to_workflows: z.optional(z.boolean()),
    send_secrets_and_variables: z.optional(z.boolean()),
    require_approval_for_fork_pr_workflows: z.optional(z.boolean())
});

export const zSelectedActions = z.object({
    github_owned_allowed: z.optional(z.boolean()),
    verified_allowed: z.optional(z.boolean()),
    patterns_allowed: z.optional(z.array(z.string()))
});

export const zSelfHostedRunnersSettings = z.object({
    enabled_repositories: z.enum([
        'all',
        'selected',
        'none'
    ]),
    selected_repositories_url: z.optional(z.string())
});

/**
 * The default workflow permissions granted to the GITHUB_TOKEN when running workflows.
 */
export const zActionsDefaultWorkflowPermissions = z.enum([
    'read',
    'write'
]);

/**
 * Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.
 */
export const zActionsCanApprovePullRequestReviews = z.boolean();

export const zActionsGetDefaultWorkflowPermissions = z.object({
    default_workflow_permissions: zActionsDefaultWorkflowPermissions,
    can_approve_pull_request_reviews: zActionsCanApprovePullRequestReviews
});

export const zActionsSetDefaultWorkflowPermissions = z.object({
    default_workflow_permissions: z.optional(zActionsDefaultWorkflowPermissions),
    can_approve_pull_request_reviews: z.optional(zActionsCanApprovePullRequestReviews)
});

export const zRunnerGroupsOrg = z.object({
    id: z.number(),
    name: z.string(),
    visibility: z.string(),
    default: z.boolean(),
    selected_repositories_url: z.optional(z.string()),
    runners_url: z.string(),
    hosted_runners_url: z.optional(z.string()),
    network_configuration_id: z.optional(z.string()),
    inherited: z.boolean(),
    inherited_allows_public_repositories: z.optional(z.boolean()),
    allows_public_repositories: z.boolean(),
    workflow_restrictions_read_only: z.optional(z.boolean()).default(false),
    restricted_to_workflows: z.optional(z.boolean()).default(false),
    selected_workflows: z.optional(z.array(z.string()))
});

/**
 * Self hosted runner label
 *
 * A label for a self hosted runner
 */
export const zRunnerLabel = z.object({
    id: z.optional(z.int()),
    name: z.string(),
    type: z.optional(z.enum([
        'read-only',
        'custom'
    ]))
});

/**
 * Self hosted runners
 *
 * A self hosted runner
 */
export const zRunner = z.object({
    id: z.int(),
    runner_group_id: z.optional(z.int()),
    name: z.string(),
    os: z.string(),
    status: z.string(),
    busy: z.boolean(),
    labels: z.array(zRunnerLabel),
    ephemeral: z.optional(z.boolean())
});

/**
 * Runner Application
 *
 * Runner Application
 */
export const zRunnerApplication = z.object({
    os: z.string(),
    architecture: z.string(),
    download_url: z.string(),
    filename: z.string(),
    temp_download_token: z.optional(z.string()),
    sha256_checksum: z.optional(z.string())
});

/**
 * Authentication Token
 *
 * Authentication Token
 */
export const zAuthenticationToken = z.object({
    token: z.string(),
    expires_at: z.iso.datetime(),
    permissions: z.optional(z.record(z.string(), z.unknown())),
    repositories: z.optional(z.array(zRepository)),
    single_file: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    repository_selection: z.optional(z.enum([
        'all',
        'selected'
    ]))
});

/**
 * Actions Secret for an Organization
 *
 * Secrets for GitHub Actions for an organization.
 */
export const zOrganizationActionsSecret = z.object({
    name: z.string(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    visibility: z.enum([
        'all',
        'private',
        'selected'
    ]),
    selected_repositories_url: z.optional(z.url())
});

/**
 * ActionsPublicKey
 *
 * The public key used for setting Actions Secrets.
 */
export const zActionsPublicKey = z.object({
    key_id: z.string(),
    key: z.string(),
    id: z.optional(z.int()),
    url: z.optional(z.string()),
    title: z.optional(z.string()),
    created_at: z.optional(z.string())
});

/**
 * Actions Variable for an Organization
 *
 * Organization variable for GitHub Actions.
 */
export const zOrganizationActionsVariable = z.object({
    name: z.string(),
    value: z.string(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    visibility: z.enum([
        'all',
        'private',
        'selected'
    ]),
    selected_repositories_url: z.optional(z.url())
});

/**
 * Campaign state
 *
 * Indicates whether a campaign is open or closed
 */
export const zCampaignState = z.enum([
    'open',
    'closed'
]);

/**
 * Campaign alert type
 *
 * Indicates the alert type of a campaign
 */
export const zCampaignAlertType = z.enum([
    'code_scanning',
    'secret_scanning'
]);

/**
 * Team Simple
 *
 * Groups of organization members that gives permissions on specified repositories.
 */
export const zNullableTeamSimple = z.union([
    z.object({
        id: z.int(),
        node_id: z.string(),
        url: z.url(),
        members_url: z.string(),
        name: z.string(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        permission: z.string(),
        privacy: z.optional(z.string()),
        notification_setting: z.optional(z.string()),
        html_url: z.url(),
        repositories_url: z.url(),
        slug: z.string(),
        ldap_dn: z.optional(z.string()),
        type: z.enum([
            'enterprise',
            'organization'
        ]),
        organization_id: z.optional(z.int()),
        enterprise_id: z.optional(z.int())
    }),
    z.null()
]);

/**
 * Team
 *
 * Groups of organization members that gives permissions on specified repositories.
 */
export const zTeam = z.object({
    id: z.int(),
    node_id: z.string(),
    name: z.string(),
    slug: z.string(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    privacy: z.optional(z.string()),
    notification_setting: z.optional(z.string()),
    permission: z.string(),
    permissions: z.optional(z.object({
        pull: z.boolean(),
        triage: z.boolean(),
        push: z.boolean(),
        maintain: z.boolean(),
        admin: z.boolean()
    })),
    url: z.url(),
    html_url: z.url(),
    members_url: z.string(),
    repositories_url: z.url(),
    type: z.enum([
        'enterprise',
        'organization'
    ]),
    organization_id: z.optional(z.int()),
    enterprise_id: z.optional(z.int()),
    parent: zNullableTeamSimple
});

/**
 * Campaign summary
 *
 * The campaign metadata and alert stats.
 */
export const zCampaignSummary = z.object({
    number: z.int(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    name: z.optional(z.string()),
    description: z.string(),
    managers: z.array(zSimpleUser),
    team_managers: z.optional(z.array(zTeam)),
    published_at: z.optional(z.iso.datetime()),
    ends_at: z.iso.datetime(),
    closed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    state: zCampaignState,
    contact_link: z.union([
        z.url(),
        z.null()
    ]),
    alert_stats: z.optional(z.object({
        open_count: z.int(),
        closed_count: z.int(),
        in_progress_count: z.int()
    }))
});

/**
 * The name of the tool used to generate the code scanning analysis.
 */
export const zCodeScanningAnalysisToolName = z.string();

/**
 * The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.
 */
export const zCodeScanningAnalysisToolGuid = z.union([
    z.string(),
    z.null()
]);

/**
 * State of a code scanning alert.
 */
export const zCodeScanningAlertStateQuery = z.enum([
    'open',
    'closed',
    'dismissed',
    'fixed'
]);

/**
 * Severity of a code scanning alert.
 */
export const zCodeScanningAlertSeverity = z.enum([
    'critical',
    'high',
    'medium',
    'low',
    'warning',
    'note',
    'error'
]);

/**
 * The REST API URL for fetching the list of instances for an alert.
 */
export const zAlertInstancesUrl = z.url().readonly();

/**
 * State of a code scanning alert.
 */
export const zCodeScanningAlertState = z.enum([
    'open',
    'dismissed',
    'fixed'
]);

/**
 * **Required when the state is dismissed.** The reason for dismissing or closing the alert.
 */
export const zCodeScanningAlertDismissedReason = z.enum([
    'false positive',
    "won't fix",
    'used in tests'
]);

/**
 * The dismissal comment associated with the dismissal of the alert.
 */
export const zCodeScanningAlertDismissedComment = z.union([
    z.string().max(280),
    z.null()
]);

export const zCodeScanningAlertRuleSummary = z.object({
    id: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    name: z.optional(z.string()),
    severity: z.optional(z.enum([
        'none',
        'note',
        'warning',
        'error'
    ])),
    security_severity_level: z.optional(z.enum([
        'low',
        'medium',
        'high',
        'critical'
    ])),
    description: z.optional(z.string()),
    full_description: z.optional(z.string()),
    tags: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    help: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    help_uri: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

/**
 * The version of the tool used to generate the code scanning analysis.
 */
export const zCodeScanningAnalysisToolVersion = z.union([
    z.string(),
    z.null()
]);

export const zCodeScanningAnalysisTool = z.object({
    name: z.optional(zCodeScanningAnalysisToolName),
    version: z.optional(zCodeScanningAnalysisToolVersion),
    guid: z.optional(zCodeScanningAnalysisToolGuid)
});

/**
 * The Git reference, formatted as `refs/pull/<number>/merge`, `refs/pull/<number>/head`,
 * `refs/heads/<branch name>` or simply `<branch name>`.
 */
export const zCodeScanningRef = z.string();

/**
 * Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.
 */
export const zCodeScanningAnalysisAnalysisKey = z.string();

/**
 * Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.
 */
export const zCodeScanningAlertEnvironment = z.string();

/**
 * Identifies the configuration under which the analysis was executed. Used to distinguish between multiple analyses for the same tool and commit, but performed on different languages or different parts of the code.
 */
export const zCodeScanningAnalysisCategory = z.string();

/**
 * Describe a region within a file for the alert.
 */
export const zCodeScanningAlertLocation = z.object({
    path: z.optional(z.string()),
    start_line: z.optional(z.int()),
    end_line: z.optional(z.int()),
    start_column: z.optional(z.int()),
    end_column: z.optional(z.int())
});

/**
 * A classification of the file. For example to identify it as generated.
 */
export const zCodeScanningAlertClassification = z.enum([
    'source',
    'generated',
    'test',
    'library'
]);

export const zCodeScanningAlertInstance = z.object({
    ref: z.optional(zCodeScanningRef),
    analysis_key: z.optional(zCodeScanningAnalysisAnalysisKey),
    environment: z.optional(zCodeScanningAlertEnvironment),
    category: z.optional(zCodeScanningAnalysisCategory),
    state: z.optional(zCodeScanningAlertState),
    commit_sha: z.optional(z.string()),
    message: z.optional(z.object({
        text: z.optional(z.string())
    })),
    location: z.optional(zCodeScanningAlertLocation),
    html_url: z.optional(z.string()),
    classifications: z.optional(z.array(zCodeScanningAlertClassification))
});

export const zCodeScanningOrganizationAlertItems = z.object({
    number: zAlertNumber,
    created_at: zAlertCreatedAt,
    updated_at: z.optional(zAlertUpdatedAt),
    url: zAlertUrl,
    html_url: zAlertHtmlUrl,
    instances_url: zAlertInstancesUrl,
    state: zCodeScanningAlertState,
    fixed_at: z.optional(zAlertFixedAt),
    dismissed_by: zNullableSimpleUser,
    dismissed_at: zAlertDismissedAt,
    dismissed_reason: zCodeScanningAlertDismissedReason,
    dismissed_comment: z.optional(zCodeScanningAlertDismissedComment),
    rule: zCodeScanningAlertRuleSummary,
    tool: zCodeScanningAnalysisTool,
    most_recent_instance: zCodeScanningAlertInstance,
    repository: zSimpleRepository,
    dismissal_approved_by: z.optional(zNullableSimpleUser),
    assignees: z.optional(z.array(zSimpleUser))
});

/**
 * Codespace machine
 *
 * A description of the machine powering a codespace.
 */
export const zNullableCodespaceMachine = z.union([
    z.object({
        name: z.string(),
        display_name: z.string(),
        operating_system: z.string(),
        storage_in_bytes: z.int(),
        memory_in_bytes: z.int(),
        cpus: z.int(),
        prebuild_availability: z.enum([
            'none',
            'ready',
            'in_progress'
        ])
    }),
    z.null()
]);

/**
 * Codespace
 *
 * A codespace.
 */
export const zCodespace = z.object({
    id: z.coerce.bigint(),
    name: z.string(),
    display_name: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    environment_id: z.union([
        z.string(),
        z.null()
    ]),
    owner: zSimpleUser,
    billable_owner: zSimpleUser,
    repository: zMinimalRepository,
    machine: zNullableCodespaceMachine,
    devcontainer_path: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    prebuild: z.union([
        z.boolean(),
        z.null()
    ]),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    last_used_at: z.iso.datetime(),
    state: z.enum([
        'Unknown',
        'Created',
        'Queued',
        'Provisioning',
        'Available',
        'Awaiting',
        'Unavailable',
        'Deleted',
        'Moved',
        'Shutdown',
        'Archived',
        'Starting',
        'ShuttingDown',
        'Failed',
        'Exporting',
        'Updating',
        'Rebuilding'
    ]),
    url: z.url(),
    git_status: z.object({
        ahead: z.optional(z.int()),
        behind: z.optional(z.int()),
        has_unpushed_changes: z.optional(z.boolean()),
        has_uncommitted_changes: z.optional(z.boolean()),
        ref: z.optional(z.string())
    }),
    location: z.enum([
        'EastUs',
        'SouthEastAsia',
        'WestEurope',
        'WestUs2'
    ]),
    idle_timeout_minutes: z.union([
        z.int(),
        z.null()
    ]),
    web_url: z.url(),
    machines_url: z.url(),
    start_url: z.url(),
    stop_url: z.url(),
    publish_url: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    pulls_url: z.union([
        z.url(),
        z.null()
    ]),
    recent_folders: z.array(z.string()),
    runtime_constraints: z.optional(z.object({
        allowed_port_privacy_settings: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ]))
    })),
    pending_operation: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    pending_operation_disabled_reason: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    idle_timeout_notice: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    retention_period_minutes: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    retention_expires_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    last_known_stop_notice: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

/**
 * Codespaces Secret
 *
 * Secrets for a GitHub Codespace.
 */
export const zCodespacesOrgSecret = z.object({
    name: z.string(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    visibility: z.enum([
        'all',
        'private',
        'selected'
    ]),
    selected_repositories_url: z.optional(z.url())
});

/**
 * CodespacesPublicKey
 *
 * The public key used for setting Codespaces secrets.
 */
export const zCodespacesPublicKey = z.object({
    key_id: z.string(),
    key: z.string(),
    id: z.optional(z.int()),
    url: z.optional(z.string()),
    title: z.optional(z.string()),
    created_at: z.optional(z.string())
});

/**
 * Copilot Seat Breakdown
 *
 * The breakdown of Copilot Business seats for the organization.
 */
export const zCopilotOrganizationSeatBreakdown = z.object({
    total: z.optional(z.int()),
    added_this_cycle: z.optional(z.int()),
    pending_cancellation: z.optional(z.int()),
    pending_invitation: z.optional(z.int()),
    active_this_cycle: z.optional(z.int()),
    inactive_this_cycle: z.optional(z.int())
});

/**
 * Copilot Organization Details
 *
 * Information about the seat breakdown and policies set for an organization with a Copilot Business or Copilot Enterprise subscription.
 */
export const zCopilotOrganizationDetails = z.object({
    seat_breakdown: zCopilotOrganizationSeatBreakdown,
    public_code_suggestions: z.enum([
        'allow',
        'block',
        'unconfigured'
    ]),
    ide_chat: z.optional(z.enum([
        'enabled',
        'disabled',
        'unconfigured'
    ])),
    platform_chat: z.optional(z.enum([
        'enabled',
        'disabled',
        'unconfigured'
    ])),
    cli: z.optional(z.enum([
        'enabled',
        'disabled',
        'unconfigured'
    ])),
    seat_management_setting: z.enum([
        'assign_all',
        'assign_selected',
        'disabled',
        'unconfigured'
    ]),
    plan_type: z.optional(z.enum([
        'business',
        'enterprise'
    ]))
});

/**
 * Organization Simple
 *
 * A GitHub organization.
 */
export const zNullableOrganizationSimple = z.union([
    z.object({
        login: z.string(),
        id: z.int(),
        node_id: z.string(),
        url: z.url(),
        repos_url: z.url(),
        events_url: z.url(),
        hooks_url: z.string(),
        issues_url: z.string(),
        members_url: z.string(),
        public_members_url: z.string(),
        avatar_url: z.string(),
        description: z.union([
            z.string(),
            z.null()
        ])
    }),
    z.null()
]);

/**
 * Copilot Business Seat Detail
 *
 * Information about a Copilot Business seat assignment for a user, team, or organization.
 */
export const zCopilotSeatDetails = z.object({
    assignee: z.optional(zNullableSimpleUser),
    organization: z.optional(zNullableOrganizationSimple),
    assigning_team: z.optional(z.union([
        zTeam,
        zEnterpriseTeam,
        z.null()
    ])),
    pending_cancellation_date: z.optional(z.union([
        z.iso.date(),
        z.null()
    ])),
    last_activity_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    last_activity_editor: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    last_authenticated_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    created_at: z.iso.datetime(),
    updated_at: z.optional(z.iso.datetime()),
    plan_type: z.optional(z.enum([
        'business',
        'enterprise',
        'unknown'
    ]))
});

/**
 * Usage metrics for Copilot editor code completions in the IDE.
 */
export const zCopilotIdeCodeCompletions = z.union([
    z.object({
        total_engaged_users: z.optional(z.int()),
        languages: z.optional(z.array(z.object({
            name: z.optional(z.string()),
            total_engaged_users: z.optional(z.int())
        }))),
        editors: z.optional(z.array(z.object({
            name: z.optional(z.string()),
            total_engaged_users: z.optional(z.int()),
            models: z.optional(z.array(z.object({
                name: z.optional(z.string()),
                is_custom_model: z.optional(z.boolean()),
                custom_model_training_date: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                total_engaged_users: z.optional(z.int()),
                languages: z.optional(z.array(z.object({
                    name: z.optional(z.string()),
                    total_engaged_users: z.optional(z.int()),
                    total_code_suggestions: z.optional(z.int()),
                    total_code_acceptances: z.optional(z.int()),
                    total_code_lines_suggested: z.optional(z.int()),
                    total_code_lines_accepted: z.optional(z.int())
                })))
            })))
        })))
    }),
    z.null()
]);

/**
 * Usage metrics for Copilot Chat in the IDE.
 */
export const zCopilotIdeChat = z.union([
    z.object({
        total_engaged_users: z.optional(z.int()),
        editors: z.optional(z.array(z.object({
            name: z.optional(z.string()),
            total_engaged_users: z.optional(z.int()),
            models: z.optional(z.array(z.object({
                name: z.optional(z.string()),
                is_custom_model: z.optional(z.boolean()),
                custom_model_training_date: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                total_engaged_users: z.optional(z.int()),
                total_chats: z.optional(z.int()),
                total_chat_insertion_events: z.optional(z.int()),
                total_chat_copy_events: z.optional(z.int())
            })))
        })))
    }),
    z.null()
]);

/**
 * Usage metrics for Copilot Chat in GitHub.com
 */
export const zCopilotDotcomChat = z.union([
    z.object({
        total_engaged_users: z.optional(z.int()),
        models: z.optional(z.array(z.object({
            name: z.optional(z.string()),
            is_custom_model: z.optional(z.boolean()),
            custom_model_training_date: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            total_engaged_users: z.optional(z.int()),
            total_chats: z.optional(z.int())
        })))
    }),
    z.null()
]);

/**
 * Usage metrics for Copilot for pull requests.
 */
export const zCopilotDotcomPullRequests = z.union([
    z.object({
        total_engaged_users: z.optional(z.int()),
        repositories: z.optional(z.array(z.object({
            name: z.optional(z.string()),
            total_engaged_users: z.optional(z.int()),
            models: z.optional(z.array(z.object({
                name: z.optional(z.string()),
                is_custom_model: z.optional(z.boolean()),
                custom_model_training_date: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                total_pr_summaries_created: z.optional(z.int()),
                total_engaged_users: z.optional(z.int())
            })))
        })))
    }),
    z.null()
]);

/**
 * Copilot Usage Metrics
 *
 * Copilot usage metrics for a given day.
 */
export const zCopilotUsageMetricsDay = z.object({
    date: z.iso.date(),
    total_active_users: z.optional(z.int()),
    total_engaged_users: z.optional(z.int()),
    copilot_ide_code_completions: z.optional(zCopilotIdeCodeCompletions),
    copilot_ide_chat: z.optional(zCopilotIdeChat),
    copilot_dotcom_chat: z.optional(zCopilotDotcomChat),
    copilot_dotcom_pull_requests: z.optional(zCopilotDotcomPullRequests)
});

/**
 * Dependabot Secret for an Organization
 *
 * Secrets for GitHub Dependabot for an organization.
 */
export const zOrganizationDependabotSecret = z.object({
    name: z.string(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    visibility: z.enum([
        'all',
        'private',
        'selected'
    ]),
    selected_repositories_url: z.optional(z.url())
});

/**
 * DependabotPublicKey
 *
 * The public key used for setting Dependabot Secrets.
 */
export const zDependabotPublicKey = z.object({
    key_id: z.string(),
    key: z.string()
});

/**
 * Minimal Repository
 *
 * Minimal Repository
 */
export const zNullableMinimalRepository = z.union([
    z.object({
        id: z.coerce.bigint(),
        node_id: z.string(),
        name: z.string(),
        full_name: z.string(),
        owner: zSimpleUser,
        private: z.boolean(),
        html_url: z.url(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        fork: z.boolean(),
        url: z.url(),
        archive_url: z.string(),
        assignees_url: z.string(),
        blobs_url: z.string(),
        branches_url: z.string(),
        collaborators_url: z.string(),
        comments_url: z.string(),
        commits_url: z.string(),
        compare_url: z.string(),
        contents_url: z.string(),
        contributors_url: z.url(),
        deployments_url: z.url(),
        downloads_url: z.url(),
        events_url: z.url(),
        forks_url: z.url(),
        git_commits_url: z.string(),
        git_refs_url: z.string(),
        git_tags_url: z.string(),
        git_url: z.optional(z.string()),
        issue_comment_url: z.string(),
        issue_events_url: z.string(),
        issues_url: z.string(),
        keys_url: z.string(),
        labels_url: z.string(),
        languages_url: z.url(),
        merges_url: z.url(),
        milestones_url: z.string(),
        notifications_url: z.string(),
        pulls_url: z.string(),
        releases_url: z.string(),
        ssh_url: z.optional(z.string()),
        stargazers_url: z.url(),
        statuses_url: z.string(),
        subscribers_url: z.url(),
        subscription_url: z.url(),
        tags_url: z.url(),
        teams_url: z.url(),
        trees_url: z.string(),
        clone_url: z.optional(z.string()),
        mirror_url: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        hooks_url: z.url(),
        svn_url: z.optional(z.string()),
        homepage: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        language: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        forks_count: z.optional(z.int()),
        stargazers_count: z.optional(z.int()),
        watchers_count: z.optional(z.int()),
        size: z.optional(z.int()),
        default_branch: z.optional(z.string()),
        open_issues_count: z.optional(z.int()),
        is_template: z.optional(z.boolean()),
        topics: z.optional(z.array(z.string())),
        has_issues: z.optional(z.boolean()),
        has_projects: z.optional(z.boolean()),
        has_wiki: z.optional(z.boolean()),
        has_pages: z.optional(z.boolean()),
        has_downloads: z.optional(z.boolean()),
        has_discussions: z.optional(z.boolean()),
        archived: z.optional(z.boolean()),
        disabled: z.optional(z.boolean()),
        visibility: z.optional(z.string()),
        pushed_at: z.optional(z.union([
            z.iso.datetime(),
            z.null()
        ])),
        created_at: z.optional(z.union([
            z.iso.datetime(),
            z.null()
        ])),
        updated_at: z.optional(z.union([
            z.iso.datetime(),
            z.null()
        ])),
        permissions: z.optional(z.object({
            admin: z.optional(z.boolean()),
            maintain: z.optional(z.boolean()),
            push: z.optional(z.boolean()),
            triage: z.optional(z.boolean()),
            pull: z.optional(z.boolean())
        })),
        role_name: z.optional(z.string()),
        temp_clone_token: z.optional(z.string()),
        delete_branch_on_merge: z.optional(z.boolean()),
        subscribers_count: z.optional(z.int()),
        network_count: z.optional(z.int()),
        code_of_conduct: z.optional(zCodeOfConduct),
        license: z.optional(z.union([
            z.object({
                key: z.optional(z.string()),
                name: z.optional(z.string()),
                spdx_id: z.optional(z.string()),
                url: z.optional(z.string()),
                node_id: z.optional(z.string())
            }),
            z.null()
        ])),
        forks: z.optional(z.int()),
        open_issues: z.optional(z.int()),
        watchers: z.optional(z.int()),
        allow_forking: z.optional(z.boolean()),
        web_commit_signoff_required: z.optional(z.boolean()),
        security_and_analysis: z.optional(zSecurityAndAnalysis),
        custom_properties: z.optional(z.record(z.string(), z.unknown()))
    }),
    z.null()
]);

/**
 * Package
 *
 * A software package
 */
export const zPackage = z.object({
    id: z.int(),
    name: z.string(),
    package_type: z.enum([
        'npm',
        'maven',
        'rubygems',
        'docker',
        'nuget',
        'container'
    ]),
    url: z.string(),
    html_url: z.string(),
    version_count: z.int(),
    visibility: z.enum([
        'private',
        'public'
    ]),
    owner: z.optional(zNullableSimpleUser),
    repository: z.optional(zNullableMinimalRepository),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime()
});

/**
 * Organization Invitation
 *
 * Organization Invitation
 */
export const zOrganizationInvitation = z.object({
    id: z.coerce.bigint(),
    login: z.union([
        z.string(),
        z.null()
    ]),
    email: z.union([
        z.string(),
        z.null()
    ]),
    role: z.string(),
    created_at: z.string(),
    failed_at: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    failed_reason: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    inviter: zSimpleUser,
    team_count: z.int(),
    node_id: z.string(),
    invitation_teams_url: z.string(),
    invitation_source: z.optional(z.string())
});

/**
 * Org Hook
 *
 * Org Hook
 */
export const zOrgHook = z.object({
    id: z.int(),
    url: z.url(),
    ping_url: z.url(),
    deliveries_url: z.optional(z.url()),
    name: z.string(),
    events: z.array(z.string()),
    active: z.boolean(),
    config: z.object({
        url: z.optional(z.string()),
        insecure_ssl: z.optional(z.string()),
        content_type: z.optional(z.string()),
        secret: z.optional(z.string())
    }),
    updated_at: z.iso.datetime(),
    created_at: z.iso.datetime(),
    type: z.string()
});

/**
 * Route Stats
 *
 * API Insights usage route stats for an actor
 */
export const zApiInsightsRouteStats = z.array(z.object({
    http_method: z.optional(z.string()),
    api_route: z.optional(z.string()),
    total_request_count: z.optional(z.coerce.bigint()),
    rate_limited_request_count: z.optional(z.coerce.bigint()),
    last_rate_limited_timestamp: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    last_request_timestamp: z.optional(z.string())
}));

/**
 * Subject Stats
 *
 * API Insights usage subject stats for an organization
 */
export const zApiInsightsSubjectStats = z.array(z.object({
    subject_type: z.optional(z.string()),
    subject_name: z.optional(z.string()),
    subject_id: z.optional(z.coerce.bigint()),
    total_request_count: z.optional(z.int()),
    rate_limited_request_count: z.optional(z.int()),
    last_rate_limited_timestamp: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    last_request_timestamp: z.optional(z.string())
}));

/**
 * Summary Stats
 *
 * API Insights usage summary stats for an organization
 */
export const zApiInsightsSummaryStats = z.object({
    total_request_count: z.optional(z.coerce.bigint()),
    rate_limited_request_count: z.optional(z.coerce.bigint())
});

/**
 * Time Stats
 *
 * API Insights usage time stats for an organization
 */
export const zApiInsightsTimeStats = z.array(z.object({
    timestamp: z.optional(z.string()),
    total_request_count: z.optional(z.coerce.bigint()),
    rate_limited_request_count: z.optional(z.coerce.bigint())
}));

/**
 * User Stats
 *
 * API Insights usage stats for a user
 */
export const zApiInsightsUserStats = z.array(z.object({
    actor_type: z.optional(z.string()),
    actor_name: z.optional(z.string()),
    actor_id: z.optional(z.coerce.bigint()),
    integration_id: z.optional(z.union([
        z.coerce.bigint(),
        z.null()
    ])),
    oauth_application_id: z.optional(z.union([
        z.coerce.bigint(),
        z.null()
    ])),
    total_request_count: z.optional(z.int()),
    rate_limited_request_count: z.optional(z.int()),
    last_rate_limited_timestamp: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    last_request_timestamp: z.optional(z.string())
}));

/**
 * The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.
 */
export const zInteractionGroup = z.enum([
    'existing_users',
    'contributors_only',
    'collaborators_only'
]);

/**
 * Interaction Limits
 *
 * Interaction limit settings.
 */
export const zInteractionLimitResponse = z.object({
    limit: zInteractionGroup,
    origin: z.string(),
    expires_at: z.iso.datetime()
});

/**
 * The duration of the interaction restriction. Default: `one_day`.
 */
export const zInteractionExpiry = z.enum([
    'one_day',
    'three_days',
    'one_week',
    'one_month',
    'six_months'
]);

/**
 * Interaction Restrictions
 *
 * Limit interactions to a specific type of user for a specified duration
 */
export const zInteractionLimit = z.object({
    limit: zInteractionGroup,
    expiry: z.optional(zInteractionExpiry)
});

export const zOrganizationCreateIssueType = z.object({
    name: z.string(),
    is_enabled: z.boolean(),
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    color: z.optional(z.enum([
        'gray',
        'blue',
        'green',
        'yellow',
        'orange',
        'red',
        'pink',
        'purple'
    ]))
});

export const zOrganizationUpdateIssueType = z.object({
    name: z.string(),
    is_enabled: z.boolean(),
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    color: z.optional(z.enum([
        'gray',
        'blue',
        'green',
        'yellow',
        'orange',
        'red',
        'pink',
        'purple'
    ]))
});

/**
 * Org Membership
 *
 * Org Membership
 */
export const zOrgMembership = z.object({
    url: z.url(),
    state: z.enum([
        'active',
        'pending'
    ]),
    role: z.enum([
        'admin',
        'member',
        'billing_manager'
    ]),
    direct_membership: z.optional(z.boolean()),
    enterprise_teams_providing_indirect_membership: z.optional(z.array(z.string()).max(100)),
    organization_url: z.url(),
    organization: zOrganizationSimple,
    user: zNullableSimpleUser,
    permissions: z.optional(z.object({
        can_create_repository: z.boolean()
    }))
});

/**
 * Migration
 *
 * A migration.
 */
export const zMigration = z.object({
    id: z.coerce.bigint(),
    owner: zNullableSimpleUser,
    guid: z.string(),
    state: z.string(),
    lock_repositories: z.boolean(),
    exclude_metadata: z.boolean(),
    exclude_git_data: z.boolean(),
    exclude_attachments: z.boolean(),
    exclude_releases: z.boolean(),
    exclude_owner_projects: z.boolean(),
    org_metadata_only: z.boolean(),
    repositories: z.array(zRepository),
    url: z.url(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    node_id: z.string(),
    archive_url: z.optional(z.url()),
    exclude: z.optional(z.array(z.string()))
});

/**
 * Organization Role
 *
 * Organization roles
 */
export const zOrganizationRole = z.object({
    id: z.coerce.bigint(),
    name: z.string(),
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    base_role: z.optional(z.enum([
        'read',
        'triage',
        'write',
        'maintain',
        'admin'
    ])),
    source: z.optional(z.enum([
        'Organization',
        'Enterprise',
        'Predefined'
    ])),
    permissions: z.array(z.string()),
    organization: zNullableSimpleUser,
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime()
});

/**
 * A Role Assignment for a Team
 *
 * The Relationship a Team has with a role.
 */
export const zTeamRoleAssignment = z.object({
    assignment: z.optional(z.enum([
        'direct',
        'indirect',
        'mixed'
    ])),
    id: z.int(),
    node_id: z.string(),
    name: z.string(),
    slug: z.string(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    privacy: z.optional(z.string()),
    notification_setting: z.optional(z.string()),
    permission: z.string(),
    permissions: z.optional(z.object({
        pull: z.boolean(),
        triage: z.boolean(),
        push: z.boolean(),
        maintain: z.boolean(),
        admin: z.boolean()
    })),
    url: z.url(),
    html_url: z.url(),
    members_url: z.string(),
    repositories_url: z.url(),
    parent: zNullableTeamSimple,
    type: z.enum([
        'enterprise',
        'organization'
    ]),
    organization_id: z.optional(z.int()),
    enterprise_id: z.optional(z.int())
});

/**
 * Team Simple
 *
 * Groups of organization members that gives permissions on specified repositories.
 */
export const zTeamSimple = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.url(),
    members_url: z.string(),
    name: z.string(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    permission: z.string(),
    privacy: z.optional(z.string()),
    notification_setting: z.optional(z.string()),
    html_url: z.url(),
    repositories_url: z.url(),
    slug: z.string(),
    ldap_dn: z.optional(z.string()),
    type: z.enum([
        'enterprise',
        'organization'
    ]),
    organization_id: z.optional(z.int()),
    enterprise_id: z.optional(z.int())
});

/**
 * A Role Assignment for a User
 *
 * The Relationship a User has with a role.
 */
export const zUserRoleAssignment = z.object({
    assignment: z.optional(z.enum([
        'direct',
        'indirect',
        'mixed'
    ])),
    inherited_from: z.optional(z.array(zTeamSimple)),
    name: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    email: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    login: z.string(),
    id: z.int(),
    node_id: z.string(),
    avatar_url: z.url(),
    gravatar_id: z.union([
        z.string(),
        z.null()
    ]),
    url: z.url(),
    html_url: z.url(),
    followers_url: z.url(),
    following_url: z.string(),
    gists_url: z.string(),
    starred_url: z.string(),
    subscriptions_url: z.url(),
    organizations_url: z.url(),
    repos_url: z.url(),
    events_url: z.string(),
    received_events_url: z.url(),
    type: z.string(),
    site_admin: z.boolean(),
    starred_at: z.optional(z.string()),
    user_view_type: z.optional(z.string())
});

/**
 * Package Version
 *
 * A version of a software package
 */
export const zPackageVersion = z.object({
    id: z.int(),
    name: z.string(),
    url: z.string(),
    package_html_url: z.string(),
    html_url: z.optional(z.string()),
    license: z.optional(z.string()),
    description: z.optional(z.string()),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    deleted_at: z.optional(z.iso.datetime()),
    metadata: z.optional(z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        container: z.optional(z.object({
            tags: z.array(z.string())
        })),
        docker: z.optional(z.object({
            tag: z.optional(z.array(z.string()))
        }))
    }))
});

/**
 * Simple Organization Programmatic Access Grant Request
 *
 * Minimal representation of an organization programmatic access grant request for enumerations
 */
export const zOrganizationProgrammaticAccessGrantRequest = z.object({
    id: z.int(),
    reason: z.union([
        z.string(),
        z.null()
    ]),
    owner: zSimpleUser,
    repository_selection: z.enum([
        'none',
        'all',
        'subset'
    ]),
    repositories_url: z.string(),
    permissions: z.object({
        organization: z.optional(z.record(z.string(), z.string())),
        repository: z.optional(z.record(z.string(), z.string())),
        other: z.optional(z.record(z.string(), z.string()))
    }),
    created_at: z.string(),
    token_id: z.int(),
    token_name: z.string(),
    token_expired: z.boolean(),
    token_expires_at: z.union([
        z.string(),
        z.null()
    ]),
    token_last_used_at: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Organization Programmatic Access Grant
 *
 * Minimal representation of an organization programmatic access grant for enumerations
 */
export const zOrganizationProgrammaticAccessGrant = z.object({
    id: z.int(),
    owner: zSimpleUser,
    repository_selection: z.enum([
        'none',
        'all',
        'subset'
    ]),
    repositories_url: z.string(),
    permissions: z.object({
        organization: z.optional(z.record(z.string(), z.string())),
        repository: z.optional(z.record(z.string(), z.string())),
        other: z.optional(z.record(z.string(), z.string()))
    }),
    access_granted_at: z.string(),
    token_id: z.int(),
    token_name: z.string(),
    token_expired: z.boolean(),
    token_expires_at: z.union([
        z.string(),
        z.null()
    ]),
    token_last_used_at: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Organization private registry
 *
 * Private registry configuration for an organization
 */
export const zOrgPrivateRegistryConfiguration = z.object({
    name: z.string(),
    registry_type: z.enum([
        'maven_repository',
        'nuget_feed',
        'goproxy_server',
        'npm_registry',
        'rubygems_server',
        'cargo_registry',
        'composer_repository',
        'docker_registry',
        'git_source',
        'helm_registry',
        'hex_organization',
        'hex_repository',
        'pub_repository',
        'python_index',
        'terraform_registry'
    ]),
    username: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    visibility: z.enum([
        'all',
        'private',
        'selected'
    ]),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime()
});

/**
 * Organization private registry
 *
 * Private registry configuration for an organization
 */
export const zOrgPrivateRegistryConfigurationWithSelectedRepositories = z.object({
    name: z.string(),
    registry_type: z.enum([
        'maven_repository',
        'nuget_feed',
        'goproxy_server',
        'npm_registry',
        'rubygems_server',
        'cargo_registry',
        'composer_repository',
        'docker_registry',
        'git_source',
        'helm_registry',
        'hex_organization',
        'hex_repository',
        'pub_repository',
        'python_index',
        'terraform_registry'
    ]),
    username: z.optional(z.string()),
    visibility: z.enum([
        'all',
        'private',
        'selected'
    ]),
    selected_repository_ids: z.optional(z.array(z.int())),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime()
});

/**
 * Project
 *
 * Projects are a way to organize columns and cards of work.
 */
export const zProject = z.object({
    owner_url: z.url(),
    url: z.url(),
    html_url: z.url(),
    columns_url: z.url(),
    id: z.int(),
    node_id: z.string(),
    name: z.string(),
    body: z.union([
        z.string(),
        z.null()
    ]),
    number: z.int(),
    state: z.string(),
    creator: zNullableSimpleUser,
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    organization_permission: z.optional(z.enum([
        'read',
        'write',
        'admin',
        'none'
    ])),
    private: z.optional(z.boolean())
});

/**
 * Projects v2 Status Update
 *
 * An status update belonging to a project
 */
export const zNullableProjectsV2StatusUpdate = z.union([
    z.object({
        id: z.number(),
        node_id: z.string(),
        project_node_id: z.optional(z.string()),
        creator: z.optional(zSimpleUser),
        created_at: z.iso.datetime(),
        updated_at: z.iso.datetime(),
        status: z.optional(z.enum([
            'INACTIVE',
            'ON_TRACK',
            'AT_RISK',
            'OFF_TRACK',
            'COMPLETE'
        ])),
        start_date: z.optional(z.iso.date()),
        target_date: z.optional(z.iso.date()),
        body: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    }),
    z.null()
]);

/**
 * Projects v2 Project
 *
 * A projects v2 project
 */
export const zProjectsV2 = z.object({
    id: z.number(),
    node_id: z.string(),
    owner: zSimpleUser,
    creator: zSimpleUser,
    title: z.string(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    public: z.boolean(),
    closed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    number: z.int(),
    short_description: z.union([
        z.string(),
        z.null()
    ]),
    deleted_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    deleted_by: zNullableSimpleUser,
    state: z.optional(z.enum([
        'open',
        'closed'
    ])),
    latest_status_update: z.optional(zNullableProjectsV2StatusUpdate),
    is_template: z.optional(z.boolean())
});

/**
 * Projects v2 Single Select Option
 *
 * An option for a single select field
 */
export const zProjectsV2SingleSelectOptions = z.object({
    id: z.string(),
    name: z.object({
        raw: z.string(),
        html: z.string()
    }),
    description: z.object({
        raw: z.string(),
        html: z.string()
    }),
    color: z.string()
});

/**
 * Projects v2 Iteration Setting
 *
 * An iteration setting for an iteration field
 */
export const zProjectsV2IterationSettings = z.object({
    id: z.string(),
    start_date: z.iso.date(),
    duration: z.int(),
    title: z.object({
        raw: z.string(),
        html: z.string()
    }),
    completed: z.boolean()
});

/**
 * Projects v2 Field
 *
 * A field inside a projects v2 project
 */
export const zProjectsV2Field = z.object({
    id: z.int(),
    node_id: z.optional(z.string()),
    project_url: z.string(),
    name: z.string(),
    data_type: z.enum([
        'assignees',
        'linked_pull_requests',
        'reviewers',
        'labels',
        'milestone',
        'repository',
        'title',
        'text',
        'single_select',
        'number',
        'date',
        'iteration',
        'issue_type',
        'parent_issue',
        'sub_issues_progress'
    ]),
    options: z.optional(z.array(zProjectsV2SingleSelectOptions)),
    configuration: z.optional(z.object({
        start_day: z.optional(z.int()),
        duration: z.optional(z.int()),
        iterations: z.optional(z.array(zProjectsV2IterationSettings))
    })),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime()
});

/**
 * Projects v2 Item Content Type
 *
 * The type of content tracked in a project item
 */
export const zProjectsV2ItemContentType = z.enum([
    'Issue',
    'PullRequest',
    'DraftIssue'
]);

/**
 * Projects v2 Item
 *
 * An item belonging to a project
 */
export const zProjectsV2ItemWithContent = z.object({
    id: z.number(),
    node_id: z.optional(z.string()),
    project_url: z.optional(z.url()),
    content_type: zProjectsV2ItemContentType,
    content: z.optional(z.union([
        z.record(z.string(), z.unknown()),
        z.null()
    ])),
    creator: z.optional(zSimpleUser),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    archived_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    item_url: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    fields: z.optional(z.array(z.record(z.string(), z.unknown())))
});

/**
 * Link
 *
 * Hypermedia Link
 */
export const zLink = z.object({
    href: z.string()
});

/**
 * Auto merge
 *
 * The status of auto merging a pull request.
 */
export const zAutoMerge = z.union([
    z.object({
        enabled_by: zSimpleUser,
        merge_method: z.enum([
            'merge',
            'squash',
            'rebase'
        ]),
        commit_title: z.string(),
        commit_message: z.string()
    }),
    z.null()
]);

/**
 * Pull Request Simple
 *
 * Pull Request Simple
 */
export const zPullRequestSimple = z.object({
    url: z.url(),
    id: z.coerce.bigint(),
    node_id: z.string(),
    html_url: z.url(),
    diff_url: z.url(),
    patch_url: z.url(),
    issue_url: z.url(),
    commits_url: z.url(),
    review_comments_url: z.url(),
    review_comment_url: z.string(),
    comments_url: z.url(),
    statuses_url: z.url(),
    number: z.int(),
    state: z.string(),
    locked: z.boolean(),
    title: z.string(),
    user: zNullableSimpleUser,
    body: z.union([
        z.string(),
        z.null()
    ]),
    labels: z.array(z.object({
        id: z.coerce.bigint(),
        node_id: z.string(),
        url: z.string(),
        name: z.string(),
        description: z.string(),
        color: z.string(),
        default: z.boolean()
    })),
    milestone: zNullableMilestone,
    active_lock_reason: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    closed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    merged_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    merge_commit_sha: z.union([
        z.string(),
        z.null()
    ]),
    assignee: zNullableSimpleUser,
    assignees: z.optional(z.union([
        z.array(zSimpleUser),
        z.null()
    ])),
    requested_reviewers: z.optional(z.union([
        z.array(zSimpleUser),
        z.null()
    ])),
    requested_teams: z.optional(z.union([
        z.array(zTeam),
        z.null()
    ])),
    head: z.object({
        label: z.string(),
        ref: z.string(),
        repo: zRepository,
        sha: z.string(),
        user: zNullableSimpleUser
    }),
    base: z.object({
        label: z.string(),
        ref: z.string(),
        repo: zRepository,
        sha: z.string(),
        user: zNullableSimpleUser
    }),
    _links: z.object({
        comments: zLink,
        commits: zLink,
        statuses: zLink,
        html: zLink,
        issue: zLink,
        review_comments: zLink,
        review_comment: zLink,
        self: zLink
    }),
    author_association: zAuthorAssociation,
    auto_merge: zAutoMerge,
    draft: z.optional(z.boolean())
});

/**
 * Draft Issue
 *
 * A draft issue in a project
 */
export const zProjectsV2DraftIssue = z.object({
    id: z.number(),
    node_id: z.string(),
    title: z.string(),
    body: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    user: zNullableSimpleUser,
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime()
});

/**
 * Projects v2 Item
 *
 * An item belonging to a project
 */
export const zProjectsV2ItemSimple = z.object({
    id: z.number(),
    node_id: z.optional(z.string()),
    content: z.optional(z.union([
        zIssue,
        zPullRequestSimple,
        zProjectsV2DraftIssue
    ])),
    content_type: zProjectsV2ItemContentType,
    creator: z.optional(zSimpleUser),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    archived_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    project_url: z.optional(z.url()),
    item_url: z.optional(z.url())
});

/**
 * Organization Custom Property
 *
 * Custom property defined on an organization
 */
export const zCustomProperty = z.object({
    property_name: z.string(),
    url: z.optional(z.url()),
    source_type: z.optional(z.enum([
        'organization',
        'enterprise'
    ])),
    value_type: z.enum([
        'string',
        'single_select',
        'multi_select',
        'true_false'
    ]),
    required: z.optional(z.boolean()),
    default_value: z.optional(z.union([
        z.string(),
        z.array(z.string()),
        z.null()
    ])),
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    allowed_values: z.optional(z.union([
        z.array(z.string().max(75)).max(200),
        z.null()
    ])),
    values_editable_by: z.optional(z.enum([
        'org_actors',
        'org_and_repo_actors'
    ]))
});

/**
 * Custom Property Set Payload
 *
 * Custom property set payload
 */
export const zCustomPropertySetPayload = z.object({
    value_type: z.enum([
        'string',
        'single_select',
        'multi_select',
        'true_false'
    ]),
    required: z.optional(z.boolean()),
    default_value: z.optional(z.union([
        z.string(),
        z.array(z.string()),
        z.null()
    ])),
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    allowed_values: z.optional(z.union([
        z.array(z.string().max(75)).max(200),
        z.null()
    ])),
    values_editable_by: z.optional(z.enum([
        'org_actors',
        'org_and_repo_actors'
    ]))
});

/**
 * Organization Repository Custom Property Values
 *
 * List of custom property values for a repository
 */
export const zOrgRepoCustomPropertyValues = z.object({
    repository_id: z.int(),
    repository_name: z.string(),
    repository_full_name: z.string(),
    properties: z.array(zCustomPropertyValue)
});

/**
 * Repository
 *
 * A repository on GitHub.
 */
export const zNullableRepository = z.union([
    z.object({
        id: z.coerce.bigint(),
        node_id: z.string(),
        name: z.string(),
        full_name: z.string(),
        license: zNullableLicenseSimple,
        forks: z.int(),
        permissions: z.optional(z.object({
            admin: z.boolean(),
            pull: z.boolean(),
            triage: z.optional(z.boolean()),
            push: z.boolean(),
            maintain: z.optional(z.boolean())
        })),
        owner: zSimpleUser,
        private: z.boolean().default(false),
        html_url: z.url(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        fork: z.boolean(),
        url: z.url(),
        archive_url: z.string(),
        assignees_url: z.string(),
        blobs_url: z.string(),
        branches_url: z.string(),
        collaborators_url: z.string(),
        comments_url: z.string(),
        commits_url: z.string(),
        compare_url: z.string(),
        contents_url: z.string(),
        contributors_url: z.url(),
        deployments_url: z.url(),
        downloads_url: z.url(),
        events_url: z.url(),
        forks_url: z.url(),
        git_commits_url: z.string(),
        git_refs_url: z.string(),
        git_tags_url: z.string(),
        git_url: z.string(),
        issue_comment_url: z.string(),
        issue_events_url: z.string(),
        issues_url: z.string(),
        keys_url: z.string(),
        labels_url: z.string(),
        languages_url: z.url(),
        merges_url: z.url(),
        milestones_url: z.string(),
        notifications_url: z.string(),
        pulls_url: z.string(),
        releases_url: z.string(),
        ssh_url: z.string(),
        stargazers_url: z.url(),
        statuses_url: z.string(),
        subscribers_url: z.url(),
        subscription_url: z.url(),
        tags_url: z.url(),
        teams_url: z.url(),
        trees_url: z.string(),
        clone_url: z.string(),
        mirror_url: z.union([
            z.url(),
            z.null()
        ]),
        hooks_url: z.url(),
        svn_url: z.url(),
        homepage: z.union([
            z.url(),
            z.null()
        ]),
        language: z.union([
            z.string(),
            z.null()
        ]),
        forks_count: z.int(),
        stargazers_count: z.int(),
        watchers_count: z.int(),
        size: z.int(),
        default_branch: z.string(),
        open_issues_count: z.int(),
        is_template: z.optional(z.boolean()).default(false),
        topics: z.optional(z.array(z.string())),
        has_issues: z.boolean().default(true),
        has_projects: z.boolean().default(true),
        has_wiki: z.boolean().default(true),
        has_pages: z.boolean(),
        has_downloads: z.boolean().default(true),
        has_discussions: z.optional(z.boolean()).default(false),
        archived: z.boolean().default(false),
        disabled: z.boolean(),
        visibility: z.optional(z.string()).default('public'),
        pushed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        created_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        updated_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        allow_rebase_merge: z.optional(z.boolean()).default(true),
        temp_clone_token: z.optional(z.string()),
        allow_squash_merge: z.optional(z.boolean()).default(true),
        allow_auto_merge: z.optional(z.boolean()).default(false),
        delete_branch_on_merge: z.optional(z.boolean()).default(false),
        allow_update_branch: z.optional(z.boolean()).default(false),
        use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
        squash_merge_commit_title: z.optional(z.enum([
            'PR_TITLE',
            'COMMIT_OR_PR_TITLE'
        ])),
        squash_merge_commit_message: z.optional(z.enum([
            'PR_BODY',
            'COMMIT_MESSAGES',
            'BLANK'
        ])),
        merge_commit_title: z.optional(z.enum([
            'PR_TITLE',
            'MERGE_MESSAGE'
        ])),
        merge_commit_message: z.optional(z.enum([
            'PR_BODY',
            'PR_TITLE',
            'BLANK'
        ])),
        allow_merge_commit: z.optional(z.boolean()).default(true),
        allow_forking: z.optional(z.boolean()),
        web_commit_signoff_required: z.optional(z.boolean()).default(false),
        open_issues: z.int(),
        watchers: z.int(),
        master_branch: z.optional(z.string()),
        starred_at: z.optional(z.string()),
        anonymous_access_enabled: z.optional(z.boolean()),
        code_search_index_status: z.optional(z.object({
            lexical_search_ok: z.optional(z.boolean()),
            lexical_commit_sha: z.optional(z.string())
        }))
    }),
    z.null()
]);

/**
 * Code Of Conduct Simple
 *
 * Code of Conduct Simple
 */
export const zCodeOfConductSimple = z.object({
    url: z.url(),
    key: z.string(),
    name: z.string(),
    html_url: z.union([
        z.url(),
        z.null()
    ])
});

/**
 * Full Repository
 *
 * Full Repository
 */
export const zFullRepository = z.object({
    id: z.coerce.bigint(),
    node_id: z.string(),
    name: z.string(),
    full_name: z.string(),
    owner: zSimpleUser,
    private: z.boolean(),
    html_url: z.url(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    fork: z.boolean(),
    url: z.url(),
    archive_url: z.string(),
    assignees_url: z.string(),
    blobs_url: z.string(),
    branches_url: z.string(),
    collaborators_url: z.string(),
    comments_url: z.string(),
    commits_url: z.string(),
    compare_url: z.string(),
    contents_url: z.string(),
    contributors_url: z.url(),
    deployments_url: z.url(),
    downloads_url: z.url(),
    events_url: z.url(),
    forks_url: z.url(),
    git_commits_url: z.string(),
    git_refs_url: z.string(),
    git_tags_url: z.string(),
    git_url: z.string(),
    issue_comment_url: z.string(),
    issue_events_url: z.string(),
    issues_url: z.string(),
    keys_url: z.string(),
    labels_url: z.string(),
    languages_url: z.url(),
    merges_url: z.url(),
    milestones_url: z.string(),
    notifications_url: z.string(),
    pulls_url: z.string(),
    releases_url: z.string(),
    ssh_url: z.string(),
    stargazers_url: z.url(),
    statuses_url: z.string(),
    subscribers_url: z.url(),
    subscription_url: z.url(),
    tags_url: z.url(),
    teams_url: z.url(),
    trees_url: z.string(),
    clone_url: z.string(),
    mirror_url: z.union([
        z.url(),
        z.null()
    ]),
    hooks_url: z.url(),
    svn_url: z.url(),
    homepage: z.union([
        z.url(),
        z.null()
    ]),
    language: z.union([
        z.string(),
        z.null()
    ]),
    forks_count: z.int(),
    stargazers_count: z.int(),
    watchers_count: z.int(),
    size: z.int(),
    default_branch: z.string(),
    open_issues_count: z.int(),
    is_template: z.optional(z.boolean()),
    topics: z.optional(z.array(z.string())),
    has_issues: z.boolean(),
    has_projects: z.boolean(),
    has_wiki: z.boolean(),
    has_pages: z.boolean(),
    has_downloads: z.optional(z.boolean()),
    has_discussions: z.boolean(),
    archived: z.boolean(),
    disabled: z.boolean(),
    visibility: z.optional(z.string()),
    pushed_at: z.iso.datetime(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    permissions: z.optional(z.object({
        admin: z.boolean(),
        maintain: z.optional(z.boolean()),
        push: z.boolean(),
        triage: z.optional(z.boolean()),
        pull: z.boolean()
    })),
    allow_rebase_merge: z.optional(z.boolean()),
    template_repository: z.optional(zNullableRepository),
    temp_clone_token: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    allow_squash_merge: z.optional(z.boolean()),
    allow_auto_merge: z.optional(z.boolean()),
    delete_branch_on_merge: z.optional(z.boolean()),
    allow_merge_commit: z.optional(z.boolean()),
    allow_update_branch: z.optional(z.boolean()),
    use_squash_pr_title_as_default: z.optional(z.boolean()),
    squash_merge_commit_title: z.optional(z.enum([
        'PR_TITLE',
        'COMMIT_OR_PR_TITLE'
    ])),
    squash_merge_commit_message: z.optional(z.enum([
        'PR_BODY',
        'COMMIT_MESSAGES',
        'BLANK'
    ])),
    merge_commit_title: z.optional(z.enum([
        'PR_TITLE',
        'MERGE_MESSAGE'
    ])),
    merge_commit_message: z.optional(z.enum([
        'PR_BODY',
        'PR_TITLE',
        'BLANK'
    ])),
    allow_forking: z.optional(z.boolean()),
    web_commit_signoff_required: z.optional(z.boolean()),
    subscribers_count: z.int(),
    network_count: z.int(),
    license: zNullableLicenseSimple,
    organization: z.optional(zNullableSimpleUser),
    parent: z.optional(zRepository),
    source: z.optional(zRepository),
    forks: z.int(),
    master_branch: z.optional(z.string()),
    open_issues: z.int(),
    watchers: z.int(),
    anonymous_access_enabled: z.optional(z.boolean()).default(true),
    code_of_conduct: z.optional(zCodeOfConductSimple),
    security_and_analysis: z.optional(zSecurityAndAnalysis),
    custom_properties: z.optional(z.record(z.string(), z.unknown()))
});

/**
 * The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).
 */
export const zRepositoryRuleEnforcement = z.enum([
    'disabled',
    'active',
    'evaluate'
]);

/**
 * Repository Ruleset Bypass Actor
 *
 * An actor that can bypass rules in a ruleset
 */
export const zRepositoryRulesetBypassActor = z.object({
    actor_id: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    actor_type: z.enum([
        'Integration',
        'OrganizationAdmin',
        'RepositoryRole',
        'Team',
        'DeployKey'
    ]),
    bypass_mode: z.optional(z.enum([
        'always',
        'pull_request',
        'exempt'
    ]))
});

/**
 * Repository ruleset conditions for ref names
 *
 * Parameters for a repository ruleset ref name condition
 */
export const zRepositoryRulesetConditions = z.object({
    ref_name: z.optional(z.object({
        include: z.optional(z.array(z.string())),
        exclude: z.optional(z.array(z.string()))
    }))
});

/**
 * Repository ruleset conditions for repository names
 *
 * Parameters for a repository name condition
 */
export const zRepositoryRulesetConditionsRepositoryNameTarget = z.object({
    repository_name: z.object({
        include: z.optional(z.array(z.string())),
        exclude: z.optional(z.array(z.string())),
        protected: z.optional(z.boolean())
    })
});

/**
 * Repository ruleset conditions for repository IDs
 *
 * Parameters for a repository ID condition
 */
export const zRepositoryRulesetConditionsRepositoryIdTarget = z.object({
    repository_id: z.object({
        repository_ids: z.optional(z.array(z.int()))
    })
});

/**
 * Repository ruleset property targeting definition
 *
 * Parameters for a targeting a repository property
 */
export const zRepositoryRulesetConditionsRepositoryPropertySpec = z.object({
    name: z.string(),
    property_values: z.array(z.string()),
    source: z.optional(z.enum([
        'custom',
        'system'
    ]))
});

/**
 * Repository ruleset conditions for repository properties
 *
 * Parameters for a repository property condition
 */
export const zRepositoryRulesetConditionsRepositoryPropertyTarget = z.object({
    repository_property: z.object({
        include: z.optional(z.array(zRepositoryRulesetConditionsRepositoryPropertySpec)),
        exclude: z.optional(z.array(zRepositoryRulesetConditionsRepositoryPropertySpec))
    })
});

/**
 * Organization ruleset conditions
 *
 * Conditions for an organization ruleset.
 * The branch and tag rulesets conditions object should contain both `repository_name` and `ref_name` properties, or both `repository_id` and `ref_name` properties, or both `repository_property` and `ref_name` properties.
 * The push rulesets conditions object does not require the `ref_name` property.
 * For repository policy rulesets, the conditions object should only contain the `repository_name`, the `repository_id`, or the `repository_property`.
 */
export const zOrgRulesetConditions = z.union([
    zRepositoryRulesetConditions.and(zRepositoryRulesetConditionsRepositoryNameTarget),
    zRepositoryRulesetConditions.and(zRepositoryRulesetConditionsRepositoryIdTarget),
    zRepositoryRulesetConditions.and(zRepositoryRulesetConditionsRepositoryPropertyTarget)
]);

/**
 * creation
 *
 * Only allow users with bypass permission to create matching refs.
 */
export const zRepositoryRuleCreation = z.object({
    type: z.enum([
        'creation'
    ])
});

/**
 * update
 *
 * Only allow users with bypass permission to update matching refs.
 */
export const zRepositoryRuleUpdate = z.object({
    type: z.enum([
        'update'
    ]),
    parameters: z.optional(z.object({
        update_allows_fetch_and_merge: z.boolean()
    }))
});

/**
 * deletion
 *
 * Only allow users with bypass permissions to delete matching refs.
 */
export const zRepositoryRuleDeletion = z.object({
    type: z.enum([
        'deletion'
    ])
});

/**
 * required_linear_history
 *
 * Prevent merge commits from being pushed to matching refs.
 */
export const zRepositoryRuleRequiredLinearHistory = z.object({
    type: z.enum([
        'required_linear_history'
    ])
});

/**
 * merge_queue
 *
 * Merges must be performed via a merge queue.
 */
export const zRepositoryRuleMergeQueue = z.object({
    type: z.enum([
        'merge_queue'
    ]),
    parameters: z.optional(z.object({
        check_response_timeout_minutes: z.int().gte(1).lte(360),
        grouping_strategy: z.enum([
            'ALLGREEN',
            'HEADGREEN'
        ]),
        max_entries_to_build: z.int().gte(0).lte(100),
        max_entries_to_merge: z.int().gte(0).lte(100),
        merge_method: z.enum([
            'MERGE',
            'SQUASH',
            'REBASE'
        ]),
        min_entries_to_merge: z.int().gte(0).lte(100),
        min_entries_to_merge_wait_minutes: z.int().gte(0).lte(360)
    }))
});

/**
 * required_deployments
 *
 * Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule.
 */
export const zRepositoryRuleRequiredDeployments = z.object({
    type: z.enum([
        'required_deployments'
    ]),
    parameters: z.optional(z.object({
        required_deployment_environments: z.array(z.string())
    }))
});

/**
 * required_signatures
 *
 * Commits pushed to matching refs must have verified signatures.
 */
export const zRepositoryRuleRequiredSignatures = z.object({
    type: z.enum([
        'required_signatures'
    ])
});

/**
 * Reviewer
 *
 * A required reviewing team
 */
export const zRepositoryRuleParamsReviewer = z.object({
    id: z.int(),
    type: z.enum([
        'Team'
    ])
});

/**
 * RequiredReviewerConfiguration
 *
 * A reviewing team, and file patterns describing which files they must approve changes to.
 */
export const zRepositoryRuleParamsRequiredReviewerConfiguration = z.object({
    file_patterns: z.array(z.string()),
    minimum_approvals: z.int(),
    reviewer: zRepositoryRuleParamsReviewer
});

/**
 * pull_request
 *
 * Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
 */
export const zRepositoryRulePullRequest = z.object({
    type: z.enum([
        'pull_request'
    ]),
    parameters: z.optional(z.object({
        allowed_merge_methods: z.optional(z.array(z.enum([
            'merge',
            'squash',
            'rebase'
        ]))),
        automatic_copilot_code_review_enabled: z.optional(z.boolean()),
        dismiss_stale_reviews_on_push: z.boolean(),
        require_code_owner_review: z.boolean(),
        require_last_push_approval: z.boolean(),
        required_approving_review_count: z.int().gte(0).lte(10),
        required_review_thread_resolution: z.boolean()
    }))
});

/**
 * StatusCheckConfiguration
 *
 * Required status check
 */
export const zRepositoryRuleParamsStatusCheckConfiguration = z.object({
    context: z.string(),
    integration_id: z.optional(z.int())
});

/**
 * required_status_checks
 *
 * Choose which status checks must pass before the ref is updated. When enabled, commits must first be pushed to another ref where the checks pass.
 */
export const zRepositoryRuleRequiredStatusChecks = z.object({
    type: z.enum([
        'required_status_checks'
    ]),
    parameters: z.optional(z.object({
        do_not_enforce_on_create: z.optional(z.boolean()),
        required_status_checks: z.array(zRepositoryRuleParamsStatusCheckConfiguration),
        strict_required_status_checks_policy: z.boolean()
    }))
});

/**
 * non_fast_forward
 *
 * Prevent users with push access from force pushing to refs.
 */
export const zRepositoryRuleNonFastForward = z.object({
    type: z.enum([
        'non_fast_forward'
    ])
});

/**
 * commit_message_pattern
 *
 * Parameters to be used for the commit_message_pattern rule
 */
export const zRepositoryRuleCommitMessagePattern = z.object({
    type: z.enum([
        'commit_message_pattern'
    ]),
    parameters: z.optional(z.object({
        name: z.optional(z.string()),
        negate: z.optional(z.boolean()),
        operator: z.enum([
            'starts_with',
            'ends_with',
            'contains',
            'regex'
        ]),
        pattern: z.string()
    }))
});

/**
 * commit_author_email_pattern
 *
 * Parameters to be used for the commit_author_email_pattern rule
 */
export const zRepositoryRuleCommitAuthorEmailPattern = z.object({
    type: z.enum([
        'commit_author_email_pattern'
    ]),
    parameters: z.optional(z.object({
        name: z.optional(z.string()),
        negate: z.optional(z.boolean()),
        operator: z.enum([
            'starts_with',
            'ends_with',
            'contains',
            'regex'
        ]),
        pattern: z.string()
    }))
});

/**
 * committer_email_pattern
 *
 * Parameters to be used for the committer_email_pattern rule
 */
export const zRepositoryRuleCommitterEmailPattern = z.object({
    type: z.enum([
        'committer_email_pattern'
    ]),
    parameters: z.optional(z.object({
        name: z.optional(z.string()),
        negate: z.optional(z.boolean()),
        operator: z.enum([
            'starts_with',
            'ends_with',
            'contains',
            'regex'
        ]),
        pattern: z.string()
    }))
});

/**
 * branch_name_pattern
 *
 * Parameters to be used for the branch_name_pattern rule
 */
export const zRepositoryRuleBranchNamePattern = z.object({
    type: z.enum([
        'branch_name_pattern'
    ]),
    parameters: z.optional(z.object({
        name: z.optional(z.string()),
        negate: z.optional(z.boolean()),
        operator: z.enum([
            'starts_with',
            'ends_with',
            'contains',
            'regex'
        ]),
        pattern: z.string()
    }))
});

/**
 * tag_name_pattern
 *
 * Parameters to be used for the tag_name_pattern rule
 */
export const zRepositoryRuleTagNamePattern = z.object({
    type: z.enum([
        'tag_name_pattern'
    ]),
    parameters: z.optional(z.object({
        name: z.optional(z.string()),
        negate: z.optional(z.boolean()),
        operator: z.enum([
            'starts_with',
            'ends_with',
            'contains',
            'regex'
        ]),
        pattern: z.string()
    }))
});

/**
 * file_path_restriction
 *
 * Prevent commits that include changes in specified file and folder paths from being pushed to the commit graph. This includes absolute paths that contain file names.
 */
export const zRepositoryRuleFilePathRestriction = z.object({
    type: z.enum([
        'file_path_restriction'
    ]),
    parameters: z.optional(z.object({
        restricted_file_paths: z.array(z.string())
    }))
});

/**
 * max_file_path_length
 *
 * Prevent commits that include file paths that exceed the specified character limit from being pushed to the commit graph.
 */
export const zRepositoryRuleMaxFilePathLength = z.object({
    type: z.enum([
        'max_file_path_length'
    ]),
    parameters: z.optional(z.object({
        max_file_path_length: z.int().gte(1).lte(32767)
    }))
});

/**
 * file_extension_restriction
 *
 * Prevent commits that include files with specified file extensions from being pushed to the commit graph.
 */
export const zRepositoryRuleFileExtensionRestriction = z.object({
    type: z.enum([
        'file_extension_restriction'
    ]),
    parameters: z.optional(z.object({
        restricted_file_extensions: z.array(z.string())
    }))
});

/**
 * max_file_size
 *
 * Prevent commits with individual files that exceed the specified limit from being pushed to the commit graph.
 */
export const zRepositoryRuleMaxFileSize = z.object({
    type: z.enum([
        'max_file_size'
    ]),
    parameters: z.optional(z.object({
        max_file_size: z.int().gte(1).lte(100)
    }))
});

/**
 * RestrictedCommits
 *
 * Restricted commit
 */
export const zRepositoryRuleParamsRestrictedCommits = z.object({
    oid: z.string(),
    reason: z.optional(z.string())
});

/**
 * WorkflowFileReference
 *
 * A workflow that must run for this rule to pass
 */
export const zRepositoryRuleParamsWorkflowFileReference = z.object({
    path: z.string(),
    ref: z.optional(z.string()),
    repository_id: z.int(),
    sha: z.optional(z.string())
});

/**
 * workflows
 *
 * Require all changes made to a targeted branch to pass the specified workflows before they can be merged.
 */
export const zRepositoryRuleWorkflows = z.object({
    type: z.enum([
        'workflows'
    ]),
    parameters: z.optional(z.object({
        do_not_enforce_on_create: z.optional(z.boolean()),
        workflows: z.array(zRepositoryRuleParamsWorkflowFileReference)
    }))
});

/**
 * CodeScanningTool
 *
 * A tool that must provide code scanning results for this rule to pass.
 */
export const zRepositoryRuleParamsCodeScanningTool = z.object({
    alerts_threshold: z.enum([
        'none',
        'errors',
        'errors_and_warnings',
        'all'
    ]),
    security_alerts_threshold: z.enum([
        'none',
        'critical',
        'high_or_higher',
        'medium_or_higher',
        'all'
    ]),
    tool: z.string()
});

/**
 * code_scanning
 *
 * Choose which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated.
 */
export const zRepositoryRuleCodeScanning = z.object({
    type: z.enum([
        'code_scanning'
    ]),
    parameters: z.optional(z.object({
        code_scanning_tools: z.array(zRepositoryRuleParamsCodeScanningTool)
    }))
});

/**
 * copilot_code_review
 *
 * Request Copilot code review for new pull requests automatically if the author has access to Copilot code review.
 */
export const zRepositoryRuleCopilotCodeReview = z.object({
    type: z.enum([
        'copilot_code_review'
    ]),
    parameters: z.optional(z.object({
        review_draft_pull_requests: z.optional(z.boolean()),
        review_on_push: z.optional(z.boolean())
    }))
});

/**
 * Repository Rule
 *
 * A repository rule.
 */
export const zRepositoryRule = z.union([
    zRepositoryRuleCreation,
    zRepositoryRuleUpdate,
    zRepositoryRuleDeletion,
    zRepositoryRuleRequiredLinearHistory,
    zRepositoryRuleMergeQueue,
    zRepositoryRuleRequiredDeployments,
    zRepositoryRuleRequiredSignatures,
    zRepositoryRulePullRequest,
    zRepositoryRuleRequiredStatusChecks,
    zRepositoryRuleNonFastForward,
    zRepositoryRuleCommitMessagePattern,
    zRepositoryRuleCommitAuthorEmailPattern,
    zRepositoryRuleCommitterEmailPattern,
    zRepositoryRuleBranchNamePattern,
    zRepositoryRuleTagNamePattern,
    zRepositoryRuleFilePathRestriction,
    zRepositoryRuleMaxFilePathLength,
    zRepositoryRuleFileExtensionRestriction,
    zRepositoryRuleMaxFileSize,
    zRepositoryRuleWorkflows,
    zRepositoryRuleCodeScanning,
    zRepositoryRuleCopilotCodeReview
]);

/**
 * Repository ruleset
 *
 * A set of rules to apply when specified conditions are met.
 */
export const zRepositoryRuleset = z.object({
    id: z.int(),
    name: z.string(),
    target: z.optional(z.enum([
        'branch',
        'tag',
        'push',
        'repository'
    ])),
    source_type: z.optional(z.enum([
        'Repository',
        'Organization',
        'Enterprise'
    ])),
    source: z.string(),
    enforcement: zRepositoryRuleEnforcement,
    bypass_actors: z.optional(z.array(zRepositoryRulesetBypassActor)),
    current_user_can_bypass: z.optional(z.enum([
        'always',
        'pull_requests_only',
        'never',
        'exempt'
    ])),
    node_id: z.optional(z.string()),
    _links: z.optional(z.object({
        self: z.optional(z.object({
            href: z.optional(z.string())
        })),
        html: z.optional(z.union([
            z.object({
                href: z.optional(z.string())
            }),
            z.null()
        ]))
    })),
    conditions: z.optional(z.union([
        zRepositoryRulesetConditions,
        zOrgRulesetConditions,
        z.null()
    ])),
    rules: z.optional(z.array(zRepositoryRule)),
    created_at: z.optional(z.iso.datetime()),
    updated_at: z.optional(z.iso.datetime())
});

/**
 * Repository Rule
 *
 * A repository rule.
 */
export const zOrgRules = z.union([
    zRepositoryRuleCreation,
    zRepositoryRuleUpdate,
    zRepositoryRuleDeletion,
    zRepositoryRuleRequiredLinearHistory,
    zRepositoryRuleRequiredDeployments,
    zRepositoryRuleRequiredSignatures,
    zRepositoryRulePullRequest,
    zRepositoryRuleRequiredStatusChecks,
    zRepositoryRuleNonFastForward,
    zRepositoryRuleCommitMessagePattern,
    zRepositoryRuleCommitAuthorEmailPattern,
    zRepositoryRuleCommitterEmailPattern,
    zRepositoryRuleBranchNamePattern,
    zRepositoryRuleTagNamePattern,
    zRepositoryRuleFilePathRestriction,
    zRepositoryRuleMaxFilePathLength,
    zRepositoryRuleFileExtensionRestriction,
    zRepositoryRuleMaxFileSize,
    zRepositoryRuleWorkflows,
    zRepositoryRuleCodeScanning
]);

/**
 * Rule Suites
 *
 * Response
 */
export const zRuleSuites = z.array(z.object({
    id: z.optional(z.int()),
    actor_id: z.optional(z.int()),
    actor_name: z.optional(z.string()),
    before_sha: z.optional(z.string()),
    after_sha: z.optional(z.string()),
    ref: z.optional(z.string()),
    repository_id: z.optional(z.int()),
    repository_name: z.optional(z.string()),
    pushed_at: z.optional(z.iso.datetime()),
    result: z.optional(z.enum([
        'pass',
        'fail',
        'bypass'
    ])),
    evaluation_result: z.optional(z.enum([
        'pass',
        'fail',
        'bypass'
    ]))
}));

/**
 * Rule Suite
 *
 * Response
 */
export const zRuleSuite = z.object({
    id: z.optional(z.int()),
    actor_id: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    actor_name: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    before_sha: z.optional(z.string()),
    after_sha: z.optional(z.string()),
    ref: z.optional(z.string()),
    repository_id: z.optional(z.int()),
    repository_name: z.optional(z.string()),
    pushed_at: z.optional(z.iso.datetime()),
    result: z.optional(z.enum([
        'pass',
        'fail',
        'bypass'
    ])),
    evaluation_result: z.optional(z.enum([
        'pass',
        'fail',
        'bypass'
    ])),
    rule_evaluations: z.optional(z.array(z.object({
        rule_source: z.optional(z.object({
            type: z.optional(z.string()),
            id: z.optional(z.union([
                z.int(),
                z.null()
            ])),
            name: z.optional(z.union([
                z.string(),
                z.null()
            ]))
        })),
        enforcement: z.optional(z.enum([
            'active',
            'evaluate',
            'deleted ruleset'
        ])),
        result: z.optional(z.enum([
            'pass',
            'fail'
        ])),
        rule_type: z.optional(z.string()),
        details: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    })))
});

/**
 * Ruleset version
 *
 * The historical version of a ruleset
 */
export const zRulesetVersion = z.object({
    version_id: z.int(),
    actor: z.object({
        id: z.optional(z.int()),
        type: z.optional(z.string())
    }),
    updated_at: z.iso.datetime()
});

export const zRulesetVersionWithState = zRulesetVersion.and(z.object({
    state: z.record(z.string(), z.unknown())
}));

/**
 * The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const zNullableAlertUpdatedAt = z.union([
    z.iso.datetime().readonly(),
    z.null()
]).readonly();

/**
 * Sets the state of the secret scanning alert. You must provide `resolution` when you set the state to `resolved`.
 */
export const zSecretScanningAlertState = z.enum([
    'open',
    'resolved'
]);

/**
 * **Required when the `state` is `resolved`.** The reason for resolving the alert.
 */
export const zSecretScanningAlertResolution = z.enum([
    'false_positive',
    'wont_fix',
    'revoked',
    'used_in_tests'
]);

/**
 * Represents a 'commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository.
 */
export const zSecretScanningLocationCommit = z.object({
    path: z.string(),
    start_line: z.number(),
    end_line: z.number(),
    start_column: z.number(),
    end_column: z.number(),
    blob_sha: z.string(),
    blob_url: z.string(),
    commit_sha: z.string(),
    commit_url: z.string()
});

/**
 * Represents a 'wiki_commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository wiki.
 */
export const zSecretScanningLocationWikiCommit = z.object({
    path: z.string(),
    start_line: z.number(),
    end_line: z.number(),
    start_column: z.number(),
    end_column: z.number(),
    blob_sha: z.string(),
    page_url: z.string(),
    commit_sha: z.string(),
    commit_url: z.string()
});

/**
 * Represents an 'issue_title' secret scanning location type. This location type shows that a secret was detected in the title of an issue.
 */
export const zSecretScanningLocationIssueTitle = z.object({
    issue_title_url: z.url()
});

/**
 * Represents an 'issue_body' secret scanning location type. This location type shows that a secret was detected in the body of an issue.
 */
export const zSecretScanningLocationIssueBody = z.object({
    issue_body_url: z.url()
});

/**
 * Represents an 'issue_comment' secret scanning location type. This location type shows that a secret was detected in a comment on an issue.
 */
export const zSecretScanningLocationIssueComment = z.object({
    issue_comment_url: z.url()
});

/**
 * Represents a 'discussion_title' secret scanning location type. This location type shows that a secret was detected in the title of a discussion.
 */
export const zSecretScanningLocationDiscussionTitle = z.object({
    discussion_title_url: z.url()
});

/**
 * Represents a 'discussion_body' secret scanning location type. This location type shows that a secret was detected in the body of a discussion.
 */
export const zSecretScanningLocationDiscussionBody = z.object({
    discussion_body_url: z.url()
});

/**
 * Represents a 'discussion_comment' secret scanning location type. This location type shows that a secret was detected in a comment on a discussion.
 */
export const zSecretScanningLocationDiscussionComment = z.object({
    discussion_comment_url: z.url()
});

/**
 * Represents a 'pull_request_title' secret scanning location type. This location type shows that a secret was detected in the title of a pull request.
 */
export const zSecretScanningLocationPullRequestTitle = z.object({
    pull_request_title_url: z.url()
});

/**
 * Represents a 'pull_request_body' secret scanning location type. This location type shows that a secret was detected in the body of a pull request.
 */
export const zSecretScanningLocationPullRequestBody = z.object({
    pull_request_body_url: z.url()
});

/**
 * Represents a 'pull_request_comment' secret scanning location type. This location type shows that a secret was detected in a comment on a pull request.
 */
export const zSecretScanningLocationPullRequestComment = z.object({
    pull_request_comment_url: z.url()
});

/**
 * Represents a 'pull_request_review' secret scanning location type. This location type shows that a secret was detected in a review on a pull request.
 */
export const zSecretScanningLocationPullRequestReview = z.object({
    pull_request_review_url: z.url()
});

/**
 * Represents a 'pull_request_review_comment' secret scanning location type. This location type shows that a secret was detected in a review comment on a pull request.
 */
export const zSecretScanningLocationPullRequestReviewComment = z.object({
    pull_request_review_comment_url: z.url()
});

/**
 * Details on the location where the token was initially detected. This can be a commit, wiki commit, issue, discussion, pull request.
 *
 */
export const zNullableSecretScanningFirstDetectedLocation = z.union([
    zSecretScanningLocationCommit,
    zSecretScanningLocationWikiCommit,
    zSecretScanningLocationIssueTitle,
    zSecretScanningLocationIssueBody,
    zSecretScanningLocationIssueComment,
    zSecretScanningLocationDiscussionTitle,
    zSecretScanningLocationDiscussionBody,
    zSecretScanningLocationDiscussionComment,
    zSecretScanningLocationPullRequestTitle,
    zSecretScanningLocationPullRequestBody,
    zSecretScanningLocationPullRequestComment,
    zSecretScanningLocationPullRequestReview,
    zSecretScanningLocationPullRequestReviewComment,
    z.null()
]);

export const zOrganizationSecretScanningAlert = z.object({
    number: z.optional(zAlertNumber),
    created_at: z.optional(zAlertCreatedAt),
    updated_at: z.optional(zNullableAlertUpdatedAt),
    url: z.optional(zAlertUrl),
    html_url: z.optional(zAlertHtmlUrl),
    locations_url: z.optional(z.url()),
    state: z.optional(zSecretScanningAlertState),
    resolution: z.optional(zSecretScanningAlertResolution),
    resolved_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    resolved_by: z.optional(zNullableSimpleUser),
    secret_type: z.optional(z.string()),
    secret_type_display_name: z.optional(z.string()),
    secret: z.optional(z.string()),
    repository: z.optional(zSimpleRepository),
    push_protection_bypassed: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    push_protection_bypassed_by: z.optional(zNullableSimpleUser),
    push_protection_bypassed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    push_protection_bypass_request_reviewer: z.optional(zNullableSimpleUser),
    push_protection_bypass_request_reviewer_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    push_protection_bypass_request_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    push_protection_bypass_request_html_url: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    resolution_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    validity: z.optional(z.enum([
        'active',
        'inactive',
        'unknown'
    ])),
    publicly_leaked: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    multi_repo: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    is_base64_encoded: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    first_location_detected: z.optional(zNullableSecretScanningFirstDetectedLocation),
    has_more_locations: z.optional(z.boolean()),
    assigned_to: z.optional(zNullableSimpleUser)
});

/**
 * The version of the entity. This is used to confirm you're updating the current version of the entity and mitigate unintentionally overriding someone else's update.
 */
export const zSecretScanningRowVersion = z.union([
    z.string(),
    z.null()
]);

export const zSecretScanningPatternOverride = z.object({
    token_type: z.optional(z.string()),
    custom_pattern_version: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    slug: z.optional(z.string()),
    display_name: z.optional(z.string()),
    alert_total: z.optional(z.int()),
    alert_total_percentage: z.optional(z.int()),
    false_positives: z.optional(z.int()),
    false_positive_rate: z.optional(z.int()),
    bypass_rate: z.optional(z.int()),
    default_setting: z.optional(z.enum([
        'disabled',
        'enabled'
    ])),
    enterprise_setting: z.optional(z.enum([
        'not-set',
        'disabled',
        'enabled'
    ])),
    setting: z.optional(z.enum([
        'not-set',
        'disabled',
        'enabled'
    ]))
});

/**
 * Secret scanning pattern configuration
 *
 * A collection of secret scanning patterns and their settings related to push protection.
 */
export const zSecretScanningPatternConfiguration = z.object({
    pattern_config_version: z.optional(zSecretScanningRowVersion),
    provider_pattern_overrides: z.optional(z.array(zSecretScanningPatternOverride)),
    custom_pattern_overrides: z.optional(z.array(zSecretScanningPatternOverride))
});

/**
 * A product affected by the vulnerability detailed in a repository security advisory.
 */
export const zRepositoryAdvisoryVulnerability = z.object({
    package: z.union([
        z.object({
            ecosystem: zSecurityAdvisoryEcosystems,
            name: z.union([
                z.string(),
                z.null()
            ])
        }),
        z.null()
    ]),
    vulnerable_version_range: z.union([
        z.string(),
        z.null()
    ]),
    patched_versions: z.union([
        z.string(),
        z.null()
    ]),
    vulnerable_functions: z.union([
        z.array(z.string()),
        z.null()
    ])
});

/**
 * A credit given to a user for a repository security advisory.
 */
export const zRepositoryAdvisoryCredit = z.object({
    user: zSimpleUser,
    type: zSecurityAdvisoryCreditTypes,
    state: z.enum([
        'accepted',
        'declined',
        'pending'
    ])
});

/**
 * A repository security advisory.
 */
export const zRepositoryAdvisory = z.object({
    ghsa_id: z.string().readonly(),
    cve_id: z.union([
        z.string(),
        z.null()
    ]),
    url: z.url().readonly(),
    html_url: z.url().readonly(),
    summary: z.string().max(1024),
    description: z.union([
        z.string().max(65535),
        z.null()
    ]),
    severity: z.enum([
        'critical',
        'high',
        'medium',
        'low'
    ]),
    author: z.union([
        zSimpleUser,
        z.null()
    ]),
    publisher: z.union([
        zSimpleUser,
        z.null()
    ]),
    identifiers: z.array(z.object({
        type: z.enum([
            'CVE',
            'GHSA'
        ]),
        value: z.string()
    })).readonly(),
    state: z.enum([
        'published',
        'closed',
        'withdrawn',
        'draft',
        'triage'
    ]),
    created_at: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    updated_at: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    published_at: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    closed_at: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    withdrawn_at: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    submission: z.union([
        z.object({
            accepted: z.boolean().readonly()
        }).readonly(),
        z.null()
    ]).readonly(),
    vulnerabilities: z.union([
        z.array(zRepositoryAdvisoryVulnerability),
        z.null()
    ]),
    cvss: z.union([
        z.object({
            vector_string: z.union([
                z.string(),
                z.null()
            ]),
            score: z.union([
                z.number().gte(0).lte(10).readonly(),
                z.null()
            ]).readonly()
        }),
        z.null()
    ]),
    cvss_severities: z.optional(zCvssSeverities),
    cwes: z.union([
        z.array(z.object({
            cwe_id: z.string(),
            name: z.string().readonly()
        })).readonly(),
        z.null()
    ]).readonly(),
    cwe_ids: z.union([
        z.array(z.string()),
        z.null()
    ]),
    credits: z.union([
        z.array(z.object({
            login: z.optional(z.string()),
            type: z.optional(zSecurityAdvisoryCreditTypes)
        })),
        z.null()
    ]),
    credits_detailed: z.union([
        z.array(zRepositoryAdvisoryCredit).readonly(),
        z.null()
    ]).readonly(),
    collaborating_users: z.union([
        z.array(zSimpleUser),
        z.null()
    ]),
    collaborating_teams: z.union([
        z.array(zTeam),
        z.null()
    ]),
    private_fork: z.union([
        zSimpleRepository,
        z.null()
    ])
});

export const zActionsBillingUsage = z.object({
    total_minutes_used: z.int(),
    total_paid_minutes_used: z.int(),
    included_minutes: z.int(),
    minutes_used_breakdown: z.object({
        UBUNTU: z.optional(z.int()),
        MACOS: z.optional(z.int()),
        WINDOWS: z.optional(z.int()),
        ubuntu_4_core: z.optional(z.int()),
        ubuntu_8_core: z.optional(z.int()),
        ubuntu_16_core: z.optional(z.int()),
        ubuntu_32_core: z.optional(z.int()),
        ubuntu_64_core: z.optional(z.int()),
        windows_4_core: z.optional(z.int()),
        windows_8_core: z.optional(z.int()),
        windows_16_core: z.optional(z.int()),
        windows_32_core: z.optional(z.int()),
        windows_64_core: z.optional(z.int()),
        macos_12_core: z.optional(z.int()),
        total: z.optional(z.int())
    })
});

export const zPackagesBillingUsage = z.object({
    total_gigabytes_bandwidth_used: z.int(),
    total_paid_gigabytes_bandwidth_used: z.int(),
    included_gigabytes_bandwidth: z.int()
});

export const zCombinedBillingUsage = z.object({
    days_left_in_billing_cycle: z.int(),
    estimated_paid_storage_for_month: z.int(),
    estimated_storage_for_month: z.int()
});

/**
 * Check immutable releases organization settings
 *
 * Check immutable releases settings for an organization.
 */
export const zImmutableReleasesOrganizationSettings = z.object({
    enforced_repositories: z.enum([
        'all',
        'none',
        'selected'
    ]),
    selected_repositories_url: z.optional(z.string())
});

/**
 * Hosted compute network configuration
 *
 * A hosted compute network configuration.
 */
export const zNetworkConfiguration = z.object({
    id: z.string(),
    name: z.string(),
    compute_service: z.optional(z.enum([
        'none',
        'actions',
        'codespaces'
    ])),
    network_settings_ids: z.optional(z.array(z.string())),
    created_on: z.union([
        z.iso.datetime(),
        z.null()
    ])
});

/**
 * Hosted compute network settings resource
 *
 * A hosted compute network settings resource.
 */
export const zNetworkSettings = z.object({
    id: z.string(),
    network_configuration_id: z.optional(z.string()),
    name: z.string(),
    subnet_id: z.string(),
    region: z.string()
});

/**
 * Team Organization
 *
 * Team Organization
 */
export const zTeamOrganization = z.object({
    login: z.string(),
    id: z.int(),
    node_id: z.string(),
    url: z.url(),
    repos_url: z.url(),
    events_url: z.url(),
    hooks_url: z.string(),
    issues_url: z.string(),
    members_url: z.string(),
    public_members_url: z.string(),
    avatar_url: z.string(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    name: z.optional(z.string()),
    company: z.optional(z.string()),
    blog: z.optional(z.url()),
    location: z.optional(z.string()),
    email: z.optional(z.email()),
    twitter_username: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    is_verified: z.optional(z.boolean()),
    has_organization_projects: z.boolean(),
    has_repository_projects: z.boolean(),
    public_repos: z.int(),
    public_gists: z.int(),
    followers: z.int(),
    following: z.int(),
    html_url: z.url(),
    created_at: z.iso.datetime(),
    type: z.string(),
    total_private_repos: z.optional(z.int()),
    owned_private_repos: z.optional(z.int()),
    private_gists: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    disk_usage: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    collaborators: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    billing_email: z.optional(z.union([
        z.email(),
        z.null()
    ])),
    plan: z.optional(z.object({
        name: z.string(),
        space: z.int(),
        private_repos: z.int(),
        filled_seats: z.optional(z.int()),
        seats: z.optional(z.int())
    })),
    default_repository_permission: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    members_can_create_repositories: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    two_factor_requirement_enabled: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    members_allowed_repository_creation_type: z.optional(z.string()),
    members_can_create_public_repositories: z.optional(z.boolean()),
    members_can_create_private_repositories: z.optional(z.boolean()),
    members_can_create_internal_repositories: z.optional(z.boolean()),
    members_can_create_pages: z.optional(z.boolean()),
    members_can_create_public_pages: z.optional(z.boolean()),
    members_can_create_private_pages: z.optional(z.boolean()),
    members_can_fork_private_repositories: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    web_commit_signoff_required: z.optional(z.boolean()),
    updated_at: z.iso.datetime(),
    archived_at: z.union([
        z.iso.datetime(),
        z.null()
    ])
});

/**
 * The [distinguished name](https://www.ldap.com/ldap-dns-and-rdns) (DN) of the LDAP entry to map to a team.
 */
export const zLdapDn = z.string();

/**
 * Full Team
 *
 * Groups of organization members that gives permissions on specified repositories.
 */
export const zTeamFull = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.url(),
    html_url: z.url(),
    name: z.string(),
    slug: z.string(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    privacy: z.optional(z.enum([
        'closed',
        'secret'
    ])),
    notification_setting: z.optional(z.enum([
        'notifications_enabled',
        'notifications_disabled'
    ])),
    permission: z.string(),
    members_url: z.string(),
    repositories_url: z.url(),
    parent: z.optional(zNullableTeamSimple),
    members_count: z.int(),
    repos_count: z.int(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    organization: zTeamOrganization,
    ldap_dn: z.optional(zLdapDn),
    type: z.enum([
        'enterprise',
        'organization'
    ]),
    organization_id: z.optional(z.int()),
    enterprise_id: z.optional(z.int())
});

/**
 * Team Discussion
 *
 * A team discussion is a persistent record of a free-form conversation within a team.
 */
export const zTeamDiscussion = z.object({
    author: zNullableSimpleUser,
    body: z.string(),
    body_html: z.string(),
    body_version: z.string(),
    comments_count: z.int(),
    comments_url: z.url(),
    created_at: z.iso.datetime(),
    last_edited_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    html_url: z.url(),
    node_id: z.string(),
    number: z.int(),
    pinned: z.boolean(),
    private: z.boolean(),
    team_url: z.url(),
    title: z.string(),
    updated_at: z.iso.datetime(),
    url: z.url(),
    reactions: z.optional(zReactionRollup)
});

/**
 * Team Discussion Comment
 *
 * A reply to a discussion within a team.
 */
export const zTeamDiscussionComment = z.object({
    author: zNullableSimpleUser,
    body: z.string(),
    body_html: z.string(),
    body_version: z.string(),
    created_at: z.iso.datetime(),
    last_edited_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    discussion_url: z.url(),
    html_url: z.url(),
    node_id: z.string(),
    number: z.int(),
    updated_at: z.iso.datetime(),
    url: z.url(),
    reactions: z.optional(zReactionRollup)
});

/**
 * Reaction
 *
 * Reactions to conversations provide a way to help people express their feelings more simply and effectively.
 */
export const zReaction = z.object({
    id: z.int(),
    node_id: z.string(),
    user: zNullableSimpleUser,
    content: z.enum([
        '+1',
        '-1',
        'laugh',
        'confused',
        'heart',
        'hooray',
        'rocket',
        'eyes'
    ]),
    created_at: z.iso.datetime()
});

/**
 * Team Membership
 *
 * Team Membership
 */
export const zTeamMembership = z.object({
    url: z.url(),
    role: z.enum([
        'member',
        'maintainer'
    ]),
    state: z.enum([
        'active',
        'pending'
    ])
});

/**
 * Team Project
 *
 * A team's access to a project.
 */
export const zTeamProject = z.object({
    owner_url: z.string(),
    url: z.string(),
    html_url: z.string(),
    columns_url: z.string(),
    id: z.int(),
    node_id: z.string(),
    name: z.string(),
    body: z.union([
        z.string(),
        z.null()
    ]),
    number: z.int(),
    state: z.string(),
    creator: zSimpleUser,
    created_at: z.string(),
    updated_at: z.string(),
    organization_permission: z.optional(z.string()),
    private: z.optional(z.boolean()),
    permissions: z.object({
        read: z.boolean(),
        write: z.boolean(),
        admin: z.boolean()
    })
});

/**
 * Team Repository
 *
 * A team's access to a repository.
 */
export const zTeamRepository = z.object({
    id: z.int(),
    node_id: z.string(),
    name: z.string(),
    full_name: z.string(),
    license: zNullableLicenseSimple,
    forks: z.int(),
    permissions: z.optional(z.object({
        admin: z.boolean(),
        pull: z.boolean(),
        triage: z.optional(z.boolean()),
        push: z.boolean(),
        maintain: z.optional(z.boolean())
    })),
    role_name: z.optional(z.string()),
    owner: zNullableSimpleUser,
    private: z.boolean().default(false),
    html_url: z.url(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    fork: z.boolean(),
    url: z.url(),
    archive_url: z.string(),
    assignees_url: z.string(),
    blobs_url: z.string(),
    branches_url: z.string(),
    collaborators_url: z.string(),
    comments_url: z.string(),
    commits_url: z.string(),
    compare_url: z.string(),
    contents_url: z.string(),
    contributors_url: z.url(),
    deployments_url: z.url(),
    downloads_url: z.url(),
    events_url: z.url(),
    forks_url: z.url(),
    git_commits_url: z.string(),
    git_refs_url: z.string(),
    git_tags_url: z.string(),
    git_url: z.string(),
    issue_comment_url: z.string(),
    issue_events_url: z.string(),
    issues_url: z.string(),
    keys_url: z.string(),
    labels_url: z.string(),
    languages_url: z.url(),
    merges_url: z.url(),
    milestones_url: z.string(),
    notifications_url: z.string(),
    pulls_url: z.string(),
    releases_url: z.string(),
    ssh_url: z.string(),
    stargazers_url: z.url(),
    statuses_url: z.string(),
    subscribers_url: z.url(),
    subscription_url: z.url(),
    tags_url: z.url(),
    teams_url: z.url(),
    trees_url: z.string(),
    clone_url: z.string(),
    mirror_url: z.union([
        z.url(),
        z.null()
    ]),
    hooks_url: z.url(),
    svn_url: z.url(),
    homepage: z.union([
        z.url(),
        z.null()
    ]),
    language: z.union([
        z.string(),
        z.null()
    ]),
    forks_count: z.int(),
    stargazers_count: z.int(),
    watchers_count: z.int(),
    size: z.int(),
    default_branch: z.string(),
    open_issues_count: z.int(),
    is_template: z.optional(z.boolean()).default(false),
    topics: z.optional(z.array(z.string())),
    has_issues: z.boolean().default(true),
    has_projects: z.boolean().default(true),
    has_wiki: z.boolean().default(true),
    has_pages: z.boolean(),
    has_downloads: z.boolean().default(true),
    archived: z.boolean().default(false),
    disabled: z.boolean(),
    visibility: z.optional(z.string()).default('public'),
    pushed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    created_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    updated_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    allow_rebase_merge: z.optional(z.boolean()).default(true),
    temp_clone_token: z.optional(z.string()),
    allow_squash_merge: z.optional(z.boolean()).default(true),
    allow_auto_merge: z.optional(z.boolean()).default(false),
    delete_branch_on_merge: z.optional(z.boolean()).default(false),
    allow_merge_commit: z.optional(z.boolean()).default(true),
    allow_forking: z.optional(z.boolean()).default(false),
    web_commit_signoff_required: z.optional(z.boolean()).default(false),
    subscribers_count: z.optional(z.int()),
    network_count: z.optional(z.int()),
    open_issues: z.int(),
    watchers: z.int(),
    master_branch: z.optional(z.string())
});

/**
 * Project Column
 *
 * Project columns contain cards of work.
 */
export const zProjectColumn = z.object({
    url: z.url(),
    project_url: z.url(),
    cards_url: z.url(),
    id: z.int(),
    node_id: z.string(),
    name: z.string(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime()
});

/**
 * Project Collaborator Permission
 *
 * Project Collaborator Permission
 */
export const zProjectCollaboratorPermission = z.object({
    permission: z.string(),
    user: zNullableSimpleUser
});

/**
 * Rate Limit
 */
export const zRateLimit = z.object({
    limit: z.int(),
    remaining: z.int(),
    reset: z.int(),
    used: z.int()
});

/**
 * Rate Limit Overview
 *
 * Rate Limit Overview
 */
export const zRateLimitOverview = z.object({
    resources: z.object({
        core: zRateLimit,
        graphql: z.optional(zRateLimit),
        search: zRateLimit,
        code_search: z.optional(zRateLimit),
        source_import: z.optional(zRateLimit),
        integration_manifest: z.optional(zRateLimit),
        code_scanning_upload: z.optional(zRateLimit),
        actions_runner_registration: z.optional(zRateLimit),
        scim: z.optional(zRateLimit),
        dependency_snapshots: z.optional(zRateLimit),
        dependency_sbom: z.optional(zRateLimit),
        code_scanning_autofix: z.optional(zRateLimit)
    }),
    rate: zRateLimit
});

/**
 * Artifact
 *
 * An artifact
 */
export const zArtifact = z.object({
    id: z.int(),
    node_id: z.string(),
    name: z.string(),
    size_in_bytes: z.int(),
    url: z.string(),
    archive_download_url: z.string(),
    expired: z.boolean(),
    created_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    expires_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    updated_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    digest: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    workflow_run: z.optional(z.union([
        z.object({
            id: z.optional(z.int()),
            repository_id: z.optional(z.int()),
            head_repository_id: z.optional(z.int()),
            head_branch: z.optional(z.string()),
            head_sha: z.optional(z.string())
        }),
        z.null()
    ]))
});

/**
 * Repository actions caches
 *
 * Repository actions caches
 */
export const zActionsCacheList = z.object({
    total_count: z.int(),
    actions_caches: z.array(z.object({
        id: z.optional(z.int()),
        ref: z.optional(z.string()),
        key: z.optional(z.string()),
        version: z.optional(z.string()),
        last_accessed_at: z.optional(z.iso.datetime()),
        created_at: z.optional(z.iso.datetime()),
        size_in_bytes: z.optional(z.int())
    }))
});

/**
 * Job
 *
 * Information of a job execution in a workflow run
 */
export const zJob = z.object({
    id: z.int(),
    run_id: z.int(),
    run_url: z.string(),
    run_attempt: z.optional(z.int()),
    node_id: z.string(),
    head_sha: z.string(),
    url: z.string(),
    html_url: z.union([
        z.string(),
        z.null()
    ]),
    status: z.enum([
        'queued',
        'in_progress',
        'completed',
        'waiting',
        'requested',
        'pending'
    ]),
    conclusion: z.enum([
        'success',
        'failure',
        'neutral',
        'cancelled',
        'skipped',
        'timed_out',
        'action_required'
    ]),
    created_at: z.iso.datetime(),
    started_at: z.iso.datetime(),
    completed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    name: z.string(),
    steps: z.optional(z.array(z.object({
        status: z.enum([
            'queued',
            'in_progress',
            'completed'
        ]),
        conclusion: z.union([
            z.string(),
            z.null()
        ]),
        name: z.string(),
        number: z.int(),
        started_at: z.optional(z.union([
            z.iso.datetime(),
            z.null()
        ])),
        completed_at: z.optional(z.union([
            z.iso.datetime(),
            z.null()
        ]))
    }))),
    check_run_url: z.string(),
    labels: z.array(z.string()),
    runner_id: z.union([
        z.int(),
        z.null()
    ]),
    runner_name: z.union([
        z.string(),
        z.null()
    ]),
    runner_group_id: z.union([
        z.int(),
        z.null()
    ]),
    runner_group_name: z.union([
        z.string(),
        z.null()
    ]),
    workflow_name: z.union([
        z.string(),
        z.null()
    ]),
    head_branch: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Actions OIDC subject customization for a repository
 *
 * Actions OIDC subject customization for a repository
 */
export const zOidcCustomSubRepo = z.object({
    use_default: z.boolean(),
    include_claim_keys: z.optional(z.array(z.string()))
});

/**
 * Actions Secret
 *
 * Set secrets for GitHub Actions.
 */
export const zActionsSecret = z.object({
    name: z.string(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime()
});

/**
 * Actions Variable
 */
export const zActionsVariable = z.object({
    name: z.string(),
    value: z.string(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime()
});

/**
 * Whether GitHub Actions is enabled on the repository.
 */
export const zActionsEnabled = z.boolean();

export const zActionsRepositoryPermissions = z.object({
    enabled: zActionsEnabled,
    allowed_actions: z.optional(zAllowedActions),
    selected_actions_url: z.optional(zSelectedActionsUrl),
    sha_pinning_required: z.optional(zShaPinningRequired)
});

export const zActionsWorkflowAccessToRepository = z.object({
    access_level: z.enum([
        'none',
        'user',
        'organization'
    ])
});

/**
 * Referenced workflow
 *
 * A workflow referenced/reused by the initial caller workflow
 */
export const zReferencedWorkflow = z.object({
    path: z.string(),
    sha: z.string(),
    ref: z.optional(z.string())
});

/**
 * Pull Request Minimal
 */
export const zPullRequestMinimal = z.object({
    id: z.coerce.bigint(),
    number: z.int(),
    url: z.string(),
    head: z.object({
        ref: z.string(),
        sha: z.string(),
        repo: z.object({
            id: z.coerce.bigint(),
            url: z.string(),
            name: z.string()
        })
    }),
    base: z.object({
        ref: z.string(),
        sha: z.string(),
        repo: z.object({
            id: z.coerce.bigint(),
            url: z.string(),
            name: z.string()
        })
    })
});

/**
 * Simple Commit
 *
 * A commit.
 */
export const zNullableSimpleCommit = z.union([
    z.object({
        id: z.string(),
        tree_id: z.string(),
        message: z.string(),
        timestamp: z.iso.datetime(),
        author: z.union([
            z.object({
                name: z.string(),
                email: z.email()
            }),
            z.null()
        ]),
        committer: z.union([
            z.object({
                name: z.string(),
                email: z.email()
            }),
            z.null()
        ])
    }),
    z.null()
]);

/**
 * Workflow Run
 *
 * An invocation of a workflow
 */
export const zWorkflowRun = z.object({
    id: z.int(),
    name: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    node_id: z.string(),
    check_suite_id: z.optional(z.int()),
    check_suite_node_id: z.optional(z.string()),
    head_branch: z.union([
        z.string(),
        z.null()
    ]),
    head_sha: z.string(),
    path: z.string(),
    run_number: z.int(),
    run_attempt: z.optional(z.int()),
    referenced_workflows: z.optional(z.union([
        z.array(zReferencedWorkflow),
        z.null()
    ])),
    event: z.string(),
    status: z.union([
        z.string(),
        z.null()
    ]),
    conclusion: z.union([
        z.string(),
        z.null()
    ]),
    workflow_id: z.int(),
    url: z.string(),
    html_url: z.string(),
    pull_requests: z.union([
        z.array(zPullRequestMinimal),
        z.null()
    ]),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    actor: z.optional(zSimpleUser),
    triggering_actor: z.optional(zSimpleUser),
    run_started_at: z.optional(z.iso.datetime()),
    jobs_url: z.string(),
    logs_url: z.string(),
    check_suite_url: z.string(),
    artifacts_url: z.string(),
    cancel_url: z.string(),
    rerun_url: z.string(),
    previous_attempt_url: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    workflow_url: z.string(),
    head_commit: zNullableSimpleCommit,
    repository: zMinimalRepository,
    head_repository: zMinimalRepository,
    head_repository_id: z.optional(z.int()),
    display_title: z.string()
});

/**
 * Environment Approval
 *
 * An entry in the reviews log for environment deployments
 */
export const zEnvironmentApprovals = z.object({
    environments: z.array(z.object({
        id: z.optional(z.int()),
        node_id: z.optional(z.string()),
        name: z.optional(z.string()),
        url: z.optional(z.string()),
        html_url: z.optional(z.string()),
        created_at: z.optional(z.iso.datetime()),
        updated_at: z.optional(z.iso.datetime())
    })),
    state: z.enum([
        'approved',
        'rejected',
        'pending'
    ]),
    user: zSimpleUser,
    comment: z.string()
});

export const zReviewCustomGatesCommentRequired = z.object({
    environment_name: z.string(),
    comment: z.string()
});

export const zReviewCustomGatesStateRequired = z.object({
    environment_name: z.string(),
    state: z.enum([
        'approved',
        'rejected'
    ]),
    comment: z.optional(z.string())
});

/**
 * The type of reviewer.
 */
export const zDeploymentReviewerType = z.enum([
    'User',
    'Team'
]);

/**
 * Pending Deployment
 *
 * Details of a deployment that is waiting for protection rules to pass
 */
export const zPendingDeployment = z.object({
    environment: z.object({
        id: z.optional(z.coerce.bigint()),
        node_id: z.optional(z.string()),
        name: z.optional(z.string()),
        url: z.optional(z.string()),
        html_url: z.optional(z.string())
    }),
    wait_timer: z.int(),
    wait_timer_started_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    current_user_can_approve: z.boolean(),
    reviewers: z.array(z.object({
        type: z.optional(zDeploymentReviewerType),
        reviewer: z.optional(z.union([
            zSimpleUser,
            zTeam
        ]))
    }))
});

/**
 * Deployment
 *
 * A request for a specific ref(branch,sha,tag) to be deployed
 */
export const zDeployment = z.object({
    url: z.url(),
    id: z.coerce.bigint(),
    node_id: z.string(),
    sha: z.string(),
    ref: z.string(),
    task: z.string(),
    payload: z.union([
        z.record(z.string(), z.unknown()),
        z.string()
    ]),
    original_environment: z.optional(z.string()),
    environment: z.string(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    creator: zNullableSimpleUser,
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    statuses_url: z.url(),
    repository_url: z.url(),
    transient_environment: z.optional(z.boolean()),
    production_environment: z.optional(z.boolean()),
    performed_via_github_app: z.optional(zNullableIntegration)
});

/**
 * Workflow Run Usage
 *
 * Workflow Run Usage
 */
export const zWorkflowRunUsage = z.object({
    billable: z.object({
        UBUNTU: z.optional(z.object({
            total_ms: z.int(),
            jobs: z.int(),
            job_runs: z.optional(z.array(z.object({
                job_id: z.int(),
                duration_ms: z.int()
            })))
        })),
        MACOS: z.optional(z.object({
            total_ms: z.int(),
            jobs: z.int(),
            job_runs: z.optional(z.array(z.object({
                job_id: z.int(),
                duration_ms: z.int()
            })))
        })),
        WINDOWS: z.optional(z.object({
            total_ms: z.int(),
            jobs: z.int(),
            job_runs: z.optional(z.array(z.object({
                job_id: z.int(),
                duration_ms: z.int()
            })))
        }))
    }),
    run_duration_ms: z.optional(z.int())
});

/**
 * Workflow
 *
 * A GitHub Actions workflow
 */
export const zWorkflow = z.object({
    id: z.int(),
    node_id: z.string(),
    name: z.string(),
    path: z.string(),
    state: z.enum([
        'active',
        'deleted',
        'disabled_fork',
        'disabled_inactivity',
        'disabled_manually'
    ]),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    url: z.string(),
    html_url: z.string(),
    badge_url: z.string(),
    deleted_at: z.optional(z.iso.datetime())
});

/**
 * Workflow Usage
 *
 * Workflow Usage
 */
export const zWorkflowUsage = z.object({
    billable: z.object({
        UBUNTU: z.optional(z.object({
            total_ms: z.optional(z.int())
        })),
        MACOS: z.optional(z.object({
            total_ms: z.optional(z.int())
        })),
        WINDOWS: z.optional(z.object({
            total_ms: z.optional(z.int())
        }))
    })
});

/**
 * Activity
 *
 * Activity
 */
export const zActivity = z.object({
    id: z.int(),
    node_id: z.string(),
    before: z.string(),
    after: z.string(),
    ref: z.string(),
    timestamp: z.iso.datetime(),
    activity_type: z.enum([
        'push',
        'force_push',
        'branch_deletion',
        'branch_creation',
        'pr_merge',
        'merge_queue_merge'
    ]),
    actor: zNullableSimpleUser
});

/**
 * Autolink reference
 *
 * An autolink reference.
 */
export const zAutolink = z.object({
    id: z.int(),
    key_prefix: z.string(),
    url_template: z.string(),
    is_alphanumeric: z.boolean(),
    updated_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ]))
});

/**
 * Check Dependabot security updates
 *
 * Check Dependabot security updates
 */
export const zCheckAutomatedSecurityFixes = z.object({
    enabled: z.boolean(),
    paused: z.boolean()
});

/**
 * Protected Branch Required Status Check
 *
 * Protected Branch Required Status Check
 */
export const zProtectedBranchRequiredStatusCheck = z.object({
    url: z.optional(z.string()),
    enforcement_level: z.optional(z.string()),
    contexts: z.array(z.string()),
    checks: z.array(z.object({
        context: z.string(),
        app_id: z.union([
            z.int(),
            z.null()
        ])
    })),
    contexts_url: z.optional(z.string()),
    strict: z.optional(z.boolean())
});

/**
 * Protected Branch Admin Enforced
 *
 * Protected Branch Admin Enforced
 */
export const zProtectedBranchAdminEnforced = z.object({
    url: z.url(),
    enabled: z.boolean()
});

/**
 * Protected Branch Pull Request Review
 *
 * Protected Branch Pull Request Review
 */
export const zProtectedBranchPullRequestReview = z.object({
    url: z.optional(z.url()),
    dismissal_restrictions: z.optional(z.object({
        users: z.optional(z.array(zSimpleUser)),
        teams: z.optional(z.array(zTeam)),
        apps: z.optional(z.array(zIntegration)),
        url: z.optional(z.string()),
        users_url: z.optional(z.string()),
        teams_url: z.optional(z.string())
    })),
    bypass_pull_request_allowances: z.optional(z.object({
        users: z.optional(z.array(zSimpleUser)),
        teams: z.optional(z.array(zTeam)),
        apps: z.optional(z.array(zIntegration))
    })),
    dismiss_stale_reviews: z.boolean(),
    require_code_owner_reviews: z.boolean(),
    required_approving_review_count: z.optional(z.int().gte(0).lte(6)),
    require_last_push_approval: z.optional(z.boolean()).default(false)
});

/**
 * Branch Restriction Policy
 *
 * Branch Restriction Policy
 */
export const zBranchRestrictionPolicy = z.object({
    url: z.url(),
    users_url: z.url(),
    teams_url: z.url(),
    apps_url: z.url(),
    users: z.array(z.object({
        login: z.optional(z.string()),
        id: z.optional(z.coerce.bigint()),
        node_id: z.optional(z.string()),
        avatar_url: z.optional(z.string()),
        gravatar_id: z.optional(z.string()),
        url: z.optional(z.string()),
        html_url: z.optional(z.string()),
        followers_url: z.optional(z.string()),
        following_url: z.optional(z.string()),
        gists_url: z.optional(z.string()),
        starred_url: z.optional(z.string()),
        subscriptions_url: z.optional(z.string()),
        organizations_url: z.optional(z.string()),
        repos_url: z.optional(z.string()),
        events_url: z.optional(z.string()),
        received_events_url: z.optional(z.string()),
        type: z.optional(z.string()),
        site_admin: z.optional(z.boolean()),
        user_view_type: z.optional(z.string())
    })),
    teams: z.array(zTeam),
    apps: z.array(z.object({
        id: z.optional(z.int()),
        slug: z.optional(z.string()),
        node_id: z.optional(z.string()),
        owner: z.optional(z.object({
            login: z.optional(z.string()),
            id: z.optional(z.int()),
            node_id: z.optional(z.string()),
            url: z.optional(z.string()),
            repos_url: z.optional(z.string()),
            events_url: z.optional(z.string()),
            hooks_url: z.optional(z.string()),
            issues_url: z.optional(z.string()),
            members_url: z.optional(z.string()),
            public_members_url: z.optional(z.string()),
            avatar_url: z.optional(z.string()),
            description: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.string()),
            followers_url: z.optional(z.string()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.string()),
            organizations_url: z.optional(z.string()),
            received_events_url: z.optional(z.string()),
            type: z.optional(z.string()),
            site_admin: z.optional(z.boolean()),
            user_view_type: z.optional(z.string())
        })),
        name: z.optional(z.string()),
        client_id: z.optional(z.string()),
        description: z.optional(z.string()),
        external_url: z.optional(z.string()),
        html_url: z.optional(z.string()),
        created_at: z.optional(z.string()),
        updated_at: z.optional(z.string()),
        permissions: z.optional(z.object({
            metadata: z.optional(z.string()),
            contents: z.optional(z.string()),
            issues: z.optional(z.string()),
            single_file: z.optional(z.string())
        })),
        events: z.optional(z.array(z.string()))
    }))
});

/**
 * Branch Protection
 *
 * Branch Protection
 */
export const zBranchProtection = z.object({
    url: z.optional(z.string()),
    enabled: z.optional(z.boolean()),
    required_status_checks: z.optional(zProtectedBranchRequiredStatusCheck),
    enforce_admins: z.optional(zProtectedBranchAdminEnforced),
    required_pull_request_reviews: z.optional(zProtectedBranchPullRequestReview),
    restrictions: z.optional(zBranchRestrictionPolicy),
    required_linear_history: z.optional(z.object({
        enabled: z.optional(z.boolean())
    })),
    allow_force_pushes: z.optional(z.object({
        enabled: z.optional(z.boolean())
    })),
    allow_deletions: z.optional(z.object({
        enabled: z.optional(z.boolean())
    })),
    block_creations: z.optional(z.object({
        enabled: z.optional(z.boolean())
    })),
    required_conversation_resolution: z.optional(z.object({
        enabled: z.optional(z.boolean())
    })),
    name: z.optional(z.string()),
    protection_url: z.optional(z.string()),
    required_signatures: z.optional(z.object({
        url: z.url(),
        enabled: z.boolean()
    })),
    lock_branch: z.optional(z.object({
        enabled: z.optional(z.boolean()).default(false)
    })),
    allow_fork_syncing: z.optional(z.object({
        enabled: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Short Branch
 *
 * Short Branch
 */
export const zShortBranch = z.object({
    name: z.string(),
    commit: z.object({
        sha: z.string(),
        url: z.url()
    }),
    protected: z.boolean(),
    protection: z.optional(zBranchProtection),
    protection_url: z.optional(z.url())
});

/**
 * Git User
 *
 * Metaproperties for Git author/committer information.
 */
export const zNullableGitUser = z.union([
    z.object({
        name: z.optional(z.string()),
        email: z.optional(z.string()),
        date: z.optional(z.string())
    }),
    z.null()
]);

/**
 * Verification
 */
export const zVerification = z.object({
    verified: z.boolean(),
    reason: z.string(),
    payload: z.union([
        z.string(),
        z.null()
    ]),
    signature: z.union([
        z.string(),
        z.null()
    ]),
    verified_at: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Diff Entry
 *
 * Diff Entry
 */
export const zDiffEntry = z.object({
    sha: z.union([
        z.string(),
        z.null()
    ]),
    filename: z.string(),
    status: z.enum([
        'added',
        'removed',
        'modified',
        'renamed',
        'copied',
        'changed',
        'unchanged'
    ]),
    additions: z.int(),
    deletions: z.int(),
    changes: z.int(),
    blob_url: z.url(),
    raw_url: z.url(),
    contents_url: z.url(),
    patch: z.optional(z.string()),
    previous_filename: z.optional(z.string())
});

/**
 * Commit
 *
 * Commit
 */
export const zCommit = z.object({
    url: z.url(),
    sha: z.string(),
    node_id: z.string(),
    html_url: z.url(),
    comments_url: z.url(),
    commit: z.object({
        url: z.url(),
        author: zNullableGitUser,
        committer: zNullableGitUser,
        message: z.string(),
        comment_count: z.int(),
        tree: z.object({
            sha: z.string(),
            url: z.url()
        }),
        verification: z.optional(zVerification)
    }),
    author: z.union([
        zSimpleUser,
        zEmptyObject,
        z.null()
    ]),
    committer: z.union([
        zSimpleUser,
        zEmptyObject,
        z.null()
    ]),
    parents: z.array(z.object({
        sha: z.string(),
        url: z.url(),
        html_url: z.optional(z.url())
    })),
    stats: z.optional(z.object({
        additions: z.optional(z.int()),
        deletions: z.optional(z.int()),
        total: z.optional(z.int())
    })),
    files: z.optional(z.array(zDiffEntry))
});

/**
 * Branch With Protection
 *
 * Branch With Protection
 */
export const zBranchWithProtection = z.object({
    name: z.string(),
    commit: zCommit,
    _links: z.object({
        html: z.string(),
        self: z.url()
    }),
    protected: z.boolean(),
    protection: zBranchProtection,
    protection_url: z.url(),
    pattern: z.optional(z.string()),
    required_approving_review_count: z.optional(z.int())
});

/**
 * Status Check Policy
 *
 * Status Check Policy
 */
export const zStatusCheckPolicy = z.object({
    url: z.url(),
    strict: z.boolean(),
    contexts: z.array(z.string()),
    checks: z.array(z.object({
        context: z.string(),
        app_id: z.union([
            z.int(),
            z.null()
        ])
    })),
    contexts_url: z.url()
});

/**
 * Protected Branch
 *
 * Branch protections protect branches
 */
export const zProtectedBranch = z.object({
    url: z.url(),
    required_status_checks: z.optional(zStatusCheckPolicy),
    required_pull_request_reviews: z.optional(z.object({
        url: z.url(),
        dismiss_stale_reviews: z.optional(z.boolean()),
        require_code_owner_reviews: z.optional(z.boolean()),
        required_approving_review_count: z.optional(z.int()),
        require_last_push_approval: z.optional(z.boolean()).default(false),
        dismissal_restrictions: z.optional(z.object({
            url: z.url(),
            users_url: z.url(),
            teams_url: z.url(),
            users: z.array(zSimpleUser),
            teams: z.array(zTeam),
            apps: z.optional(z.array(zIntegration))
        })),
        bypass_pull_request_allowances: z.optional(z.object({
            users: z.array(zSimpleUser),
            teams: z.array(zTeam),
            apps: z.optional(z.array(zIntegration))
        }))
    })),
    required_signatures: z.optional(z.object({
        url: z.url(),
        enabled: z.boolean()
    })),
    enforce_admins: z.optional(z.object({
        url: z.url(),
        enabled: z.boolean()
    })),
    required_linear_history: z.optional(z.object({
        enabled: z.boolean()
    })),
    allow_force_pushes: z.optional(z.object({
        enabled: z.boolean()
    })),
    allow_deletions: z.optional(z.object({
        enabled: z.boolean()
    })),
    restrictions: z.optional(zBranchRestrictionPolicy),
    required_conversation_resolution: z.optional(z.object({
        enabled: z.optional(z.boolean())
    })),
    block_creations: z.optional(z.object({
        enabled: z.boolean()
    })),
    lock_branch: z.optional(z.object({
        enabled: z.optional(z.boolean()).default(false)
    })),
    allow_fork_syncing: z.optional(z.object({
        enabled: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Deployment
 *
 * A deployment created as the result of an Actions check run from a workflow that references an environment
 */
export const zDeploymentSimple = z.object({
    url: z.url(),
    id: z.int(),
    node_id: z.string(),
    task: z.string(),
    original_environment: z.optional(z.string()),
    environment: z.string(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    statuses_url: z.url(),
    repository_url: z.url(),
    transient_environment: z.optional(z.boolean()),
    production_environment: z.optional(z.boolean()),
    performed_via_github_app: z.optional(zNullableIntegration)
});

/**
 * CheckRun
 *
 * A check performed on the code of a given code change
 */
export const zCheckRun = z.object({
    id: z.coerce.bigint(),
    head_sha: z.string(),
    node_id: z.string(),
    external_id: z.union([
        z.string(),
        z.null()
    ]),
    url: z.string(),
    html_url: z.union([
        z.string(),
        z.null()
    ]),
    details_url: z.union([
        z.string(),
        z.null()
    ]),
    status: z.enum([
        'queued',
        'in_progress',
        'completed',
        'waiting',
        'requested',
        'pending'
    ]),
    conclusion: z.enum([
        'success',
        'failure',
        'neutral',
        'cancelled',
        'skipped',
        'timed_out',
        'action_required'
    ]),
    started_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    completed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    output: z.object({
        title: z.union([
            z.string(),
            z.null()
        ]),
        summary: z.union([
            z.string(),
            z.null()
        ]),
        text: z.union([
            z.string(),
            z.null()
        ]),
        annotations_count: z.int(),
        annotations_url: z.url()
    }),
    name: z.string(),
    check_suite: z.union([
        z.object({
            id: z.int()
        }),
        z.null()
    ]),
    app: zNullableIntegration,
    pull_requests: z.array(zPullRequestMinimal),
    deployment: z.optional(zDeploymentSimple)
});

/**
 * Check Annotation
 *
 * Check Annotation
 */
export const zCheckAnnotation = z.object({
    path: z.string(),
    start_line: z.int(),
    end_line: z.int(),
    start_column: z.union([
        z.int(),
        z.null()
    ]),
    end_column: z.union([
        z.int(),
        z.null()
    ]),
    annotation_level: z.union([
        z.string(),
        z.null()
    ]),
    title: z.union([
        z.string(),
        z.null()
    ]),
    message: z.union([
        z.string(),
        z.null()
    ]),
    raw_details: z.union([
        z.string(),
        z.null()
    ]),
    blob_href: z.string()
});

/**
 * Simple Commit
 *
 * A commit.
 */
export const zSimpleCommit = z.object({
    id: z.string(),
    tree_id: z.string(),
    message: z.string(),
    timestamp: z.iso.datetime(),
    author: z.union([
        z.object({
            name: z.string(),
            email: z.email()
        }),
        z.null()
    ]),
    committer: z.union([
        z.object({
            name: z.string(),
            email: z.email()
        }),
        z.null()
    ])
});

/**
 * CheckSuite
 *
 * A suite of checks performed on the code of a given code change
 */
export const zCheckSuite = z.object({
    id: z.coerce.bigint(),
    node_id: z.string(),
    head_branch: z.union([
        z.string(),
        z.null()
    ]),
    head_sha: z.string(),
    status: z.enum([
        'queued',
        'in_progress',
        'completed',
        'waiting',
        'requested',
        'pending'
    ]),
    conclusion: z.nullable(z.enum([
        'success',
        'failure',
        'neutral',
        'cancelled',
        'skipped',
        'timed_out',
        'action_required',
        'startup_failure',
        'stale'
    ])),
    url: z.union([
        z.string(),
        z.null()
    ]),
    before: z.union([
        z.string(),
        z.null()
    ]),
    after: z.union([
        z.string(),
        z.null()
    ]),
    pull_requests: z.union([
        z.array(zPullRequestMinimal),
        z.null()
    ]),
    app: zNullableIntegration,
    repository: zMinimalRepository,
    created_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    updated_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    head_commit: zSimpleCommit,
    latest_check_runs_count: z.int(),
    check_runs_url: z.string(),
    rerequestable: z.optional(z.boolean()),
    runs_rerequestable: z.optional(z.boolean())
});

/**
 * Check Suite Preference
 *
 * Check suite configuration preferences for a repository.
 */
export const zCheckSuitePreference = z.object({
    preferences: z.object({
        auto_trigger_checks: z.optional(z.array(z.object({
            app_id: z.int(),
            setting: z.boolean()
        })))
    }),
    repository: zMinimalRepository
});

export const zCodeScanningAlertItems = z.object({
    number: zAlertNumber,
    created_at: zAlertCreatedAt,
    updated_at: z.optional(zAlertUpdatedAt),
    url: zAlertUrl,
    html_url: zAlertHtmlUrl,
    instances_url: zAlertInstancesUrl,
    state: zCodeScanningAlertState,
    fixed_at: z.optional(zAlertFixedAt),
    dismissed_by: zNullableSimpleUser,
    dismissed_at: zAlertDismissedAt,
    dismissed_reason: zCodeScanningAlertDismissedReason,
    dismissed_comment: z.optional(zCodeScanningAlertDismissedComment),
    rule: zCodeScanningAlertRuleSummary,
    tool: zCodeScanningAnalysisTool,
    most_recent_instance: zCodeScanningAlertInstance,
    dismissal_approved_by: z.optional(zNullableSimpleUser),
    assignees: z.optional(z.array(zSimpleUser))
});

export const zCodeScanningAlertRule = z.object({
    id: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    name: z.optional(z.string()),
    severity: z.optional(z.enum([
        'none',
        'note',
        'warning',
        'error'
    ])),
    security_severity_level: z.optional(z.enum([
        'low',
        'medium',
        'high',
        'critical'
    ])),
    description: z.optional(z.string()),
    full_description: z.optional(z.string()),
    tags: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    help: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    help_uri: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

export const zCodeScanningAlert = z.object({
    number: zAlertNumber,
    created_at: zAlertCreatedAt,
    updated_at: z.optional(zAlertUpdatedAt),
    url: zAlertUrl,
    html_url: zAlertHtmlUrl,
    instances_url: zAlertInstancesUrl,
    state: zCodeScanningAlertState,
    fixed_at: z.optional(zAlertFixedAt),
    dismissed_by: zNullableSimpleUser,
    dismissed_at: zAlertDismissedAt,
    dismissed_reason: zCodeScanningAlertDismissedReason,
    dismissed_comment: z.optional(zCodeScanningAlertDismissedComment),
    rule: zCodeScanningAlertRule,
    tool: zCodeScanningAnalysisTool,
    most_recent_instance: zCodeScanningAlertInstance,
    dismissal_approved_by: z.optional(zNullableSimpleUser),
    assignees: z.optional(z.array(zSimpleUser))
});

/**
 * Sets the state of the code scanning alert. You must provide `dismissed_reason` when you set the state to `dismissed`.
 */
export const zCodeScanningAlertSetState = z.enum([
    'open',
    'dismissed'
]);

/**
 * If `true`, attempt to create an alert dismissal request.
 */
export const zCodeScanningAlertCreateRequest = z.boolean();

/**
 * The status of an autofix.
 */
export const zCodeScanningAutofixStatus = z.enum([
    'pending',
    'error',
    'success',
    'outdated'
]);

/**
 * The description of an autofix.
 */
export const zCodeScanningAutofixDescription = z.union([
    z.string(),
    z.null()
]);

/**
 * The start time of an autofix in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const zCodeScanningAutofixStartedAt = z.iso.datetime().readonly();

export const zCodeScanningAutofix = z.object({
    status: zCodeScanningAutofixStatus,
    description: zCodeScanningAutofixDescription,
    started_at: zCodeScanningAutofixStartedAt
});

/**
 * Commit an autofix for a code scanning alert
 */
export const zCodeScanningAutofixCommits = z.union([
    z.object({
        target_ref: z.optional(z.string()),
        message: z.optional(z.string())
    }),
    z.null()
]);

export const zCodeScanningAutofixCommitsResponse = z.object({
    target_ref: z.optional(z.string()),
    sha: z.optional(z.string())
});

/**
 * An identifier for the upload.
 */
export const zCodeScanningAnalysisSarifId = z.string();

/**
 * The SHA of the commit to which the analysis you are uploading relates.
 */
export const zCodeScanningAnalysisCommitSha = z.string().length(40).regex(/^[0-9a-fA-F]+$/);

/**
 * Identifies the variable values associated with the environment in which this analysis was performed.
 */
export const zCodeScanningAnalysisEnvironment = z.string();

/**
 * The time that the analysis was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const zCodeScanningAnalysisCreatedAt = z.iso.datetime().readonly();

/**
 * The REST API URL of the analysis resource.
 */
export const zCodeScanningAnalysisUrl = z.url().readonly();

export const zCodeScanningAnalysis = z.object({
    ref: zCodeScanningRef,
    commit_sha: zCodeScanningAnalysisCommitSha,
    analysis_key: zCodeScanningAnalysisAnalysisKey,
    environment: zCodeScanningAnalysisEnvironment,
    category: z.optional(zCodeScanningAnalysisCategory),
    error: z.string(),
    created_at: zCodeScanningAnalysisCreatedAt,
    results_count: z.int(),
    rules_count: z.int(),
    id: z.int(),
    url: zCodeScanningAnalysisUrl,
    sarif_id: zCodeScanningAnalysisSarifId,
    tool: zCodeScanningAnalysisTool,
    deletable: z.boolean(),
    warning: z.string()
});

/**
 * Analysis deletion
 *
 * Successful deletion of a code scanning analysis
 */
export const zCodeScanningAnalysisDeletion = z.object({
    next_analysis_url: z.union([
        z.url().readonly(),
        z.null()
    ]).readonly(),
    confirm_delete_url: z.union([
        z.url().readonly(),
        z.null()
    ]).readonly()
});

/**
 * CodeQL Database
 *
 * A CodeQL database.
 */
export const zCodeScanningCodeqlDatabase = z.object({
    id: z.int(),
    name: z.string(),
    language: z.string(),
    uploader: zSimpleUser,
    content_type: z.string(),
    size: z.int(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    url: z.url(),
    commit_oid: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

/**
 * The language targeted by the CodeQL query
 */
export const zCodeScanningVariantAnalysisLanguage = z.enum([
    'cpp',
    'csharp',
    'go',
    'java',
    'javascript',
    'python',
    'ruby',
    'rust',
    'swift'
]);

/**
 * Repository Identifier
 *
 * Repository Identifier
 */
export const zCodeScanningVariantAnalysisRepository = z.object({
    id: z.int(),
    name: z.string(),
    full_name: z.string(),
    private: z.boolean(),
    stargazers_count: z.int(),
    updated_at: z.union([
        z.iso.datetime(),
        z.null()
    ])
});

/**
 * The new status of the CodeQL variant analysis repository task.
 */
export const zCodeScanningVariantAnalysisStatus = z.enum([
    'pending',
    'in_progress',
    'succeeded',
    'failed',
    'canceled',
    'timed_out'
]);

export const zCodeScanningVariantAnalysisSkippedRepoGroup = z.object({
    repository_count: z.int(),
    repositories: z.array(zCodeScanningVariantAnalysisRepository)
});

/**
 * Variant Analysis
 *
 * A run of a CodeQL query against one or more repositories.
 */
export const zCodeScanningVariantAnalysis = z.object({
    id: z.int(),
    controller_repo: zSimpleRepository,
    actor: zSimpleUser,
    query_language: zCodeScanningVariantAnalysisLanguage,
    query_pack_url: z.string(),
    created_at: z.optional(z.iso.datetime()),
    updated_at: z.optional(z.iso.datetime()),
    completed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    status: z.enum([
        'in_progress',
        'succeeded',
        'failed',
        'cancelled'
    ]),
    actions_workflow_run_id: z.optional(z.int()),
    failure_reason: z.optional(z.enum([
        'no_repos_queried',
        'actions_workflow_run_failed',
        'internal_error'
    ])),
    scanned_repositories: z.optional(z.array(z.object({
        repository: zCodeScanningVariantAnalysisRepository,
        analysis_status: zCodeScanningVariantAnalysisStatus,
        result_count: z.optional(z.int()),
        artifact_size_in_bytes: z.optional(z.int()),
        failure_message: z.optional(z.string())
    }))),
    skipped_repositories: z.optional(z.object({
        access_mismatch_repos: zCodeScanningVariantAnalysisSkippedRepoGroup,
        not_found_repos: z.object({
            repository_count: z.int(),
            repository_full_names: z.array(z.string())
        }),
        no_codeql_db_repos: zCodeScanningVariantAnalysisSkippedRepoGroup,
        over_limit_repos: zCodeScanningVariantAnalysisSkippedRepoGroup
    }))
});

export const zCodeScanningVariantAnalysisRepoTask = z.object({
    repository: zSimpleRepository,
    analysis_status: zCodeScanningVariantAnalysisStatus,
    artifact_size_in_bytes: z.optional(z.int()),
    result_count: z.optional(z.int()),
    failure_message: z.optional(z.string()),
    database_commit_sha: z.optional(z.string()),
    source_location_prefix: z.optional(z.string()),
    artifact_url: z.optional(z.string())
});

/**
 * Configuration for code scanning default setup.
 */
export const zCodeScanningDefaultSetup = z.object({
    state: z.optional(z.enum([
        'configured',
        'not-configured'
    ])),
    languages: z.optional(z.array(z.enum([
        'actions',
        'c-cpp',
        'csharp',
        'go',
        'java-kotlin',
        'javascript-typescript',
        'javascript',
        'python',
        'ruby',
        'typescript',
        'swift'
    ]))),
    runner_type: z.optional(z.enum([
        'standard',
        'labeled'
    ])),
    runner_label: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    query_suite: z.optional(z.enum([
        'default',
        'extended'
    ])),
    threat_model: z.optional(z.enum([
        'remote',
        'remote_and_local'
    ])),
    updated_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    schedule: z.optional(z.enum([
        'weekly'
    ]))
});

/**
 * Configuration for code scanning default setup.
 */
export const zCodeScanningDefaultSetupUpdate = z.object({
    state: z.optional(z.enum([
        'configured',
        'not-configured'
    ])),
    runner_type: z.optional(z.enum([
        'standard',
        'labeled'
    ])),
    runner_label: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    query_suite: z.optional(z.enum([
        'default',
        'extended'
    ])),
    threat_model: z.optional(z.enum([
        'remote',
        'remote_and_local'
    ])),
    languages: z.optional(z.array(z.enum([
        'actions',
        'c-cpp',
        'csharp',
        'go',
        'java-kotlin',
        'javascript-typescript',
        'python',
        'ruby',
        'swift'
    ])))
});

/**
 * You can use `run_url` to track the status of the run. This includes a property status and conclusion.
 * You should not rely on this always being an actions workflow run object.
 */
export const zCodeScanningDefaultSetupUpdateResponse = z.object({
    run_id: z.optional(z.int()),
    run_url: z.optional(z.string())
});

/**
 * The full Git reference, formatted as `refs/heads/<branch name>`,
 * `refs/tags/<tag>`, `refs/pull/<number>/merge`, or `refs/pull/<number>/head`.
 */
export const zCodeScanningRefFull = z.string().regex(/^refs\/(heads|tags|pull)\/.*$/);

/**
 * A Base64 string representing the SARIF file to upload. You must first compress your SARIF file using [`gzip`](http://www.gnu.org/software/gzip/manual/gzip.html) and then translate the contents of the file into a Base64 encoding string. For more information, see "[SARIF support for code scanning](https://docs.github.com/code-security/secure-coding/sarif-support-for-code-scanning)."
 */
export const zCodeScanningAnalysisSarifFile = z.string();

export const zCodeScanningSarifsReceipt = z.object({
    id: z.optional(zCodeScanningAnalysisSarifId),
    url: z.optional(z.url().readonly())
});

export const zCodeScanningSarifsStatus = z.object({
    processing_status: z.optional(z.enum([
        'pending',
        'complete',
        'failed'
    ])),
    analyses_url: z.optional(z.union([
        z.url().readonly(),
        z.null()
    ]).readonly()),
    errors: z.optional(z.union([
        z.array(z.string()).readonly(),
        z.null()
    ]).readonly())
});

/**
 * Code security configuration associated with a repository and attachment status
 */
export const zCodeSecurityConfigurationForRepository = z.object({
    status: z.optional(z.enum([
        'attached',
        'attaching',
        'detached',
        'removed',
        'enforced',
        'failed',
        'updating',
        'removed_by_enterprise'
    ])),
    configuration: z.optional(zCodeSecurityConfiguration)
});

/**
 * CODEOWNERS errors
 *
 * A list of errors found in a repo's CODEOWNERS file
 */
export const zCodeownersErrors = z.object({
    errors: z.array(z.object({
        line: z.int(),
        column: z.int(),
        source: z.optional(z.string()),
        kind: z.string(),
        suggestion: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        message: z.string(),
        path: z.string()
    }))
});

/**
 * Codespace machine
 *
 * A description of the machine powering a codespace.
 */
export const zCodespaceMachine = z.object({
    name: z.string(),
    display_name: z.string(),
    operating_system: z.string(),
    storage_in_bytes: z.int(),
    memory_in_bytes: z.int(),
    cpus: z.int(),
    prebuild_availability: z.enum([
        'none',
        'ready',
        'in_progress'
    ])
});

/**
 * Codespaces Permissions Check
 *
 * Permission check result for a given devcontainer config.
 */
export const zCodespacesPermissionsCheckForDevcontainer = z.object({
    accepted: z.boolean()
});

/**
 * Codespaces Secret
 *
 * Set repository secrets for GitHub Codespaces.
 */
export const zRepoCodespacesSecret = z.object({
    name: z.string(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime()
});

/**
 * Collaborator
 *
 * Collaborator
 */
export const zCollaborator = z.object({
    login: z.string(),
    id: z.coerce.bigint(),
    email: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    name: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    node_id: z.string(),
    avatar_url: z.url(),
    gravatar_id: z.union([
        z.string(),
        z.null()
    ]),
    url: z.url(),
    html_url: z.url(),
    followers_url: z.url(),
    following_url: z.string(),
    gists_url: z.string(),
    starred_url: z.string(),
    subscriptions_url: z.url(),
    organizations_url: z.url(),
    repos_url: z.url(),
    events_url: z.string(),
    received_events_url: z.url(),
    type: z.string(),
    site_admin: z.boolean(),
    permissions: z.optional(z.object({
        pull: z.boolean(),
        triage: z.optional(z.boolean()),
        push: z.boolean(),
        maintain: z.optional(z.boolean()),
        admin: z.boolean()
    })),
    role_name: z.string(),
    user_view_type: z.optional(z.string())
});

/**
 * Repository Invitation
 *
 * Repository invitations let you manage who you collaborate with.
 */
export const zRepositoryInvitation = z.object({
    id: z.coerce.bigint(),
    repository: zMinimalRepository,
    invitee: zNullableSimpleUser,
    inviter: zNullableSimpleUser,
    permissions: z.enum([
        'read',
        'write',
        'admin',
        'triage',
        'maintain'
    ]),
    created_at: z.iso.datetime(),
    expired: z.optional(z.boolean()),
    url: z.string(),
    html_url: z.string(),
    node_id: z.string()
});

/**
 * Collaborator
 *
 * Collaborator
 */
export const zNullableCollaborator = z.union([
    z.object({
        login: z.string(),
        id: z.coerce.bigint(),
        email: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        node_id: z.string(),
        avatar_url: z.url(),
        gravatar_id: z.union([
            z.string(),
            z.null()
        ]),
        url: z.url(),
        html_url: z.url(),
        followers_url: z.url(),
        following_url: z.string(),
        gists_url: z.string(),
        starred_url: z.string(),
        subscriptions_url: z.url(),
        organizations_url: z.url(),
        repos_url: z.url(),
        events_url: z.string(),
        received_events_url: z.url(),
        type: z.string(),
        site_admin: z.boolean(),
        permissions: z.optional(z.object({
            pull: z.boolean(),
            triage: z.optional(z.boolean()),
            push: z.boolean(),
            maintain: z.optional(z.boolean()),
            admin: z.boolean()
        })),
        role_name: z.string(),
        user_view_type: z.optional(z.string())
    }),
    z.null()
]);

/**
 * Repository Collaborator Permission
 *
 * Repository Collaborator Permission
 */
export const zRepositoryCollaboratorPermission = z.object({
    permission: z.string(),
    role_name: z.string(),
    user: zNullableCollaborator
});

/**
 * Commit Comment
 *
 * Commit Comment
 */
export const zCommitComment = z.object({
    html_url: z.url(),
    url: z.url(),
    id: z.int(),
    node_id: z.string(),
    body: z.string(),
    path: z.union([
        z.string(),
        z.null()
    ]),
    position: z.union([
        z.int(),
        z.null()
    ]),
    line: z.union([
        z.int(),
        z.null()
    ]),
    commit_id: z.string(),
    user: zNullableSimpleUser,
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    author_association: zAuthorAssociation,
    reactions: z.optional(zReactionRollup)
});

/**
 * Branch Short
 *
 * Branch Short
 */
export const zBranchShort = z.object({
    name: z.string(),
    commit: z.object({
        sha: z.string(),
        url: z.string()
    }),
    protected: z.boolean()
});

/**
 * Simple Commit Status
 */
export const zSimpleCommitStatus = z.object({
    description: z.union([
        z.string(),
        z.null()
    ]),
    id: z.int(),
    node_id: z.string(),
    state: z.string(),
    context: z.string(),
    target_url: z.union([
        z.url(),
        z.null()
    ]),
    required: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    avatar_url: z.union([
        z.url(),
        z.null()
    ]),
    url: z.url(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime()
});

/**
 * Combined Commit Status
 *
 * Combined Commit Status
 */
export const zCombinedCommitStatus = z.object({
    state: z.string(),
    statuses: z.array(zSimpleCommitStatus),
    sha: z.string(),
    total_count: z.int(),
    repository: zMinimalRepository,
    commit_url: z.url(),
    url: z.url()
});

/**
 * Status
 *
 * The status of a commit.
 */
export const zStatus = z.object({
    url: z.string(),
    avatar_url: z.union([
        z.string(),
        z.null()
    ]),
    id: z.int(),
    node_id: z.string(),
    state: z.string(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    target_url: z.union([
        z.string(),
        z.null()
    ]),
    context: z.string(),
    created_at: z.string(),
    updated_at: z.string(),
    creator: zNullableSimpleUser
});

/**
 * Code Of Conduct Simple
 *
 * Code of Conduct Simple
 */
export const zNullableCodeOfConductSimple = z.union([
    z.object({
        url: z.url(),
        key: z.string(),
        name: z.string(),
        html_url: z.union([
            z.url(),
            z.null()
        ])
    }),
    z.null()
]);

/**
 * Community Health File
 */
export const zNullableCommunityHealthFile = z.union([
    z.object({
        url: z.url(),
        html_url: z.url()
    }),
    z.null()
]);

/**
 * Community Profile
 *
 * Community Profile
 */
export const zCommunityProfile = z.object({
    health_percentage: z.int(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    documentation: z.union([
        z.string(),
        z.null()
    ]),
    files: z.object({
        code_of_conduct: zNullableCodeOfConductSimple,
        code_of_conduct_file: zNullableCommunityHealthFile,
        license: zNullableLicenseSimple,
        contributing: zNullableCommunityHealthFile,
        readme: zNullableCommunityHealthFile,
        issue_template: zNullableCommunityHealthFile,
        pull_request_template: zNullableCommunityHealthFile
    }),
    updated_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    content_reports_enabled: z.optional(z.boolean())
});

/**
 * Commit Comparison
 *
 * Commit Comparison
 */
export const zCommitComparison = z.object({
    url: z.url(),
    html_url: z.url(),
    permalink_url: z.url(),
    diff_url: z.url(),
    patch_url: z.url(),
    base_commit: zCommit,
    merge_base_commit: zCommit,
    status: z.enum([
        'diverged',
        'ahead',
        'behind',
        'identical'
    ]),
    ahead_by: z.int(),
    behind_by: z.int(),
    total_commits: z.int(),
    commits: z.array(zCommit),
    files: z.optional(z.array(zDiffEntry))
});

/**
 * Content Tree
 *
 * Content Tree
 */
export const zContentTree = z.object({
    type: z.string(),
    size: z.int(),
    name: z.string(),
    path: z.string(),
    sha: z.string(),
    content: z.optional(z.string()),
    url: z.url(),
    git_url: z.union([
        z.url(),
        z.null()
    ]),
    html_url: z.union([
        z.url(),
        z.null()
    ]),
    download_url: z.union([
        z.url(),
        z.null()
    ]),
    entries: z.optional(z.array(z.object({
        type: z.string(),
        size: z.int(),
        name: z.string(),
        path: z.string(),
        sha: z.string(),
        url: z.url(),
        git_url: z.union([
            z.url(),
            z.null()
        ]),
        html_url: z.union([
            z.url(),
            z.null()
        ]),
        download_url: z.union([
            z.url(),
            z.null()
        ]),
        _links: z.object({
            git: z.union([
                z.url(),
                z.null()
            ]),
            html: z.union([
                z.url(),
                z.null()
            ]),
            self: z.url()
        })
    }))),
    encoding: z.optional(z.string()),
    _links: z.object({
        git: z.union([
            z.url(),
            z.null()
        ]),
        html: z.union([
            z.url(),
            z.null()
        ]),
        self: z.url()
    })
});

/**
 * Content Directory
 *
 * A list of directory items
 */
export const zContentDirectory = z.array(z.object({
    type: z.enum([
        'dir',
        'file',
        'submodule',
        'symlink'
    ]),
    size: z.int(),
    name: z.string(),
    path: z.string(),
    content: z.optional(z.string()),
    sha: z.string(),
    url: z.url(),
    git_url: z.union([
        z.url(),
        z.null()
    ]),
    html_url: z.union([
        z.url(),
        z.null()
    ]),
    download_url: z.union([
        z.url(),
        z.null()
    ]),
    _links: z.object({
        git: z.union([
            z.url(),
            z.null()
        ]),
        html: z.union([
            z.url(),
            z.null()
        ]),
        self: z.url()
    })
}));

/**
 * Content File
 *
 * Content File
 */
export const zContentFile = z.object({
    type: z.enum([
        'file'
    ]),
    encoding: z.string(),
    size: z.int(),
    name: z.string(),
    path: z.string(),
    content: z.string(),
    sha: z.string(),
    url: z.url(),
    git_url: z.union([
        z.url(),
        z.null()
    ]),
    html_url: z.union([
        z.url(),
        z.null()
    ]),
    download_url: z.union([
        z.url(),
        z.null()
    ]),
    _links: z.object({
        git: z.union([
            z.url(),
            z.null()
        ]),
        html: z.union([
            z.url(),
            z.null()
        ]),
        self: z.url()
    }),
    target: z.optional(z.string()),
    submodule_git_url: z.optional(z.string())
});

/**
 * Symlink Content
 *
 * An object describing a symlink
 */
export const zContentSymlink = z.object({
    type: z.enum([
        'symlink'
    ]),
    target: z.string(),
    size: z.int(),
    name: z.string(),
    path: z.string(),
    sha: z.string(),
    url: z.url(),
    git_url: z.union([
        z.url(),
        z.null()
    ]),
    html_url: z.union([
        z.url(),
        z.null()
    ]),
    download_url: z.union([
        z.url(),
        z.null()
    ]),
    _links: z.object({
        git: z.union([
            z.url(),
            z.null()
        ]),
        html: z.union([
            z.url(),
            z.null()
        ]),
        self: z.url()
    })
});

/**
 * Submodule Content
 *
 * An object describing a submodule
 */
export const zContentSubmodule = z.object({
    type: z.enum([
        'submodule'
    ]),
    submodule_git_url: z.url(),
    size: z.int(),
    name: z.string(),
    path: z.string(),
    sha: z.string(),
    url: z.url(),
    git_url: z.union([
        z.url(),
        z.null()
    ]),
    html_url: z.union([
        z.url(),
        z.null()
    ]),
    download_url: z.union([
        z.url(),
        z.null()
    ]),
    _links: z.object({
        git: z.union([
            z.url(),
            z.null()
        ]),
        html: z.union([
            z.url(),
            z.null()
        ]),
        self: z.url()
    })
});

/**
 * File Commit
 *
 * File Commit
 */
export const zFileCommit = z.object({
    content: z.union([
        z.object({
            name: z.optional(z.string()),
            path: z.optional(z.string()),
            sha: z.optional(z.string()),
            size: z.optional(z.int()),
            url: z.optional(z.string()),
            html_url: z.optional(z.string()),
            git_url: z.optional(z.string()),
            download_url: z.optional(z.string()),
            type: z.optional(z.string()),
            _links: z.optional(z.object({
                self: z.optional(z.string()),
                git: z.optional(z.string()),
                html: z.optional(z.string())
            }))
        }),
        z.null()
    ]),
    commit: z.object({
        sha: z.optional(z.string()),
        node_id: z.optional(z.string()),
        url: z.optional(z.string()),
        html_url: z.optional(z.string()),
        author: z.optional(z.object({
            date: z.optional(z.string()),
            name: z.optional(z.string()),
            email: z.optional(z.string())
        })),
        committer: z.optional(z.object({
            date: z.optional(z.string()),
            name: z.optional(z.string()),
            email: z.optional(z.string())
        })),
        message: z.optional(z.string()),
        tree: z.optional(z.object({
            url: z.optional(z.string()),
            sha: z.optional(z.string())
        })),
        parents: z.optional(z.array(z.object({
            url: z.optional(z.string()),
            html_url: z.optional(z.string()),
            sha: z.optional(z.string())
        }))),
        verification: z.optional(z.object({
            verified: z.optional(z.boolean()),
            reason: z.optional(z.string()),
            signature: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            payload: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            verified_at: z.optional(z.union([
                z.string(),
                z.null()
            ]))
        }))
    })
});

/**
 * The ID of the push protection bypass placeholder. This value is returned on any push protected routes.
 */
export const zSecretScanningPushProtectionBypassPlaceholderId = z.string();

/**
 * Repository rule violation was detected
 */
export const zRepositoryRuleViolationError = z.object({
    message: z.optional(z.string()),
    documentation_url: z.optional(z.string()),
    status: z.optional(z.string()),
    metadata: z.optional(z.object({
        secret_scanning: z.optional(z.object({
            bypass_placeholders: z.optional(z.array(z.object({
                placeholder_id: z.optional(zSecretScanningPushProtectionBypassPlaceholderId),
                token_type: z.optional(z.string())
            })))
        }))
    }))
});

/**
 * Contributor
 *
 * Contributor
 */
export const zContributor = z.object({
    login: z.optional(z.string()),
    id: z.optional(z.int()),
    node_id: z.optional(z.string()),
    avatar_url: z.optional(z.url()),
    gravatar_id: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    url: z.optional(z.url()),
    html_url: z.optional(z.url()),
    followers_url: z.optional(z.url()),
    following_url: z.optional(z.string()),
    gists_url: z.optional(z.string()),
    starred_url: z.optional(z.string()),
    subscriptions_url: z.optional(z.url()),
    organizations_url: z.optional(z.url()),
    repos_url: z.optional(z.url()),
    events_url: z.optional(z.string()),
    received_events_url: z.optional(z.url()),
    type: z.string(),
    site_admin: z.optional(z.boolean()),
    contributions: z.int(),
    email: z.optional(z.string()),
    name: z.optional(z.string()),
    user_view_type: z.optional(z.string())
});

/**
 * A Dependabot alert.
 */
export const zDependabotAlert = z.object({
    number: zAlertNumber,
    state: z.enum([
        'auto_dismissed',
        'dismissed',
        'fixed',
        'open'
    ]),
    dependency: z.object({
        package: z.optional(zDependabotAlertPackage),
        manifest_path: z.optional(z.string().readonly()),
        scope: z.optional(z.enum([
            'development',
            'runtime'
        ])),
        relationship: z.optional(z.enum([
            'unknown',
            'direct',
            'transitive'
        ]))
    }).readonly(),
    security_advisory: zDependabotAlertSecurityAdvisory,
    security_vulnerability: zDependabotAlertSecurityVulnerability,
    url: zAlertUrl,
    html_url: zAlertHtmlUrl,
    created_at: zAlertCreatedAt,
    updated_at: zAlertUpdatedAt,
    dismissed_at: zAlertDismissedAt,
    dismissed_by: zNullableSimpleUser,
    dismissed_reason: z.enum([
        'fix_started',
        'inaccurate',
        'no_bandwidth',
        'not_used',
        'tolerable_risk'
    ]),
    dismissed_comment: z.union([
        z.string().max(280),
        z.null()
    ]),
    fixed_at: zAlertFixedAt,
    auto_dismissed_at: z.optional(zAlertAutoDismissedAt)
});

/**
 * Dependabot Secret
 *
 * Set secrets for Dependabot.
 */
export const zDependabotSecret = z.object({
    name: z.string(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime()
});

/**
 * Dependency Graph Diff
 *
 * A diff of the dependencies between two commits.
 */
export const zDependencyGraphDiff = z.array(z.object({
    change_type: z.enum([
        'added',
        'removed'
    ]),
    manifest: z.string(),
    ecosystem: z.string(),
    name: z.string(),
    version: z.string(),
    package_url: z.union([
        z.string(),
        z.null()
    ]),
    license: z.union([
        z.string(),
        z.null()
    ]),
    source_repository_url: z.union([
        z.string(),
        z.null()
    ]),
    vulnerabilities: z.array(z.object({
        severity: z.string(),
        advisory_ghsa_id: z.string(),
        advisory_summary: z.string(),
        advisory_url: z.string()
    })),
    scope: z.enum([
        'unknown',
        'runtime',
        'development'
    ])
}));

/**
 * Dependency Graph SPDX SBOM
 *
 * A schema for the SPDX JSON format returned by the Dependency Graph.
 */
export const zDependencyGraphSpdxSbom = z.object({
    sbom: z.object({
        SPDXID: z.string(),
        spdxVersion: z.string(),
        comment: z.optional(z.string()),
        creationInfo: z.object({
            created: z.string(),
            creators: z.array(z.string())
        }),
        name: z.string(),
        dataLicense: z.string(),
        documentNamespace: z.string(),
        packages: z.array(z.object({
            SPDXID: z.optional(z.string()),
            name: z.optional(z.string()),
            versionInfo: z.optional(z.string()),
            downloadLocation: z.optional(z.string()),
            filesAnalyzed: z.optional(z.boolean()),
            licenseConcluded: z.optional(z.string()),
            licenseDeclared: z.optional(z.string()),
            supplier: z.optional(z.string()),
            copyrightText: z.optional(z.string()),
            externalRefs: z.optional(z.array(z.object({
                referenceCategory: z.string(),
                referenceLocator: z.string(),
                referenceType: z.string()
            })))
        })),
        relationships: z.optional(z.array(z.object({
            relationshipType: z.optional(z.string()),
            spdxElementId: z.optional(z.string()),
            relatedSpdxElement: z.optional(z.string())
        })))
    })
});

/**
 * metadata
 *
 * User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
 */
export const zMetadata = z.record(z.string(), z.union([
    z.string(),
    z.number(),
    z.boolean(),
    z.null()
]));

export const zDependency = z.object({
    package_url: z.optional(z.string().regex(/^pkg/)),
    metadata: z.optional(zMetadata),
    relationship: z.optional(z.enum([
        'direct',
        'indirect'
    ])),
    scope: z.optional(z.enum([
        'runtime',
        'development'
    ])),
    dependencies: z.optional(z.array(z.string()))
});

export const zManifest = z.object({
    name: z.string(),
    file: z.optional(z.object({
        source_location: z.optional(z.string())
    })),
    metadata: z.optional(zMetadata),
    resolved: z.optional(z.record(z.string(), zDependency))
});

/**
 * snapshot
 *
 * Create a new snapshot of a repository's dependencies.
 */
export const zSnapshot = z.object({
    version: z.int(),
    job: z.object({
        id: z.string(),
        correlator: z.string(),
        html_url: z.optional(z.string())
    }),
    sha: z.string().length(40),
    ref: z.string().regex(/^refs\//),
    detector: z.object({
        name: z.string(),
        version: z.string(),
        url: z.string()
    }),
    metadata: z.optional(zMetadata),
    manifests: z.optional(z.record(z.string(), zManifest)),
    scanned: z.iso.datetime()
});

/**
 * Deployment Status
 *
 * The status of a deployment.
 */
export const zDeploymentStatus = z.object({
    url: z.url(),
    id: z.coerce.bigint(),
    node_id: z.string(),
    state: z.enum([
        'error',
        'failure',
        'inactive',
        'pending',
        'success',
        'queued',
        'in_progress'
    ]),
    creator: zNullableSimpleUser,
    description: z.string().max(140).default(''),
    environment: z.optional(z.string()).default(''),
    target_url: z.url().default(''),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    deployment_url: z.url(),
    repository_url: z.url(),
    environment_url: z.optional(z.url()).default(''),
    log_url: z.optional(z.url()).default(''),
    performed_via_github_app: z.optional(zNullableIntegration)
});

/**
 * The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days).
 */
export const zWaitTimer = z.int();

/**
 * The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.
 */
export const zDeploymentBranchPolicySettings = z.union([
    z.object({
        protected_branches: z.boolean(),
        custom_branch_policies: z.boolean()
    }),
    z.null()
]);

/**
 * Environment
 *
 * Details of a deployment environment
 */
export const zEnvironment = z.object({
    id: z.coerce.bigint(),
    node_id: z.string(),
    name: z.string(),
    url: z.string(),
    html_url: z.string(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    protection_rules: z.optional(z.array(z.union([
        z.object({
            id: z.int(),
            node_id: z.string(),
            type: z.string(),
            wait_timer: z.optional(zWaitTimer)
        }),
        z.object({
            id: z.int(),
            node_id: z.string(),
            prevent_self_review: z.optional(z.boolean()),
            type: z.string(),
            reviewers: z.optional(z.array(z.object({
                type: z.optional(zDeploymentReviewerType),
                reviewer: z.optional(z.union([
                    zSimpleUser,
                    zTeam
                ]))
            })))
        }),
        z.object({
            id: z.int(),
            node_id: z.string(),
            type: z.string()
        })
    ]))),
    deployment_branch_policy: z.optional(zDeploymentBranchPolicySettings)
});

/**
 * Whether or not a user who created the job is prevented from approving their own job.
 */
export const zPreventSelfReview = z.boolean();

/**
 * Deployment branch policy
 *
 * Details of a deployment branch or tag policy.
 */
export const zDeploymentBranchPolicy = z.object({
    id: z.optional(z.int()),
    node_id: z.optional(z.string()),
    name: z.optional(z.string()),
    type: z.optional(z.enum([
        'branch',
        'tag'
    ]))
});

/**
 * Deployment branch and tag policy name pattern
 */
export const zDeploymentBranchPolicyNamePatternWithType = z.object({
    name: z.string(),
    type: z.optional(z.enum([
        'branch',
        'tag'
    ]))
});

/**
 * Deployment branch policy name pattern
 */
export const zDeploymentBranchPolicyNamePattern = z.object({
    name: z.string()
});

/**
 * Custom deployment protection rule app
 *
 * A GitHub App that is providing a custom deployment protection rule.
 */
export const zCustomDeploymentRuleApp = z.object({
    id: z.int(),
    slug: z.string(),
    integration_url: z.string(),
    node_id: z.string()
});

/**
 * Deployment protection rule
 *
 * Deployment protection rule
 */
export const zDeploymentProtectionRule = z.object({
    id: z.int(),
    node_id: z.string(),
    enabled: z.boolean(),
    app: zCustomDeploymentRuleApp
});

/**
 * Short Blob
 *
 * Short Blob
 */
export const zShortBlob = z.object({
    url: z.string(),
    sha: z.string()
});

/**
 * Blob
 *
 * Blob
 */
export const zBlob = z.object({
    content: z.string(),
    encoding: z.string(),
    url: z.url(),
    sha: z.string(),
    size: z.union([
        z.int(),
        z.null()
    ]),
    node_id: z.string(),
    highlighted_content: z.optional(z.string())
});

/**
 * Git Commit
 *
 * Low-level Git commit operations within a repository
 */
export const zGitCommit = z.object({
    sha: z.string(),
    node_id: z.string(),
    url: z.url(),
    author: z.object({
        date: z.iso.datetime(),
        email: z.string(),
        name: z.string()
    }),
    committer: z.object({
        date: z.iso.datetime(),
        email: z.string(),
        name: z.string()
    }),
    message: z.string(),
    tree: z.object({
        sha: z.string(),
        url: z.url()
    }),
    parents: z.array(z.object({
        sha: z.string(),
        url: z.url(),
        html_url: z.url()
    })),
    verification: z.object({
        verified: z.boolean(),
        reason: z.string(),
        signature: z.union([
            z.string(),
            z.null()
        ]),
        payload: z.union([
            z.string(),
            z.null()
        ]),
        verified_at: z.union([
            z.string(),
            z.null()
        ])
    }),
    html_url: z.url()
});

/**
 * Git Reference
 *
 * Git references within a repository
 */
export const zGitRef = z.object({
    ref: z.string(),
    node_id: z.string(),
    url: z.url(),
    object: z.object({
        type: z.string(),
        sha: z.string().length(40),
        url: z.url()
    })
});

/**
 * Git Tag
 *
 * Metadata for a Git tag
 */
export const zGitTag = z.object({
    node_id: z.string(),
    tag: z.string(),
    sha: z.string(),
    url: z.url(),
    message: z.string(),
    tagger: z.object({
        date: z.string(),
        email: z.string(),
        name: z.string()
    }),
    object: z.object({
        sha: z.string(),
        type: z.string(),
        url: z.url()
    }),
    verification: z.optional(zVerification)
});

/**
 * Git Tree
 *
 * The hierarchy between files in a Git repository.
 */
export const zGitTree = z.object({
    sha: z.string(),
    url: z.optional(z.url()),
    truncated: z.boolean(),
    tree: z.array(z.object({
        path: z.string(),
        mode: z.string(),
        type: z.string(),
        sha: z.string(),
        size: z.optional(z.int()),
        url: z.optional(z.string())
    }))
});

/**
 * Hook Response
 */
export const zHookResponse = z.object({
    code: z.union([
        z.int(),
        z.null()
    ]),
    status: z.union([
        z.string(),
        z.null()
    ]),
    message: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Webhook
 *
 * Webhooks for repositories.
 */
export const zHook = z.object({
    type: z.string(),
    id: z.int(),
    name: z.string(),
    active: z.boolean(),
    events: z.array(z.string()),
    config: zWebhookConfig,
    updated_at: z.iso.datetime(),
    created_at: z.iso.datetime(),
    url: z.url(),
    test_url: z.url(),
    ping_url: z.url(),
    deliveries_url: z.optional(z.url()),
    last_response: zHookResponse
});

/**
 * Check immutable releases
 *
 * Check immutable releases
 */
export const zCheckImmutableReleases = z.object({
    enabled: z.boolean(),
    enforced_by_owner: z.boolean()
});

/**
 * Import
 *
 * A repository import from an external source.
 */
export const zImport = z.object({
    vcs: z.union([
        z.string(),
        z.null()
    ]),
    use_lfs: z.optional(z.boolean()),
    vcs_url: z.string(),
    svc_root: z.optional(z.string()),
    tfvc_project: z.optional(z.string()),
    status: z.enum([
        'auth',
        'error',
        'none',
        'detecting',
        'choose',
        'auth_failed',
        'importing',
        'mapping',
        'waiting_to_push',
        'pushing',
        'complete',
        'setup',
        'unknown',
        'detection_found_multiple',
        'detection_found_nothing',
        'detection_needs_auth'
    ]),
    status_text: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    failed_step: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    error_message: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    import_percent: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    commit_count: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    push_percent: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    has_large_files: z.optional(z.boolean()),
    large_files_size: z.optional(z.int()),
    large_files_count: z.optional(z.int()),
    project_choices: z.optional(z.array(z.object({
        vcs: z.optional(z.string()),
        tfvc_project: z.optional(z.string()),
        human_name: z.optional(z.string())
    }))),
    message: z.optional(z.string()),
    authors_count: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    url: z.url(),
    html_url: z.url(),
    authors_url: z.url(),
    repository_url: z.url(),
    svn_root: z.optional(z.string())
});

/**
 * Porter Author
 *
 * Porter Author
 */
export const zPorterAuthor = z.object({
    id: z.int(),
    remote_id: z.string(),
    remote_name: z.string(),
    email: z.string(),
    name: z.string(),
    url: z.url(),
    import_url: z.url()
});

/**
 * Porter Large File
 *
 * Porter Large File
 */
export const zPorterLargeFile = z.object({
    ref_name: z.string(),
    path: z.string(),
    oid: z.string(),
    size: z.int()
});

/**
 * Issue
 *
 * Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
 */
export const zNullableIssue = z.union([
    z.object({
        id: z.coerce.bigint(),
        node_id: z.string(),
        url: z.url(),
        repository_url: z.url(),
        labels_url: z.string(),
        comments_url: z.url(),
        events_url: z.url(),
        html_url: z.url(),
        number: z.int(),
        state: z.string(),
        state_reason: z.optional(z.enum([
            'completed',
            'reopened',
            'not_planned',
            'duplicate'
        ])),
        title: z.string(),
        body: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        user: zNullableSimpleUser,
        labels: z.array(z.union([
            z.string(),
            z.object({
                id: z.optional(z.coerce.bigint()),
                node_id: z.optional(z.string()),
                url: z.optional(z.url()),
                name: z.optional(z.string()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                color: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                default: z.optional(z.boolean())
            })
        ])),
        assignee: zNullableSimpleUser,
        assignees: z.optional(z.union([
            z.array(zSimpleUser),
            z.null()
        ])),
        milestone: zNullableMilestone,
        locked: z.boolean(),
        active_lock_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        comments: z.int(),
        pull_request: z.optional(z.object({
            merged_at: z.optional(z.union([
                z.iso.datetime(),
                z.null()
            ])),
            diff_url: z.union([
                z.url(),
                z.null()
            ]),
            html_url: z.union([
                z.url(),
                z.null()
            ]),
            patch_url: z.union([
                z.url(),
                z.null()
            ]),
            url: z.union([
                z.url(),
                z.null()
            ])
        })),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        created_at: z.iso.datetime(),
        updated_at: z.iso.datetime(),
        draft: z.optional(z.boolean()),
        closed_by: z.optional(zNullableSimpleUser),
        body_html: z.optional(z.string()),
        body_text: z.optional(z.string()),
        timeline_url: z.optional(z.url()),
        type: z.optional(zIssueType),
        repository: z.optional(zRepository),
        performed_via_github_app: z.optional(zNullableIntegration),
        author_association: z.optional(zAuthorAssociation),
        reactions: z.optional(zReactionRollup),
        sub_issues_summary: z.optional(zSubIssuesSummary),
        parent_issue_url: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
        issue_field_values: z.optional(z.array(zIssueFieldValue))
    }),
    z.null()
]);

/**
 * Issue Event Label
 *
 * Issue Event Label
 */
export const zIssueEventLabel = z.object({
    name: z.union([
        z.string(),
        z.null()
    ]),
    color: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Issue Event Dismissed Review
 */
export const zIssueEventDismissedReview = z.object({
    state: z.string(),
    review_id: z.int(),
    dismissal_message: z.union([
        z.string(),
        z.null()
    ]),
    dismissal_commit_id: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

/**
 * Issue Event Milestone
 *
 * Issue Event Milestone
 */
export const zIssueEventMilestone = z.object({
    title: z.string()
});

/**
 * Issue Event Project Card
 *
 * Issue Event Project Card
 */
export const zIssueEventProjectCard = z.object({
    url: z.url(),
    id: z.int(),
    project_url: z.url(),
    project_id: z.int(),
    column_name: z.string(),
    previous_column_name: z.optional(z.string())
});

/**
 * Issue Event Rename
 *
 * Issue Event Rename
 */
export const zIssueEventRename = z.object({
    from: z.string(),
    to: z.string()
});

/**
 * Issue Event
 *
 * Issue Event
 */
export const zIssueEvent = z.object({
    id: z.coerce.bigint(),
    node_id: z.string(),
    url: z.url(),
    actor: zNullableSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.iso.datetime(),
    issue: z.optional(zNullableIssue),
    label: z.optional(zIssueEventLabel),
    assignee: z.optional(zNullableSimpleUser),
    assigner: z.optional(zNullableSimpleUser),
    review_requester: z.optional(zNullableSimpleUser),
    requested_reviewer: z.optional(zNullableSimpleUser),
    requested_team: z.optional(zTeam),
    dismissed_review: z.optional(zIssueEventDismissedReview),
    milestone: z.optional(zIssueEventMilestone),
    project_card: z.optional(zIssueEventProjectCard),
    rename: z.optional(zIssueEventRename),
    author_association: z.optional(zAuthorAssociation),
    lock_reason: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    performed_via_github_app: z.optional(zNullableIntegration)
});

/**
 * Labeled Issue Event
 *
 * Labeled Issue Event
 */
export const zLabeledIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zNullableIntegration,
    label: z.object({
        name: z.string(),
        color: z.string()
    })
});

/**
 * Unlabeled Issue Event
 *
 * Unlabeled Issue Event
 */
export const zUnlabeledIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zNullableIntegration,
    label: z.object({
        name: z.string(),
        color: z.string()
    })
});

/**
 * Assigned Issue Event
 *
 * Assigned Issue Event
 */
export const zAssignedIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zIntegration,
    assignee: zSimpleUser,
    assigner: zSimpleUser
});

/**
 * Unassigned Issue Event
 *
 * Unassigned Issue Event
 */
export const zUnassignedIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zNullableIntegration,
    assignee: zSimpleUser,
    assigner: zSimpleUser
});

/**
 * Milestoned Issue Event
 *
 * Milestoned Issue Event
 */
export const zMilestonedIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zNullableIntegration,
    milestone: z.object({
        title: z.string()
    })
});

/**
 * Demilestoned Issue Event
 *
 * Demilestoned Issue Event
 */
export const zDemilestonedIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zNullableIntegration,
    milestone: z.object({
        title: z.string()
    })
});

/**
 * Renamed Issue Event
 *
 * Renamed Issue Event
 */
export const zRenamedIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zNullableIntegration,
    rename: z.object({
        from: z.string(),
        to: z.string()
    })
});

/**
 * Review Requested Issue Event
 *
 * Review Requested Issue Event
 */
export const zReviewRequestedIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zNullableIntegration,
    review_requester: zSimpleUser,
    requested_team: z.optional(zTeam),
    requested_reviewer: z.optional(zSimpleUser)
});

/**
 * Review Request Removed Issue Event
 *
 * Review Request Removed Issue Event
 */
export const zReviewRequestRemovedIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zNullableIntegration,
    review_requester: zSimpleUser,
    requested_team: z.optional(zTeam),
    requested_reviewer: z.optional(zSimpleUser)
});

/**
 * Review Dismissed Issue Event
 *
 * Review Dismissed Issue Event
 */
export const zReviewDismissedIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zNullableIntegration,
    dismissed_review: z.object({
        state: z.string(),
        review_id: z.int(),
        dismissal_message: z.union([
            z.string(),
            z.null()
        ]),
        dismissal_commit_id: z.optional(z.string())
    })
});

/**
 * Locked Issue Event
 *
 * Locked Issue Event
 */
export const zLockedIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zNullableIntegration,
    lock_reason: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Added to Project Issue Event
 *
 * Added to Project Issue Event
 */
export const zAddedToProjectIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zNullableIntegration,
    project_card: z.optional(z.object({
        id: z.int(),
        url: z.url(),
        project_id: z.int(),
        project_url: z.url(),
        column_name: z.string(),
        previous_column_name: z.optional(z.string())
    }))
});

/**
 * Moved Column in Project Issue Event
 *
 * Moved Column in Project Issue Event
 */
export const zMovedColumnInProjectIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zNullableIntegration,
    project_card: z.optional(z.object({
        id: z.int(),
        url: z.url(),
        project_id: z.int(),
        project_url: z.url(),
        column_name: z.string(),
        previous_column_name: z.optional(z.string())
    }))
});

/**
 * Removed from Project Issue Event
 *
 * Removed from Project Issue Event
 */
export const zRemovedFromProjectIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zNullableIntegration,
    project_card: z.optional(z.object({
        id: z.int(),
        url: z.url(),
        project_id: z.int(),
        project_url: z.url(),
        column_name: z.string(),
        previous_column_name: z.optional(z.string())
    }))
});

/**
 * Converted Note to Issue Issue Event
 *
 * Converted Note to Issue Issue Event
 */
export const zConvertedNoteToIssueIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zIntegration,
    project_card: z.optional(z.object({
        id: z.int(),
        url: z.url(),
        project_id: z.int(),
        project_url: z.url(),
        column_name: z.string(),
        previous_column_name: z.optional(z.string())
    }))
});

/**
 * Issue Event for Issue
 *
 * Issue Event for Issue
 */
export const zIssueEventForIssue = z.union([
    zLabeledIssueEvent,
    zUnlabeledIssueEvent,
    zAssignedIssueEvent,
    zUnassignedIssueEvent,
    zMilestonedIssueEvent,
    zDemilestonedIssueEvent,
    zRenamedIssueEvent,
    zReviewRequestedIssueEvent,
    zReviewRequestRemovedIssueEvent,
    zReviewDismissedIssueEvent,
    zLockedIssueEvent,
    zAddedToProjectIssueEvent,
    zMovedColumnInProjectIssueEvent,
    zRemovedFromProjectIssueEvent,
    zConvertedNoteToIssueIssueEvent
]);

/**
 * Label
 *
 * Color-coded labels help you categorize and filter your issues (just like labels in Gmail).
 */
export const zLabel = z.object({
    id: z.coerce.bigint(),
    node_id: z.string(),
    url: z.url(),
    name: z.string(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    color: z.string(),
    default: z.boolean()
});

/**
 * Timeline Comment Event
 *
 * Timeline Comment Event
 */
export const zTimelineCommentEvent = z.object({
    event: z.string(),
    actor: zSimpleUser,
    id: z.int(),
    node_id: z.string(),
    url: z.url(),
    body: z.optional(z.string()),
    body_text: z.optional(z.string()),
    body_html: z.optional(z.string()),
    html_url: z.url(),
    user: zSimpleUser,
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    issue_url: z.url(),
    author_association: zAuthorAssociation,
    performed_via_github_app: z.optional(zNullableIntegration),
    reactions: z.optional(zReactionRollup)
});

/**
 * Timeline Cross Referenced Event
 *
 * Timeline Cross Referenced Event
 */
export const zTimelineCrossReferencedEvent = z.object({
    event: z.string(),
    actor: z.optional(zSimpleUser),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    source: z.object({
        type: z.optional(z.string()),
        issue: z.optional(zIssue)
    })
});

/**
 * Timeline Committed Event
 *
 * Timeline Committed Event
 */
export const zTimelineCommittedEvent = z.object({
    event: z.optional(z.string()),
    sha: z.string(),
    node_id: z.string(),
    url: z.url(),
    author: z.object({
        date: z.iso.datetime(),
        email: z.string(),
        name: z.string()
    }),
    committer: z.object({
        date: z.iso.datetime(),
        email: z.string(),
        name: z.string()
    }),
    message: z.string(),
    tree: z.object({
        sha: z.string(),
        url: z.url()
    }),
    parents: z.array(z.object({
        sha: z.string(),
        url: z.url(),
        html_url: z.url()
    })),
    verification: z.object({
        verified: z.boolean(),
        reason: z.string(),
        signature: z.union([
            z.string(),
            z.null()
        ]),
        payload: z.union([
            z.string(),
            z.null()
        ]),
        verified_at: z.union([
            z.string(),
            z.null()
        ])
    }),
    html_url: z.url()
});

/**
 * Timeline Reviewed Event
 *
 * Timeline Reviewed Event
 */
export const zTimelineReviewedEvent = z.object({
    event: z.string(),
    id: z.int(),
    node_id: z.string(),
    user: zSimpleUser,
    body: z.union([
        z.string(),
        z.null()
    ]),
    state: z.string(),
    html_url: z.url(),
    pull_request_url: z.url(),
    _links: z.object({
        html: z.object({
            href: z.string()
        }),
        pull_request: z.object({
            href: z.string()
        })
    }),
    submitted_at: z.optional(z.iso.datetime()),
    updated_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    commit_id: z.string(),
    body_html: z.optional(z.string()),
    body_text: z.optional(z.string()),
    author_association: zAuthorAssociation
});

/**
 * Pull Request Review Comment
 *
 * Pull Request Review Comments are comments on a portion of the Pull Request's diff.
 */
export const zPullRequestReviewComment = z.object({
    url: z.string(),
    pull_request_review_id: z.union([
        z.coerce.bigint(),
        z.null()
    ]),
    id: z.coerce.bigint(),
    node_id: z.string(),
    diff_hunk: z.string(),
    path: z.string(),
    position: z.optional(z.int()),
    original_position: z.optional(z.int()),
    commit_id: z.string(),
    original_commit_id: z.string(),
    in_reply_to_id: z.optional(z.int()),
    user: zSimpleUser,
    body: z.string(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    html_url: z.url(),
    pull_request_url: z.url(),
    author_association: zAuthorAssociation,
    _links: z.object({
        self: z.object({
            href: z.url()
        }),
        html: z.object({
            href: z.url()
        }),
        pull_request: z.object({
            href: z.url()
        })
    }),
    start_line: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    original_start_line: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    start_side: z.optional(z.enum([
        'LEFT',
        'RIGHT'
    ])),
    line: z.optional(z.int()),
    original_line: z.optional(z.int()),
    side: z.optional(z.enum([
        'LEFT',
        'RIGHT'
    ])),
    subject_type: z.optional(z.enum([
        'line',
        'file'
    ])),
    reactions: z.optional(zReactionRollup),
    body_html: z.optional(z.string()),
    body_text: z.optional(z.string())
});

/**
 * Timeline Line Commented Event
 *
 * Timeline Line Commented Event
 */
export const zTimelineLineCommentedEvent = z.object({
    event: z.optional(z.string()),
    node_id: z.optional(z.string()),
    comments: z.optional(z.array(zPullRequestReviewComment))
});

/**
 * Timeline Commit Commented Event
 *
 * Timeline Commit Commented Event
 */
export const zTimelineCommitCommentedEvent = z.object({
    event: z.optional(z.string()),
    node_id: z.optional(z.string()),
    commit_id: z.optional(z.string()),
    comments: z.optional(z.array(zCommitComment))
});

/**
 * Timeline Assigned Issue Event
 *
 * Timeline Assigned Issue Event
 */
export const zTimelineAssignedIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zNullableIntegration,
    assignee: zSimpleUser
});

/**
 * Timeline Unassigned Issue Event
 *
 * Timeline Unassigned Issue Event
 */
export const zTimelineUnassignedIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zNullableIntegration,
    assignee: zSimpleUser
});

/**
 * State Change Issue Event
 *
 * State Change Issue Event
 */
export const zStateChangeIssueEvent = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.string(),
    actor: zSimpleUser,
    event: z.string(),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    commit_url: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.string(),
    performed_via_github_app: zNullableIntegration,
    state_reason: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

/**
 * Timeline Event
 *
 * Timeline Event
 */
export const zTimelineIssueEvents = z.union([
    zLabeledIssueEvent,
    zUnlabeledIssueEvent,
    zMilestonedIssueEvent,
    zDemilestonedIssueEvent,
    zRenamedIssueEvent,
    zReviewRequestedIssueEvent,
    zReviewRequestRemovedIssueEvent,
    zReviewDismissedIssueEvent,
    zLockedIssueEvent,
    zAddedToProjectIssueEvent,
    zMovedColumnInProjectIssueEvent,
    zRemovedFromProjectIssueEvent,
    zConvertedNoteToIssueIssueEvent,
    zTimelineCommentEvent,
    zTimelineCrossReferencedEvent,
    zTimelineCommittedEvent,
    zTimelineReviewedEvent,
    zTimelineLineCommentedEvent,
    zTimelineCommitCommentedEvent,
    zTimelineAssignedIssueEvent,
    zTimelineUnassignedIssueEvent,
    zStateChangeIssueEvent
]);

/**
 * Deploy Key
 *
 * An SSH key granting access to a single repository.
 */
export const zDeployKey = z.object({
    id: z.int(),
    key: z.string(),
    url: z.string(),
    title: z.string(),
    verified: z.boolean(),
    created_at: z.string(),
    read_only: z.boolean(),
    added_by: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    last_used: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    enabled: z.optional(z.boolean())
});

/**
 * Language
 *
 * Language
 */
export const zLanguage = z.record(z.string(), z.int());

/**
 * License Content
 *
 * License Content
 */
export const zLicenseContent = z.object({
    name: z.string(),
    path: z.string(),
    sha: z.string(),
    size: z.int(),
    url: z.url(),
    html_url: z.union([
        z.url(),
        z.null()
    ]),
    git_url: z.union([
        z.url(),
        z.null()
    ]),
    download_url: z.union([
        z.url(),
        z.null()
    ]),
    type: z.string(),
    content: z.string(),
    encoding: z.string(),
    _links: z.object({
        git: z.union([
            z.url(),
            z.null()
        ]),
        html: z.union([
            z.url(),
            z.null()
        ]),
        self: z.url()
    }),
    license: zNullableLicenseSimple
});

/**
 * Merged upstream
 *
 * Results of a successful merge upstream request
 */
export const zMergedUpstream = z.object({
    message: z.optional(z.string()),
    merge_type: z.optional(z.enum([
        'merge',
        'fast-forward',
        'none'
    ])),
    base_branch: z.optional(z.string())
});

/**
 * Milestone
 *
 * A collection of related issues and pull requests.
 */
export const zMilestone = z.object({
    url: z.url(),
    html_url: z.url(),
    labels_url: z.url(),
    id: z.int(),
    node_id: z.string(),
    number: z.int(),
    state: z.enum([
        'open',
        'closed'
    ]),
    title: z.string(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    creator: zNullableSimpleUser,
    open_issues: z.int(),
    closed_issues: z.int(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    closed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    due_on: z.union([
        z.iso.datetime(),
        z.null()
    ])
});

/**
 * Pages Source Hash
 */
export const zPagesSourceHash = z.object({
    branch: z.string(),
    path: z.string()
});

/**
 * Pages Https Certificate
 */
export const zPagesHttpsCertificate = z.object({
    state: z.enum([
        'new',
        'authorization_created',
        'authorization_pending',
        'authorized',
        'authorization_revoked',
        'issued',
        'uploaded',
        'approved',
        'errored',
        'bad_authz',
        'destroy_pending',
        'dns_changed'
    ]),
    description: z.string(),
    domains: z.array(z.string()),
    expires_at: z.optional(z.iso.date())
});

/**
 * GitHub Pages
 *
 * The configuration for GitHub Pages for a repository.
 */
export const zPage = z.object({
    url: z.url(),
    status: z.enum([
        'built',
        'building',
        'errored'
    ]),
    cname: z.union([
        z.string(),
        z.null()
    ]),
    protected_domain_state: z.optional(z.enum([
        'pending',
        'verified',
        'unverified'
    ])),
    pending_domain_unverified_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    custom_404: z.boolean().default(false),
    html_url: z.optional(z.url()),
    build_type: z.optional(z.enum([
        'legacy',
        'workflow'
    ])),
    source: z.optional(zPagesSourceHash),
    public: z.boolean(),
    https_certificate: z.optional(zPagesHttpsCertificate),
    https_enforced: z.optional(z.boolean())
});

/**
 * Page Build
 *
 * Page Build
 */
export const zPageBuild = z.object({
    url: z.url(),
    status: z.string(),
    error: z.object({
        message: z.union([
            z.string(),
            z.null()
        ])
    }),
    pusher: zNullableSimpleUser,
    commit: z.string(),
    duration: z.int(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime()
});

/**
 * Page Build Status
 *
 * Page Build Status
 */
export const zPageBuildStatus = z.object({
    url: z.url(),
    status: z.string()
});

/**
 * GitHub Pages
 *
 * The GitHub Pages deployment status.
 */
export const zPageDeployment = z.object({
    id: z.union([
        z.int(),
        z.string()
    ]),
    status_url: z.url(),
    page_url: z.url(),
    preview_url: z.optional(z.url())
});

/**
 * GitHub Pages deployment status
 */
export const zPagesDeploymentStatus = z.object({
    status: z.optional(z.enum([
        'deployment_in_progress',
        'syncing_files',
        'finished_file_sync',
        'updating_pages',
        'purging_cdn',
        'deployment_cancelled',
        'deployment_failed',
        'deployment_content_failed',
        'deployment_attempt_error',
        'deployment_lost',
        'succeed'
    ]))
});

/**
 * Pages Health Check Status
 *
 * Pages Health Check Status
 */
export const zPagesHealthCheck = z.object({
    domain: z.optional(z.object({
        host: z.optional(z.string()),
        uri: z.optional(z.string()),
        nameservers: z.optional(z.string()),
        dns_resolves: z.optional(z.boolean()),
        is_proxied: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        is_cloudflare_ip: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        is_fastly_ip: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        is_old_ip_address: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        is_a_record: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        has_cname_record: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        has_mx_records_present: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        is_valid_domain: z.optional(z.boolean()),
        is_apex_domain: z.optional(z.boolean()),
        should_be_a_record: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        is_cname_to_github_user_domain: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        is_cname_to_pages_dot_github_dot_com: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        is_cname_to_fastly: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        is_pointed_to_github_pages_ip: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        is_non_github_pages_ip_present: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        is_pages_domain: z.optional(z.boolean()),
        is_served_by_pages: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        is_valid: z.optional(z.boolean()),
        reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        responds_to_https: z.optional(z.boolean()),
        enforces_https: z.optional(z.boolean()),
        https_error: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        is_https_eligible: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        caa_error: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    })),
    alt_domain: z.optional(z.union([
        z.object({
            host: z.optional(z.string()),
            uri: z.optional(z.string()),
            nameservers: z.optional(z.string()),
            dns_resolves: z.optional(z.boolean()),
            is_proxied: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            is_cloudflare_ip: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            is_fastly_ip: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            is_old_ip_address: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            is_a_record: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            has_cname_record: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            has_mx_records_present: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            is_valid_domain: z.optional(z.boolean()),
            is_apex_domain: z.optional(z.boolean()),
            should_be_a_record: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            is_cname_to_github_user_domain: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            is_cname_to_pages_dot_github_dot_com: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            is_cname_to_fastly: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            is_pointed_to_github_pages_ip: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            is_non_github_pages_ip_present: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            is_pages_domain: z.optional(z.boolean()),
            is_served_by_pages: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            is_valid: z.optional(z.boolean()),
            reason: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            responds_to_https: z.optional(z.boolean()),
            enforces_https: z.optional(z.boolean()),
            https_error: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            is_https_eligible: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            caa_error: z.optional(z.union([
                z.string(),
                z.null()
            ]))
        }),
        z.null()
    ]))
});

/**
 * Pull Request
 *
 * Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.
 */
export const zPullRequest = z.object({
    url: z.url(),
    id: z.coerce.bigint(),
    node_id: z.string(),
    html_url: z.url(),
    diff_url: z.url(),
    patch_url: z.url(),
    issue_url: z.url(),
    commits_url: z.url(),
    review_comments_url: z.url(),
    review_comment_url: z.string(),
    comments_url: z.url(),
    statuses_url: z.url(),
    number: z.int(),
    state: z.enum([
        'open',
        'closed'
    ]),
    locked: z.boolean(),
    title: z.string(),
    user: zSimpleUser,
    body: z.union([
        z.string(),
        z.null()
    ]),
    labels: z.array(z.object({
        id: z.coerce.bigint(),
        node_id: z.string(),
        url: z.string(),
        name: z.string(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        color: z.string(),
        default: z.boolean()
    })),
    milestone: zNullableMilestone,
    active_lock_reason: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    closed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    merged_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    merge_commit_sha: z.union([
        z.string(),
        z.null()
    ]),
    assignee: zNullableSimpleUser,
    assignees: z.optional(z.union([
        z.array(zSimpleUser),
        z.null()
    ])),
    requested_reviewers: z.optional(z.union([
        z.array(zSimpleUser),
        z.null()
    ])),
    requested_teams: z.optional(z.union([
        z.array(zTeamSimple),
        z.null()
    ])),
    head: z.object({
        label: z.string(),
        ref: z.string(),
        repo: zRepository,
        sha: z.string(),
        user: zSimpleUser
    }),
    base: z.object({
        label: z.string(),
        ref: z.string(),
        repo: zRepository,
        sha: z.string(),
        user: zSimpleUser
    }),
    _links: z.object({
        comments: zLink,
        commits: zLink,
        statuses: zLink,
        html: zLink,
        issue: zLink,
        review_comments: zLink,
        review_comment: zLink,
        self: zLink
    }),
    author_association: zAuthorAssociation,
    auto_merge: zAutoMerge,
    draft: z.optional(z.boolean()),
    merged: z.boolean(),
    mergeable: z.union([
        z.boolean(),
        z.null()
    ]),
    rebaseable: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    mergeable_state: z.string(),
    merged_by: zNullableSimpleUser,
    comments: z.int(),
    review_comments: z.int(),
    maintainer_can_modify: z.boolean(),
    commits: z.int(),
    additions: z.int(),
    deletions: z.int(),
    changed_files: z.int()
});

/**
 * Pull Request Merge Result
 *
 * Pull Request Merge Result
 */
export const zPullRequestMergeResult = z.object({
    sha: z.string(),
    merged: z.boolean(),
    message: z.string()
});

/**
 * Pull Request Review Request
 *
 * Pull Request Review Request
 */
export const zPullRequestReviewRequest = z.object({
    users: z.array(zSimpleUser),
    teams: z.array(zTeam)
});

/**
 * Pull Request Review
 *
 * Pull Request Reviews are reviews on pull requests.
 */
export const zPullRequestReview = z.object({
    id: z.coerce.bigint(),
    node_id: z.string(),
    user: zNullableSimpleUser,
    body: z.string(),
    state: z.string(),
    html_url: z.url(),
    pull_request_url: z.url(),
    _links: z.object({
        html: z.object({
            href: z.string()
        }),
        pull_request: z.object({
            href: z.string()
        })
    }),
    submitted_at: z.optional(z.iso.datetime()),
    commit_id: z.union([
        z.string(),
        z.null()
    ]),
    body_html: z.optional(z.string()),
    body_text: z.optional(z.string()),
    author_association: zAuthorAssociation
});

/**
 * Legacy Review Comment
 *
 * Legacy Review Comment
 */
export const zReviewComment = z.object({
    url: z.url(),
    pull_request_review_id: z.union([
        z.coerce.bigint(),
        z.null()
    ]),
    id: z.coerce.bigint(),
    node_id: z.string(),
    diff_hunk: z.string(),
    path: z.string(),
    position: z.union([
        z.int(),
        z.null()
    ]),
    original_position: z.int(),
    commit_id: z.string(),
    original_commit_id: z.string(),
    in_reply_to_id: z.optional(z.int()),
    user: zNullableSimpleUser,
    body: z.string(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    html_url: z.url(),
    pull_request_url: z.url(),
    author_association: zAuthorAssociation,
    _links: z.object({
        self: zLink,
        html: zLink,
        pull_request: zLink
    }),
    body_text: z.optional(z.string()),
    body_html: z.optional(z.string()),
    reactions: z.optional(zReactionRollup),
    side: z.optional(z.enum([
        'LEFT',
        'RIGHT'
    ])),
    start_side: z.optional(z.enum([
        'LEFT',
        'RIGHT'
    ])),
    line: z.optional(z.int()),
    original_line: z.optional(z.int()),
    start_line: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    original_start_line: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    subject_type: z.optional(z.enum([
        'line',
        'file'
    ]))
});

/**
 * Release Asset
 *
 * Data related to a release.
 */
export const zReleaseAsset = z.object({
    url: z.url(),
    browser_download_url: z.url(),
    id: z.int(),
    node_id: z.string(),
    name: z.string(),
    label: z.union([
        z.string(),
        z.null()
    ]),
    state: z.enum([
        'uploaded',
        'open'
    ]),
    content_type: z.string(),
    size: z.int(),
    digest: z.union([
        z.string(),
        z.null()
    ]),
    download_count: z.int(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    uploader: zNullableSimpleUser
});

/**
 * Release
 *
 * A release.
 */
export const zRelease = z.object({
    url: z.url(),
    html_url: z.url(),
    assets_url: z.url(),
    upload_url: z.string(),
    tarball_url: z.union([
        z.url(),
        z.null()
    ]),
    zipball_url: z.union([
        z.url(),
        z.null()
    ]),
    id: z.int(),
    node_id: z.string(),
    tag_name: z.string(),
    target_commitish: z.string(),
    name: z.union([
        z.string(),
        z.null()
    ]),
    body: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    draft: z.boolean(),
    prerelease: z.boolean(),
    immutable: z.optional(z.boolean()),
    created_at: z.iso.datetime(),
    published_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    updated_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    author: zSimpleUser,
    assets: z.array(zReleaseAsset),
    body_html: z.optional(z.string()),
    body_text: z.optional(z.string()),
    mentions_count: z.optional(z.int()),
    discussion_url: z.optional(z.url()),
    reactions: z.optional(zReactionRollup)
});

/**
 * Generated Release Notes Content
 *
 * Generated name and body describing a release
 */
export const zReleaseNotesContent = z.object({
    name: z.string(),
    body: z.string()
});

/**
 * repository ruleset data for rule
 *
 * User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
 */
export const zRepositoryRuleRulesetInfo = z.object({
    ruleset_source_type: z.optional(z.enum([
        'Repository',
        'Organization'
    ])),
    ruleset_source: z.optional(z.string()),
    ruleset_id: z.optional(z.int())
});

/**
 * Repository Rule
 *
 * A repository rule with ruleset details.
 */
export const zRepositoryRuleDetailed = z.union([
    zRepositoryRuleCreation.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleUpdate.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleDeletion.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleRequiredLinearHistory.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleMergeQueue.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleRequiredDeployments.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleRequiredSignatures.and(zRepositoryRuleRulesetInfo),
    zRepositoryRulePullRequest.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleRequiredStatusChecks.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleNonFastForward.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleCommitMessagePattern.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleCommitAuthorEmailPattern.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleCommitterEmailPattern.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleBranchNamePattern.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleTagNamePattern.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleFilePathRestriction.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleMaxFilePathLength.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleFileExtensionRestriction.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleMaxFileSize.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleWorkflows.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleCodeScanning.and(zRepositoryRuleRulesetInfo),
    zRepositoryRuleCopilotCodeReview.and(zRepositoryRuleRulesetInfo)
]);

export const zSecretScanningAlert = z.object({
    number: z.optional(zAlertNumber),
    created_at: z.optional(zAlertCreatedAt),
    updated_at: z.optional(zNullableAlertUpdatedAt),
    url: z.optional(zAlertUrl),
    html_url: z.optional(zAlertHtmlUrl),
    locations_url: z.optional(z.url()),
    state: z.optional(zSecretScanningAlertState),
    resolution: z.optional(zSecretScanningAlertResolution),
    resolved_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    resolved_by: z.optional(zNullableSimpleUser),
    resolution_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    secret_type: z.optional(z.string()),
    secret_type_display_name: z.optional(z.string()),
    secret: z.optional(z.string()),
    push_protection_bypassed: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    push_protection_bypassed_by: z.optional(zNullableSimpleUser),
    push_protection_bypassed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    push_protection_bypass_request_reviewer: z.optional(zNullableSimpleUser),
    push_protection_bypass_request_reviewer_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    push_protection_bypass_request_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    push_protection_bypass_request_html_url: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    validity: z.optional(z.enum([
        'active',
        'inactive',
        'unknown'
    ])),
    publicly_leaked: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    multi_repo: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    is_base64_encoded: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    first_location_detected: z.optional(zNullableSecretScanningFirstDetectedLocation),
    has_more_locations: z.optional(z.boolean()),
    assigned_to: z.optional(zNullableSimpleUser)
});

/**
 * An optional comment when closing or reopening an alert. Cannot be updated or deleted.
 */
export const zSecretScanningAlertResolutionComment = z.union([
    z.string(),
    z.null()
]);

export const zSecretScanningLocation = z.object({
    type: z.optional(z.enum([
        'commit',
        'wiki_commit',
        'issue_title',
        'issue_body',
        'issue_comment',
        'discussion_title',
        'discussion_body',
        'discussion_comment',
        'pull_request_title',
        'pull_request_body',
        'pull_request_comment',
        'pull_request_review',
        'pull_request_review_comment'
    ])),
    details: z.optional(z.union([
        zSecretScanningLocationCommit,
        zSecretScanningLocationWikiCommit,
        zSecretScanningLocationIssueTitle,
        zSecretScanningLocationIssueBody,
        zSecretScanningLocationIssueComment,
        zSecretScanningLocationDiscussionTitle,
        zSecretScanningLocationDiscussionBody,
        zSecretScanningLocationDiscussionComment,
        zSecretScanningLocationPullRequestTitle,
        zSecretScanningLocationPullRequestBody,
        zSecretScanningLocationPullRequestComment,
        zSecretScanningLocationPullRequestReview,
        zSecretScanningLocationPullRequestReviewComment
    ]))
});

/**
 * The reason for bypassing push protection.
 */
export const zSecretScanningPushProtectionBypassReason = z.enum([
    'false_positive',
    'used_in_tests',
    'will_fix_later'
]);

export const zSecretScanningPushProtectionBypass = z.object({
    reason: z.optional(zSecretScanningPushProtectionBypassReason),
    expire_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    token_type: z.optional(z.string())
});

/**
 * Information on a single scan performed by secret scanning on the repository
 */
export const zSecretScanningScan = z.object({
    type: z.optional(z.string()),
    status: z.optional(z.string()),
    completed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    started_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ]))
});

export const zSecretScanningScanHistory = z.object({
    incremental_scans: z.optional(z.array(zSecretScanningScan)),
    pattern_update_scans: z.optional(z.array(zSecretScanningScan)),
    backfill_scans: z.optional(z.array(zSecretScanningScan)),
    custom_pattern_backfill_scans: z.optional(z.array(zSecretScanningScan.and(z.object({
        pattern_name: z.optional(z.string()),
        pattern_scope: z.optional(z.string())
    }))))
});

export const zRepositoryAdvisoryCreate = z.object({
    summary: z.string().max(1024),
    description: z.string().max(65535),
    cve_id: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    vulnerabilities: z.array(z.object({
        package: z.object({
            ecosystem: zSecurityAdvisoryEcosystems,
            name: z.optional(z.union([
                z.string(),
                z.null()
            ]))
        }),
        vulnerable_version_range: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        patched_versions: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        vulnerable_functions: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ]))
    })),
    cwe_ids: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    credits: z.optional(z.union([
        z.array(z.object({
            login: z.string(),
            type: zSecurityAdvisoryCreditTypes
        })),
        z.null()
    ])),
    severity: z.optional(z.enum([
        'critical',
        'high',
        'medium',
        'low'
    ])),
    cvss_vector_string: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    start_private_fork: z.optional(z.boolean()).default(false)
});

export const zPrivateVulnerabilityReportCreate = z.object({
    summary: z.string().max(1024),
    description: z.string().max(65535),
    vulnerabilities: z.optional(z.union([
        z.array(z.object({
            package: z.object({
                ecosystem: zSecurityAdvisoryEcosystems,
                name: z.optional(z.union([
                    z.string(),
                    z.null()
                ]))
            }),
            vulnerable_version_range: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            patched_versions: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            vulnerable_functions: z.optional(z.union([
                z.array(z.string()),
                z.null()
            ]))
        })),
        z.null()
    ])),
    cwe_ids: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    severity: z.optional(z.enum([
        'critical',
        'high',
        'medium',
        'low'
    ])),
    cvss_vector_string: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    start_private_fork: z.optional(z.boolean()).default(false)
});

export const zRepositoryAdvisoryUpdate = z.object({
    summary: z.optional(z.string().max(1024)),
    description: z.optional(z.string().max(65535)),
    cve_id: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    vulnerabilities: z.optional(z.array(z.object({
        package: z.object({
            ecosystem: zSecurityAdvisoryEcosystems,
            name: z.optional(z.union([
                z.string(),
                z.null()
            ]))
        }),
        vulnerable_version_range: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        patched_versions: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        vulnerable_functions: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ]))
    }))),
    cwe_ids: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    credits: z.optional(z.union([
        z.array(z.object({
            login: z.string(),
            type: zSecurityAdvisoryCreditTypes
        })),
        z.null()
    ])),
    severity: z.optional(z.enum([
        'critical',
        'high',
        'medium',
        'low'
    ])),
    cvss_vector_string: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    state: z.optional(z.enum([
        'published',
        'closed',
        'draft'
    ])),
    collaborating_users: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    collaborating_teams: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ]))
});

/**
 * Stargazer
 *
 * Stargazer
 */
export const zStargazer = z.object({
    starred_at: z.iso.datetime(),
    user: zNullableSimpleUser
});

/**
 * Code Frequency Stat
 *
 * Code Frequency Stat
 */
export const zCodeFrequencyStat = z.array(z.int());

/**
 * Commit Activity
 *
 * Commit Activity
 */
export const zCommitActivity = z.object({
    days: z.array(z.int()),
    total: z.int(),
    week: z.int()
});

/**
 * Contributor Activity
 *
 * Contributor Activity
 */
export const zContributorActivity = z.object({
    author: zNullableSimpleUser,
    total: z.int(),
    weeks: z.array(z.object({
        w: z.optional(z.int()),
        a: z.optional(z.int()),
        d: z.optional(z.int()),
        c: z.optional(z.int())
    }))
});

/**
 * Participation Stats
 */
export const zParticipationStats = z.object({
    all: z.array(z.int()),
    owner: z.array(z.int())
});

/**
 * Repository Invitation
 *
 * Repository invitations let you manage who you collaborate with.
 */
export const zRepositorySubscription = z.object({
    subscribed: z.boolean(),
    ignored: z.boolean(),
    reason: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.iso.datetime(),
    url: z.url(),
    repository_url: z.url()
});

/**
 * Tag
 *
 * Tag
 */
export const zTag = z.object({
    name: z.string(),
    commit: z.object({
        sha: z.string(),
        url: z.url()
    }),
    zipball_url: z.url(),
    tarball_url: z.url(),
    node_id: z.string()
});

/**
 * Tag protection
 *
 * Tag protection
 */
export const zTagProtection = z.object({
    id: z.optional(z.int()),
    created_at: z.optional(z.string()),
    updated_at: z.optional(z.string()),
    enabled: z.optional(z.boolean()),
    pattern: z.string()
});

/**
 * Topic
 *
 * A topic aggregates entities that are related to a subject.
 */
export const zTopic = z.object({
    names: z.array(z.string())
});

/**
 * Traffic
 */
export const zTraffic = z.object({
    timestamp: z.iso.datetime(),
    uniques: z.int(),
    count: z.int()
});

/**
 * Clone Traffic
 *
 * Clone Traffic
 */
export const zCloneTraffic = z.object({
    count: z.int(),
    uniques: z.int(),
    clones: z.array(zTraffic)
});

/**
 * Content Traffic
 *
 * Content Traffic
 */
export const zContentTraffic = z.object({
    path: z.string(),
    title: z.string(),
    count: z.int(),
    uniques: z.int()
});

/**
 * Referrer Traffic
 *
 * Referrer Traffic
 */
export const zReferrerTraffic = z.object({
    referrer: z.string(),
    count: z.int(),
    uniques: z.int()
});

/**
 * View Traffic
 *
 * View Traffic
 */
export const zViewTraffic = z.object({
    count: z.int(),
    uniques: z.int(),
    views: z.array(zTraffic)
});

/**
 * Search Result Text Matches
 */
export const zSearchResultTextMatches = z.array(z.object({
    object_url: z.optional(z.string()),
    object_type: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    property: z.optional(z.string()),
    fragment: z.optional(z.string()),
    matches: z.optional(z.array(z.object({
        text: z.optional(z.string()),
        indices: z.optional(z.array(z.int()))
    })))
}));

/**
 * Code Search Result Item
 *
 * Code Search Result Item
 */
export const zCodeSearchResultItem = z.object({
    name: z.string(),
    path: z.string(),
    sha: z.string(),
    url: z.url(),
    git_url: z.url(),
    html_url: z.url(),
    repository: zMinimalRepository,
    score: z.number(),
    file_size: z.optional(z.int()),
    language: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    last_modified_at: z.optional(z.iso.datetime()),
    line_numbers: z.optional(z.array(z.string())),
    text_matches: z.optional(zSearchResultTextMatches)
});

/**
 * Commit Search Result Item
 *
 * Commit Search Result Item
 */
export const zCommitSearchResultItem = z.object({
    url: z.url(),
    sha: z.string(),
    html_url: z.url(),
    comments_url: z.url(),
    commit: z.object({
        author: z.object({
            name: z.string(),
            email: z.string(),
            date: z.iso.datetime()
        }),
        committer: zNullableGitUser,
        comment_count: z.int(),
        message: z.string(),
        tree: z.object({
            sha: z.string(),
            url: z.url()
        }),
        url: z.url(),
        verification: z.optional(zVerification)
    }),
    author: zNullableSimpleUser,
    committer: zNullableGitUser,
    parents: z.array(z.object({
        url: z.optional(z.string()),
        html_url: z.optional(z.string()),
        sha: z.optional(z.string())
    })),
    repository: zMinimalRepository,
    score: z.number(),
    node_id: z.string(),
    text_matches: z.optional(zSearchResultTextMatches)
});

/**
 * Issue Search Result Item
 *
 * Issue Search Result Item
 */
export const zIssueSearchResultItem = z.object({
    url: z.url(),
    repository_url: z.url(),
    labels_url: z.string(),
    comments_url: z.url(),
    events_url: z.url(),
    html_url: z.url(),
    id: z.coerce.bigint(),
    node_id: z.string(),
    number: z.int(),
    title: z.string(),
    locked: z.boolean(),
    active_lock_reason: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    assignees: z.optional(z.union([
        z.array(zSimpleUser),
        z.null()
    ])),
    user: zNullableSimpleUser,
    labels: z.array(z.object({
        id: z.optional(z.coerce.bigint()),
        node_id: z.optional(z.string()),
        url: z.optional(z.string()),
        name: z.optional(z.string()),
        color: z.optional(z.string()),
        default: z.optional(z.boolean()),
        description: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    })),
    sub_issues_summary: z.optional(zSubIssuesSummary),
    issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
    issue_field_values: z.optional(z.array(zIssueFieldValue)),
    state: z.string(),
    state_reason: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    assignee: zNullableSimpleUser,
    milestone: zNullableMilestone,
    comments: z.int(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    closed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    text_matches: z.optional(zSearchResultTextMatches),
    pull_request: z.optional(z.object({
        merged_at: z.optional(z.union([
            z.iso.datetime(),
            z.null()
        ])),
        diff_url: z.union([
            z.url(),
            z.null()
        ]),
        html_url: z.union([
            z.url(),
            z.null()
        ]),
        patch_url: z.union([
            z.url(),
            z.null()
        ]),
        url: z.union([
            z.url(),
            z.null()
        ])
    })),
    body: z.optional(z.string()),
    score: z.number(),
    author_association: zAuthorAssociation,
    draft: z.optional(z.boolean()),
    repository: z.optional(zRepository),
    body_html: z.optional(z.string()),
    body_text: z.optional(z.string()),
    timeline_url: z.optional(z.url()),
    type: z.optional(zIssueType),
    performed_via_github_app: z.optional(zNullableIntegration),
    reactions: z.optional(zReactionRollup)
});

/**
 * Label Search Result Item
 *
 * Label Search Result Item
 */
export const zLabelSearchResultItem = z.object({
    id: z.int(),
    node_id: z.string(),
    url: z.url(),
    name: z.string(),
    color: z.string(),
    default: z.boolean(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    score: z.number(),
    text_matches: z.optional(zSearchResultTextMatches)
});

/**
 * Repo Search Result Item
 *
 * Repo Search Result Item
 */
export const zRepoSearchResultItem = z.object({
    id: z.int(),
    node_id: z.string(),
    name: z.string(),
    full_name: z.string(),
    owner: zNullableSimpleUser,
    private: z.boolean(),
    html_url: z.url(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    fork: z.boolean(),
    url: z.url(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    pushed_at: z.iso.datetime(),
    homepage: z.union([
        z.url(),
        z.null()
    ]),
    size: z.int(),
    stargazers_count: z.int(),
    watchers_count: z.int(),
    language: z.union([
        z.string(),
        z.null()
    ]),
    forks_count: z.int(),
    open_issues_count: z.int(),
    master_branch: z.optional(z.string()),
    default_branch: z.string(),
    score: z.number(),
    forks_url: z.url(),
    keys_url: z.string(),
    collaborators_url: z.string(),
    teams_url: z.url(),
    hooks_url: z.url(),
    issue_events_url: z.string(),
    events_url: z.url(),
    assignees_url: z.string(),
    branches_url: z.string(),
    tags_url: z.url(),
    blobs_url: z.string(),
    git_tags_url: z.string(),
    git_refs_url: z.string(),
    trees_url: z.string(),
    statuses_url: z.string(),
    languages_url: z.url(),
    stargazers_url: z.url(),
    contributors_url: z.url(),
    subscribers_url: z.url(),
    subscription_url: z.url(),
    commits_url: z.string(),
    git_commits_url: z.string(),
    comments_url: z.string(),
    issue_comment_url: z.string(),
    contents_url: z.string(),
    compare_url: z.string(),
    merges_url: z.url(),
    archive_url: z.string(),
    downloads_url: z.url(),
    issues_url: z.string(),
    pulls_url: z.string(),
    milestones_url: z.string(),
    notifications_url: z.string(),
    labels_url: z.string(),
    releases_url: z.string(),
    deployments_url: z.url(),
    git_url: z.string(),
    ssh_url: z.string(),
    clone_url: z.string(),
    svn_url: z.url(),
    forks: z.int(),
    open_issues: z.int(),
    watchers: z.int(),
    topics: z.optional(z.array(z.string())),
    mirror_url: z.union([
        z.url(),
        z.null()
    ]),
    has_issues: z.boolean(),
    has_projects: z.boolean(),
    has_pages: z.boolean(),
    has_wiki: z.boolean(),
    has_downloads: z.boolean(),
    has_discussions: z.optional(z.boolean()),
    archived: z.boolean(),
    disabled: z.boolean(),
    visibility: z.optional(z.string()),
    license: zNullableLicenseSimple,
    permissions: z.optional(z.object({
        admin: z.boolean(),
        maintain: z.optional(z.boolean()),
        push: z.boolean(),
        triage: z.optional(z.boolean()),
        pull: z.boolean()
    })),
    text_matches: z.optional(zSearchResultTextMatches),
    temp_clone_token: z.optional(z.string()),
    allow_merge_commit: z.optional(z.boolean()),
    allow_squash_merge: z.optional(z.boolean()),
    allow_rebase_merge: z.optional(z.boolean()),
    allow_auto_merge: z.optional(z.boolean()),
    delete_branch_on_merge: z.optional(z.boolean()),
    allow_forking: z.optional(z.boolean()),
    is_template: z.optional(z.boolean()),
    web_commit_signoff_required: z.optional(z.boolean())
});

/**
 * Topic Search Result Item
 *
 * Topic Search Result Item
 */
export const zTopicSearchResultItem = z.object({
    name: z.string(),
    display_name: z.union([
        z.string(),
        z.null()
    ]),
    short_description: z.union([
        z.string(),
        z.null()
    ]),
    description: z.union([
        z.string(),
        z.null()
    ]),
    created_by: z.union([
        z.string(),
        z.null()
    ]),
    released: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    featured: z.boolean(),
    curated: z.boolean(),
    score: z.number(),
    repository_count: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    logo_url: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    text_matches: z.optional(zSearchResultTextMatches),
    related: z.optional(z.union([
        z.array(z.object({
            topic_relation: z.optional(z.object({
                id: z.optional(z.int()),
                name: z.optional(z.string()),
                topic_id: z.optional(z.int()),
                relation_type: z.optional(z.string())
            }))
        })),
        z.null()
    ])),
    aliases: z.optional(z.union([
        z.array(z.object({
            topic_relation: z.optional(z.object({
                id: z.optional(z.int()),
                name: z.optional(z.string()),
                topic_id: z.optional(z.int()),
                relation_type: z.optional(z.string())
            }))
        })),
        z.null()
    ]))
});

/**
 * User Search Result Item
 *
 * User Search Result Item
 */
export const zUserSearchResultItem = z.object({
    login: z.string(),
    id: z.coerce.bigint(),
    node_id: z.string(),
    avatar_url: z.url(),
    gravatar_id: z.union([
        z.string(),
        z.null()
    ]),
    url: z.url(),
    html_url: z.url(),
    followers_url: z.url(),
    subscriptions_url: z.url(),
    organizations_url: z.url(),
    repos_url: z.url(),
    received_events_url: z.url(),
    type: z.string(),
    score: z.number(),
    following_url: z.string(),
    gists_url: z.string(),
    starred_url: z.string(),
    events_url: z.string(),
    public_repos: z.optional(z.int()),
    public_gists: z.optional(z.int()),
    followers: z.optional(z.int()),
    following: z.optional(z.int()),
    created_at: z.optional(z.iso.datetime()),
    updated_at: z.optional(z.iso.datetime()),
    name: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    bio: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    email: z.optional(z.union([
        z.email(),
        z.null()
    ])),
    location: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    site_admin: z.boolean(),
    hireable: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    text_matches: z.optional(zSearchResultTextMatches),
    blog: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    company: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    suspended_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    user_view_type: z.optional(z.string())
});

/**
 * Private User
 *
 * Private User
 */
export const zPrivateUser = z.object({
    login: z.string(),
    id: z.coerce.bigint(),
    user_view_type: z.optional(z.string()),
    node_id: z.string(),
    avatar_url: z.url(),
    gravatar_id: z.union([
        z.string(),
        z.null()
    ]),
    url: z.url(),
    html_url: z.url(),
    followers_url: z.url(),
    following_url: z.string(),
    gists_url: z.string(),
    starred_url: z.string(),
    subscriptions_url: z.url(),
    organizations_url: z.url(),
    repos_url: z.url(),
    events_url: z.string(),
    received_events_url: z.url(),
    type: z.string(),
    site_admin: z.boolean(),
    name: z.union([
        z.string(),
        z.null()
    ]),
    company: z.union([
        z.string(),
        z.null()
    ]),
    blog: z.union([
        z.string(),
        z.null()
    ]),
    location: z.union([
        z.string(),
        z.null()
    ]),
    email: z.union([
        z.email(),
        z.null()
    ]),
    notification_email: z.optional(z.union([
        z.email(),
        z.null()
    ])),
    hireable: z.union([
        z.boolean(),
        z.null()
    ]),
    bio: z.union([
        z.string(),
        z.null()
    ]),
    twitter_username: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    public_repos: z.int(),
    public_gists: z.int(),
    followers: z.int(),
    following: z.int(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    private_gists: z.int(),
    total_private_repos: z.int(),
    owned_private_repos: z.int(),
    disk_usage: z.int(),
    collaborators: z.int(),
    two_factor_authentication: z.boolean(),
    plan: z.optional(z.object({
        collaborators: z.int(),
        name: z.string(),
        space: z.int(),
        private_repos: z.int()
    })),
    business_plus: z.optional(z.boolean()),
    ldap_dn: z.optional(z.string())
});

/**
 * Codespaces Secret
 *
 * Secrets for a GitHub Codespace.
 */
export const zCodespacesSecret = z.object({
    name: z.string(),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    visibility: z.enum([
        'all',
        'private',
        'selected'
    ]),
    selected_repositories_url: z.url()
});

/**
 * CodespacesUserPublicKey
 *
 * The public key used for setting user Codespaces' Secrets.
 */
export const zCodespacesUserPublicKey = z.object({
    key_id: z.string(),
    key: z.string()
});

/**
 * Fetches information about an export of a codespace.
 *
 * An export of a codespace. Also, latest export details for a codespace can be fetched with id = latest
 */
export const zCodespaceExportDetails = z.object({
    state: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    completed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    branch: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    sha: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    id: z.optional(z.string()),
    export_url: z.optional(z.string()),
    html_url: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

/**
 * Codespace
 *
 * A codespace.
 */
export const zCodespaceWithFullRepository = z.object({
    id: z.coerce.bigint(),
    name: z.string(),
    display_name: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    environment_id: z.union([
        z.string(),
        z.null()
    ]),
    owner: zSimpleUser,
    billable_owner: zSimpleUser,
    repository: zFullRepository,
    machine: zNullableCodespaceMachine,
    devcontainer_path: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    prebuild: z.union([
        z.boolean(),
        z.null()
    ]),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    last_used_at: z.iso.datetime(),
    state: z.enum([
        'Unknown',
        'Created',
        'Queued',
        'Provisioning',
        'Available',
        'Awaiting',
        'Unavailable',
        'Deleted',
        'Moved',
        'Shutdown',
        'Archived',
        'Starting',
        'ShuttingDown',
        'Failed',
        'Exporting',
        'Updating',
        'Rebuilding'
    ]),
    url: z.url(),
    git_status: z.object({
        ahead: z.optional(z.int()),
        behind: z.optional(z.int()),
        has_unpushed_changes: z.optional(z.boolean()),
        has_uncommitted_changes: z.optional(z.boolean()),
        ref: z.optional(z.string())
    }),
    location: z.enum([
        'EastUs',
        'SouthEastAsia',
        'WestEurope',
        'WestUs2'
    ]),
    idle_timeout_minutes: z.union([
        z.int(),
        z.null()
    ]),
    web_url: z.url(),
    machines_url: z.url(),
    start_url: z.url(),
    stop_url: z.url(),
    publish_url: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    pulls_url: z.union([
        z.url(),
        z.null()
    ]),
    recent_folders: z.array(z.string()),
    runtime_constraints: z.optional(z.object({
        allowed_port_privacy_settings: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ]))
    })),
    pending_operation: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    pending_operation_disabled_reason: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    idle_timeout_notice: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    retention_period_minutes: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    retention_expires_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ]))
});

/**
 * Email
 *
 * Email
 */
export const zEmail = z.object({
    email: z.email(),
    primary: z.boolean(),
    verified: z.boolean(),
    visibility: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * GPG Key
 *
 * A unique encryption key
 */
export const zGpgKey = z.object({
    id: z.coerce.bigint(),
    name: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    primary_key_id: z.union([
        z.int(),
        z.null()
    ]),
    key_id: z.string(),
    public_key: z.string(),
    emails: z.array(z.object({
        email: z.optional(z.string()),
        verified: z.optional(z.boolean())
    })),
    subkeys: z.array(z.object({
        id: z.optional(z.coerce.bigint()),
        primary_key_id: z.optional(z.int()),
        key_id: z.optional(z.string()),
        public_key: z.optional(z.string()),
        emails: z.optional(z.array(z.object({
            email: z.optional(z.string()),
            verified: z.optional(z.boolean())
        }))),
        subkeys: z.optional(z.array(z.unknown())),
        can_sign: z.optional(z.boolean()),
        can_encrypt_comms: z.optional(z.boolean()),
        can_encrypt_storage: z.optional(z.boolean()),
        can_certify: z.optional(z.boolean()),
        created_at: z.optional(z.string()),
        expires_at: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        raw_key: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        revoked: z.optional(z.boolean())
    })),
    can_sign: z.boolean(),
    can_encrypt_comms: z.boolean(),
    can_encrypt_storage: z.boolean(),
    can_certify: z.boolean(),
    created_at: z.iso.datetime(),
    expires_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    revoked: z.boolean(),
    raw_key: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Key
 *
 * Key
 */
export const zKey = z.object({
    key: z.string(),
    id: z.coerce.bigint(),
    url: z.string(),
    title: z.string(),
    created_at: z.iso.datetime(),
    verified: z.boolean(),
    read_only: z.boolean(),
    last_used: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ]))
});

/**
 * Marketplace Account
 */
export const zMarketplaceAccount = z.object({
    url: z.url(),
    id: z.int(),
    type: z.string(),
    node_id: z.optional(z.string()),
    login: z.string(),
    email: z.optional(z.union([
        z.email(),
        z.null()
    ])),
    organization_billing_email: z.optional(z.union([
        z.email(),
        z.null()
    ]))
});

/**
 * User Marketplace Purchase
 *
 * User Marketplace Purchase
 */
export const zUserMarketplacePurchase = z.object({
    billing_cycle: z.string(),
    next_billing_date: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    unit_count: z.union([
        z.int(),
        z.null()
    ]),
    on_free_trial: z.boolean(),
    free_trial_ends_on: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    updated_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    account: zMarketplaceAccount,
    plan: zMarketplaceListingPlan
});

/**
 * Social account
 *
 * Social media account
 */
export const zSocialAccount = z.object({
    provider: z.string(),
    url: z.string()
});

/**
 * SSH Signing Key
 *
 * A public SSH key used to sign Git commits
 */
export const zSshSigningKey = z.object({
    key: z.string(),
    id: z.int(),
    title: z.string(),
    created_at: z.iso.datetime()
});

/**
 * Starred Repository
 *
 * Starred Repository
 */
export const zStarredRepository = z.object({
    starred_at: z.iso.datetime(),
    repo: zRepository
});

/**
 * Hovercard
 *
 * Hovercard
 */
export const zHovercard = z.object({
    contexts: z.array(z.object({
        message: z.string(),
        octicon: z.string()
    }))
});

/**
 * Key Simple
 *
 * Key Simple
 */
export const zKeySimple = z.object({
    id: z.int(),
    key: z.string(),
    created_at: z.optional(z.iso.datetime()),
    last_used: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ]))
});

export const zBillingPremiumRequestUsageReportUser = z.object({
    timePeriod: z.object({
        year: z.int(),
        month: z.optional(z.int()),
        day: z.optional(z.int())
    }),
    user: z.string(),
    product: z.optional(z.string()),
    model: z.optional(z.string()),
    usageItems: z.array(z.object({
        product: z.string(),
        sku: z.string(),
        model: z.string(),
        unitType: z.string(),
        pricePerUnit: z.number(),
        grossQuantity: z.number(),
        grossAmount: z.number(),
        discountQuantity: z.number(),
        discountAmount: z.number(),
        netQuantity: z.number(),
        netAmount: z.number()
    }))
});

export const zBillingUsageReportUser = z.object({
    usageItems: z.optional(z.array(z.object({
        date: z.string(),
        product: z.string(),
        sku: z.string(),
        quantity: z.int(),
        unitType: z.string(),
        pricePerUnit: z.number(),
        grossAmount: z.number(),
        discountAmount: z.number(),
        netAmount: z.number(),
        repositoryName: z.optional(z.string())
    })))
});

/**
 * Enterprise
 *
 * An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured
 * on an enterprise account or an organization that's part of an enterprise account. For more information,
 * see "[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts)."
 */
export const zEnterpriseWebhooks = z.object({
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    html_url: z.url(),
    website_url: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    id: z.int(),
    node_id: z.string(),
    name: z.string(),
    slug: z.string(),
    created_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    updated_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    avatar_url: z.url()
});

/**
 * Simple Installation
 *
 * The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured
 * for and sent to a GitHub App. For more information,
 * see "[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps)."
 */
export const zSimpleInstallation = z.object({
    id: z.int(),
    node_id: z.string()
});

/**
 * Organization Simple
 *
 * A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an
 * organization, or when the event occurs from activity in a repository owned by an organization.
 */
export const zOrganizationSimpleWebhooks = z.object({
    login: z.string(),
    id: z.int(),
    node_id: z.string(),
    url: z.url(),
    repos_url: z.url(),
    events_url: z.url(),
    hooks_url: z.string(),
    issues_url: z.string(),
    members_url: z.string(),
    public_members_url: z.string(),
    avatar_url: z.string(),
    description: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Repository
 *
 * The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property
 * when the event occurs from activity in a repository.
 */
export const zRepositoryWebhooks = z.object({
    id: z.coerce.bigint(),
    node_id: z.string(),
    name: z.string(),
    full_name: z.string(),
    license: zNullableLicenseSimple,
    organization: z.optional(zNullableSimpleUser),
    forks: z.int(),
    permissions: z.optional(z.object({
        admin: z.boolean(),
        pull: z.boolean(),
        triage: z.optional(z.boolean()),
        push: z.boolean(),
        maintain: z.optional(z.boolean())
    })),
    owner: zSimpleUser,
    private: z.boolean().default(false),
    html_url: z.url(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    fork: z.boolean(),
    url: z.url(),
    archive_url: z.string(),
    assignees_url: z.string(),
    blobs_url: z.string(),
    branches_url: z.string(),
    collaborators_url: z.string(),
    comments_url: z.string(),
    commits_url: z.string(),
    compare_url: z.string(),
    contents_url: z.string(),
    contributors_url: z.url(),
    deployments_url: z.url(),
    downloads_url: z.url(),
    events_url: z.url(),
    forks_url: z.url(),
    git_commits_url: z.string(),
    git_refs_url: z.string(),
    git_tags_url: z.string(),
    git_url: z.string(),
    issue_comment_url: z.string(),
    issue_events_url: z.string(),
    issues_url: z.string(),
    keys_url: z.string(),
    labels_url: z.string(),
    languages_url: z.url(),
    merges_url: z.url(),
    milestones_url: z.string(),
    notifications_url: z.string(),
    pulls_url: z.string(),
    releases_url: z.string(),
    ssh_url: z.string(),
    stargazers_url: z.url(),
    statuses_url: z.string(),
    subscribers_url: z.url(),
    subscription_url: z.url(),
    tags_url: z.url(),
    teams_url: z.url(),
    trees_url: z.string(),
    clone_url: z.string(),
    mirror_url: z.union([
        z.url(),
        z.null()
    ]),
    hooks_url: z.url(),
    svn_url: z.url(),
    homepage: z.union([
        z.url(),
        z.null()
    ]),
    language: z.union([
        z.string(),
        z.null()
    ]),
    forks_count: z.int(),
    stargazers_count: z.int(),
    watchers_count: z.int(),
    size: z.int(),
    default_branch: z.string(),
    open_issues_count: z.int(),
    is_template: z.optional(z.boolean()).default(false),
    topics: z.optional(z.array(z.string())),
    custom_properties: z.optional(z.record(z.string(), z.unknown())),
    has_issues: z.boolean().default(true),
    has_projects: z.boolean().default(true),
    has_wiki: z.boolean().default(true),
    has_pages: z.boolean(),
    has_downloads: z.boolean().default(true),
    has_discussions: z.optional(z.boolean()).default(false),
    archived: z.boolean().default(false),
    disabled: z.boolean(),
    visibility: z.optional(z.string()).default('public'),
    pushed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    created_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    updated_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    allow_rebase_merge: z.optional(z.boolean()).default(true),
    template_repository: z.optional(z.union([
        z.object({
            id: z.optional(z.int()),
            node_id: z.optional(z.string()),
            name: z.optional(z.string()),
            full_name: z.optional(z.string()),
            owner: z.optional(z.object({
                login: z.optional(z.string()),
                id: z.optional(z.int()),
                node_id: z.optional(z.string()),
                avatar_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                url: z.optional(z.string()),
                html_url: z.optional(z.string()),
                followers_url: z.optional(z.string()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.string()),
                organizations_url: z.optional(z.string()),
                repos_url: z.optional(z.string()),
                events_url: z.optional(z.string()),
                received_events_url: z.optional(z.string()),
                type: z.optional(z.string()),
                site_admin: z.optional(z.boolean())
            })),
            private: z.optional(z.boolean()),
            html_url: z.optional(z.string()),
            description: z.optional(z.string()),
            fork: z.optional(z.boolean()),
            url: z.optional(z.string()),
            archive_url: z.optional(z.string()),
            assignees_url: z.optional(z.string()),
            blobs_url: z.optional(z.string()),
            branches_url: z.optional(z.string()),
            collaborators_url: z.optional(z.string()),
            comments_url: z.optional(z.string()),
            commits_url: z.optional(z.string()),
            compare_url: z.optional(z.string()),
            contents_url: z.optional(z.string()),
            contributors_url: z.optional(z.string()),
            deployments_url: z.optional(z.string()),
            downloads_url: z.optional(z.string()),
            events_url: z.optional(z.string()),
            forks_url: z.optional(z.string()),
            git_commits_url: z.optional(z.string()),
            git_refs_url: z.optional(z.string()),
            git_tags_url: z.optional(z.string()),
            git_url: z.optional(z.string()),
            issue_comment_url: z.optional(z.string()),
            issue_events_url: z.optional(z.string()),
            issues_url: z.optional(z.string()),
            keys_url: z.optional(z.string()),
            labels_url: z.optional(z.string()),
            languages_url: z.optional(z.string()),
            merges_url: z.optional(z.string()),
            milestones_url: z.optional(z.string()),
            notifications_url: z.optional(z.string()),
            pulls_url: z.optional(z.string()),
            releases_url: z.optional(z.string()),
            ssh_url: z.optional(z.string()),
            stargazers_url: z.optional(z.string()),
            statuses_url: z.optional(z.string()),
            subscribers_url: z.optional(z.string()),
            subscription_url: z.optional(z.string()),
            tags_url: z.optional(z.string()),
            teams_url: z.optional(z.string()),
            trees_url: z.optional(z.string()),
            clone_url: z.optional(z.string()),
            mirror_url: z.optional(z.string()),
            hooks_url: z.optional(z.string()),
            svn_url: z.optional(z.string()),
            homepage: z.optional(z.string()),
            language: z.optional(z.string()),
            forks_count: z.optional(z.int()),
            stargazers_count: z.optional(z.int()),
            watchers_count: z.optional(z.int()),
            size: z.optional(z.int()),
            default_branch: z.optional(z.string()),
            open_issues_count: z.optional(z.int()),
            is_template: z.optional(z.boolean()),
            topics: z.optional(z.array(z.string())),
            has_issues: z.optional(z.boolean()),
            has_projects: z.optional(z.boolean()),
            has_wiki: z.optional(z.boolean()),
            has_pages: z.optional(z.boolean()),
            has_downloads: z.optional(z.boolean()),
            archived: z.optional(z.boolean()),
            disabled: z.optional(z.boolean()),
            visibility: z.optional(z.string()),
            pushed_at: z.optional(z.string()),
            created_at: z.optional(z.string()),
            updated_at: z.optional(z.string()),
            permissions: z.optional(z.object({
                admin: z.optional(z.boolean()),
                maintain: z.optional(z.boolean()),
                push: z.optional(z.boolean()),
                triage: z.optional(z.boolean()),
                pull: z.optional(z.boolean())
            })),
            allow_rebase_merge: z.optional(z.boolean()),
            temp_clone_token: z.optional(z.string()),
            allow_squash_merge: z.optional(z.boolean()),
            allow_auto_merge: z.optional(z.boolean()),
            delete_branch_on_merge: z.optional(z.boolean()),
            allow_update_branch: z.optional(z.boolean()),
            use_squash_pr_title_as_default: z.optional(z.boolean()),
            squash_merge_commit_title: z.optional(z.enum([
                'PR_TITLE',
                'COMMIT_OR_PR_TITLE'
            ])),
            squash_merge_commit_message: z.optional(z.enum([
                'PR_BODY',
                'COMMIT_MESSAGES',
                'BLANK'
            ])),
            merge_commit_title: z.optional(z.enum([
                'PR_TITLE',
                'MERGE_MESSAGE'
            ])),
            merge_commit_message: z.optional(z.enum([
                'PR_BODY',
                'PR_TITLE',
                'BLANK'
            ])),
            allow_merge_commit: z.optional(z.boolean()),
            subscribers_count: z.optional(z.int()),
            network_count: z.optional(z.int())
        }),
        z.null()
    ])),
    temp_clone_token: z.optional(z.string()),
    allow_squash_merge: z.optional(z.boolean()).default(true),
    allow_auto_merge: z.optional(z.boolean()).default(false),
    delete_branch_on_merge: z.optional(z.boolean()).default(false),
    allow_update_branch: z.optional(z.boolean()).default(false),
    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
    squash_merge_commit_title: z.optional(z.enum([
        'PR_TITLE',
        'COMMIT_OR_PR_TITLE'
    ])),
    squash_merge_commit_message: z.optional(z.enum([
        'PR_BODY',
        'COMMIT_MESSAGES',
        'BLANK'
    ])),
    merge_commit_title: z.optional(z.enum([
        'PR_TITLE',
        'MERGE_MESSAGE'
    ])),
    merge_commit_message: z.optional(z.enum([
        'PR_BODY',
        'PR_TITLE',
        'BLANK'
    ])),
    allow_merge_commit: z.optional(z.boolean()).default(true),
    allow_forking: z.optional(z.boolean()),
    web_commit_signoff_required: z.optional(z.boolean()).default(false),
    subscribers_count: z.optional(z.int()),
    network_count: z.optional(z.int()),
    open_issues: z.int(),
    watchers: z.int(),
    master_branch: z.optional(z.string()),
    starred_at: z.optional(z.string()),
    anonymous_access_enabled: z.optional(z.boolean())
});

/**
 * branch protection rule
 *
 * The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings.
 */
export const zWebhooksRule = z.object({
    admin_enforced: z.boolean(),
    allow_deletions_enforcement_level: z.enum([
        'off',
        'non_admins',
        'everyone'
    ]),
    allow_force_pushes_enforcement_level: z.enum([
        'off',
        'non_admins',
        'everyone'
    ]),
    authorized_actor_names: z.array(z.string()),
    authorized_actors_only: z.boolean(),
    authorized_dismissal_actors_only: z.boolean(),
    create_protected: z.optional(z.boolean()),
    created_at: z.iso.datetime(),
    dismiss_stale_reviews_on_push: z.boolean(),
    id: z.int(),
    ignore_approvals_from_contributors: z.boolean(),
    linear_history_requirement_enforcement_level: z.enum([
        'off',
        'non_admins',
        'everyone'
    ]),
    lock_branch_enforcement_level: z.enum([
        'off',
        'non_admins',
        'everyone'
    ]),
    lock_allows_fork_sync: z.optional(z.boolean()),
    merge_queue_enforcement_level: z.enum([
        'off',
        'non_admins',
        'everyone'
    ]),
    name: z.string(),
    pull_request_reviews_enforcement_level: z.enum([
        'off',
        'non_admins',
        'everyone'
    ]),
    repository_id: z.int(),
    require_code_owner_review: z.boolean(),
    require_last_push_approval: z.optional(z.boolean()),
    required_approving_review_count: z.int(),
    required_conversation_resolution_level: z.enum([
        'off',
        'non_admins',
        'everyone'
    ]),
    required_deployments_enforcement_level: z.enum([
        'off',
        'non_admins',
        'everyone'
    ]),
    required_status_checks: z.array(z.string()),
    required_status_checks_enforcement_level: z.enum([
        'off',
        'non_admins',
        'everyone'
    ]),
    signature_requirement_enforcement_level: z.enum([
        'off',
        'non_admins',
        'everyone'
    ]),
    strict_required_status_checks_policy: z.boolean(),
    updated_at: z.iso.datetime()
});

/**
 * A suite of checks performed on the code of a given code change
 */
export const zSimpleCheckSuite = z.object({
    after: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    app: z.optional(zIntegration),
    before: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    conclusion: z.optional(z.enum([
        'success',
        'failure',
        'neutral',
        'cancelled',
        'skipped',
        'timed_out',
        'action_required',
        'stale',
        'startup_failure'
    ])),
    created_at: z.optional(z.iso.datetime()),
    head_branch: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    head_sha: z.optional(z.string()),
    id: z.optional(z.int()),
    node_id: z.optional(z.string()),
    pull_requests: z.optional(z.array(zPullRequestMinimal)),
    repository: z.optional(zMinimalRepository),
    status: z.optional(z.enum([
        'queued',
        'in_progress',
        'completed',
        'pending',
        'waiting'
    ])),
    updated_at: z.optional(z.iso.datetime()),
    url: z.optional(z.string())
});

/**
 * CheckRun
 *
 * A check performed on the code of a given code change
 */
export const zCheckRunWithSimpleCheckSuite = z.object({
    app: zIntegration,
    check_suite: zSimpleCheckSuite,
    completed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    conclusion: z.enum([
        'waiting',
        'pending',
        'startup_failure',
        'stale',
        'success',
        'failure',
        'neutral',
        'cancelled',
        'skipped',
        'timed_out',
        'action_required'
    ]),
    deployment: z.optional(zDeploymentSimple),
    details_url: z.string(),
    external_id: z.string(),
    head_sha: z.string(),
    html_url: z.string(),
    id: z.int(),
    name: z.string(),
    node_id: z.string(),
    output: z.object({
        annotations_count: z.int(),
        annotations_url: z.url(),
        summary: z.union([
            z.string(),
            z.null()
        ]),
        text: z.union([
            z.string(),
            z.null()
        ]),
        title: z.union([
            z.string(),
            z.null()
        ])
    }),
    pull_requests: z.array(zPullRequestMinimal),
    started_at: z.iso.datetime(),
    status: z.enum([
        'queued',
        'in_progress',
        'completed',
        'pending'
    ]),
    url: z.string()
});

/**
 * The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
 */
export const zWebhooksCodeScanningCommitOid = z.string();

/**
 * The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
 */
export const zWebhooksCodeScanningRef = z.string();

/**
 * The pusher type for the event. Can be either `user` or a deploy key.
 */
export const zWebhooksDeployPusherType = z.string();

/**
 * The [`git ref`](https://docs.github.com/rest/git/refs#get-a-reference) resource.
 */
export const zWebhooksRef0 = z.string();

/**
 * The [`deploy key`](https://docs.github.com/rest/deploy-keys/deploy-keys#get-a-deploy-key) resource.
 */
export const zWebhooksDeployKey = z.object({
    added_by: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    created_at: z.string(),
    id: z.int(),
    key: z.string(),
    last_used: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    read_only: z.boolean(),
    title: z.string(),
    url: z.url(),
    verified: z.boolean(),
    enabled: z.optional(z.boolean())
});

/**
 * Workflow
 */
export const zWebhooksWorkflow = z.union([
    z.object({
        badge_url: z.url(),
        created_at: z.iso.datetime(),
        html_url: z.url(),
        id: z.int(),
        name: z.string(),
        node_id: z.string(),
        path: z.string(),
        state: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url()
    }),
    z.null()
]);

export const zWebhooksApprover = z.object({
    avatar_url: z.optional(z.string()),
    events_url: z.optional(z.string()),
    followers_url: z.optional(z.string()),
    following_url: z.optional(z.string()),
    gists_url: z.optional(z.string()),
    gravatar_id: z.optional(z.string()),
    html_url: z.optional(z.string()),
    id: z.optional(z.int()),
    login: z.optional(z.string()),
    node_id: z.optional(z.string()),
    organizations_url: z.optional(z.string()),
    received_events_url: z.optional(z.string()),
    repos_url: z.optional(z.string()),
    site_admin: z.optional(z.boolean()),
    starred_url: z.optional(z.string()),
    subscriptions_url: z.optional(z.string()),
    type: z.optional(z.string()),
    url: z.optional(z.string()),
    user_view_type: z.optional(z.string())
});

export const zWebhooksReviewers = z.array(z.object({
    reviewer: z.optional(z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url())
        }),
        z.null()
    ])),
    type: z.optional(z.enum([
        'User'
    ]))
}));

export const zWebhooksWorkflowJobRun = z.object({
    conclusion: z.unknown(),
    created_at: z.string(),
    environment: z.string(),
    html_url: z.string(),
    id: z.int(),
    name: z.unknown(),
    status: z.string(),
    updated_at: z.string()
});

/**
 * User
 */
export const zWebhooksUser = z.union([
    z.object({
        avatar_url: z.optional(z.url()),
        deleted: z.optional(z.boolean()),
        email: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        events_url: z.optional(z.string()),
        followers_url: z.optional(z.url()),
        following_url: z.optional(z.string()),
        gists_url: z.optional(z.string()),
        gravatar_id: z.optional(z.string()),
        html_url: z.optional(z.url()),
        id: z.coerce.bigint(),
        login: z.string(),
        name: z.optional(z.string()),
        node_id: z.optional(z.string()),
        organizations_url: z.optional(z.url()),
        received_events_url: z.optional(z.url()),
        repos_url: z.optional(z.url()),
        site_admin: z.optional(z.boolean()),
        starred_url: z.optional(z.string()),
        subscriptions_url: z.optional(z.url()),
        type: z.optional(z.enum([
            'Bot',
            'User',
            'Organization'
        ])),
        url: z.optional(z.url()),
        user_view_type: z.optional(z.string())
    }),
    z.null()
]);

export const zWebhooksAnswer = z.object({
    author_association: z.enum([
        'COLLABORATOR',
        'CONTRIBUTOR',
        'FIRST_TIMER',
        'FIRST_TIME_CONTRIBUTOR',
        'MANNEQUIN',
        'MEMBER',
        'NONE',
        'OWNER'
    ]),
    body: z.string(),
    child_comment_count: z.int(),
    created_at: z.iso.datetime(),
    discussion_id: z.int(),
    html_url: z.string(),
    id: z.int(),
    node_id: z.string(),
    parent_id: z.unknown(),
    reactions: z.optional(z.object({
        '+1': z.int(),
        '-1': z.int(),
        confused: z.int(),
        eyes: z.int(),
        heart: z.int(),
        hooray: z.int(),
        laugh: z.int(),
        rocket: z.int(),
        total_count: z.int(),
        url: z.url()
    })),
    repository_url: z.string(),
    updated_at: z.iso.datetime(),
    user: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.coerce.bigint(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ])
});

/**
 * Discussion
 *
 * A Discussion in a repository.
 */
export const zDiscussion = z.object({
    active_lock_reason: z.union([
        z.string(),
        z.null()
    ]),
    answer_chosen_at: z.union([
        z.string(),
        z.null()
    ]),
    answer_chosen_by: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ]),
    answer_html_url: z.union([
        z.string(),
        z.null()
    ]),
    author_association: z.enum([
        'COLLABORATOR',
        'CONTRIBUTOR',
        'FIRST_TIMER',
        'FIRST_TIME_CONTRIBUTOR',
        'MANNEQUIN',
        'MEMBER',
        'NONE',
        'OWNER'
    ]),
    body: z.string(),
    category: z.object({
        created_at: z.iso.datetime(),
        description: z.string(),
        emoji: z.string(),
        id: z.int(),
        is_answerable: z.boolean(),
        name: z.string(),
        node_id: z.optional(z.string()),
        repository_id: z.int(),
        slug: z.string(),
        updated_at: z.string()
    }),
    comments: z.int(),
    created_at: z.iso.datetime(),
    html_url: z.string(),
    id: z.int(),
    locked: z.boolean(),
    node_id: z.string(),
    number: z.int(),
    reactions: z.optional(z.object({
        '+1': z.int(),
        '-1': z.int(),
        confused: z.int(),
        eyes: z.int(),
        heart: z.int(),
        hooray: z.int(),
        laugh: z.int(),
        rocket: z.int(),
        total_count: z.int(),
        url: z.url()
    })),
    repository_url: z.string(),
    state: z.enum([
        'open',
        'closed',
        'locked',
        'converting',
        'transferring'
    ]),
    state_reason: z.enum([
        'resolved',
        'outdated',
        'duplicate',
        'reopened'
    ]),
    timeline_url: z.optional(z.string()),
    title: z.string(),
    updated_at: z.iso.datetime(),
    user: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.coerce.bigint(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ]),
    labels: z.optional(z.array(zLabel))
});

export const zWebhooksComment = z.object({
    author_association: z.enum([
        'COLLABORATOR',
        'CONTRIBUTOR',
        'FIRST_TIMER',
        'FIRST_TIME_CONTRIBUTOR',
        'MANNEQUIN',
        'MEMBER',
        'NONE',
        'OWNER'
    ]),
    body: z.string(),
    child_comment_count: z.int(),
    created_at: z.string(),
    discussion_id: z.int(),
    html_url: z.string(),
    id: z.int(),
    node_id: z.string(),
    parent_id: z.union([
        z.int(),
        z.null()
    ]),
    reactions: z.object({
        '+1': z.int(),
        '-1': z.int(),
        confused: z.int(),
        eyes: z.int(),
        heart: z.int(),
        hooray: z.int(),
        laugh: z.int(),
        rocket: z.int(),
        total_count: z.int(),
        url: z.url()
    }),
    repository_url: z.string(),
    updated_at: z.string(),
    user: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.coerce.bigint(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ])
});

/**
 * Label
 */
export const zWebhooksLabel = z.object({
    color: z.string(),
    default: z.boolean(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    id: z.int(),
    name: z.string(),
    node_id: z.string(),
    url: z.url()
});

/**
 * An array of repository objects that the installation can access.
 */
export const zWebhooksRepositories = z.array(z.object({
    full_name: z.string(),
    id: z.int(),
    name: z.string(),
    node_id: z.string(),
    private: z.boolean()
}));

/**
 * An array of repository objects, which were added to the installation.
 */
export const zWebhooksRepositoriesAdded = z.array(z.object({
    full_name: z.string(),
    id: z.int(),
    name: z.string(),
    node_id: z.string(),
    private: z.boolean()
}));

/**
 * Describe whether all repositories have been selected or there's a selection involved
 */
export const zWebhooksRepositorySelection = z.enum([
    'all',
    'selected'
]);

/**
 * issue comment
 *
 * The [comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment) itself.
 */
export const zWebhooksIssueComment = z.object({
    author_association: z.enum([
        'COLLABORATOR',
        'CONTRIBUTOR',
        'FIRST_TIMER',
        'FIRST_TIME_CONTRIBUTOR',
        'MANNEQUIN',
        'MEMBER',
        'NONE',
        'OWNER'
    ]),
    body: z.string(),
    created_at: z.iso.datetime(),
    html_url: z.url(),
    id: z.coerce.bigint(),
    issue_url: z.url(),
    node_id: z.string(),
    performed_via_github_app: zIntegration,
    reactions: z.object({
        '+1': z.int(),
        '-1': z.int(),
        confused: z.int(),
        eyes: z.int(),
        heart: z.int(),
        hooray: z.int(),
        laugh: z.int(),
        rocket: z.int(),
        total_count: z.int(),
        url: z.url()
    }),
    updated_at: z.iso.datetime(),
    url: z.url(),
    user: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.coerce.bigint(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization',
                'Mannequin'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ])
});

/**
 * The changes to the comment.
 */
export const zWebhooksChanges = z.object({
    body: z.optional(z.object({
        from: z.string()
    }))
});

/**
 * Issue
 *
 * The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
 */
export const zWebhooksIssue = z.object({
    active_lock_reason: z.nullable(z.enum([
        'resolved',
        'off-topic',
        'too heated',
        'spam'
    ])),
    assignee: z.optional(z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization',
                'Mannequin'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ])),
    assignees: z.array(z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization',
                'Mannequin'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ])),
    author_association: z.enum([
        'COLLABORATOR',
        'CONTRIBUTOR',
        'FIRST_TIMER',
        'FIRST_TIME_CONTRIBUTOR',
        'MANNEQUIN',
        'MEMBER',
        'NONE',
        'OWNER'
    ]),
    body: z.union([
        z.string(),
        z.null()
    ]),
    closed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    comments: z.int(),
    comments_url: z.url(),
    created_at: z.iso.datetime(),
    draft: z.optional(z.boolean()),
    events_url: z.url(),
    html_url: z.url(),
    id: z.coerce.bigint(),
    labels: z.optional(z.array(z.object({
        color: z.string(),
        default: z.boolean(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        id: z.int(),
        name: z.string(),
        node_id: z.string(),
        url: z.url()
    }))),
    labels_url: z.string(),
    locked: z.optional(z.boolean()),
    milestone: z.union([
        z.object({
            closed_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            closed_issues: z.int(),
            created_at: z.iso.datetime(),
            creator: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization',
                        'Mannequin'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            description: z.union([
                z.string(),
                z.null()
            ]),
            due_on: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            html_url: z.url(),
            id: z.int(),
            labels_url: z.url(),
            node_id: z.string(),
            number: z.int(),
            open_issues: z.int(),
            state: z.enum([
                'open',
                'closed'
            ]),
            title: z.string(),
            updated_at: z.iso.datetime(),
            url: z.url()
        }),
        z.null()
    ]),
    node_id: z.string(),
    number: z.int(),
    performed_via_github_app: z.optional(z.union([
        z.object({
            created_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            description: z.union([
                z.string(),
                z.null()
            ]),
            events: z.optional(z.array(z.enum([
                'branch_protection_rule',
                'check_run',
                'check_suite',
                'code_scanning_alert',
                'commit_comment',
                'content_reference',
                'create',
                'delete',
                'deployment',
                'deployment_review',
                'deployment_status',
                'deploy_key',
                'discussion',
                'discussion_comment',
                'fork',
                'gollum',
                'issues',
                'issue_comment',
                'label',
                'member',
                'membership',
                'milestone',
                'organization',
                'org_block',
                'page_build',
                'project',
                'project_card',
                'project_column',
                'public',
                'pull_request',
                'pull_request_review',
                'pull_request_review_comment',
                'push',
                'registry_package',
                'release',
                'repository',
                'repository_dispatch',
                'secret_scanning_alert',
                'star',
                'status',
                'team',
                'team_add',
                'watch',
                'workflow_dispatch',
                'workflow_run',
                'reminder',
                'pull_request_review_thread'
            ]))),
            external_url: z.union([
                z.url(),
                z.null()
            ]),
            html_url: z.url(),
            id: z.union([
                z.int(),
                z.null()
            ]),
            name: z.string(),
            node_id: z.string(),
            owner: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            permissions: z.optional(z.object({
                actions: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                administration: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                checks: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                content_references: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                contents: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                deployments: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                discussions: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                emails: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                environments: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                issues: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                keys: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                members: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                metadata: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_administration: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_hooks: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_packages: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_plan: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_projects: z.optional(z.enum([
                    'read',
                    'write',
                    'admin'
                ])),
                organization_secrets: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_self_hosted_runners: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_user_blocking: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                packages: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                pages: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                pull_requests: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                repository_hooks: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                repository_projects: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                secret_scanning_alerts: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                secrets: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                security_events: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                security_scanning_alert: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                single_file: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                statuses: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                team_discussions: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                vulnerability_alerts: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                workflows: z.optional(z.enum([
                    'read',
                    'write'
                ]))
            })),
            slug: z.optional(z.string()),
            updated_at: z.union([
                z.iso.datetime(),
                z.null()
            ])
        }),
        z.null()
    ])),
    pull_request: z.optional(z.object({
        diff_url: z.optional(z.url()),
        html_url: z.optional(z.url()),
        merged_at: z.optional(z.union([
            z.iso.datetime(),
            z.null()
        ])),
        patch_url: z.optional(z.url()),
        url: z.optional(z.url())
    })),
    reactions: z.object({
        '+1': z.int(),
        '-1': z.int(),
        confused: z.int(),
        eyes: z.int(),
        heart: z.int(),
        hooray: z.int(),
        laugh: z.int(),
        rocket: z.int(),
        total_count: z.int(),
        url: z.url()
    }),
    repository_url: z.url(),
    sub_issues_summary: z.optional(zSubIssuesSummary),
    issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
    issue_field_values: z.optional(z.array(zIssueFieldValue)),
    state: z.optional(z.enum([
        'open',
        'closed'
    ])),
    state_reason: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    timeline_url: z.optional(z.url()),
    title: z.string(),
    type: z.optional(zIssueType),
    updated_at: z.iso.datetime(),
    url: z.url(),
    user: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.coerce.bigint(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization',
                'Mannequin'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ])
});

/**
 * Milestone
 *
 * A collection of related issues and pull requests.
 */
export const zWebhooksMilestone = z.object({
    closed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    closed_issues: z.int(),
    created_at: z.iso.datetime(),
    creator: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization',
                'Mannequin'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ]),
    description: z.union([
        z.string(),
        z.null()
    ]),
    due_on: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    html_url: z.url(),
    id: z.int(),
    labels_url: z.url(),
    node_id: z.string(),
    number: z.int(),
    open_issues: z.int(),
    state: z.enum([
        'open',
        'closed'
    ]),
    title: z.string(),
    updated_at: z.iso.datetime(),
    url: z.url()
});

/**
 * Issue
 *
 * The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
 */
export const zWebhooksIssue2 = z.object({
    active_lock_reason: z.nullable(z.enum([
        'resolved',
        'off-topic',
        'too heated',
        'spam'
    ])),
    assignee: z.optional(z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ])),
    assignees: z.array(z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ])),
    author_association: z.enum([
        'COLLABORATOR',
        'CONTRIBUTOR',
        'FIRST_TIMER',
        'FIRST_TIME_CONTRIBUTOR',
        'MANNEQUIN',
        'MEMBER',
        'NONE',
        'OWNER'
    ]),
    body: z.union([
        z.string(),
        z.null()
    ]),
    closed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    comments: z.int(),
    comments_url: z.url(),
    created_at: z.iso.datetime(),
    draft: z.optional(z.boolean()),
    events_url: z.url(),
    html_url: z.url(),
    id: z.coerce.bigint(),
    labels: z.optional(z.array(z.object({
        color: z.string(),
        default: z.boolean(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        id: z.int(),
        name: z.string(),
        node_id: z.string(),
        url: z.url()
    }))),
    labels_url: z.string(),
    locked: z.optional(z.boolean()),
    milestone: z.union([
        z.object({
            closed_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            closed_issues: z.int(),
            created_at: z.iso.datetime(),
            creator: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            description: z.union([
                z.string(),
                z.null()
            ]),
            due_on: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            html_url: z.url(),
            id: z.int(),
            labels_url: z.url(),
            node_id: z.string(),
            number: z.int(),
            open_issues: z.int(),
            state: z.enum([
                'open',
                'closed'
            ]),
            title: z.string(),
            updated_at: z.iso.datetime(),
            url: z.url()
        }),
        z.null()
    ]),
    node_id: z.string(),
    number: z.int(),
    performed_via_github_app: z.optional(z.union([
        z.object({
            created_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            description: z.union([
                z.string(),
                z.null()
            ]),
            events: z.optional(z.array(z.enum([
                'branch_protection_rule',
                'check_run',
                'check_suite',
                'code_scanning_alert',
                'commit_comment',
                'content_reference',
                'create',
                'delete',
                'deployment',
                'deployment_review',
                'deployment_status',
                'deploy_key',
                'discussion',
                'discussion_comment',
                'fork',
                'gollum',
                'issues',
                'issue_comment',
                'label',
                'member',
                'membership',
                'milestone',
                'organization',
                'org_block',
                'page_build',
                'project',
                'project_card',
                'project_column',
                'public',
                'pull_request',
                'pull_request_review',
                'pull_request_review_comment',
                'push',
                'registry_package',
                'release',
                'repository',
                'repository_dispatch',
                'secret_scanning_alert',
                'star',
                'status',
                'team',
                'team_add',
                'watch',
                'workflow_dispatch',
                'workflow_run'
            ]))),
            external_url: z.union([
                z.url(),
                z.null()
            ]),
            html_url: z.url(),
            id: z.union([
                z.int(),
                z.null()
            ]),
            name: z.string(),
            node_id: z.string(),
            owner: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            permissions: z.optional(z.object({
                actions: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                administration: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                checks: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                content_references: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                contents: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                deployments: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                discussions: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                emails: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                environments: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                issues: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                keys: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                members: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                metadata: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_administration: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_hooks: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_packages: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_plan: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_projects: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_secrets: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_self_hosted_runners: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_user_blocking: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                packages: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                pages: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                pull_requests: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                repository_hooks: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                repository_projects: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                secret_scanning_alerts: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                secrets: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                security_events: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                security_scanning_alert: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                single_file: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                statuses: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                team_discussions: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                vulnerability_alerts: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                workflows: z.optional(z.enum([
                    'read',
                    'write'
                ]))
            })),
            slug: z.optional(z.string()),
            updated_at: z.union([
                z.iso.datetime(),
                z.null()
            ])
        }),
        z.null()
    ])),
    pull_request: z.optional(z.object({
        diff_url: z.optional(z.url()),
        html_url: z.optional(z.url()),
        merged_at: z.optional(z.union([
            z.iso.datetime(),
            z.null()
        ])),
        patch_url: z.optional(z.url()),
        url: z.optional(z.url())
    })),
    reactions: z.object({
        '+1': z.int(),
        '-1': z.int(),
        confused: z.int(),
        eyes: z.int(),
        heart: z.int(),
        hooray: z.int(),
        laugh: z.int(),
        rocket: z.int(),
        total_count: z.int(),
        url: z.url()
    }),
    repository_url: z.url(),
    sub_issues_summary: z.optional(zSubIssuesSummary),
    issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
    issue_field_values: z.optional(z.array(zIssueFieldValue)),
    state: z.optional(z.enum([
        'open',
        'closed'
    ])),
    state_reason: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    timeline_url: z.optional(z.url()),
    title: z.string(),
    type: z.optional(zIssueType),
    updated_at: z.iso.datetime(),
    url: z.url(),
    user: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.coerce.bigint(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ])
});

/**
 * User
 */
export const zWebhooksUserMannequin = z.union([
    z.object({
        avatar_url: z.optional(z.url()),
        deleted: z.optional(z.boolean()),
        email: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        events_url: z.optional(z.string()),
        followers_url: z.optional(z.url()),
        following_url: z.optional(z.string()),
        gists_url: z.optional(z.string()),
        gravatar_id: z.optional(z.string()),
        html_url: z.optional(z.url()),
        id: z.int(),
        login: z.string(),
        name: z.optional(z.string()),
        node_id: z.optional(z.string()),
        organizations_url: z.optional(z.url()),
        received_events_url: z.optional(z.url()),
        repos_url: z.optional(z.url()),
        site_admin: z.optional(z.boolean()),
        starred_url: z.optional(z.string()),
        subscriptions_url: z.optional(z.url()),
        type: z.optional(z.enum([
            'Bot',
            'User',
            'Organization',
            'Mannequin'
        ])),
        url: z.optional(z.url()),
        user_view_type: z.optional(z.string())
    }),
    z.null()
]);

/**
 * Marketplace Purchase
 */
export const zWebhooksMarketplacePurchase = z.object({
    account: z.object({
        id: z.int(),
        login: z.string(),
        node_id: z.string(),
        organization_billing_email: z.union([
            z.string(),
            z.null()
        ]),
        type: z.string()
    }),
    billing_cycle: z.string(),
    free_trial_ends_on: z.union([
        z.string(),
        z.null()
    ]),
    next_billing_date: z.union([
        z.string(),
        z.null()
    ]),
    on_free_trial: z.boolean(),
    plan: z.object({
        bullets: z.array(z.union([
            z.string(),
            z.null()
        ])),
        description: z.string(),
        has_free_trial: z.boolean(),
        id: z.int(),
        monthly_price_in_cents: z.int(),
        name: z.string(),
        price_model: z.enum([
            'FREE',
            'FLAT_RATE',
            'PER_UNIT'
        ]),
        unit_name: z.union([
            z.string(),
            z.null()
        ]),
        yearly_price_in_cents: z.int()
    }),
    unit_count: z.int()
});

/**
 * Marketplace Purchase
 */
export const zWebhooksPreviousMarketplacePurchase = z.object({
    account: z.object({
        id: z.int(),
        login: z.string(),
        node_id: z.string(),
        organization_billing_email: z.union([
            z.string(),
            z.null()
        ]),
        type: z.string()
    }),
    billing_cycle: z.string(),
    free_trial_ends_on: z.unknown(),
    next_billing_date: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    on_free_trial: z.boolean(),
    plan: z.object({
        bullets: z.array(z.string()),
        description: z.string(),
        has_free_trial: z.boolean(),
        id: z.int(),
        monthly_price_in_cents: z.int(),
        name: z.string(),
        price_model: z.enum([
            'FREE',
            'FLAT_RATE',
            'PER_UNIT'
        ]),
        unit_name: z.union([
            z.string(),
            z.null()
        ]),
        yearly_price_in_cents: z.int()
    }),
    unit_count: z.int()
});

/**
 * Team
 *
 * Groups of organization members that gives permissions on specified repositories.
 */
export const zWebhooksTeam = z.object({
    deleted: z.optional(z.boolean()),
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    html_url: z.optional(z.url()),
    id: z.int(),
    members_url: z.optional(z.string()),
    name: z.string(),
    node_id: z.optional(z.string()),
    parent: z.optional(z.union([
        z.object({
            description: z.union([
                z.string(),
                z.null()
            ]),
            html_url: z.url(),
            id: z.int(),
            members_url: z.string(),
            name: z.string(),
            node_id: z.string(),
            permission: z.string(),
            privacy: z.enum([
                'open',
                'closed',
                'secret'
            ]),
            notification_setting: z.enum([
                'notifications_enabled',
                'notifications_disabled'
            ]),
            repositories_url: z.url(),
            slug: z.string(),
            url: z.url(),
            type: z.enum([
                'enterprise',
                'organization'
            ]),
            organization_id: z.optional(z.int()),
            enterprise_id: z.optional(z.int())
        }),
        z.null()
    ])),
    permission: z.optional(z.string()),
    privacy: z.optional(z.enum([
        'open',
        'closed',
        'secret'
    ])),
    notification_setting: z.optional(z.enum([
        'notifications_enabled',
        'notifications_disabled'
    ])),
    repositories_url: z.optional(z.url()),
    slug: z.optional(z.string()),
    url: z.optional(z.url()),
    type: z.optional(z.enum([
        'enterprise',
        'organization'
    ])),
    organization_id: z.optional(z.int()),
    enterprise_id: z.optional(z.int())
});

/**
 * Merge Group
 *
 * A group of pull requests that the merge queue has grouped together to be merged.
 */
export const zMergeGroup = z.object({
    head_sha: z.string(),
    head_ref: z.string(),
    base_sha: z.string(),
    base_ref: z.string(),
    head_commit: zSimpleCommit
});

/**
 * Repository
 *
 * The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property
 * when the event occurs from activity in a repository.
 */
export const zNullableRepositoryWebhooks = z.union([
    z.object({
        id: z.coerce.bigint(),
        node_id: z.string(),
        name: z.string(),
        full_name: z.string(),
        license: zNullableLicenseSimple,
        organization: z.optional(zNullableSimpleUser),
        forks: z.int(),
        permissions: z.optional(z.object({
            admin: z.boolean(),
            pull: z.boolean(),
            triage: z.optional(z.boolean()),
            push: z.boolean(),
            maintain: z.optional(z.boolean())
        })),
        owner: zSimpleUser,
        private: z.boolean().default(false),
        html_url: z.url(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        fork: z.boolean(),
        url: z.url(),
        archive_url: z.string(),
        assignees_url: z.string(),
        blobs_url: z.string(),
        branches_url: z.string(),
        collaborators_url: z.string(),
        comments_url: z.string(),
        commits_url: z.string(),
        compare_url: z.string(),
        contents_url: z.string(),
        contributors_url: z.url(),
        deployments_url: z.url(),
        downloads_url: z.url(),
        events_url: z.url(),
        forks_url: z.url(),
        git_commits_url: z.string(),
        git_refs_url: z.string(),
        git_tags_url: z.string(),
        git_url: z.string(),
        issue_comment_url: z.string(),
        issue_events_url: z.string(),
        issues_url: z.string(),
        keys_url: z.string(),
        labels_url: z.string(),
        languages_url: z.url(),
        merges_url: z.url(),
        milestones_url: z.string(),
        notifications_url: z.string(),
        pulls_url: z.string(),
        releases_url: z.string(),
        ssh_url: z.string(),
        stargazers_url: z.url(),
        statuses_url: z.string(),
        subscribers_url: z.url(),
        subscription_url: z.url(),
        tags_url: z.url(),
        teams_url: z.url(),
        trees_url: z.string(),
        clone_url: z.string(),
        mirror_url: z.union([
            z.url(),
            z.null()
        ]),
        hooks_url: z.url(),
        svn_url: z.url(),
        homepage: z.union([
            z.url(),
            z.null()
        ]),
        language: z.union([
            z.string(),
            z.null()
        ]),
        forks_count: z.int(),
        stargazers_count: z.int(),
        watchers_count: z.int(),
        size: z.int(),
        default_branch: z.string(),
        open_issues_count: z.int(),
        is_template: z.optional(z.boolean()).default(false),
        topics: z.optional(z.array(z.string())),
        custom_properties: z.optional(z.record(z.string(), z.unknown())),
        has_issues: z.boolean().default(true),
        has_projects: z.boolean().default(true),
        has_wiki: z.boolean().default(true),
        has_pages: z.boolean(),
        has_downloads: z.boolean().default(true),
        has_discussions: z.optional(z.boolean()).default(false),
        archived: z.boolean().default(false),
        disabled: z.boolean(),
        visibility: z.optional(z.string()).default('public'),
        pushed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        created_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        updated_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        allow_rebase_merge: z.optional(z.boolean()).default(true),
        template_repository: z.optional(z.union([
            z.object({
                id: z.optional(z.int()),
                node_id: z.optional(z.string()),
                name: z.optional(z.string()),
                full_name: z.optional(z.string()),
                owner: z.optional(z.object({
                    login: z.optional(z.string()),
                    id: z.optional(z.int()),
                    node_id: z.optional(z.string()),
                    avatar_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    url: z.optional(z.string()),
                    html_url: z.optional(z.string()),
                    followers_url: z.optional(z.string()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.string()),
                    organizations_url: z.optional(z.string()),
                    repos_url: z.optional(z.string()),
                    events_url: z.optional(z.string()),
                    received_events_url: z.optional(z.string()),
                    type: z.optional(z.string()),
                    site_admin: z.optional(z.boolean())
                })),
                private: z.optional(z.boolean()),
                html_url: z.optional(z.string()),
                description: z.optional(z.string()),
                fork: z.optional(z.boolean()),
                url: z.optional(z.string()),
                archive_url: z.optional(z.string()),
                assignees_url: z.optional(z.string()),
                blobs_url: z.optional(z.string()),
                branches_url: z.optional(z.string()),
                collaborators_url: z.optional(z.string()),
                comments_url: z.optional(z.string()),
                commits_url: z.optional(z.string()),
                compare_url: z.optional(z.string()),
                contents_url: z.optional(z.string()),
                contributors_url: z.optional(z.string()),
                deployments_url: z.optional(z.string()),
                downloads_url: z.optional(z.string()),
                events_url: z.optional(z.string()),
                forks_url: z.optional(z.string()),
                git_commits_url: z.optional(z.string()),
                git_refs_url: z.optional(z.string()),
                git_tags_url: z.optional(z.string()),
                git_url: z.optional(z.string()),
                issue_comment_url: z.optional(z.string()),
                issue_events_url: z.optional(z.string()),
                issues_url: z.optional(z.string()),
                keys_url: z.optional(z.string()),
                labels_url: z.optional(z.string()),
                languages_url: z.optional(z.string()),
                merges_url: z.optional(z.string()),
                milestones_url: z.optional(z.string()),
                notifications_url: z.optional(z.string()),
                pulls_url: z.optional(z.string()),
                releases_url: z.optional(z.string()),
                ssh_url: z.optional(z.string()),
                stargazers_url: z.optional(z.string()),
                statuses_url: z.optional(z.string()),
                subscribers_url: z.optional(z.string()),
                subscription_url: z.optional(z.string()),
                tags_url: z.optional(z.string()),
                teams_url: z.optional(z.string()),
                trees_url: z.optional(z.string()),
                clone_url: z.optional(z.string()),
                mirror_url: z.optional(z.string()),
                hooks_url: z.optional(z.string()),
                svn_url: z.optional(z.string()),
                homepage: z.optional(z.string()),
                language: z.optional(z.string()),
                forks_count: z.optional(z.int()),
                stargazers_count: z.optional(z.int()),
                watchers_count: z.optional(z.int()),
                size: z.optional(z.int()),
                default_branch: z.optional(z.string()),
                open_issues_count: z.optional(z.int()),
                is_template: z.optional(z.boolean()),
                topics: z.optional(z.array(z.string())),
                has_issues: z.optional(z.boolean()),
                has_projects: z.optional(z.boolean()),
                has_wiki: z.optional(z.boolean()),
                has_pages: z.optional(z.boolean()),
                has_downloads: z.optional(z.boolean()),
                archived: z.optional(z.boolean()),
                disabled: z.optional(z.boolean()),
                visibility: z.optional(z.string()),
                pushed_at: z.optional(z.string()),
                created_at: z.optional(z.string()),
                updated_at: z.optional(z.string()),
                permissions: z.optional(z.object({
                    admin: z.optional(z.boolean()),
                    maintain: z.optional(z.boolean()),
                    push: z.optional(z.boolean()),
                    triage: z.optional(z.boolean()),
                    pull: z.optional(z.boolean())
                })),
                allow_rebase_merge: z.optional(z.boolean()),
                temp_clone_token: z.optional(z.string()),
                allow_squash_merge: z.optional(z.boolean()),
                allow_auto_merge: z.optional(z.boolean()),
                delete_branch_on_merge: z.optional(z.boolean()),
                allow_update_branch: z.optional(z.boolean()),
                use_squash_pr_title_as_default: z.optional(z.boolean()),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                allow_merge_commit: z.optional(z.boolean()),
                subscribers_count: z.optional(z.int()),
                network_count: z.optional(z.int())
            }),
            z.null()
        ])),
        temp_clone_token: z.optional(z.string()),
        allow_squash_merge: z.optional(z.boolean()).default(true),
        allow_auto_merge: z.optional(z.boolean()).default(false),
        delete_branch_on_merge: z.optional(z.boolean()).default(false),
        allow_update_branch: z.optional(z.boolean()).default(false),
        use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
        squash_merge_commit_title: z.optional(z.enum([
            'PR_TITLE',
            'COMMIT_OR_PR_TITLE'
        ])),
        squash_merge_commit_message: z.optional(z.enum([
            'PR_BODY',
            'COMMIT_MESSAGES',
            'BLANK'
        ])),
        merge_commit_title: z.optional(z.enum([
            'PR_TITLE',
            'MERGE_MESSAGE'
        ])),
        merge_commit_message: z.optional(z.enum([
            'PR_BODY',
            'PR_TITLE',
            'BLANK'
        ])),
        allow_merge_commit: z.optional(z.boolean()).default(true),
        allow_forking: z.optional(z.boolean()),
        web_commit_signoff_required: z.optional(z.boolean()).default(false),
        subscribers_count: z.optional(z.int()),
        network_count: z.optional(z.int()),
        open_issues: z.int(),
        watchers: z.int(),
        master_branch: z.optional(z.string()),
        starred_at: z.optional(z.string()),
        anonymous_access_enabled: z.optional(z.boolean())
    }),
    z.null()
]);

/**
 * Milestone
 *
 * A collection of related issues and pull requests.
 */
export const zWebhooksMilestone3 = z.object({
    closed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    closed_issues: z.int(),
    created_at: z.iso.datetime(),
    creator: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ]),
    description: z.union([
        z.string(),
        z.null()
    ]),
    due_on: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    html_url: z.url(),
    id: z.int(),
    labels_url: z.url(),
    node_id: z.string(),
    number: z.int(),
    open_issues: z.int(),
    state: z.enum([
        'open',
        'closed'
    ]),
    title: z.string(),
    updated_at: z.iso.datetime(),
    url: z.url()
});

/**
 * Membership
 *
 * The membership between the user and the organization. Not present when the action is `member_invited`.
 */
export const zWebhooksMembership = z.object({
    organization_url: z.url(),
    role: z.string(),
    direct_membership: z.optional(z.boolean()),
    enterprise_teams_providing_indirect_membership: z.optional(z.array(z.string()).max(100)),
    state: z.string(),
    url: z.url(),
    user: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.coerce.bigint(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ])
});

/**
 * Personal Access Token Request
 *
 * Details of a Personal Access Token Request.
 */
export const zPersonalAccessTokenRequest = z.object({
    id: z.int(),
    owner: zSimpleUser,
    permissions_added: z.object({
        organization: z.optional(z.record(z.string(), z.string())),
        repository: z.optional(z.record(z.string(), z.string())),
        other: z.optional(z.record(z.string(), z.string()))
    }),
    permissions_upgraded: z.object({
        organization: z.optional(z.record(z.string(), z.string())),
        repository: z.optional(z.record(z.string(), z.string())),
        other: z.optional(z.record(z.string(), z.string()))
    }),
    permissions_result: z.object({
        organization: z.optional(z.record(z.string(), z.string())),
        repository: z.optional(z.record(z.string(), z.string())),
        other: z.optional(z.record(z.string(), z.string()))
    }),
    repository_selection: z.enum([
        'none',
        'all',
        'subset'
    ]),
    repository_count: z.union([
        z.int(),
        z.null()
    ]),
    repositories: z.union([
        z.array(z.object({
            full_name: z.string(),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            private: z.boolean()
        })),
        z.null()
    ]),
    created_at: z.string(),
    token_id: z.int(),
    token_name: z.string(),
    token_expired: z.boolean(),
    token_expires_at: z.union([
        z.string(),
        z.null()
    ]),
    token_last_used_at: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Project Card
 */
export const zWebhooksProjectCard = z.object({
    after_id: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    archived: z.boolean(),
    column_id: z.int(),
    column_url: z.url(),
    content_url: z.optional(z.url()),
    created_at: z.iso.datetime(),
    creator: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ]),
    id: z.int(),
    node_id: z.string(),
    note: z.union([
        z.string(),
        z.null()
    ]),
    project_url: z.url(),
    updated_at: z.iso.datetime(),
    url: z.url()
});

/**
 * Project
 */
export const zWebhooksProject = z.object({
    body: z.union([
        z.string(),
        z.null()
    ]),
    columns_url: z.url(),
    created_at: z.iso.datetime(),
    creator: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ]),
    html_url: z.url(),
    id: z.int(),
    name: z.string(),
    node_id: z.string(),
    number: z.int(),
    owner_url: z.url(),
    state: z.enum([
        'open',
        'closed'
    ]),
    updated_at: z.iso.datetime(),
    url: z.url()
});

/**
 * Project Column
 */
export const zWebhooksProjectColumn = z.object({
    after_id: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    cards_url: z.url(),
    created_at: z.iso.datetime(),
    id: z.int(),
    name: z.string(),
    node_id: z.string(),
    project_url: z.url(),
    updated_at: z.iso.datetime(),
    url: z.url()
});

export const zWebhooksProjectChanges = z.object({
    archived_at: z.optional(z.object({
        from: z.optional(z.union([
            z.iso.datetime(),
            z.null()
        ])),
        to: z.optional(z.union([
            z.iso.datetime(),
            z.null()
        ]))
    }))
});

/**
 * Projects v2 Item
 *
 * An item belonging to a project
 */
export const zProjectsV2Item = z.object({
    id: z.number(),
    node_id: z.optional(z.string()),
    project_node_id: z.optional(z.string()),
    content_node_id: z.string(),
    content_type: zProjectsV2ItemContentType,
    creator: z.optional(zSimpleUser),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    archived_at: z.union([
        z.iso.datetime(),
        z.null()
    ])
});

/**
 * Projects v2 Single Select Option
 *
 * An option for a single select field
 */
export const zProjectsV2SingleSelectOption = z.object({
    id: z.string(),
    name: z.string(),
    color: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    description: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

/**
 * Projects v2 Iteration Setting
 *
 * An iteration setting for an iteration field
 */
export const zProjectsV2IterationSetting = z.object({
    id: z.string(),
    title: z.string(),
    title_html: z.optional(z.string()),
    duration: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    start_date: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    completed: z.optional(z.boolean())
});

/**
 * Projects v2 Status Update
 *
 * An status update belonging to a project
 */
export const zProjectsV2StatusUpdate = z.object({
    id: z.number(),
    node_id: z.string(),
    project_node_id: z.optional(z.string()),
    creator: z.optional(zSimpleUser),
    created_at: z.iso.datetime(),
    updated_at: z.iso.datetime(),
    status: z.optional(z.enum([
        'INACTIVE',
        'ON_TRACK',
        'AT_RISK',
        'OFF_TRACK',
        'COMPLETE'
    ])),
    start_date: z.optional(z.iso.date()),
    target_date: z.optional(z.iso.date()),
    body: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

/**
 * The pull request number.
 */
export const zWebhooksNumber = z.int();

export const zPullRequestWebhook = zPullRequest.and(z.object({
    allow_auto_merge: z.optional(z.boolean()).default(false),
    allow_update_branch: z.optional(z.boolean()),
    delete_branch_on_merge: z.optional(z.boolean()).default(false),
    merge_commit_message: z.optional(z.enum([
        'PR_BODY',
        'PR_TITLE',
        'BLANK'
    ])),
    merge_commit_title: z.optional(z.enum([
        'PR_TITLE',
        'MERGE_MESSAGE'
    ])),
    squash_merge_commit_message: z.optional(z.enum([
        'PR_BODY',
        'COMMIT_MESSAGES',
        'BLANK'
    ])),
    squash_merge_commit_title: z.optional(z.enum([
        'PR_TITLE',
        'COMMIT_OR_PR_TITLE'
    ])),
    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false)
}));

/**
 * Pull Request
 */
export const zWebhooksPullRequest5 = z.object({
    _links: z.object({
        comments: z.object({
            href: z.string()
        }),
        commits: z.object({
            href: z.string()
        }),
        html: z.object({
            href: z.string()
        }),
        issue: z.object({
            href: z.string()
        }),
        review_comment: z.object({
            href: z.string()
        }),
        review_comments: z.object({
            href: z.string()
        }),
        self: z.object({
            href: z.string()
        }),
        statuses: z.object({
            href: z.string()
        })
    }),
    active_lock_reason: z.nullable(z.enum([
        'resolved',
        'off-topic',
        'too heated',
        'spam'
    ])),
    additions: z.optional(z.int()),
    assignee: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization',
                'Mannequin'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ]),
    assignees: z.array(z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization',
                'Mannequin'
            ])),
            url: z.optional(z.url())
        }),
        z.null()
    ])),
    author_association: z.enum([
        'COLLABORATOR',
        'CONTRIBUTOR',
        'FIRST_TIMER',
        'FIRST_TIME_CONTRIBUTOR',
        'MANNEQUIN',
        'MEMBER',
        'NONE',
        'OWNER'
    ]),
    auto_merge: z.union([
        z.object({
            commit_message: z.union([
                z.string(),
                z.null()
            ]),
            commit_title: z.union([
                z.string(),
                z.null()
            ]),
            enabled_by: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            merge_method: z.enum([
                'merge',
                'squash',
                'rebase'
            ])
        }),
        z.null()
    ]),
    base: z.object({
        label: z.string(),
        ref: z.string(),
        repo: z.object({
            allow_auto_merge: z.optional(z.boolean()).default(false),
            allow_forking: z.optional(z.boolean()),
            allow_merge_commit: z.optional(z.boolean()).default(true),
            allow_rebase_merge: z.optional(z.boolean()).default(true),
            allow_squash_merge: z.optional(z.boolean()).default(true),
            allow_update_branch: z.optional(z.boolean()),
            archive_url: z.string(),
            archived: z.boolean().default(false),
            assignees_url: z.string(),
            blobs_url: z.string(),
            branches_url: z.string(),
            clone_url: z.url(),
            collaborators_url: z.string(),
            comments_url: z.string(),
            commits_url: z.string(),
            compare_url: z.string(),
            contents_url: z.string(),
            contributors_url: z.url(),
            created_at: z.union([
                z.int(),
                z.iso.datetime()
            ]),
            default_branch: z.string(),
            delete_branch_on_merge: z.optional(z.boolean()).default(false),
            deployments_url: z.url(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            disabled: z.optional(z.boolean()),
            downloads_url: z.url(),
            events_url: z.url(),
            fork: z.boolean(),
            forks: z.int(),
            forks_count: z.int(),
            forks_url: z.url(),
            full_name: z.string(),
            git_commits_url: z.string(),
            git_refs_url: z.string(),
            git_tags_url: z.string(),
            git_url: z.url(),
            has_downloads: z.boolean().default(true),
            has_issues: z.boolean().default(true),
            has_pages: z.boolean(),
            has_projects: z.boolean().default(true),
            has_wiki: z.boolean().default(true),
            has_discussions: z.boolean().default(false),
            homepage: z.union([
                z.string(),
                z.null()
            ]),
            hooks_url: z.url(),
            html_url: z.url(),
            id: z.coerce.bigint(),
            is_template: z.optional(z.boolean()),
            issue_comment_url: z.string(),
            issue_events_url: z.string(),
            issues_url: z.string(),
            keys_url: z.string(),
            labels_url: z.string(),
            language: z.union([
                z.string(),
                z.null()
            ]),
            languages_url: z.url(),
            license: z.union([
                z.object({
                    key: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    spdx_id: z.string(),
                    url: z.union([
                        z.url(),
                        z.null()
                    ])
                }),
                z.null()
            ]),
            master_branch: z.optional(z.string()),
            merge_commit_message: z.optional(z.enum([
                'PR_BODY',
                'PR_TITLE',
                'BLANK'
            ])),
            merge_commit_title: z.optional(z.enum([
                'PR_TITLE',
                'MERGE_MESSAGE'
            ])),
            merges_url: z.url(),
            milestones_url: z.string(),
            mirror_url: z.union([
                z.url(),
                z.null()
            ]),
            name: z.string(),
            node_id: z.string(),
            notifications_url: z.string(),
            open_issues: z.int(),
            open_issues_count: z.int(),
            organization: z.optional(z.string()),
            owner: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            permissions: z.optional(z.object({
                admin: z.boolean(),
                maintain: z.optional(z.boolean()),
                pull: z.boolean(),
                push: z.boolean(),
                triage: z.optional(z.boolean())
            })),
            private: z.boolean(),
            public: z.optional(z.boolean()),
            pulls_url: z.string(),
            pushed_at: z.union([
                z.int(),
                z.iso.datetime(),
                z.null()
            ]),
            releases_url: z.string(),
            role_name: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            size: z.int(),
            squash_merge_commit_message: z.optional(z.enum([
                'PR_BODY',
                'COMMIT_MESSAGES',
                'BLANK'
            ])),
            squash_merge_commit_title: z.optional(z.enum([
                'PR_TITLE',
                'COMMIT_OR_PR_TITLE'
            ])),
            ssh_url: z.string(),
            stargazers: z.optional(z.int()),
            stargazers_count: z.int(),
            stargazers_url: z.url(),
            statuses_url: z.string(),
            subscribers_url: z.url(),
            subscription_url: z.url(),
            svn_url: z.url(),
            tags_url: z.url(),
            teams_url: z.url(),
            topics: z.array(z.string()),
            trees_url: z.string(),
            updated_at: z.iso.datetime(),
            url: z.url(),
            use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
            visibility: z.enum([
                'public',
                'private',
                'internal'
            ]),
            watchers: z.int(),
            watchers_count: z.int(),
            web_commit_signoff_required: z.optional(z.boolean())
        }),
        sha: z.string(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    body: z.union([
        z.string(),
        z.null()
    ]),
    changed_files: z.optional(z.int()),
    closed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    comments: z.optional(z.int()),
    comments_url: z.url(),
    commits: z.optional(z.int()),
    commits_url: z.url(),
    created_at: z.iso.datetime(),
    deletions: z.optional(z.int()),
    diff_url: z.url(),
    draft: z.boolean(),
    head: z.object({
        label: z.string(),
        ref: z.string(),
        repo: z.object({
            allow_auto_merge: z.optional(z.boolean()).default(false),
            allow_forking: z.optional(z.boolean()),
            allow_merge_commit: z.optional(z.boolean()).default(true),
            allow_rebase_merge: z.optional(z.boolean()).default(true),
            allow_squash_merge: z.optional(z.boolean()).default(true),
            allow_update_branch: z.optional(z.boolean()),
            archive_url: z.string(),
            archived: z.boolean().default(false),
            assignees_url: z.string(),
            blobs_url: z.string(),
            branches_url: z.string(),
            clone_url: z.url(),
            collaborators_url: z.string(),
            comments_url: z.string(),
            commits_url: z.string(),
            compare_url: z.string(),
            contents_url: z.string(),
            contributors_url: z.url(),
            created_at: z.union([
                z.int(),
                z.iso.datetime()
            ]),
            default_branch: z.string(),
            delete_branch_on_merge: z.optional(z.boolean()).default(false),
            deployments_url: z.url(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            disabled: z.optional(z.boolean()),
            downloads_url: z.url(),
            events_url: z.url(),
            fork: z.boolean(),
            forks: z.int(),
            forks_count: z.int(),
            forks_url: z.url(),
            full_name: z.string(),
            git_commits_url: z.string(),
            git_refs_url: z.string(),
            git_tags_url: z.string(),
            git_url: z.url(),
            has_downloads: z.boolean().default(true),
            has_issues: z.boolean().default(true),
            has_pages: z.boolean(),
            has_projects: z.boolean().default(true),
            has_wiki: z.boolean().default(true),
            has_discussions: z.boolean().default(false),
            homepage: z.union([
                z.string(),
                z.null()
            ]),
            hooks_url: z.url(),
            html_url: z.url(),
            id: z.coerce.bigint(),
            is_template: z.optional(z.boolean()),
            issue_comment_url: z.string(),
            issue_events_url: z.string(),
            issues_url: z.string(),
            keys_url: z.string(),
            labels_url: z.string(),
            language: z.union([
                z.string(),
                z.null()
            ]),
            languages_url: z.url(),
            license: z.union([
                z.object({
                    key: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    spdx_id: z.string(),
                    url: z.union([
                        z.url(),
                        z.null()
                    ])
                }),
                z.null()
            ]),
            master_branch: z.optional(z.string()),
            merge_commit_message: z.optional(z.enum([
                'PR_BODY',
                'PR_TITLE',
                'BLANK'
            ])),
            merge_commit_title: z.optional(z.enum([
                'PR_TITLE',
                'MERGE_MESSAGE'
            ])),
            merges_url: z.url(),
            milestones_url: z.string(),
            mirror_url: z.union([
                z.url(),
                z.null()
            ]),
            name: z.string(),
            node_id: z.string(),
            notifications_url: z.string(),
            open_issues: z.int(),
            open_issues_count: z.int(),
            organization: z.optional(z.string()),
            owner: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            permissions: z.optional(z.object({
                admin: z.boolean(),
                maintain: z.optional(z.boolean()),
                pull: z.boolean(),
                push: z.boolean(),
                triage: z.optional(z.boolean())
            })),
            private: z.boolean(),
            public: z.optional(z.boolean()),
            pulls_url: z.string(),
            pushed_at: z.union([
                z.int(),
                z.iso.datetime(),
                z.null()
            ]),
            releases_url: z.string(),
            role_name: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            size: z.int(),
            squash_merge_commit_message: z.optional(z.enum([
                'PR_BODY',
                'COMMIT_MESSAGES',
                'BLANK'
            ])),
            squash_merge_commit_title: z.optional(z.enum([
                'PR_TITLE',
                'COMMIT_OR_PR_TITLE'
            ])),
            ssh_url: z.string(),
            stargazers: z.optional(z.int()),
            stargazers_count: z.int(),
            stargazers_url: z.url(),
            statuses_url: z.string(),
            subscribers_url: z.url(),
            subscription_url: z.url(),
            svn_url: z.url(),
            tags_url: z.url(),
            teams_url: z.url(),
            topics: z.array(z.string()),
            trees_url: z.string(),
            updated_at: z.iso.datetime(),
            url: z.url(),
            use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
            visibility: z.enum([
                'public',
                'private',
                'internal'
            ]),
            watchers: z.int(),
            watchers_count: z.int(),
            web_commit_signoff_required: z.optional(z.boolean())
        }),
        sha: z.string(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    html_url: z.url(),
    id: z.int(),
    issue_url: z.url(),
    labels: z.array(z.object({
        color: z.string(),
        default: z.boolean(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        id: z.int(),
        name: z.string(),
        node_id: z.string(),
        url: z.url()
    })),
    locked: z.boolean(),
    maintainer_can_modify: z.optional(z.boolean()),
    merge_commit_sha: z.union([
        z.string(),
        z.null()
    ]),
    mergeable: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    mergeable_state: z.optional(z.string()),
    merged: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    merged_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    merged_by: z.optional(z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization',
                'Mannequin'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ])),
    milestone: z.union([
        z.object({
            closed_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            closed_issues: z.int(),
            created_at: z.iso.datetime(),
            creator: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization',
                        'Mannequin'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            description: z.union([
                z.string(),
                z.null()
            ]),
            due_on: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            html_url: z.url(),
            id: z.int(),
            labels_url: z.url(),
            node_id: z.string(),
            number: z.int(),
            open_issues: z.int(),
            state: z.enum([
                'open',
                'closed'
            ]),
            title: z.string(),
            updated_at: z.iso.datetime(),
            url: z.url()
        }),
        z.null()
    ]),
    node_id: z.string(),
    number: z.int(),
    patch_url: z.url(),
    rebaseable: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    requested_reviewers: z.array(z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url())
        }),
        z.null(),
        z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })
    ])),
    requested_teams: z.array(z.object({
        deleted: z.optional(z.boolean()),
        description: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        html_url: z.optional(z.url()),
        id: z.int(),
        members_url: z.optional(z.string()),
        name: z.string(),
        node_id: z.optional(z.string()),
        parent: z.optional(z.union([
            z.object({
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                members_url: z.string(),
                name: z.string(),
                node_id: z.string(),
                permission: z.string(),
                privacy: z.enum([
                    'open',
                    'closed',
                    'secret'
                ]),
                repositories_url: z.url(),
                slug: z.string(),
                url: z.url()
            }),
            z.null()
        ])),
        permission: z.optional(z.string()),
        privacy: z.optional(z.enum([
            'open',
            'closed',
            'secret'
        ])),
        repositories_url: z.optional(z.url()),
        slug: z.optional(z.string()),
        url: z.optional(z.url())
    })),
    review_comment_url: z.string(),
    review_comments: z.optional(z.int()),
    review_comments_url: z.url(),
    state: z.enum([
        'open',
        'closed'
    ]),
    statuses_url: z.url(),
    title: z.string(),
    updated_at: z.iso.datetime(),
    url: z.url(),
    user: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.coerce.bigint(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization',
                'Mannequin'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ])
});

/**
 * Pull Request Review Comment
 *
 * The [comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request) itself.
 */
export const zWebhooksReviewComment = z.object({
    _links: z.object({
        html: z.object({
            href: z.string()
        }),
        pull_request: z.object({
            href: z.string()
        }),
        self: z.object({
            href: z.string()
        })
    }),
    author_association: z.enum([
        'COLLABORATOR',
        'CONTRIBUTOR',
        'FIRST_TIMER',
        'FIRST_TIME_CONTRIBUTOR',
        'MANNEQUIN',
        'MEMBER',
        'NONE',
        'OWNER'
    ]),
    body: z.string(),
    commit_id: z.string(),
    created_at: z.iso.datetime(),
    diff_hunk: z.string(),
    html_url: z.url(),
    id: z.int(),
    in_reply_to_id: z.optional(z.int()),
    line: z.union([
        z.int(),
        z.null()
    ]),
    node_id: z.string(),
    original_commit_id: z.string(),
    original_line: z.int(),
    original_position: z.int(),
    original_start_line: z.union([
        z.int(),
        z.null()
    ]),
    path: z.string(),
    position: z.union([
        z.int(),
        z.null()
    ]),
    pull_request_review_id: z.union([
        z.int(),
        z.null()
    ]),
    pull_request_url: z.url(),
    reactions: z.object({
        '+1': z.int(),
        '-1': z.int(),
        confused: z.int(),
        eyes: z.int(),
        heart: z.int(),
        hooray: z.int(),
        laugh: z.int(),
        rocket: z.int(),
        total_count: z.int(),
        url: z.url()
    }),
    side: z.enum([
        'LEFT',
        'RIGHT'
    ]),
    start_line: z.union([
        z.int(),
        z.null()
    ]),
    start_side: z.nullable(z.enum([
        'LEFT',
        'RIGHT'
    ])),
    subject_type: z.optional(z.enum([
        'line',
        'file'
    ])),
    updated_at: z.iso.datetime(),
    url: z.url(),
    user: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.coerce.bigint(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ])
});

/**
 * The review that was affected.
 */
export const zWebhooksReview = z.object({
    _links: z.object({
        html: z.object({
            href: z.string()
        }),
        pull_request: z.object({
            href: z.string()
        })
    }),
    author_association: z.enum([
        'COLLABORATOR',
        'CONTRIBUTOR',
        'FIRST_TIMER',
        'FIRST_TIME_CONTRIBUTOR',
        'MANNEQUIN',
        'MEMBER',
        'NONE',
        'OWNER'
    ]),
    body: z.union([
        z.string(),
        z.null()
    ]),
    commit_id: z.string(),
    html_url: z.url(),
    id: z.int(),
    node_id: z.string(),
    pull_request_url: z.url(),
    state: z.string(),
    submitted_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    updated_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    user: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.coerce.bigint(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ])
});

export const zWebhooksNullableString = z.union([
    z.string(),
    z.null()
]);

/**
 * Release
 *
 * The [release](https://docs.github.com/rest/releases/releases/#get-a-release) object.
 */
export const zWebhooksRelease = z.object({
    assets: z.array(z.object({
        browser_download_url: z.url(),
        content_type: z.string(),
        created_at: z.iso.datetime(),
        download_count: z.int(),
        id: z.int(),
        label: z.union([
            z.string(),
            z.null()
        ]),
        name: z.string(),
        node_id: z.string(),
        size: z.int(),
        digest: z.union([
            z.string(),
            z.null()
        ]),
        state: z.enum([
            'uploaded'
        ]),
        updated_at: z.iso.datetime(),
        uploader: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        url: z.url()
    })),
    assets_url: z.url(),
    author: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ]),
    body: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    updated_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    discussion_url: z.optional(z.url()),
    draft: z.boolean(),
    html_url: z.url(),
    id: z.int(),
    immutable: z.boolean(),
    name: z.union([
        z.string(),
        z.null()
    ]),
    node_id: z.string(),
    prerelease: z.boolean(),
    published_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    reactions: z.optional(z.object({
        '+1': z.int(),
        '-1': z.int(),
        confused: z.int(),
        eyes: z.int(),
        heart: z.int(),
        hooray: z.int(),
        laugh: z.int(),
        rocket: z.int(),
        total_count: z.int(),
        url: z.url()
    })),
    tag_name: z.string(),
    tarball_url: z.union([
        z.url(),
        z.null()
    ]),
    target_commitish: z.string(),
    upload_url: z.string(),
    url: z.url(),
    zipball_url: z.union([
        z.url(),
        z.null()
    ])
});

/**
 * Release
 *
 * The [release](https://docs.github.com/rest/releases/releases/#get-a-release) object.
 */
export const zWebhooksRelease1 = z.object({
    assets: z.array(z.union([
        z.object({
            browser_download_url: z.url(),
            content_type: z.string(),
            created_at: z.iso.datetime(),
            download_count: z.int(),
            id: z.int(),
            label: z.union([
                z.string(),
                z.null()
            ]),
            name: z.string(),
            node_id: z.string(),
            size: z.int(),
            digest: z.union([
                z.string(),
                z.null()
            ]),
            state: z.enum([
                'uploaded'
            ]),
            updated_at: z.iso.datetime(),
            uploader: z.optional(z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url())
                }),
                z.null()
            ])),
            url: z.url()
        }),
        z.null()
    ])),
    assets_url: z.url(),
    author: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ]),
    body: z.union([
        z.string(),
        z.null()
    ]),
    created_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    discussion_url: z.optional(z.url()),
    draft: z.boolean(),
    html_url: z.url(),
    id: z.int(),
    immutable: z.boolean(),
    name: z.union([
        z.string(),
        z.null()
    ]),
    node_id: z.string(),
    prerelease: z.boolean(),
    published_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    reactions: z.optional(z.object({
        '+1': z.int(),
        '-1': z.int(),
        confused: z.int(),
        eyes: z.int(),
        heart: z.int(),
        hooray: z.int(),
        laugh: z.int(),
        rocket: z.int(),
        total_count: z.int(),
        url: z.url()
    })),
    tag_name: z.string(),
    tarball_url: z.union([
        z.url(),
        z.null()
    ]),
    target_commitish: z.string(),
    updated_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    upload_url: z.string(),
    url: z.url(),
    zipball_url: z.union([
        z.url(),
        z.null()
    ])
});

/**
 * Repository Vulnerability Alert Alert
 *
 * The security alert of the vulnerable dependency.
 */
export const zWebhooksAlert = z.object({
    affected_package_name: z.string(),
    affected_range: z.string(),
    created_at: z.string(),
    dismiss_reason: z.optional(z.string()),
    dismissed_at: z.optional(z.string()),
    dismisser: z.optional(z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url())
        }),
        z.null()
    ])),
    external_identifier: z.string(),
    external_reference: z.union([
        z.url(),
        z.null()
    ]),
    fix_reason: z.optional(z.string()),
    fixed_at: z.optional(z.iso.datetime()),
    fixed_in: z.optional(z.string()),
    ghsa_id: z.string(),
    id: z.int(),
    node_id: z.string(),
    number: z.int(),
    severity: z.string(),
    state: z.enum([
        'open'
    ])
});

/**
 * The reason for resolving the alert.
 */
export const zSecretScanningAlertResolutionWebhook = z.enum([
    'false_positive',
    'wont_fix',
    'revoked',
    'used_in_tests',
    'pattern_deleted',
    'pattern_edited'
]);

export const zSecretScanningAlertWebhook = z.object({
    number: z.optional(zAlertNumber),
    created_at: z.optional(zAlertCreatedAt),
    updated_at: z.optional(zNullableAlertUpdatedAt),
    url: z.optional(zAlertUrl),
    html_url: z.optional(zAlertHtmlUrl),
    locations_url: z.optional(z.url()),
    resolution: z.optional(zSecretScanningAlertResolutionWebhook),
    resolved_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    resolved_by: z.optional(zNullableSimpleUser),
    resolution_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    secret_type: z.optional(z.string()),
    secret_type_display_name: z.optional(z.string()),
    validity: z.optional(z.enum([
        'active',
        'inactive',
        'unknown'
    ])),
    push_protection_bypassed: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    push_protection_bypassed_by: z.optional(zNullableSimpleUser),
    push_protection_bypassed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    push_protection_bypass_request_reviewer: z.optional(zNullableSimpleUser),
    push_protection_bypass_request_reviewer_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    push_protection_bypass_request_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    push_protection_bypass_request_html_url: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    publicly_leaked: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    multi_repo: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    assigned_to: z.optional(zNullableSimpleUser)
});

/**
 * The details of the security advisory, including summary, description, and severity.
 */
export const zWebhooksSecurityAdvisory = z.object({
    cvss: z.object({
        score: z.number(),
        vector_string: z.union([
            z.string(),
            z.null()
        ])
    }),
    cvss_severities: z.optional(zCvssSeverities),
    cwes: z.array(z.object({
        cwe_id: z.string(),
        name: z.string()
    })),
    description: z.string(),
    ghsa_id: z.string(),
    identifiers: z.array(z.object({
        type: z.string(),
        value: z.string()
    })),
    published_at: z.string(),
    references: z.array(z.object({
        url: z.url()
    })),
    severity: z.string(),
    summary: z.string(),
    updated_at: z.string(),
    vulnerabilities: z.array(z.object({
        first_patched_version: z.union([
            z.object({
                identifier: z.string()
            }),
            z.null()
        ]),
        package: z.object({
            ecosystem: z.string(),
            name: z.string()
        }),
        severity: z.string(),
        vulnerable_version_range: z.string()
    })),
    withdrawn_at: z.union([
        z.string(),
        z.null()
    ])
});

export const zWebhooksSponsorship = z.object({
    created_at: z.string(),
    maintainer: z.optional(z.object({
        avatar_url: z.optional(z.string()),
        events_url: z.optional(z.string()),
        followers_url: z.optional(z.string()),
        following_url: z.optional(z.string()),
        gists_url: z.optional(z.string()),
        gravatar_id: z.optional(z.string()),
        html_url: z.optional(z.string()),
        id: z.optional(z.int()),
        login: z.optional(z.string()),
        node_id: z.optional(z.string()),
        organizations_url: z.optional(z.string()),
        received_events_url: z.optional(z.string()),
        repos_url: z.optional(z.string()),
        site_admin: z.optional(z.boolean()),
        starred_url: z.optional(z.string()),
        subscriptions_url: z.optional(z.string()),
        type: z.optional(z.string()),
        url: z.optional(z.string()),
        user_view_type: z.optional(z.string())
    })),
    node_id: z.string(),
    privacy_level: z.string(),
    sponsor: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ]),
    sponsorable: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ]),
    tier: z.object({
        created_at: z.string(),
        description: z.string(),
        is_custom_ammount: z.optional(z.boolean()),
        is_custom_amount: z.optional(z.boolean()),
        is_one_time: z.boolean(),
        monthly_price_in_cents: z.int(),
        monthly_price_in_dollars: z.int(),
        name: z.string(),
        node_id: z.string()
    })
});

/**
 * The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect.
 */
export const zWebhooksEffectiveDate = z.string();

export const zWebhooksChanges8 = z.object({
    tier: z.object({
        from: z.object({
            created_at: z.string(),
            description: z.string(),
            is_custom_ammount: z.optional(z.boolean()),
            is_custom_amount: z.optional(z.boolean()),
            is_one_time: z.boolean(),
            monthly_price_in_cents: z.int(),
            monthly_price_in_dollars: z.int(),
            name: z.string(),
            node_id: z.string()
        })
    })
});

/**
 * Team
 *
 * Groups of organization members that gives permissions on specified repositories.
 */
export const zWebhooksTeam1 = z.object({
    deleted: z.optional(z.boolean()),
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    html_url: z.optional(z.url()),
    id: z.int(),
    members_url: z.optional(z.string()),
    name: z.string(),
    node_id: z.optional(z.string()),
    parent: z.optional(z.union([
        z.object({
            description: z.union([
                z.string(),
                z.null()
            ]),
            html_url: z.url(),
            id: z.int(),
            members_url: z.string(),
            name: z.string(),
            node_id: z.string(),
            permission: z.string(),
            privacy: z.enum([
                'open',
                'closed',
                'secret'
            ]),
            notification_setting: z.enum([
                'notifications_enabled',
                'notifications_disabled'
            ]),
            repositories_url: z.url(),
            slug: z.string(),
            url: z.url(),
            type: z.enum([
                'enterprise',
                'organization'
            ]),
            organization_id: z.optional(z.int()),
            enterprise_id: z.optional(z.int())
        }),
        z.null()
    ])),
    permission: z.optional(z.string()),
    privacy: z.optional(z.enum([
        'open',
        'closed',
        'secret'
    ])),
    notification_setting: z.optional(z.enum([
        'notifications_enabled',
        'notifications_disabled'
    ])),
    repositories_url: z.optional(z.url()),
    slug: z.optional(z.string()),
    url: z.optional(z.url()),
    type: z.optional(z.enum([
        'enterprise',
        'organization'
    ])),
    organization_id: z.optional(z.int()),
    enterprise_id: z.optional(z.int())
});

/**
 * branch protection configuration disabled event
 */
export const zWebhookBranchProtectionConfigurationDisabled = z.object({
    action: z.enum([
        'disabled'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * branch protection configuration enabled event
 */
export const zWebhookBranchProtectionConfigurationEnabled = z.object({
    action: z.enum([
        'enabled'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * branch protection rule created event
 */
export const zWebhookBranchProtectionRuleCreated = z.object({
    action: z.enum([
        'created'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    rule: zWebhooksRule,
    sender: zSimpleUser
});

/**
 * branch protection rule deleted event
 */
export const zWebhookBranchProtectionRuleDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    rule: zWebhooksRule,
    sender: zSimpleUser
});

/**
 * branch protection rule edited event
 */
export const zWebhookBranchProtectionRuleEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.optional(z.object({
        admin_enforced: z.optional(z.object({
            from: z.union([
                z.boolean(),
                z.null()
            ])
        })),
        authorized_actor_names: z.optional(z.object({
            from: z.array(z.string())
        })),
        authorized_actors_only: z.optional(z.object({
            from: z.union([
                z.boolean(),
                z.null()
            ])
        })),
        authorized_dismissal_actors_only: z.optional(z.object({
            from: z.union([
                z.boolean(),
                z.null()
            ])
        })),
        linear_history_requirement_enforcement_level: z.optional(z.object({
            from: z.enum([
                'off',
                'non_admins',
                'everyone'
            ])
        })),
        lock_branch_enforcement_level: z.optional(z.object({
            from: z.enum([
                'off',
                'non_admins',
                'everyone'
            ])
        })),
        lock_allows_fork_sync: z.optional(z.object({
            from: z.union([
                z.boolean(),
                z.null()
            ])
        })),
        pull_request_reviews_enforcement_level: z.optional(z.object({
            from: z.enum([
                'off',
                'non_admins',
                'everyone'
            ])
        })),
        require_last_push_approval: z.optional(z.object({
            from: z.union([
                z.boolean(),
                z.null()
            ])
        })),
        required_status_checks: z.optional(z.object({
            from: z.array(z.string())
        })),
        required_status_checks_enforcement_level: z.optional(z.object({
            from: z.enum([
                'off',
                'non_admins',
                'everyone'
            ])
        }))
    })),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    rule: zWebhooksRule,
    sender: zSimpleUser
});

/**
 * Check Run Completed Event
 */
export const zWebhookCheckRunCompleted = z.object({
    action: z.optional(z.enum([
        'completed'
    ])),
    check_run: zCheckRunWithSimpleCheckSuite,
    installation: z.optional(zSimpleInstallation),
    enterprise: z.optional(zEnterpriseWebhooks),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Check Run Completed Event
 *
 * The check_run.completed webhook encoded with URL encoding
 */
export const zWebhookCheckRunCompletedFormEncoded = z.object({
    payload: z.string()
});

/**
 * Check Run Created Event
 */
export const zWebhookCheckRunCreated = z.object({
    action: z.optional(z.enum([
        'created'
    ])),
    check_run: zCheckRunWithSimpleCheckSuite,
    installation: z.optional(zSimpleInstallation),
    enterprise: z.optional(zEnterpriseWebhooks),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Check Run Created Event
 *
 * The check_run.created webhook encoded with URL encoding
 */
export const zWebhookCheckRunCreatedFormEncoded = z.object({
    payload: z.string()
});

/**
 * Check Run Requested Action Event
 */
export const zWebhookCheckRunRequestedAction = z.object({
    action: z.enum([
        'requested_action'
    ]),
    check_run: zCheckRunWithSimpleCheckSuite,
    installation: z.optional(zSimpleInstallation),
    enterprise: z.optional(zEnterpriseWebhooks),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    requested_action: z.optional(z.object({
        identifier: z.optional(z.string())
    })),
    sender: zSimpleUser
});

/**
 * Check Run Requested Action Event
 *
 * The check_run.requested_action webhook encoded with URL encoding
 */
export const zWebhookCheckRunRequestedActionFormEncoded = z.object({
    payload: z.string()
});

/**
 * Check Run Re-Requested Event
 */
export const zWebhookCheckRunRerequested = z.object({
    action: z.optional(z.enum([
        'rerequested'
    ])),
    check_run: zCheckRunWithSimpleCheckSuite,
    installation: z.optional(zSimpleInstallation),
    enterprise: z.optional(zEnterpriseWebhooks),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Check Run Re-Requested Event
 *
 * The check_run.rerequested webhook encoded with URL encoding
 */
export const zWebhookCheckRunRerequestedFormEncoded = z.object({
    payload: z.string()
});

/**
 * check_suite completed event
 */
export const zWebhookCheckSuiteCompleted = z.object({
    action: z.enum([
        'completed'
    ]),
    check_suite: z.object({
        after: z.union([
            z.string(),
            z.null()
        ]),
        app: z.object({
            created_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            description: z.union([
                z.string(),
                z.null()
            ]),
            events: z.optional(z.array(z.enum([
                'branch_protection_rule',
                'check_run',
                'check_suite',
                'code_scanning_alert',
                'commit_comment',
                'content_reference',
                'create',
                'delete',
                'deployment',
                'deployment_review',
                'deployment_status',
                'deploy_key',
                'discussion',
                'discussion_comment',
                'fork',
                'gollum',
                'issues',
                'issue_comment',
                'label',
                'member',
                'membership',
                'milestone',
                'organization',
                'org_block',
                'page_build',
                'project',
                'project_card',
                'project_column',
                'public',
                'pull_request',
                'pull_request_review',
                'pull_request_review_comment',
                'push',
                'registry_package',
                'release',
                'repository',
                'repository_dispatch',
                'secret_scanning_alert',
                'star',
                'status',
                'team',
                'team_add',
                'watch',
                'workflow_dispatch',
                'workflow_run',
                'merge_group',
                'pull_request_review_thread',
                'workflow_job',
                'merge_queue_entry',
                'security_and_analysis',
                'projects_v2_item',
                'secret_scanning_alert_location'
            ]))),
            external_url: z.union([
                z.url(),
                z.null()
            ]),
            html_url: z.url(),
            id: z.union([
                z.int(),
                z.null()
            ]),
            client_id: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            name: z.string(),
            node_id: z.string(),
            owner: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            permissions: z.optional(z.object({
                actions: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                administration: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                checks: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                content_references: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                contents: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                deployments: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                discussions: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                emails: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                environments: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                issues: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                keys: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                members: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                metadata: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_administration: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_hooks: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_packages: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_plan: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_projects: z.optional(z.enum([
                    'read',
                    'write',
                    'admin'
                ])),
                organization_secrets: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_self_hosted_runners: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_user_blocking: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                packages: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                pages: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                pull_requests: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                repository_hooks: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                repository_projects: z.optional(z.enum([
                    'read',
                    'write',
                    'admin'
                ])),
                secret_scanning_alerts: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                secrets: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                security_events: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                security_scanning_alert: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                single_file: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                statuses: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                team_discussions: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                vulnerability_alerts: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                workflows: z.optional(z.enum([
                    'read',
                    'write'
                ]))
            })),
            slug: z.optional(z.string()),
            updated_at: z.union([
                z.iso.datetime(),
                z.null()
            ])
        }),
        before: z.union([
            z.string(),
            z.null()
        ]),
        check_runs_url: z.url(),
        conclusion: z.nullable(z.enum([
            'success',
            'failure',
            'neutral',
            'cancelled',
            'timed_out',
            'action_required',
            'stale',
            'skipped',
            'startup_failure'
        ])),
        created_at: z.iso.datetime(),
        head_branch: z.union([
            z.string(),
            z.null()
        ]),
        head_commit: z.object({
            author: z.object({
                date: z.optional(z.iso.datetime()),
                email: z.union([
                    z.email(),
                    z.null()
                ]),
                name: z.string(),
                username: z.optional(z.string())
            }),
            committer: z.object({
                date: z.optional(z.iso.datetime()),
                email: z.union([
                    z.email(),
                    z.null()
                ]),
                name: z.string(),
                username: z.optional(z.string())
            }),
            id: z.string(),
            message: z.string(),
            timestamp: z.string(),
            tree_id: z.string()
        }),
        head_sha: z.string(),
        id: z.int(),
        latest_check_runs_count: z.int(),
        node_id: z.string(),
        pull_requests: z.array(z.object({
            base: z.object({
                ref: z.string(),
                repo: z.object({
                    id: z.int(),
                    name: z.string(),
                    url: z.url()
                }),
                sha: z.string()
            }),
            head: z.object({
                ref: z.string(),
                repo: z.object({
                    id: z.int(),
                    name: z.string(),
                    url: z.url()
                }),
                sha: z.string()
            }),
            id: z.int(),
            number: z.int(),
            url: z.url()
        })),
        rerequestable: z.optional(z.boolean()),
        runs_rerequestable: z.optional(z.boolean()),
        status: z.nullable(z.enum([
            'requested',
            'in_progress',
            'completed',
            'queued',
            'pending'
        ])),
        updated_at: z.iso.datetime(),
        url: z.url()
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * check_suite requested event
 */
export const zWebhookCheckSuiteRequested = z.object({
    action: z.enum([
        'requested'
    ]),
    check_suite: z.object({
        after: z.union([
            z.string(),
            z.null()
        ]),
        app: z.object({
            created_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            description: z.union([
                z.string(),
                z.null()
            ]),
            events: z.optional(z.array(z.enum([
                'branch_protection_rule',
                'check_run',
                'check_suite',
                'code_scanning_alert',
                'commit_comment',
                'content_reference',
                'create',
                'delete',
                'deployment',
                'deployment_review',
                'deployment_status',
                'deploy_key',
                'discussion',
                'discussion_comment',
                'fork',
                'gollum',
                'issues',
                'issue_comment',
                'label',
                'member',
                'membership',
                'milestone',
                'organization',
                'org_block',
                'page_build',
                'project',
                'project_card',
                'project_column',
                'public',
                'pull_request',
                'pull_request_review',
                'pull_request_review_comment',
                'push',
                'registry_package',
                'release',
                'repository',
                'repository_dispatch',
                'secret_scanning_alert',
                'star',
                'status',
                'team',
                'team_add',
                'watch',
                'workflow_dispatch',
                'workflow_run',
                'pull_request_review_thread',
                'workflow_job',
                'merge_queue_entry',
                'security_and_analysis',
                'secret_scanning_alert_location',
                'projects_v2_item',
                'merge_group',
                'repository_import'
            ]))),
            external_url: z.union([
                z.url(),
                z.null()
            ]),
            html_url: z.url(),
            id: z.union([
                z.int(),
                z.null()
            ]),
            client_id: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            name: z.string(),
            node_id: z.string(),
            owner: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            permissions: z.optional(z.object({
                actions: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                administration: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                checks: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                content_references: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                contents: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                deployments: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                discussions: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                emails: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                environments: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                issues: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                keys: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                members: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                metadata: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_administration: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_hooks: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_packages: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_plan: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_projects: z.optional(z.enum([
                    'read',
                    'write',
                    'admin'
                ])),
                organization_secrets: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_self_hosted_runners: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_user_blocking: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                packages: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                pages: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                pull_requests: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                repository_hooks: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                repository_projects: z.optional(z.enum([
                    'read',
                    'write',
                    'admin'
                ])),
                secret_scanning_alerts: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                secrets: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                security_events: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                security_scanning_alert: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                single_file: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                statuses: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                team_discussions: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                vulnerability_alerts: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                workflows: z.optional(z.enum([
                    'read',
                    'write'
                ]))
            })),
            slug: z.optional(z.string()),
            updated_at: z.union([
                z.iso.datetime(),
                z.null()
            ])
        }),
        before: z.union([
            z.string(),
            z.null()
        ]),
        check_runs_url: z.url(),
        conclusion: z.nullable(z.enum([
            'success',
            'failure',
            'neutral',
            'cancelled',
            'timed_out',
            'action_required',
            'stale',
            'skipped'
        ])),
        created_at: z.iso.datetime(),
        head_branch: z.union([
            z.string(),
            z.null()
        ]),
        head_commit: z.object({
            author: z.object({
                date: z.optional(z.iso.datetime()),
                email: z.union([
                    z.email(),
                    z.null()
                ]),
                name: z.string(),
                username: z.optional(z.string())
            }),
            committer: z.object({
                date: z.optional(z.iso.datetime()),
                email: z.union([
                    z.email(),
                    z.null()
                ]),
                name: z.string(),
                username: z.optional(z.string())
            }),
            id: z.string(),
            message: z.string(),
            timestamp: z.string(),
            tree_id: z.string()
        }),
        head_sha: z.string(),
        id: z.int(),
        latest_check_runs_count: z.int(),
        node_id: z.string(),
        pull_requests: z.array(z.object({
            base: z.object({
                ref: z.string(),
                repo: z.object({
                    id: z.int(),
                    name: z.string(),
                    url: z.url()
                }),
                sha: z.string()
            }),
            head: z.object({
                ref: z.string(),
                repo: z.object({
                    id: z.int(),
                    name: z.string(),
                    url: z.url()
                }),
                sha: z.string()
            }),
            id: z.int(),
            number: z.int(),
            url: z.url()
        })),
        rerequestable: z.optional(z.boolean()),
        runs_rerequestable: z.optional(z.boolean()),
        status: z.nullable(z.enum([
            'requested',
            'in_progress',
            'completed',
            'queued'
        ])),
        updated_at: z.iso.datetime(),
        url: z.url()
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * check_suite rerequested event
 */
export const zWebhookCheckSuiteRerequested = z.object({
    action: z.enum([
        'rerequested'
    ]),
    check_suite: z.object({
        after: z.union([
            z.string(),
            z.null()
        ]),
        app: z.object({
            created_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            description: z.union([
                z.string(),
                z.null()
            ]),
            events: z.optional(z.array(z.enum([
                'branch_protection_rule',
                'check_run',
                'check_suite',
                'code_scanning_alert',
                'commit_comment',
                'content_reference',
                'create',
                'delete',
                'deployment',
                'deployment_review',
                'deployment_status',
                'deploy_key',
                'discussion',
                'discussion_comment',
                'fork',
                'gollum',
                'issues',
                'issue_comment',
                'label',
                'member',
                'membership',
                'milestone',
                'organization',
                'org_block',
                'page_build',
                'project',
                'project_card',
                'project_column',
                'public',
                'pull_request',
                'pull_request_review',
                'pull_request_review_comment',
                'push',
                'registry_package',
                'release',
                'repository',
                'repository_dispatch',
                'secret_scanning_alert',
                'star',
                'status',
                'team',
                'team_add',
                'watch',
                'workflow_dispatch',
                'workflow_run',
                'pull_request_review_thread',
                'merge_queue_entry',
                'workflow_job'
            ]))),
            external_url: z.union([
                z.url(),
                z.null()
            ]),
            html_url: z.url(),
            id: z.union([
                z.int(),
                z.null()
            ]),
            client_id: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            name: z.string(),
            node_id: z.string(),
            owner: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            permissions: z.optional(z.object({
                actions: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                administration: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                checks: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                content_references: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                contents: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                deployments: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                discussions: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                emails: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                environments: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                issues: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                keys: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                members: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                metadata: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_administration: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_hooks: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_packages: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_plan: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_projects: z.optional(z.enum([
                    'read',
                    'write',
                    'admin'
                ])),
                organization_secrets: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_self_hosted_runners: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                organization_user_blocking: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                packages: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                pages: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                pull_requests: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                repository_hooks: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                repository_projects: z.optional(z.enum([
                    'read',
                    'write',
                    'admin'
                ])),
                secret_scanning_alerts: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                secrets: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                security_events: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                security_scanning_alert: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                single_file: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                statuses: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                team_discussions: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                vulnerability_alerts: z.optional(z.enum([
                    'read',
                    'write'
                ])),
                workflows: z.optional(z.enum([
                    'read',
                    'write'
                ]))
            })),
            slug: z.optional(z.string()),
            updated_at: z.union([
                z.iso.datetime(),
                z.null()
            ])
        }),
        before: z.union([
            z.string(),
            z.null()
        ]),
        check_runs_url: z.url(),
        conclusion: z.nullable(z.enum([
            'success',
            'failure',
            'neutral',
            'cancelled',
            'timed_out',
            'action_required',
            'stale'
        ])),
        created_at: z.iso.datetime(),
        head_branch: z.union([
            z.string(),
            z.null()
        ]),
        head_commit: z.object({
            author: z.object({
                date: z.optional(z.iso.datetime()),
                email: z.union([
                    z.email(),
                    z.null()
                ]),
                name: z.string(),
                username: z.optional(z.string())
            }),
            committer: z.object({
                date: z.optional(z.iso.datetime()),
                email: z.union([
                    z.email(),
                    z.null()
                ]),
                name: z.string(),
                username: z.optional(z.string())
            }),
            id: z.string(),
            message: z.string(),
            timestamp: z.string(),
            tree_id: z.string()
        }),
        head_sha: z.string(),
        id: z.int(),
        latest_check_runs_count: z.int(),
        node_id: z.string(),
        pull_requests: z.array(z.object({
            base: z.object({
                ref: z.string(),
                repo: z.object({
                    id: z.int(),
                    name: z.string(),
                    url: z.url()
                }),
                sha: z.string()
            }),
            head: z.object({
                ref: z.string(),
                repo: z.object({
                    id: z.int(),
                    name: z.string(),
                    url: z.url()
                }),
                sha: z.string()
            }),
            id: z.int(),
            number: z.int(),
            url: z.url()
        })),
        rerequestable: z.optional(z.boolean()),
        runs_rerequestable: z.optional(z.boolean()),
        status: z.nullable(z.enum([
            'requested',
            'in_progress',
            'completed',
            'queued'
        ])),
        updated_at: z.iso.datetime(),
        url: z.url()
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * code_scanning_alert appeared_in_branch event
 */
export const zWebhookCodeScanningAlertAppearedInBranch = z.object({
    action: z.enum([
        'appeared_in_branch'
    ]),
    alert: z.object({
        assignees: z.optional(z.array(zSimpleUser)),
        created_at: z.iso.datetime(),
        dismissed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        dismissed_by: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        dismissed_comment: z.optional(zCodeScanningAlertDismissedComment),
        dismissed_reason: z.nullable(z.enum([
            'false positive',
            "won't fix",
            'used in tests'
        ])),
        fixed_at: z.optional(z.unknown()),
        html_url: z.url(),
        most_recent_instance: z.optional(z.union([
            z.object({
                analysis_key: z.string(),
                category: z.optional(z.string()),
                classifications: z.optional(z.array(z.string())),
                commit_sha: z.optional(z.string()),
                environment: z.string(),
                location: z.optional(z.object({
                    end_column: z.optional(z.int()),
                    end_line: z.optional(z.int()),
                    path: z.optional(z.string()),
                    start_column: z.optional(z.int()),
                    start_line: z.optional(z.int())
                })),
                message: z.optional(z.object({
                    text: z.optional(z.string())
                })),
                ref: z.string(),
                state: z.enum([
                    'open',
                    'dismissed',
                    'fixed'
                ])
            }),
            z.null()
        ])),
        number: z.int(),
        rule: z.object({
            description: z.string(),
            id: z.string(),
            severity: z.nullable(z.enum([
                'none',
                'note',
                'warning',
                'error'
            ]))
        }),
        state: z.enum([
            'open',
            'dismissed',
            'fixed'
        ]),
        tool: z.object({
            name: z.string(),
            version: z.union([
                z.string(),
                z.null()
            ])
        }),
        url: z.url()
    }),
    commit_oid: zWebhooksCodeScanningCommitOid,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    ref: zWebhooksCodeScanningRef,
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * code_scanning_alert closed_by_user event
 */
export const zWebhookCodeScanningAlertClosedByUser = z.object({
    action: z.enum([
        'closed_by_user'
    ]),
    alert: z.object({
        assignees: z.optional(z.array(zSimpleUser)),
        created_at: z.iso.datetime(),
        dismissed_at: z.iso.datetime(),
        dismissed_by: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        dismissed_comment: z.optional(zCodeScanningAlertDismissedComment),
        dismissed_reason: z.nullable(z.enum([
            'false positive',
            "won't fix",
            'used in tests'
        ])),
        fixed_at: z.optional(z.unknown()),
        html_url: z.url(),
        most_recent_instance: z.optional(z.union([
            z.object({
                analysis_key: z.string(),
                category: z.optional(z.string()),
                classifications: z.optional(z.array(z.string())),
                commit_sha: z.optional(z.string()),
                environment: z.string(),
                location: z.optional(z.object({
                    end_column: z.optional(z.int()),
                    end_line: z.optional(z.int()),
                    path: z.optional(z.string()),
                    start_column: z.optional(z.int()),
                    start_line: z.optional(z.int())
                })),
                message: z.optional(z.object({
                    text: z.optional(z.string())
                })),
                ref: z.string(),
                state: z.enum([
                    'open',
                    'dismissed',
                    'fixed'
                ])
            }),
            z.null()
        ])),
        number: z.int(),
        rule: z.object({
            description: z.string(),
            full_description: z.optional(z.string()),
            help: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            help_uri: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            id: z.string(),
            name: z.optional(z.string()),
            severity: z.nullable(z.enum([
                'none',
                'note',
                'warning',
                'error'
            ])),
            tags: z.optional(z.union([
                z.array(z.string()),
                z.null()
            ]))
        }),
        state: z.enum([
            'dismissed',
            'fixed'
        ]),
        tool: z.object({
            guid: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            name: z.string(),
            version: z.union([
                z.string(),
                z.null()
            ])
        }),
        url: z.url(),
        dismissal_approved_by: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]))
    }),
    commit_oid: zWebhooksCodeScanningCommitOid,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    ref: zWebhooksCodeScanningRef,
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * code_scanning_alert created event
 */
export const zWebhookCodeScanningAlertCreated = z.object({
    action: z.enum([
        'created'
    ]),
    alert: z.object({
        created_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        dismissed_at: z.unknown(),
        dismissed_by: z.unknown(),
        dismissed_comment: z.optional(zCodeScanningAlertDismissedComment),
        dismissed_reason: z.unknown(),
        fixed_at: z.optional(z.unknown()),
        html_url: z.url(),
        instances_url: z.optional(z.string()),
        most_recent_instance: z.optional(z.union([
            z.object({
                analysis_key: z.string(),
                category: z.optional(z.string()),
                classifications: z.optional(z.array(z.string())),
                commit_sha: z.optional(z.string()),
                environment: z.string(),
                location: z.optional(z.object({
                    end_column: z.optional(z.int()),
                    end_line: z.optional(z.int()),
                    path: z.optional(z.string()),
                    start_column: z.optional(z.int()),
                    start_line: z.optional(z.int())
                })),
                message: z.optional(z.object({
                    text: z.optional(z.string())
                })),
                ref: z.string(),
                state: z.enum([
                    'open',
                    'dismissed',
                    'fixed'
                ])
            }),
            z.null()
        ])),
        number: z.int(),
        rule: z.object({
            description: z.string(),
            full_description: z.optional(z.string()),
            help: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            help_uri: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            id: z.string(),
            name: z.optional(z.string()),
            severity: z.nullable(z.enum([
                'none',
                'note',
                'warning',
                'error'
            ])),
            tags: z.optional(z.union([
                z.array(z.string()),
                z.null()
            ]))
        }),
        state: z.enum([
            'open',
            'dismissed'
        ]),
        tool: z.union([
            z.object({
                guid: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                name: z.string(),
                version: z.union([
                    z.string(),
                    z.null()
                ])
            }),
            z.null()
        ]),
        updated_at: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        url: z.url(),
        dismissal_approved_by: z.optional(z.unknown()),
        assignees: z.optional(z.array(zSimpleUser))
    }),
    commit_oid: zWebhooksCodeScanningCommitOid,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    ref: zWebhooksCodeScanningRef,
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * code_scanning_alert fixed event
 */
export const zWebhookCodeScanningAlertFixed = z.object({
    action: z.enum([
        'fixed'
    ]),
    alert: z.object({
        assignees: z.optional(z.array(zSimpleUser)),
        created_at: z.iso.datetime(),
        dismissed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        dismissed_by: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        dismissed_comment: z.optional(zCodeScanningAlertDismissedComment),
        dismissed_reason: z.nullable(z.enum([
            'false positive',
            "won't fix",
            'used in tests'
        ])),
        fixed_at: z.optional(z.unknown()),
        html_url: z.url(),
        instances_url: z.optional(z.url()),
        most_recent_instance: z.optional(z.union([
            z.object({
                analysis_key: z.string(),
                category: z.optional(z.string()),
                classifications: z.optional(z.array(z.string())),
                commit_sha: z.optional(z.string()),
                environment: z.string(),
                location: z.optional(z.object({
                    end_column: z.optional(z.int()),
                    end_line: z.optional(z.int()),
                    path: z.optional(z.string()),
                    start_column: z.optional(z.int()),
                    start_line: z.optional(z.int())
                })),
                message: z.optional(z.object({
                    text: z.optional(z.string())
                })),
                ref: z.string(),
                state: z.enum([
                    'open',
                    'dismissed',
                    'fixed'
                ])
            }),
            z.null()
        ])),
        number: z.int(),
        rule: z.object({
            description: z.string(),
            full_description: z.optional(z.string()),
            help: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            help_uri: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            id: z.string(),
            name: z.optional(z.string()),
            severity: z.nullable(z.enum([
                'none',
                'note',
                'warning',
                'error'
            ])),
            tags: z.optional(z.union([
                z.array(z.string()),
                z.null()
            ]))
        }),
        state: z.enum([
            'fixed'
        ]),
        tool: z.object({
            guid: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            name: z.string(),
            version: z.union([
                z.string(),
                z.null()
            ])
        }),
        url: z.url()
    }),
    commit_oid: zWebhooksCodeScanningCommitOid,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    ref: zWebhooksCodeScanningRef,
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * code_scanning_alert reopened event
 */
export const zWebhookCodeScanningAlertReopened = z.object({
    action: z.enum([
        'reopened'
    ]),
    alert: z.union([
        z.object({
            assignees: z.optional(z.array(zSimpleUser)),
            created_at: z.iso.datetime(),
            dismissed_at: z.union([
                z.string(),
                z.null()
            ]),
            dismissed_by: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ]),
            dismissed_comment: z.optional(zCodeScanningAlertDismissedComment),
            dismissed_reason: z.union([
                z.string(),
                z.null()
            ]),
            fixed_at: z.optional(z.unknown()),
            html_url: z.url(),
            most_recent_instance: z.optional(z.union([
                z.object({
                    analysis_key: z.string(),
                    category: z.optional(z.string()),
                    classifications: z.optional(z.array(z.string())),
                    commit_sha: z.optional(z.string()),
                    environment: z.string(),
                    location: z.optional(z.object({
                        end_column: z.optional(z.int()),
                        end_line: z.optional(z.int()),
                        path: z.optional(z.string()),
                        start_column: z.optional(z.int()),
                        start_line: z.optional(z.int())
                    })),
                    message: z.optional(z.object({
                        text: z.optional(z.string())
                    })),
                    ref: z.string(),
                    state: z.enum([
                        'open',
                        'dismissed',
                        'fixed'
                    ])
                }),
                z.null()
            ])),
            number: z.int(),
            rule: z.object({
                description: z.string(),
                full_description: z.optional(z.string()),
                help: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                help_uri: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                id: z.string(),
                name: z.optional(z.string()),
                severity: z.nullable(z.enum([
                    'none',
                    'note',
                    'warning',
                    'error'
                ])),
                tags: z.optional(z.union([
                    z.array(z.string()),
                    z.null()
                ]))
            }),
            state: z.enum([
                'open',
                'dismissed',
                'fixed'
            ]),
            tool: z.object({
                guid: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                name: z.string(),
                version: z.union([
                    z.string(),
                    z.null()
                ])
            }),
            url: z.url()
        }),
        z.null()
    ]),
    commit_oid: z.union([
        z.string(),
        z.null()
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    ref: z.union([
        z.string(),
        z.null()
    ]),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * code_scanning_alert reopened_by_user event
 */
export const zWebhookCodeScanningAlertReopenedByUser = z.object({
    action: z.enum([
        'reopened_by_user'
    ]),
    alert: z.object({
        assignees: z.optional(z.array(zSimpleUser)),
        created_at: z.iso.datetime(),
        dismissed_at: z.unknown(),
        dismissed_by: z.unknown(),
        dismissed_comment: z.optional(zCodeScanningAlertDismissedComment),
        dismissed_reason: z.unknown(),
        fixed_at: z.optional(z.unknown()),
        html_url: z.url(),
        most_recent_instance: z.optional(z.union([
            z.object({
                analysis_key: z.string(),
                category: z.optional(z.string()),
                classifications: z.optional(z.array(z.string())),
                commit_sha: z.optional(z.string()),
                environment: z.string(),
                location: z.optional(z.object({
                    end_column: z.optional(z.int()),
                    end_line: z.optional(z.int()),
                    path: z.optional(z.string()),
                    start_column: z.optional(z.int()),
                    start_line: z.optional(z.int())
                })),
                message: z.optional(z.object({
                    text: z.optional(z.string())
                })),
                ref: z.string(),
                state: z.enum([
                    'open',
                    'dismissed',
                    'fixed'
                ])
            }),
            z.null()
        ])),
        number: z.int(),
        rule: z.object({
            description: z.string(),
            id: z.string(),
            severity: z.nullable(z.enum([
                'none',
                'note',
                'warning',
                'error'
            ]))
        }),
        state: z.enum([
            'open',
            'fixed'
        ]),
        tool: z.object({
            name: z.string(),
            version: z.union([
                z.string(),
                z.null()
            ])
        }),
        url: z.url()
    }),
    commit_oid: zWebhooksCodeScanningCommitOid,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    ref: zWebhooksCodeScanningRef,
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * commit_comment created event
 */
export const zWebhookCommitCommentCreated = z.object({
    action: z.enum([
        'created'
    ]),
    comment: z.object({
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.string(),
        commit_id: z.string(),
        created_at: z.string(),
        html_url: z.url(),
        id: z.int(),
        line: z.union([
            z.int(),
            z.null()
        ]),
        node_id: z.string(),
        path: z.union([
            z.string(),
            z.null()
        ]),
        position: z.union([
            z.int(),
            z.null()
        ]),
        reactions: z.optional(z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        })),
        updated_at: z.string(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * create event
 */
export const zWebhookCreate = z.object({
    description: z.union([
        z.string(),
        z.null()
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    master_branch: z.string(),
    organization: z.optional(zOrganizationSimpleWebhooks),
    pusher_type: zWebhooksDeployPusherType,
    ref: zWebhooksRef0,
    ref_type: z.enum([
        'tag',
        'branch'
    ]),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * custom property created event
 */
export const zWebhookCustomPropertyCreated = z.object({
    action: z.enum([
        'created'
    ]),
    definition: zCustomProperty,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    sender: z.optional(zSimpleUser)
});

/**
 * custom property deleted event
 */
export const zWebhookCustomPropertyDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    definition: z.object({
        property_name: z.string()
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    sender: z.optional(zSimpleUser)
});

/**
 * custom property promoted to business event
 */
export const zWebhookCustomPropertyPromotedToEnterprise = z.object({
    action: z.enum([
        'promote_to_enterprise'
    ]),
    definition: zCustomProperty,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    sender: z.optional(zSimpleUser)
});

/**
 * custom property updated event
 */
export const zWebhookCustomPropertyUpdated = z.object({
    action: z.enum([
        'updated'
    ]),
    definition: zCustomProperty,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    sender: z.optional(zSimpleUser)
});

/**
 * Custom property values updated event
 */
export const zWebhookCustomPropertyValuesUpdated = z.object({
    action: z.enum([
        'updated'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    repository: zRepositoryWebhooks,
    organization: zOrganizationSimpleWebhooks,
    sender: z.optional(zSimpleUser),
    new_property_values: z.array(zCustomPropertyValue),
    old_property_values: z.array(zCustomPropertyValue)
});

/**
 * delete event
 */
export const zWebhookDelete = z.object({
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    pusher_type: zWebhooksDeployPusherType,
    ref: zWebhooksRef0,
    ref_type: z.enum([
        'tag',
        'branch'
    ]),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Dependabot alert auto-dismissed event
 */
export const zWebhookDependabotAlertAutoDismissed = z.object({
    action: z.enum([
        'auto_dismissed'
    ]),
    alert: zDependabotAlert,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    enterprise: z.optional(zEnterpriseWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Dependabot alert auto-reopened event
 */
export const zWebhookDependabotAlertAutoReopened = z.object({
    action: z.enum([
        'auto_reopened'
    ]),
    alert: zDependabotAlert,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    enterprise: z.optional(zEnterpriseWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Dependabot alert created event
 */
export const zWebhookDependabotAlertCreated = z.object({
    action: z.enum([
        'created'
    ]),
    alert: zDependabotAlert,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    enterprise: z.optional(zEnterpriseWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Dependabot alert dismissed event
 */
export const zWebhookDependabotAlertDismissed = z.object({
    action: z.enum([
        'dismissed'
    ]),
    alert: zDependabotAlert,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    enterprise: z.optional(zEnterpriseWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Dependabot alert fixed event
 */
export const zWebhookDependabotAlertFixed = z.object({
    action: z.enum([
        'fixed'
    ]),
    alert: zDependabotAlert,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    enterprise: z.optional(zEnterpriseWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Dependabot alert reintroduced event
 */
export const zWebhookDependabotAlertReintroduced = z.object({
    action: z.enum([
        'reintroduced'
    ]),
    alert: zDependabotAlert,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    enterprise: z.optional(zEnterpriseWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Dependabot alert reopened event
 */
export const zWebhookDependabotAlertReopened = z.object({
    action: z.enum([
        'reopened'
    ]),
    alert: zDependabotAlert,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    enterprise: z.optional(zEnterpriseWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * deploy_key created event
 */
export const zWebhookDeployKeyCreated = z.object({
    action: z.enum([
        'created'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    key: zWebhooksDeployKey,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * deploy_key deleted event
 */
export const zWebhookDeployKeyDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    key: zWebhooksDeployKey,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * deployment created event
 */
export const zWebhookDeploymentCreated = z.object({
    action: z.enum([
        'created'
    ]),
    deployment: z.object({
        created_at: z.string(),
        creator: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        description: z.union([
            z.string(),
            z.null()
        ]),
        environment: z.string(),
        id: z.int(),
        node_id: z.string(),
        original_environment: z.string(),
        payload: z.union([
            z.record(z.string(), z.unknown()),
            z.string()
        ]),
        performed_via_github_app: z.optional(z.union([
            z.object({
                created_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                events: z.optional(z.array(z.enum([
                    'branch_protection_rule',
                    'check_run',
                    'check_suite',
                    'code_scanning_alert',
                    'commit_comment',
                    'content_reference',
                    'create',
                    'delete',
                    'deployment',
                    'deployment_review',
                    'deployment_status',
                    'deploy_key',
                    'discussion',
                    'discussion_comment',
                    'fork',
                    'gollum',
                    'issues',
                    'issue_comment',
                    'label',
                    'member',
                    'membership',
                    'milestone',
                    'organization',
                    'org_block',
                    'page_build',
                    'project',
                    'project_card',
                    'project_column',
                    'public',
                    'pull_request',
                    'pull_request_review',
                    'pull_request_review_comment',
                    'push',
                    'registry_package',
                    'release',
                    'repository',
                    'repository_dispatch',
                    'secret_scanning_alert',
                    'star',
                    'status',
                    'team',
                    'team_add',
                    'watch',
                    'workflow_dispatch',
                    'workflow_run',
                    'workflow_job',
                    'pull_request_review_thread',
                    'merge_queue_entry',
                    'secret_scanning_alert_location',
                    'merge_group'
                ]))),
                external_url: z.union([
                    z.url(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    actions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    checks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    content_references: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    contents: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    deployments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    emails: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    environments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    issues: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    keys: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    members: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    metadata: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_plan: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_self_hosted_runners: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_user_blocking: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pull_requests: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secret_scanning_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_events: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_scanning_alert: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    single_file: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    statuses: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    team_discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    vulnerability_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    workflows: z.optional(z.enum([
                        'read',
                        'write'
                    ]))
                })),
                slug: z.optional(z.string()),
                updated_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        production_environment: z.optional(z.boolean()),
        ref: z.string(),
        repository_url: z.url(),
        sha: z.string(),
        statuses_url: z.url(),
        task: z.string(),
        transient_environment: z.optional(z.boolean()),
        updated_at: z.string(),
        url: z.url()
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser,
    workflow: zWebhooksWorkflow,
    workflow_run: z.union([
        z.object({
            actor: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            artifacts_url: z.optional(z.string()),
            cancel_url: z.optional(z.string()),
            check_suite_id: z.int(),
            check_suite_node_id: z.string(),
            check_suite_url: z.optional(z.string()),
            conclusion: z.nullable(z.enum([
                'success',
                'failure',
                'neutral',
                'cancelled',
                'timed_out',
                'action_required',
                'stale'
            ])),
            created_at: z.iso.datetime(),
            display_title: z.string(),
            event: z.string(),
            head_branch: z.string(),
            head_commit: z.optional(z.unknown()),
            head_repository: z.optional(z.object({
                archive_url: z.optional(z.string()),
                assignees_url: z.optional(z.string()),
                blobs_url: z.optional(z.string()),
                branches_url: z.optional(z.string()),
                collaborators_url: z.optional(z.string()),
                comments_url: z.optional(z.string()),
                commits_url: z.optional(z.string()),
                compare_url: z.optional(z.string()),
                contents_url: z.optional(z.string()),
                contributors_url: z.optional(z.string()),
                deployments_url: z.optional(z.string()),
                description: z.optional(z.unknown()),
                downloads_url: z.optional(z.string()),
                events_url: z.optional(z.string()),
                fork: z.optional(z.boolean()),
                forks_url: z.optional(z.string()),
                full_name: z.optional(z.string()),
                git_commits_url: z.optional(z.string()),
                git_refs_url: z.optional(z.string()),
                git_tags_url: z.optional(z.string()),
                hooks_url: z.optional(z.string()),
                html_url: z.optional(z.string()),
                id: z.optional(z.int()),
                issue_comment_url: z.optional(z.string()),
                issue_events_url: z.optional(z.string()),
                issues_url: z.optional(z.string()),
                keys_url: z.optional(z.string()),
                labels_url: z.optional(z.string()),
                languages_url: z.optional(z.string()),
                merges_url: z.optional(z.string()),
                milestones_url: z.optional(z.string()),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                notifications_url: z.optional(z.string()),
                owner: z.optional(z.object({
                    avatar_url: z.optional(z.string()),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.string()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.string()),
                    id: z.optional(z.int()),
                    login: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.string()),
                    received_events_url: z.optional(z.string()),
                    repos_url: z.optional(z.string()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.string()),
                    type: z.optional(z.string()),
                    url: z.optional(z.string())
                })),
                private: z.optional(z.boolean()),
                pulls_url: z.optional(z.string()),
                releases_url: z.optional(z.string()),
                stargazers_url: z.optional(z.string()),
                statuses_url: z.optional(z.string()),
                subscribers_url: z.optional(z.string()),
                subscription_url: z.optional(z.string()),
                tags_url: z.optional(z.string()),
                teams_url: z.optional(z.string()),
                trees_url: z.optional(z.string()),
                url: z.optional(z.string())
            })),
            head_sha: z.string(),
            html_url: z.url(),
            id: z.int(),
            jobs_url: z.optional(z.string()),
            logs_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.string(),
            path: z.string(),
            previous_attempt_url: z.optional(z.unknown()),
            pull_requests: z.array(z.object({
                base: z.object({
                    ref: z.string(),
                    repo: z.object({
                        id: z.int(),
                        name: z.string(),
                        url: z.url()
                    }),
                    sha: z.string()
                }),
                head: z.object({
                    ref: z.string(),
                    repo: z.object({
                        id: z.int(),
                        name: z.string(),
                        url: z.url()
                    }),
                    sha: z.string()
                }),
                id: z.int(),
                number: z.int(),
                url: z.url()
            })),
            referenced_workflows: z.optional(z.union([
                z.array(z.object({
                    path: z.string(),
                    ref: z.optional(z.string()),
                    sha: z.string()
                })),
                z.null()
            ])),
            repository: z.optional(z.object({
                archive_url: z.optional(z.string()),
                assignees_url: z.optional(z.string()),
                blobs_url: z.optional(z.string()),
                branches_url: z.optional(z.string()),
                collaborators_url: z.optional(z.string()),
                comments_url: z.optional(z.string()),
                commits_url: z.optional(z.string()),
                compare_url: z.optional(z.string()),
                contents_url: z.optional(z.string()),
                contributors_url: z.optional(z.string()),
                deployments_url: z.optional(z.string()),
                description: z.optional(z.unknown()),
                downloads_url: z.optional(z.string()),
                events_url: z.optional(z.string()),
                fork: z.optional(z.boolean()),
                forks_url: z.optional(z.string()),
                full_name: z.optional(z.string()),
                git_commits_url: z.optional(z.string()),
                git_refs_url: z.optional(z.string()),
                git_tags_url: z.optional(z.string()),
                hooks_url: z.optional(z.string()),
                html_url: z.optional(z.string()),
                id: z.optional(z.int()),
                issue_comment_url: z.optional(z.string()),
                issue_events_url: z.optional(z.string()),
                issues_url: z.optional(z.string()),
                keys_url: z.optional(z.string()),
                labels_url: z.optional(z.string()),
                languages_url: z.optional(z.string()),
                merges_url: z.optional(z.string()),
                milestones_url: z.optional(z.string()),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                notifications_url: z.optional(z.string()),
                owner: z.optional(z.object({
                    avatar_url: z.optional(z.string()),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.string()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.string()),
                    id: z.optional(z.int()),
                    login: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.string()),
                    received_events_url: z.optional(z.string()),
                    repos_url: z.optional(z.string()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.string()),
                    type: z.optional(z.string()),
                    url: z.optional(z.string())
                })),
                private: z.optional(z.boolean()),
                pulls_url: z.optional(z.string()),
                releases_url: z.optional(z.string()),
                stargazers_url: z.optional(z.string()),
                statuses_url: z.optional(z.string()),
                subscribers_url: z.optional(z.string()),
                subscription_url: z.optional(z.string()),
                tags_url: z.optional(z.string()),
                teams_url: z.optional(z.string()),
                trees_url: z.optional(z.string()),
                url: z.optional(z.string())
            })),
            rerun_url: z.optional(z.string()),
            run_attempt: z.int(),
            run_number: z.int(),
            run_started_at: z.iso.datetime(),
            status: z.enum([
                'requested',
                'in_progress',
                'completed',
                'queued',
                'waiting',
                'pending'
            ]),
            triggering_actor: z.optional(z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])),
            updated_at: z.iso.datetime(),
            url: z.url(),
            workflow_id: z.int(),
            workflow_url: z.optional(z.string())
        }),
        z.null()
    ])
});

/**
 * deployment protection rule requested event
 */
export const zWebhookDeploymentProtectionRuleRequested = z.object({
    action: z.optional(z.enum([
        'requested'
    ])),
    environment: z.optional(z.string()),
    event: z.optional(z.string()),
    deployment_callback_url: z.optional(z.url()),
    deployment: z.optional(zDeployment),
    pull_requests: z.optional(z.array(zPullRequest)),
    repository: z.optional(zRepositoryWebhooks),
    organization: z.optional(zOrganizationSimpleWebhooks),
    installation: z.optional(zSimpleInstallation),
    sender: z.optional(zSimpleUser)
});

export const zWebhookDeploymentReviewApproved = z.object({
    action: z.enum([
        'approved'
    ]),
    approver: z.optional(zWebhooksApprover),
    comment: z.optional(z.string()),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    repository: zRepositoryWebhooks,
    reviewers: z.optional(zWebhooksReviewers),
    sender: zSimpleUser,
    since: z.string(),
    workflow_job_run: z.optional(zWebhooksWorkflowJobRun),
    workflow_job_runs: z.optional(z.array(z.object({
        conclusion: z.optional(z.unknown()),
        created_at: z.optional(z.string()),
        environment: z.optional(z.string()),
        html_url: z.optional(z.string()),
        id: z.optional(z.int()),
        name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        status: z.optional(z.string()),
        updated_at: z.optional(z.string())
    }))),
    workflow_run: z.union([
        z.object({
            actor: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            artifacts_url: z.optional(z.string()),
            cancel_url: z.optional(z.string()),
            check_suite_id: z.int(),
            check_suite_node_id: z.string(),
            check_suite_url: z.optional(z.string()),
            conclusion: z.nullable(z.enum([
                'success',
                'failure',
                'neutral',
                'cancelled',
                'timed_out',
                'action_required',
                'stale'
            ])),
            created_at: z.iso.datetime(),
            display_title: z.string(),
            event: z.string(),
            head_branch: z.string(),
            head_commit: z.optional(z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ])),
            head_repository: z.optional(z.object({
                archive_url: z.optional(z.string()),
                assignees_url: z.optional(z.string()),
                blobs_url: z.optional(z.string()),
                branches_url: z.optional(z.string()),
                collaborators_url: z.optional(z.string()),
                comments_url: z.optional(z.string()),
                commits_url: z.optional(z.string()),
                compare_url: z.optional(z.string()),
                contents_url: z.optional(z.string()),
                contributors_url: z.optional(z.string()),
                deployments_url: z.optional(z.string()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                downloads_url: z.optional(z.string()),
                events_url: z.optional(z.string()),
                fork: z.optional(z.boolean()),
                forks_url: z.optional(z.string()),
                full_name: z.optional(z.string()),
                git_commits_url: z.optional(z.string()),
                git_refs_url: z.optional(z.string()),
                git_tags_url: z.optional(z.string()),
                hooks_url: z.optional(z.string()),
                html_url: z.optional(z.string()),
                id: z.optional(z.int()),
                issue_comment_url: z.optional(z.string()),
                issue_events_url: z.optional(z.string()),
                issues_url: z.optional(z.string()),
                keys_url: z.optional(z.string()),
                labels_url: z.optional(z.string()),
                languages_url: z.optional(z.string()),
                merges_url: z.optional(z.string()),
                milestones_url: z.optional(z.string()),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                notifications_url: z.optional(z.string()),
                owner: z.optional(z.object({
                    avatar_url: z.optional(z.string()),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.string()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.string()),
                    id: z.optional(z.int()),
                    login: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.string()),
                    received_events_url: z.optional(z.string()),
                    repos_url: z.optional(z.string()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.string()),
                    type: z.optional(z.string()),
                    url: z.optional(z.string()),
                    user_view_type: z.optional(z.string())
                })),
                private: z.optional(z.boolean()),
                pulls_url: z.optional(z.string()),
                releases_url: z.optional(z.string()),
                stargazers_url: z.optional(z.string()),
                statuses_url: z.optional(z.string()),
                subscribers_url: z.optional(z.string()),
                subscription_url: z.optional(z.string()),
                tags_url: z.optional(z.string()),
                teams_url: z.optional(z.string()),
                trees_url: z.optional(z.string()),
                url: z.optional(z.string())
            })),
            head_sha: z.string(),
            html_url: z.url(),
            id: z.int(),
            jobs_url: z.optional(z.string()),
            logs_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.string(),
            path: z.string(),
            previous_attempt_url: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            pull_requests: z.array(z.object({
                base: z.object({
                    ref: z.string(),
                    repo: z.object({
                        id: z.int(),
                        name: z.string(),
                        url: z.url()
                    }),
                    sha: z.string()
                }),
                head: z.object({
                    ref: z.string(),
                    repo: z.object({
                        id: z.int(),
                        name: z.string(),
                        url: z.url()
                    }),
                    sha: z.string()
                }),
                id: z.int(),
                number: z.int(),
                url: z.url()
            })),
            referenced_workflows: z.optional(z.union([
                z.array(z.object({
                    path: z.string(),
                    ref: z.optional(z.string()),
                    sha: z.string()
                })),
                z.null()
            ])),
            repository: z.optional(z.object({
                archive_url: z.optional(z.string()),
                assignees_url: z.optional(z.string()),
                blobs_url: z.optional(z.string()),
                branches_url: z.optional(z.string()),
                collaborators_url: z.optional(z.string()),
                comments_url: z.optional(z.string()),
                commits_url: z.optional(z.string()),
                compare_url: z.optional(z.string()),
                contents_url: z.optional(z.string()),
                contributors_url: z.optional(z.string()),
                deployments_url: z.optional(z.string()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                downloads_url: z.optional(z.string()),
                events_url: z.optional(z.string()),
                fork: z.optional(z.boolean()),
                forks_url: z.optional(z.string()),
                full_name: z.optional(z.string()),
                git_commits_url: z.optional(z.string()),
                git_refs_url: z.optional(z.string()),
                git_tags_url: z.optional(z.string()),
                hooks_url: z.optional(z.string()),
                html_url: z.optional(z.string()),
                id: z.optional(z.int()),
                issue_comment_url: z.optional(z.string()),
                issue_events_url: z.optional(z.string()),
                issues_url: z.optional(z.string()),
                keys_url: z.optional(z.string()),
                labels_url: z.optional(z.string()),
                languages_url: z.optional(z.string()),
                merges_url: z.optional(z.string()),
                milestones_url: z.optional(z.string()),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                notifications_url: z.optional(z.string()),
                owner: z.optional(z.object({
                    avatar_url: z.optional(z.string()),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.string()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.string()),
                    id: z.optional(z.int()),
                    login: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.string()),
                    received_events_url: z.optional(z.string()),
                    repos_url: z.optional(z.string()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.string()),
                    type: z.optional(z.string()),
                    url: z.optional(z.string()),
                    user_view_type: z.optional(z.string())
                })),
                private: z.optional(z.boolean()),
                pulls_url: z.optional(z.string()),
                releases_url: z.optional(z.string()),
                stargazers_url: z.optional(z.string()),
                statuses_url: z.optional(z.string()),
                subscribers_url: z.optional(z.string()),
                subscription_url: z.optional(z.string()),
                tags_url: z.optional(z.string()),
                teams_url: z.optional(z.string()),
                trees_url: z.optional(z.string()),
                url: z.optional(z.string())
            })),
            rerun_url: z.optional(z.string()),
            run_attempt: z.int(),
            run_number: z.int(),
            run_started_at: z.iso.datetime(),
            status: z.enum([
                'requested',
                'in_progress',
                'completed',
                'queued',
                'waiting',
                'pending'
            ]),
            triggering_actor: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            updated_at: z.iso.datetime(),
            url: z.url(),
            workflow_id: z.int(),
            workflow_url: z.optional(z.string())
        }),
        z.null()
    ])
});

export const zWebhookDeploymentReviewRejected = z.object({
    action: z.enum([
        'rejected'
    ]),
    approver: z.optional(zWebhooksApprover),
    comment: z.optional(z.string()),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    repository: zRepositoryWebhooks,
    reviewers: z.optional(zWebhooksReviewers),
    sender: zSimpleUser,
    since: z.string(),
    workflow_job_run: z.optional(zWebhooksWorkflowJobRun),
    workflow_job_runs: z.optional(z.array(z.object({
        conclusion: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        created_at: z.optional(z.string()),
        environment: z.optional(z.string()),
        html_url: z.optional(z.string()),
        id: z.optional(z.int()),
        name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        status: z.optional(z.string()),
        updated_at: z.optional(z.string())
    }))),
    workflow_run: z.union([
        z.object({
            actor: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            artifacts_url: z.optional(z.string()),
            cancel_url: z.optional(z.string()),
            check_suite_id: z.int(),
            check_suite_node_id: z.string(),
            check_suite_url: z.optional(z.string()),
            conclusion: z.nullable(z.enum([
                'success',
                'failure',
                'neutral',
                'cancelled',
                'timed_out',
                'action_required',
                'stale'
            ])),
            created_at: z.iso.datetime(),
            event: z.string(),
            head_branch: z.string(),
            head_commit: z.optional(z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ])),
            head_repository: z.optional(z.object({
                archive_url: z.optional(z.string()),
                assignees_url: z.optional(z.string()),
                blobs_url: z.optional(z.string()),
                branches_url: z.optional(z.string()),
                collaborators_url: z.optional(z.string()),
                comments_url: z.optional(z.string()),
                commits_url: z.optional(z.string()),
                compare_url: z.optional(z.string()),
                contents_url: z.optional(z.string()),
                contributors_url: z.optional(z.string()),
                deployments_url: z.optional(z.string()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                downloads_url: z.optional(z.string()),
                events_url: z.optional(z.string()),
                fork: z.optional(z.boolean()),
                forks_url: z.optional(z.string()),
                full_name: z.optional(z.string()),
                git_commits_url: z.optional(z.string()),
                git_refs_url: z.optional(z.string()),
                git_tags_url: z.optional(z.string()),
                hooks_url: z.optional(z.string()),
                html_url: z.optional(z.string()),
                id: z.optional(z.int()),
                issue_comment_url: z.optional(z.string()),
                issue_events_url: z.optional(z.string()),
                issues_url: z.optional(z.string()),
                keys_url: z.optional(z.string()),
                labels_url: z.optional(z.string()),
                languages_url: z.optional(z.string()),
                merges_url: z.optional(z.string()),
                milestones_url: z.optional(z.string()),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                notifications_url: z.optional(z.string()),
                owner: z.optional(z.object({
                    avatar_url: z.optional(z.string()),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.string()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.string()),
                    id: z.optional(z.int()),
                    login: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.string()),
                    received_events_url: z.optional(z.string()),
                    repos_url: z.optional(z.string()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.string()),
                    type: z.optional(z.string()),
                    url: z.optional(z.string()),
                    user_view_type: z.optional(z.string())
                })),
                private: z.optional(z.boolean()),
                pulls_url: z.optional(z.string()),
                releases_url: z.optional(z.string()),
                stargazers_url: z.optional(z.string()),
                statuses_url: z.optional(z.string()),
                subscribers_url: z.optional(z.string()),
                subscription_url: z.optional(z.string()),
                tags_url: z.optional(z.string()),
                teams_url: z.optional(z.string()),
                trees_url: z.optional(z.string()),
                url: z.optional(z.string())
            })),
            head_sha: z.string(),
            html_url: z.url(),
            id: z.int(),
            jobs_url: z.optional(z.string()),
            logs_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.string(),
            path: z.string(),
            previous_attempt_url: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            pull_requests: z.array(z.object({
                base: z.object({
                    ref: z.string(),
                    repo: z.object({
                        id: z.int(),
                        name: z.string(),
                        url: z.url()
                    }),
                    sha: z.string()
                }),
                head: z.object({
                    ref: z.string(),
                    repo: z.object({
                        id: z.int(),
                        name: z.string(),
                        url: z.url()
                    }),
                    sha: z.string()
                }),
                id: z.int(),
                number: z.int(),
                url: z.url()
            })),
            referenced_workflows: z.optional(z.union([
                z.array(z.object({
                    path: z.string(),
                    ref: z.optional(z.string()),
                    sha: z.string()
                })),
                z.null()
            ])),
            repository: z.optional(z.object({
                archive_url: z.optional(z.string()),
                assignees_url: z.optional(z.string()),
                blobs_url: z.optional(z.string()),
                branches_url: z.optional(z.string()),
                collaborators_url: z.optional(z.string()),
                comments_url: z.optional(z.string()),
                commits_url: z.optional(z.string()),
                compare_url: z.optional(z.string()),
                contents_url: z.optional(z.string()),
                contributors_url: z.optional(z.string()),
                deployments_url: z.optional(z.string()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                downloads_url: z.optional(z.string()),
                events_url: z.optional(z.string()),
                fork: z.optional(z.boolean()),
                forks_url: z.optional(z.string()),
                full_name: z.optional(z.string()),
                git_commits_url: z.optional(z.string()),
                git_refs_url: z.optional(z.string()),
                git_tags_url: z.optional(z.string()),
                hooks_url: z.optional(z.string()),
                html_url: z.optional(z.string()),
                id: z.optional(z.int()),
                issue_comment_url: z.optional(z.string()),
                issue_events_url: z.optional(z.string()),
                issues_url: z.optional(z.string()),
                keys_url: z.optional(z.string()),
                labels_url: z.optional(z.string()),
                languages_url: z.optional(z.string()),
                merges_url: z.optional(z.string()),
                milestones_url: z.optional(z.string()),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                notifications_url: z.optional(z.string()),
                owner: z.optional(z.object({
                    avatar_url: z.optional(z.string()),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.string()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.string()),
                    id: z.optional(z.int()),
                    login: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.string()),
                    received_events_url: z.optional(z.string()),
                    repos_url: z.optional(z.string()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.string()),
                    type: z.optional(z.string()),
                    url: z.optional(z.string()),
                    user_view_type: z.optional(z.string())
                })),
                private: z.optional(z.boolean()),
                pulls_url: z.optional(z.string()),
                releases_url: z.optional(z.string()),
                stargazers_url: z.optional(z.string()),
                statuses_url: z.optional(z.string()),
                subscribers_url: z.optional(z.string()),
                subscription_url: z.optional(z.string()),
                tags_url: z.optional(z.string()),
                teams_url: z.optional(z.string()),
                trees_url: z.optional(z.string()),
                url: z.optional(z.string())
            })),
            rerun_url: z.optional(z.string()),
            run_attempt: z.int(),
            run_number: z.int(),
            run_started_at: z.iso.datetime(),
            status: z.enum([
                'requested',
                'in_progress',
                'completed',
                'queued',
                'waiting'
            ]),
            triggering_actor: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            updated_at: z.iso.datetime(),
            url: z.url(),
            workflow_id: z.int(),
            workflow_url: z.optional(z.string()),
            display_title: z.string()
        }),
        z.null()
    ])
});

export const zWebhookDeploymentReviewRequested = z.object({
    action: z.enum([
        'requested'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    environment: z.string(),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    repository: zRepositoryWebhooks,
    requestor: zWebhooksUser,
    reviewers: z.array(z.object({
        reviewer: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.optional(z.string()),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        type: z.optional(z.enum([
            'User',
            'Team'
        ]))
    })),
    sender: zSimpleUser,
    since: z.string(),
    workflow_job_run: z.object({
        conclusion: z.unknown(),
        created_at: z.string(),
        environment: z.string(),
        html_url: z.string(),
        id: z.int(),
        name: z.union([
            z.string(),
            z.null()
        ]),
        status: z.string(),
        updated_at: z.string()
    }),
    workflow_run: z.union([
        z.object({
            actor: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            artifacts_url: z.optional(z.string()),
            cancel_url: z.optional(z.string()),
            check_suite_id: z.int(),
            check_suite_node_id: z.string(),
            check_suite_url: z.optional(z.string()),
            conclusion: z.nullable(z.enum([
                'success',
                'failure',
                'neutral',
                'cancelled',
                'timed_out',
                'action_required',
                'stale'
            ])),
            created_at: z.iso.datetime(),
            event: z.string(),
            head_branch: z.string(),
            head_commit: z.optional(z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ])),
            head_repository: z.optional(z.object({
                archive_url: z.optional(z.string()),
                assignees_url: z.optional(z.string()),
                blobs_url: z.optional(z.string()),
                branches_url: z.optional(z.string()),
                collaborators_url: z.optional(z.string()),
                comments_url: z.optional(z.string()),
                commits_url: z.optional(z.string()),
                compare_url: z.optional(z.string()),
                contents_url: z.optional(z.string()),
                contributors_url: z.optional(z.string()),
                deployments_url: z.optional(z.string()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                downloads_url: z.optional(z.string()),
                events_url: z.optional(z.string()),
                fork: z.optional(z.boolean()),
                forks_url: z.optional(z.string()),
                full_name: z.optional(z.string()),
                git_commits_url: z.optional(z.string()),
                git_refs_url: z.optional(z.string()),
                git_tags_url: z.optional(z.string()),
                hooks_url: z.optional(z.string()),
                html_url: z.optional(z.string()),
                id: z.optional(z.int()),
                issue_comment_url: z.optional(z.string()),
                issue_events_url: z.optional(z.string()),
                issues_url: z.optional(z.string()),
                keys_url: z.optional(z.string()),
                labels_url: z.optional(z.string()),
                languages_url: z.optional(z.string()),
                merges_url: z.optional(z.string()),
                milestones_url: z.optional(z.string()),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                notifications_url: z.optional(z.string()),
                owner: z.optional(z.object({
                    avatar_url: z.optional(z.string()),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.string()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.string()),
                    id: z.optional(z.int()),
                    login: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.string()),
                    received_events_url: z.optional(z.string()),
                    repos_url: z.optional(z.string()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.string()),
                    type: z.optional(z.string()),
                    url: z.optional(z.string()),
                    user_view_type: z.optional(z.string())
                })),
                private: z.optional(z.boolean()),
                pulls_url: z.optional(z.string()),
                releases_url: z.optional(z.string()),
                stargazers_url: z.optional(z.string()),
                statuses_url: z.optional(z.string()),
                subscribers_url: z.optional(z.string()),
                subscription_url: z.optional(z.string()),
                tags_url: z.optional(z.string()),
                teams_url: z.optional(z.string()),
                trees_url: z.optional(z.string()),
                url: z.optional(z.string())
            })),
            head_sha: z.string(),
            html_url: z.url(),
            id: z.int(),
            jobs_url: z.optional(z.string()),
            logs_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.string(),
            path: z.string(),
            previous_attempt_url: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            pull_requests: z.array(z.object({
                base: z.object({
                    ref: z.string(),
                    repo: z.object({
                        id: z.int(),
                        name: z.string(),
                        url: z.url()
                    }),
                    sha: z.string()
                }),
                head: z.object({
                    ref: z.string(),
                    repo: z.object({
                        id: z.int(),
                        name: z.string(),
                        url: z.url()
                    }),
                    sha: z.string()
                }),
                id: z.int(),
                number: z.int(),
                url: z.url()
            })),
            referenced_workflows: z.optional(z.union([
                z.array(z.object({
                    path: z.string(),
                    ref: z.optional(z.string()),
                    sha: z.string()
                })),
                z.null()
            ])),
            repository: z.optional(z.object({
                archive_url: z.optional(z.string()),
                assignees_url: z.optional(z.string()),
                blobs_url: z.optional(z.string()),
                branches_url: z.optional(z.string()),
                collaborators_url: z.optional(z.string()),
                comments_url: z.optional(z.string()),
                commits_url: z.optional(z.string()),
                compare_url: z.optional(z.string()),
                contents_url: z.optional(z.string()),
                contributors_url: z.optional(z.string()),
                deployments_url: z.optional(z.string()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                downloads_url: z.optional(z.string()),
                events_url: z.optional(z.string()),
                fork: z.optional(z.boolean()),
                forks_url: z.optional(z.string()),
                full_name: z.optional(z.string()),
                git_commits_url: z.optional(z.string()),
                git_refs_url: z.optional(z.string()),
                git_tags_url: z.optional(z.string()),
                hooks_url: z.optional(z.string()),
                html_url: z.optional(z.string()),
                id: z.optional(z.int()),
                issue_comment_url: z.optional(z.string()),
                issue_events_url: z.optional(z.string()),
                issues_url: z.optional(z.string()),
                keys_url: z.optional(z.string()),
                labels_url: z.optional(z.string()),
                languages_url: z.optional(z.string()),
                merges_url: z.optional(z.string()),
                milestones_url: z.optional(z.string()),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                notifications_url: z.optional(z.string()),
                owner: z.optional(z.object({
                    avatar_url: z.optional(z.string()),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.string()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.string()),
                    id: z.optional(z.int()),
                    login: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.string()),
                    received_events_url: z.optional(z.string()),
                    repos_url: z.optional(z.string()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.string()),
                    type: z.optional(z.string()),
                    url: z.optional(z.string()),
                    user_view_type: z.optional(z.string())
                })),
                private: z.optional(z.boolean()),
                pulls_url: z.optional(z.string()),
                releases_url: z.optional(z.string()),
                stargazers_url: z.optional(z.string()),
                statuses_url: z.optional(z.string()),
                subscribers_url: z.optional(z.string()),
                subscription_url: z.optional(z.string()),
                tags_url: z.optional(z.string()),
                teams_url: z.optional(z.string()),
                trees_url: z.optional(z.string()),
                url: z.optional(z.string())
            })),
            rerun_url: z.optional(z.string()),
            run_attempt: z.int(),
            run_number: z.int(),
            run_started_at: z.iso.datetime(),
            status: z.enum([
                'requested',
                'in_progress',
                'completed',
                'queued',
                'waiting',
                'pending'
            ]),
            triggering_actor: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            updated_at: z.iso.datetime(),
            url: z.url(),
            workflow_id: z.int(),
            workflow_url: z.optional(z.string()),
            display_title: z.string()
        }),
        z.null()
    ])
});

/**
 * deployment_status created event
 */
export const zWebhookDeploymentStatusCreated = z.object({
    action: z.enum([
        'created'
    ]),
    check_run: z.optional(z.union([
        z.object({
            completed_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            conclusion: z.nullable(z.enum([
                'success',
                'failure',
                'neutral',
                'cancelled',
                'timed_out',
                'action_required',
                'stale',
                'skipped'
            ])),
            details_url: z.url(),
            external_id: z.string(),
            head_sha: z.string(),
            html_url: z.url(),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            started_at: z.iso.datetime(),
            status: z.enum([
                'queued',
                'in_progress',
                'completed',
                'waiting',
                'pending'
            ]),
            url: z.url()
        }),
        z.null()
    ])),
    deployment: z.object({
        created_at: z.string(),
        creator: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        description: z.union([
            z.string(),
            z.null()
        ]),
        environment: z.string(),
        id: z.int(),
        node_id: z.string(),
        original_environment: z.string(),
        payload: z.union([
            z.string(),
            z.record(z.string(), z.unknown()),
            z.null()
        ]),
        performed_via_github_app: z.optional(z.union([
            z.object({
                created_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                events: z.optional(z.array(z.enum([
                    'branch_protection_rule',
                    'check_run',
                    'check_suite',
                    'code_scanning_alert',
                    'commit_comment',
                    'content_reference',
                    'create',
                    'delete',
                    'deployment',
                    'deployment_review',
                    'deployment_status',
                    'deploy_key',
                    'discussion',
                    'discussion_comment',
                    'fork',
                    'gollum',
                    'issues',
                    'issue_comment',
                    'label',
                    'member',
                    'membership',
                    'milestone',
                    'organization',
                    'org_block',
                    'page_build',
                    'project',
                    'project_card',
                    'project_column',
                    'public',
                    'pull_request',
                    'pull_request_review',
                    'pull_request_review_comment',
                    'push',
                    'registry_package',
                    'release',
                    'repository',
                    'repository_dispatch',
                    'secret_scanning_alert',
                    'star',
                    'status',
                    'team',
                    'team_add',
                    'watch',
                    'workflow_dispatch',
                    'workflow_run',
                    'merge_queue_entry',
                    'workflow_job',
                    'pull_request_review_thread',
                    'secret_scanning_alert_location',
                    'merge_group'
                ]))),
                external_url: z.union([
                    z.url(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    actions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    checks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    content_references: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    contents: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    deployments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    emails: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    environments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    issues: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    keys: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    members: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    metadata: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_plan: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_self_hosted_runners: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_user_blocking: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pull_requests: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secret_scanning_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_events: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_scanning_alert: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    single_file: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    statuses: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    team_discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    vulnerability_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    workflows: z.optional(z.enum([
                        'read',
                        'write'
                    ]))
                })),
                slug: z.optional(z.string()),
                updated_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        production_environment: z.optional(z.boolean()),
        ref: z.string(),
        repository_url: z.url(),
        sha: z.string(),
        statuses_url: z.url(),
        task: z.string(),
        transient_environment: z.optional(z.boolean()),
        updated_at: z.string(),
        url: z.url()
    }),
    deployment_status: z.object({
        created_at: z.string(),
        creator: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        deployment_url: z.url(),
        description: z.string(),
        environment: z.string(),
        environment_url: z.optional(z.url()),
        id: z.int(),
        log_url: z.optional(z.url()),
        node_id: z.string(),
        performed_via_github_app: z.optional(z.union([
            z.object({
                created_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                events: z.optional(z.array(z.enum([
                    'branch_protection_rule',
                    'check_run',
                    'check_suite',
                    'code_scanning_alert',
                    'commit_comment',
                    'content_reference',
                    'create',
                    'delete',
                    'deployment',
                    'deployment_review',
                    'deployment_status',
                    'deploy_key',
                    'discussion',
                    'discussion_comment',
                    'fork',
                    'gollum',
                    'issues',
                    'issue_comment',
                    'label',
                    'member',
                    'membership',
                    'milestone',
                    'organization',
                    'org_block',
                    'page_build',
                    'project',
                    'project_card',
                    'project_column',
                    'public',
                    'pull_request',
                    'pull_request_review',
                    'pull_request_review_comment',
                    'push',
                    'registry_package',
                    'release',
                    'repository',
                    'repository_dispatch',
                    'secret_scanning_alert',
                    'star',
                    'status',
                    'team',
                    'team_add',
                    'watch',
                    'workflow_dispatch',
                    'workflow_run',
                    'pull_request_review_thread',
                    'merge_queue_entry',
                    'workflow_job',
                    'merge_group',
                    'secret_scanning_alert_location'
                ]))),
                external_url: z.union([
                    z.url(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    actions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    checks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    content_references: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    contents: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    deployments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    emails: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    environments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    issues: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    keys: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    members: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    metadata: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_plan: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_self_hosted_runners: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_user_blocking: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pull_requests: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secret_scanning_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_events: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_scanning_alert: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    single_file: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    statuses: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    team_discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    vulnerability_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    workflows: z.optional(z.enum([
                        'read',
                        'write'
                    ]))
                })),
                slug: z.optional(z.string()),
                updated_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        repository_url: z.url(),
        state: z.string(),
        target_url: z.string(),
        updated_at: z.string(),
        url: z.url()
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser,
    workflow: z.optional(zWebhooksWorkflow),
    workflow_run: z.optional(z.union([
        z.object({
            actor: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            artifacts_url: z.optional(z.string()),
            cancel_url: z.optional(z.string()),
            check_suite_id: z.int(),
            check_suite_node_id: z.string(),
            check_suite_url: z.optional(z.string()),
            conclusion: z.nullable(z.enum([
                'success',
                'failure',
                'neutral',
                'cancelled',
                'timed_out',
                'action_required',
                'stale',
                'startup_failure'
            ])),
            created_at: z.iso.datetime(),
            display_title: z.string(),
            event: z.string(),
            head_branch: z.string(),
            head_commit: z.optional(z.unknown()),
            head_repository: z.optional(z.object({
                archive_url: z.optional(z.string()),
                assignees_url: z.optional(z.string()),
                blobs_url: z.optional(z.string()),
                branches_url: z.optional(z.string()),
                collaborators_url: z.optional(z.string()),
                comments_url: z.optional(z.string()),
                commits_url: z.optional(z.string()),
                compare_url: z.optional(z.string()),
                contents_url: z.optional(z.string()),
                contributors_url: z.optional(z.string()),
                deployments_url: z.optional(z.string()),
                description: z.optional(z.unknown()),
                downloads_url: z.optional(z.string()),
                events_url: z.optional(z.string()),
                fork: z.optional(z.boolean()),
                forks_url: z.optional(z.string()),
                full_name: z.optional(z.string()),
                git_commits_url: z.optional(z.string()),
                git_refs_url: z.optional(z.string()),
                git_tags_url: z.optional(z.string()),
                hooks_url: z.optional(z.string()),
                html_url: z.optional(z.string()),
                id: z.optional(z.int()),
                issue_comment_url: z.optional(z.string()),
                issue_events_url: z.optional(z.string()),
                issues_url: z.optional(z.string()),
                keys_url: z.optional(z.string()),
                labels_url: z.optional(z.string()),
                languages_url: z.optional(z.string()),
                merges_url: z.optional(z.string()),
                milestones_url: z.optional(z.string()),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                notifications_url: z.optional(z.string()),
                owner: z.optional(z.object({
                    avatar_url: z.optional(z.string()),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.string()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.string()),
                    id: z.optional(z.int()),
                    login: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.string()),
                    received_events_url: z.optional(z.string()),
                    repos_url: z.optional(z.string()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.string()),
                    type: z.optional(z.string()),
                    url: z.optional(z.string())
                })),
                private: z.optional(z.boolean()),
                pulls_url: z.optional(z.string()),
                releases_url: z.optional(z.string()),
                stargazers_url: z.optional(z.string()),
                statuses_url: z.optional(z.string()),
                subscribers_url: z.optional(z.string()),
                subscription_url: z.optional(z.string()),
                tags_url: z.optional(z.string()),
                teams_url: z.optional(z.string()),
                trees_url: z.optional(z.string()),
                url: z.optional(z.string())
            })),
            head_sha: z.string(),
            html_url: z.url(),
            id: z.int(),
            jobs_url: z.optional(z.string()),
            logs_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.string(),
            path: z.string(),
            previous_attempt_url: z.optional(z.unknown()),
            pull_requests: z.array(z.object({
                base: z.object({
                    ref: z.string(),
                    repo: z.object({
                        id: z.int(),
                        name: z.string(),
                        url: z.url()
                    }),
                    sha: z.string()
                }),
                head: z.object({
                    ref: z.string(),
                    repo: z.object({
                        id: z.int(),
                        name: z.string(),
                        url: z.url()
                    }),
                    sha: z.string()
                }),
                id: z.int(),
                number: z.int(),
                url: z.url()
            })),
            referenced_workflows: z.optional(z.union([
                z.array(z.object({
                    path: z.string(),
                    ref: z.optional(z.string()),
                    sha: z.string()
                })),
                z.null()
            ])),
            repository: z.optional(z.object({
                archive_url: z.optional(z.string()),
                assignees_url: z.optional(z.string()),
                blobs_url: z.optional(z.string()),
                branches_url: z.optional(z.string()),
                collaborators_url: z.optional(z.string()),
                comments_url: z.optional(z.string()),
                commits_url: z.optional(z.string()),
                compare_url: z.optional(z.string()),
                contents_url: z.optional(z.string()),
                contributors_url: z.optional(z.string()),
                deployments_url: z.optional(z.string()),
                description: z.optional(z.unknown()),
                downloads_url: z.optional(z.string()),
                events_url: z.optional(z.string()),
                fork: z.optional(z.boolean()),
                forks_url: z.optional(z.string()),
                full_name: z.optional(z.string()),
                git_commits_url: z.optional(z.string()),
                git_refs_url: z.optional(z.string()),
                git_tags_url: z.optional(z.string()),
                hooks_url: z.optional(z.string()),
                html_url: z.optional(z.string()),
                id: z.optional(z.int()),
                issue_comment_url: z.optional(z.string()),
                issue_events_url: z.optional(z.string()),
                issues_url: z.optional(z.string()),
                keys_url: z.optional(z.string()),
                labels_url: z.optional(z.string()),
                languages_url: z.optional(z.string()),
                merges_url: z.optional(z.string()),
                milestones_url: z.optional(z.string()),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                notifications_url: z.optional(z.string()),
                owner: z.optional(z.object({
                    avatar_url: z.optional(z.string()),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.string()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.string()),
                    id: z.optional(z.int()),
                    login: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.string()),
                    received_events_url: z.optional(z.string()),
                    repos_url: z.optional(z.string()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.string()),
                    type: z.optional(z.string()),
                    url: z.optional(z.string())
                })),
                private: z.optional(z.boolean()),
                pulls_url: z.optional(z.string()),
                releases_url: z.optional(z.string()),
                stargazers_url: z.optional(z.string()),
                statuses_url: z.optional(z.string()),
                subscribers_url: z.optional(z.string()),
                subscription_url: z.optional(z.string()),
                tags_url: z.optional(z.string()),
                teams_url: z.optional(z.string()),
                trees_url: z.optional(z.string()),
                url: z.optional(z.string())
            })),
            rerun_url: z.optional(z.string()),
            run_attempt: z.int(),
            run_number: z.int(),
            run_started_at: z.iso.datetime(),
            status: z.enum([
                'requested',
                'in_progress',
                'completed',
                'queued',
                'waiting',
                'pending'
            ]),
            triggering_actor: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            updated_at: z.iso.datetime(),
            url: z.url(),
            workflow_id: z.int(),
            workflow_url: z.optional(z.string())
        }),
        z.null()
    ]))
});

/**
 * discussion answered event
 */
export const zWebhookDiscussionAnswered = z.object({
    action: z.enum([
        'answered'
    ]),
    answer: zWebhooksAnswer,
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * discussion category changed event
 */
export const zWebhookDiscussionCategoryChanged = z.object({
    action: z.enum([
        'category_changed'
    ]),
    changes: z.object({
        category: z.object({
            from: z.object({
                created_at: z.iso.datetime(),
                description: z.string(),
                emoji: z.string(),
                id: z.int(),
                is_answerable: z.boolean(),
                name: z.string(),
                node_id: z.optional(z.string()),
                repository_id: z.int(),
                slug: z.string(),
                updated_at: z.string()
            })
        })
    }),
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * discussion closed event
 */
export const zWebhookDiscussionClosed = z.object({
    action: z.enum([
        'closed'
    ]),
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * discussion_comment created event
 */
export const zWebhookDiscussionCommentCreated = z.object({
    action: z.enum([
        'created'
    ]),
    comment: zWebhooksComment,
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * discussion_comment deleted event
 */
export const zWebhookDiscussionCommentDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    comment: zWebhooksComment,
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * discussion_comment edited event
 */
export const zWebhookDiscussionCommentEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.object({
        body: z.object({
            from: z.string()
        })
    }),
    comment: zWebhooksComment,
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * discussion created event
 */
export const zWebhookDiscussionCreated = z.object({
    action: z.enum([
        'created'
    ]),
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * discussion deleted event
 */
export const zWebhookDiscussionDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * discussion edited event
 */
export const zWebhookDiscussionEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.optional(z.object({
        body: z.optional(z.object({
            from: z.string()
        })),
        title: z.optional(z.object({
            from: z.string()
        }))
    })),
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * discussion labeled event
 */
export const zWebhookDiscussionLabeled = z.object({
    action: z.enum([
        'labeled'
    ]),
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    label: zWebhooksLabel,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * discussion locked event
 */
export const zWebhookDiscussionLocked = z.object({
    action: z.enum([
        'locked'
    ]),
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * discussion pinned event
 */
export const zWebhookDiscussionPinned = z.object({
    action: z.enum([
        'pinned'
    ]),
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * discussion reopened event
 */
export const zWebhookDiscussionReopened = z.object({
    action: z.enum([
        'reopened'
    ]),
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * discussion transferred event
 */
export const zWebhookDiscussionTransferred = z.object({
    action: z.enum([
        'transferred'
    ]),
    changes: z.object({
        new_discussion: zDiscussion,
        new_repository: zRepositoryWebhooks
    }),
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * discussion unanswered event
 */
export const zWebhookDiscussionUnanswered = z.object({
    action: z.enum([
        'unanswered'
    ]),
    discussion: zDiscussion,
    old_answer: zWebhooksAnswer,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * discussion unlabeled event
 */
export const zWebhookDiscussionUnlabeled = z.object({
    action: z.enum([
        'unlabeled'
    ]),
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    label: zWebhooksLabel,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * discussion unlocked event
 */
export const zWebhookDiscussionUnlocked = z.object({
    action: z.enum([
        'unlocked'
    ]),
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * discussion unpinned event
 */
export const zWebhookDiscussionUnpinned = z.object({
    action: z.enum([
        'unpinned'
    ]),
    discussion: zDiscussion,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * fork event
 *
 * A user forks a repository.
 */
export const zWebhookFork = z.object({
    enterprise: z.optional(zEnterpriseWebhooks),
    forkee: z.object({
        allow_auto_merge: z.optional(z.boolean()).default(false),
        allow_forking: z.optional(z.boolean()),
        allow_merge_commit: z.optional(z.boolean()).default(true),
        allow_rebase_merge: z.optional(z.boolean()).default(true),
        allow_squash_merge: z.optional(z.boolean()).default(true),
        allow_update_branch: z.optional(z.boolean()),
        archive_url: z.string(),
        archived: z.boolean().default(false),
        assignees_url: z.string(),
        blobs_url: z.string(),
        branches_url: z.string(),
        clone_url: z.url(),
        collaborators_url: z.string(),
        comments_url: z.string(),
        commits_url: z.string(),
        compare_url: z.string(),
        contents_url: z.string(),
        contributors_url: z.url(),
        created_at: z.union([
            z.int(),
            z.iso.datetime()
        ]),
        default_branch: z.string(),
        delete_branch_on_merge: z.optional(z.boolean()).default(false),
        deployments_url: z.url(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        disabled: z.optional(z.boolean()),
        downloads_url: z.url(),
        events_url: z.url(),
        fork: z.boolean(),
        forks: z.int(),
        forks_count: z.int(),
        forks_url: z.url(),
        full_name: z.string(),
        git_commits_url: z.string(),
        git_refs_url: z.string(),
        git_tags_url: z.string(),
        git_url: z.url(),
        has_downloads: z.boolean().default(true),
        has_issues: z.boolean().default(true),
        has_pages: z.boolean(),
        has_projects: z.boolean().default(true),
        has_wiki: z.boolean().default(true),
        homepage: z.union([
            z.string(),
            z.null()
        ]),
        hooks_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        is_template: z.optional(z.boolean()),
        issue_comment_url: z.string(),
        issue_events_url: z.string(),
        issues_url: z.string(),
        keys_url: z.string(),
        labels_url: z.string(),
        language: z.union([
            z.string(),
            z.null()
        ]),
        languages_url: z.url(),
        license: z.union([
            z.object({
                key: z.string(),
                name: z.string(),
                node_id: z.string(),
                spdx_id: z.string(),
                url: z.union([
                    z.url(),
                    z.null()
                ])
            }),
            z.null()
        ]),
        master_branch: z.optional(z.string()),
        merges_url: z.url(),
        milestones_url: z.string(),
        mirror_url: z.union([
            z.url(),
            z.null()
        ]),
        name: z.string(),
        node_id: z.string(),
        notifications_url: z.string(),
        open_issues: z.int(),
        open_issues_count: z.int(),
        organization: z.optional(z.string()),
        owner: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        permissions: z.optional(z.object({
            admin: z.boolean(),
            maintain: z.optional(z.boolean()),
            pull: z.boolean(),
            push: z.boolean(),
            triage: z.optional(z.boolean())
        })),
        private: z.boolean(),
        public: z.optional(z.boolean()),
        pulls_url: z.string(),
        pushed_at: z.union([
            z.int(),
            z.iso.datetime(),
            z.null()
        ]),
        releases_url: z.string(),
        role_name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        size: z.int(),
        ssh_url: z.string(),
        stargazers: z.optional(z.int()),
        stargazers_count: z.int(),
        stargazers_url: z.url(),
        statuses_url: z.string(),
        subscribers_url: z.url(),
        subscription_url: z.url(),
        svn_url: z.url(),
        tags_url: z.url(),
        teams_url: z.url(),
        topics: z.array(z.string()),
        trees_url: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        visibility: z.enum([
            'public',
            'private',
            'internal'
        ]),
        watchers: z.int(),
        watchers_count: z.int(),
        web_commit_signoff_required: z.optional(z.boolean())
    }).and(z.object({
        allow_forking: z.optional(z.boolean()),
        archive_url: z.optional(z.string()),
        archived: z.optional(z.boolean()),
        assignees_url: z.optional(z.string()),
        blobs_url: z.optional(z.string()),
        branches_url: z.optional(z.string()),
        clone_url: z.optional(z.string()),
        collaborators_url: z.optional(z.string()),
        comments_url: z.optional(z.string()),
        commits_url: z.optional(z.string()),
        compare_url: z.optional(z.string()),
        contents_url: z.optional(z.string()),
        contributors_url: z.optional(z.string()),
        created_at: z.optional(z.string()),
        default_branch: z.optional(z.string()),
        deployments_url: z.optional(z.string()),
        description: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        disabled: z.optional(z.boolean()),
        downloads_url: z.optional(z.string()),
        events_url: z.optional(z.string()),
        fork: z.optional(z.literal(true)),
        forks: z.optional(z.int()),
        forks_count: z.optional(z.int()),
        forks_url: z.optional(z.string()),
        full_name: z.optional(z.string()),
        git_commits_url: z.optional(z.string()),
        git_refs_url: z.optional(z.string()),
        git_tags_url: z.optional(z.string()),
        git_url: z.optional(z.string()),
        has_downloads: z.optional(z.boolean()),
        has_issues: z.optional(z.boolean()),
        has_pages: z.optional(z.boolean()),
        has_projects: z.optional(z.boolean()),
        has_wiki: z.optional(z.boolean()),
        homepage: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        hooks_url: z.optional(z.string()),
        html_url: z.optional(z.string()),
        id: z.optional(z.int()),
        is_template: z.optional(z.boolean()),
        issue_comment_url: z.optional(z.string()),
        issue_events_url: z.optional(z.string()),
        issues_url: z.optional(z.string()),
        keys_url: z.optional(z.string()),
        labels_url: z.optional(z.string()),
        language: z.optional(z.unknown()),
        languages_url: z.optional(z.string()),
        license: z.optional(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ])),
        merges_url: z.optional(z.string()),
        milestones_url: z.optional(z.string()),
        mirror_url: z.optional(z.unknown()),
        name: z.optional(z.string()),
        node_id: z.optional(z.string()),
        notifications_url: z.optional(z.string()),
        open_issues: z.optional(z.int()),
        open_issues_count: z.optional(z.int()),
        owner: z.optional(z.object({
            avatar_url: z.optional(z.string()),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.string()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.string()),
            id: z.optional(z.int()),
            login: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.string()),
            received_events_url: z.optional(z.string()),
            repos_url: z.optional(z.string()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.string()),
            type: z.optional(z.string()),
            url: z.optional(z.string())
        })),
        private: z.optional(z.boolean()),
        public: z.optional(z.boolean()),
        pulls_url: z.optional(z.string()),
        pushed_at: z.optional(z.string()),
        releases_url: z.optional(z.string()),
        size: z.optional(z.int()),
        ssh_url: z.optional(z.string()),
        stargazers_count: z.optional(z.int()),
        stargazers_url: z.optional(z.string()),
        statuses_url: z.optional(z.string()),
        subscribers_url: z.optional(z.string()),
        subscription_url: z.optional(z.string()),
        svn_url: z.optional(z.string()),
        tags_url: z.optional(z.string()),
        teams_url: z.optional(z.string()),
        topics: z.optional(z.array(z.unknown())),
        trees_url: z.optional(z.string()),
        updated_at: z.optional(z.string()),
        url: z.optional(z.string()),
        visibility: z.optional(z.string()),
        watchers: z.optional(z.int()),
        watchers_count: z.optional(z.int())
    })),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * github_app_authorization revoked event
 */
export const zWebhookGithubAppAuthorizationRevoked = z.object({
    action: z.enum([
        'revoked'
    ]),
    sender: zSimpleUser
});

/**
 * gollum event
 */
export const zWebhookGollum = z.object({
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    pages: z.array(z.object({
        action: z.enum([
            'created',
            'edited'
        ]),
        html_url: z.url(),
        page_name: z.string(),
        sha: z.string(),
        summary: z.union([
            z.string(),
            z.null()
        ]),
        title: z.string()
    })),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * installation created event
 */
export const zWebhookInstallationCreated = z.object({
    action: z.enum([
        'created'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: zInstallation,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repositories: z.optional(zWebhooksRepositories),
    repository: z.optional(zRepositoryWebhooks),
    requester: z.optional(zWebhooksUser),
    sender: zSimpleUser
});

/**
 * installation deleted event
 */
export const zWebhookInstallationDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: zInstallation,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repositories: z.optional(zWebhooksRepositories),
    repository: z.optional(zRepositoryWebhooks),
    requester: z.optional(z.unknown()),
    sender: zSimpleUser
});

/**
 * installation new_permissions_accepted event
 */
export const zWebhookInstallationNewPermissionsAccepted = z.object({
    action: z.enum([
        'new_permissions_accepted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: zInstallation,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repositories: z.optional(zWebhooksRepositories),
    repository: z.optional(zRepositoryWebhooks),
    requester: z.optional(z.unknown()),
    sender: zSimpleUser
});

/**
 * installation_repositories added event
 */
export const zWebhookInstallationRepositoriesAdded = z.object({
    action: z.enum([
        'added'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: zInstallation,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repositories_added: zWebhooksRepositoriesAdded,
    repositories_removed: z.array(z.object({
        full_name: z.optional(z.string()),
        id: z.optional(z.int()),
        name: z.optional(z.string()),
        node_id: z.optional(z.string()),
        private: z.optional(z.boolean())
    })),
    repository: z.optional(zRepositoryWebhooks),
    repository_selection: zWebhooksRepositorySelection,
    requester: zWebhooksUser,
    sender: zSimpleUser
});

/**
 * installation_repositories removed event
 */
export const zWebhookInstallationRepositoriesRemoved = z.object({
    action: z.enum([
        'removed'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: zInstallation,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repositories_added: zWebhooksRepositoriesAdded,
    repositories_removed: z.array(z.object({
        full_name: z.string(),
        id: z.int(),
        name: z.string(),
        node_id: z.string(),
        private: z.boolean()
    })),
    repository: z.optional(zRepositoryWebhooks),
    repository_selection: zWebhooksRepositorySelection,
    requester: zWebhooksUser,
    sender: zSimpleUser
});

/**
 * installation suspend event
 */
export const zWebhookInstallationSuspend = z.object({
    action: z.enum([
        'suspend'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: zInstallation,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repositories: z.optional(zWebhooksRepositories),
    repository: z.optional(zRepositoryWebhooks),
    requester: z.optional(z.unknown()),
    sender: zSimpleUser
});

export const zWebhookInstallationTargetRenamed = z.object({
    account: z.object({
        archived_at: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        avatar_url: z.string(),
        created_at: z.optional(z.string()),
        description: z.optional(z.unknown()),
        events_url: z.optional(z.string()),
        followers: z.optional(z.int()),
        followers_url: z.optional(z.string()),
        following: z.optional(z.int()),
        following_url: z.optional(z.string()),
        gists_url: z.optional(z.string()),
        gravatar_id: z.optional(z.string()),
        has_organization_projects: z.optional(z.boolean()),
        has_repository_projects: z.optional(z.boolean()),
        hooks_url: z.optional(z.string()),
        html_url: z.string(),
        id: z.int(),
        is_verified: z.optional(z.boolean()),
        issues_url: z.optional(z.string()),
        login: z.optional(z.string()),
        members_url: z.optional(z.string()),
        name: z.optional(z.string()),
        node_id: z.string(),
        organizations_url: z.optional(z.string()),
        public_gists: z.optional(z.int()),
        public_members_url: z.optional(z.string()),
        public_repos: z.optional(z.int()),
        received_events_url: z.optional(z.string()),
        repos_url: z.optional(z.string()),
        site_admin: z.optional(z.boolean()),
        slug: z.optional(z.string()),
        starred_url: z.optional(z.string()),
        subscriptions_url: z.optional(z.string()),
        type: z.optional(z.string()),
        updated_at: z.optional(z.string()),
        url: z.optional(z.string()),
        website_url: z.optional(z.unknown()),
        user_view_type: z.optional(z.string())
    }),
    action: z.enum([
        'renamed'
    ]),
    changes: z.object({
        login: z.optional(z.object({
            from: z.string()
        })),
        slug: z.optional(z.object({
            from: z.string()
        }))
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: zSimpleInstallation,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    sender: z.optional(zSimpleUser),
    target_type: z.string()
});

/**
 * installation unsuspend event
 */
export const zWebhookInstallationUnsuspend = z.object({
    action: z.enum([
        'unsuspend'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: zInstallation,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repositories: z.optional(zWebhooksRepositories),
    repository: z.optional(zRepositoryWebhooks),
    requester: z.optional(z.unknown()),
    sender: zSimpleUser
});

/**
 * issue_comment created event
 */
export const zWebhookIssueCommentCreated = z.object({
    action: z.enum([
        'created'
    ]),
    comment: z.object({
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.string(),
        created_at: z.iso.datetime(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        issue_url: z.url(),
        node_id: z.string(),
        performed_via_github_app: zNullableIntegration,
        reactions: z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        }),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: z.object({
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.int(),
        comments_url: z.url(),
        created_at: z.iso.datetime(),
        draft: z.optional(z.boolean()),
        events_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        labels: z.optional(z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        }))),
        labels_url: z.string(),
        locked: z.optional(z.boolean()),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        performed_via_github_app: z.optional(z.union([
            z.object({
                created_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                events: z.optional(z.array(z.enum([
                    'branch_protection_rule',
                    'check_run',
                    'check_suite',
                    'code_scanning_alert',
                    'commit_comment',
                    'content_reference',
                    'create',
                    'delete',
                    'deployment',
                    'deployment_review',
                    'deployment_status',
                    'deploy_key',
                    'discussion',
                    'discussion_comment',
                    'fork',
                    'gollum',
                    'issues',
                    'issue_comment',
                    'label',
                    'member',
                    'membership',
                    'milestone',
                    'organization',
                    'org_block',
                    'page_build',
                    'project',
                    'project_card',
                    'project_column',
                    'public',
                    'pull_request',
                    'pull_request_review',
                    'pull_request_review_comment',
                    'push',
                    'registry_package',
                    'release',
                    'repository',
                    'repository_dispatch',
                    'secret_scanning_alert',
                    'star',
                    'status',
                    'team',
                    'team_add',
                    'watch',
                    'workflow_dispatch',
                    'workflow_run',
                    'reminder',
                    'pull_request_review_thread'
                ]))),
                external_url: z.union([
                    z.url(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    actions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    checks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    content_references: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    contents: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    deployments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    emails: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    environments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    issues: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    keys: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    members: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    metadata: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_plan: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_projects: z.optional(z.enum([
                        'read',
                        'write',
                        'admin'
                    ])),
                    organization_secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_self_hosted_runners: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_user_blocking: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pull_requests: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_projects: z.optional(z.enum([
                        'read',
                        'write',
                        'admin'
                    ])),
                    secret_scanning_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_events: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_scanning_alert: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    single_file: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    statuses: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    team_discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    vulnerability_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    workflows: z.optional(z.enum([
                        'read',
                        'write'
                    ]))
                })),
                slug: z.optional(z.string()),
                updated_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        pull_request: z.optional(z.object({
            diff_url: z.optional(z.url()),
            html_url: z.optional(z.url()),
            merged_at: z.optional(z.union([
                z.iso.datetime(),
                z.null()
            ])),
            patch_url: z.optional(z.url()),
            url: z.optional(z.url())
        })),
        reactions: z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        }),
        repository_url: z.url(),
        sub_issues_summary: z.optional(zSubIssuesSummary),
        issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
        state: z.optional(z.enum([
            'open',
            'closed'
        ])),
        state_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        timeline_url: z.optional(z.url()),
        title: z.string(),
        type: z.optional(zIssueType),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }).and(z.object({
        active_lock_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.optional(z.array(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]))),
        author_association: z.optional(z.string()),
        body: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        closed_at: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        comments: z.optional(z.int()),
        comments_url: z.optional(z.string()),
        created_at: z.optional(z.string()),
        events_url: z.optional(z.string()),
        html_url: z.optional(z.string()),
        id: z.optional(z.int()),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        labels_url: z.optional(z.string()),
        locked: z.boolean(),
        milestone: z.optional(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ])),
        node_id: z.optional(z.string()),
        number: z.optional(z.int()),
        performed_via_github_app: z.optional(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ])),
        reactions: z.optional(z.object({
            '+1': z.optional(z.int()),
            '-1': z.optional(z.int()),
            confused: z.optional(z.int()),
            eyes: z.optional(z.int()),
            heart: z.optional(z.int()),
            hooray: z.optional(z.int()),
            laugh: z.optional(z.int()),
            rocket: z.optional(z.int()),
            total_count: z.optional(z.int()),
            url: z.optional(z.string())
        })),
        repository_url: z.optional(z.string()),
        state: z.enum([
            'open',
            'closed'
        ]),
        timeline_url: z.optional(z.string()),
        title: z.optional(z.string()),
        updated_at: z.optional(z.string()),
        url: z.optional(z.string()),
        user: z.optional(z.object({
            avatar_url: z.optional(z.string()),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.string()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.string()),
            id: z.optional(z.coerce.bigint()),
            login: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.string()),
            received_events_url: z.optional(z.string()),
            repos_url: z.optional(z.string()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.string()),
            type: z.optional(z.string()),
            url: z.optional(z.string())
        }))
    })),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issue_comment deleted event
 */
export const zWebhookIssueCommentDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    comment: zWebhooksIssueComment,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: z.object({
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.int(),
        comments_url: z.url(),
        created_at: z.iso.datetime(),
        draft: z.optional(z.boolean()),
        events_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        labels: z.optional(z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        }))),
        labels_url: z.string(),
        locked: z.optional(z.boolean()),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        performed_via_github_app: z.optional(z.union([
            z.object({
                created_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                events: z.optional(z.array(z.enum([
                    'branch_protection_rule',
                    'check_run',
                    'check_suite',
                    'code_scanning_alert',
                    'commit_comment',
                    'content_reference',
                    'create',
                    'delete',
                    'deployment',
                    'deployment_review',
                    'deployment_status',
                    'deploy_key',
                    'discussion',
                    'discussion_comment',
                    'fork',
                    'gollum',
                    'issues',
                    'issue_comment',
                    'label',
                    'member',
                    'membership',
                    'milestone',
                    'organization',
                    'org_block',
                    'page_build',
                    'project',
                    'project_card',
                    'project_column',
                    'public',
                    'pull_request',
                    'pull_request_review',
                    'pull_request_review_comment',
                    'push',
                    'registry_package',
                    'release',
                    'repository',
                    'repository_dispatch',
                    'secret_scanning_alert',
                    'star',
                    'status',
                    'team',
                    'team_add',
                    'watch',
                    'workflow_dispatch',
                    'workflow_run'
                ]))),
                external_url: z.union([
                    z.url(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    actions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    checks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    content_references: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    contents: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    deployments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    emails: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    environments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    issues: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    keys: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    members: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    metadata: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_plan: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_self_hosted_runners: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_user_blocking: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pull_requests: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secret_scanning_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_events: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_scanning_alert: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    single_file: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    statuses: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    team_discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    vulnerability_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    workflows: z.optional(z.enum([
                        'read',
                        'write'
                    ]))
                })),
                slug: z.optional(z.string()),
                updated_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        pull_request: z.optional(z.object({
            diff_url: z.optional(z.url()),
            html_url: z.optional(z.url()),
            merged_at: z.optional(z.union([
                z.iso.datetime(),
                z.null()
            ])),
            patch_url: z.optional(z.url()),
            url: z.optional(z.url())
        })),
        reactions: z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        }),
        repository_url: z.url(),
        sub_issues_summary: z.optional(zSubIssuesSummary),
        issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
        state: z.optional(z.enum([
            'open',
            'closed'
        ])),
        state_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        timeline_url: z.optional(z.url()),
        title: z.string(),
        type: z.optional(zIssueType),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }).and(z.object({
        active_lock_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.optional(z.array(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]))),
        author_association: z.optional(z.string()),
        body: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        closed_at: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        comments: z.optional(z.int()),
        comments_url: z.optional(z.string()),
        created_at: z.optional(z.string()),
        events_url: z.optional(z.string()),
        html_url: z.optional(z.string()),
        id: z.optional(z.int()),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        labels_url: z.optional(z.string()),
        locked: z.boolean(),
        milestone: z.optional(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ])),
        node_id: z.optional(z.string()),
        number: z.optional(z.int()),
        performed_via_github_app: z.optional(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ])),
        reactions: z.optional(z.object({
            '+1': z.optional(z.int()),
            '-1': z.optional(z.int()),
            confused: z.optional(z.int()),
            eyes: z.optional(z.int()),
            heart: z.optional(z.int()),
            hooray: z.optional(z.int()),
            laugh: z.optional(z.int()),
            rocket: z.optional(z.int()),
            total_count: z.optional(z.int()),
            url: z.optional(z.string())
        })),
        repository_url: z.optional(z.string()),
        state: z.enum([
            'open',
            'closed'
        ]),
        timeline_url: z.optional(z.string()),
        title: z.optional(z.string()),
        updated_at: z.optional(z.string()),
        url: z.optional(z.string()),
        user: z.optional(z.object({
            avatar_url: z.optional(z.string()),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.string()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.string()),
            id: z.optional(z.coerce.bigint()),
            login: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.string()),
            received_events_url: z.optional(z.string()),
            repos_url: z.optional(z.string()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.string()),
            type: z.optional(z.string()),
            url: z.optional(z.string()),
            user_view_type: z.optional(z.string())
        }))
    })),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issue_comment edited event
 */
export const zWebhookIssueCommentEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: zWebhooksChanges,
    comment: zWebhooksIssueComment,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: z.object({
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.int(),
        comments_url: z.url(),
        created_at: z.iso.datetime(),
        draft: z.optional(z.boolean()),
        events_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        labels: z.optional(z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        }))),
        labels_url: z.string(),
        locked: z.optional(z.boolean()),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        performed_via_github_app: z.optional(z.union([
            z.object({
                created_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                events: z.optional(z.array(z.enum([
                    'branch_protection_rule',
                    'check_run',
                    'check_suite',
                    'code_scanning_alert',
                    'commit_comment',
                    'content_reference',
                    'create',
                    'delete',
                    'deployment',
                    'deployment_review',
                    'deployment_status',
                    'deploy_key',
                    'discussion',
                    'discussion_comment',
                    'fork',
                    'gollum',
                    'issues',
                    'issue_comment',
                    'label',
                    'member',
                    'membership',
                    'milestone',
                    'organization',
                    'org_block',
                    'page_build',
                    'project',
                    'project_card',
                    'project_column',
                    'public',
                    'pull_request',
                    'pull_request_review',
                    'pull_request_review_comment',
                    'push',
                    'registry_package',
                    'release',
                    'repository',
                    'repository_dispatch',
                    'secret_scanning_alert',
                    'star',
                    'status',
                    'team',
                    'team_add',
                    'watch',
                    'workflow_dispatch',
                    'workflow_run',
                    'reminder',
                    'pull_request_review_thread'
                ]))),
                external_url: z.union([
                    z.url(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    actions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    checks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    content_references: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    contents: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    deployments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    emails: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    environments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    issues: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    keys: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    members: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    metadata: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_plan: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_projects: z.optional(z.enum([
                        'read',
                        'write',
                        'admin'
                    ])),
                    organization_secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_self_hosted_runners: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_user_blocking: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pull_requests: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secret_scanning_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_events: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_scanning_alert: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    single_file: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    statuses: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    team_discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    vulnerability_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    workflows: z.optional(z.enum([
                        'read',
                        'write'
                    ]))
                })),
                slug: z.optional(z.string()),
                updated_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        pull_request: z.optional(z.object({
            diff_url: z.optional(z.url()),
            html_url: z.optional(z.url()),
            merged_at: z.optional(z.union([
                z.iso.datetime(),
                z.null()
            ])),
            patch_url: z.optional(z.url()),
            url: z.optional(z.url())
        })),
        reactions: z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        }),
        repository_url: z.url(),
        sub_issues_summary: z.optional(zSubIssuesSummary),
        issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
        state: z.optional(z.enum([
            'open',
            'closed'
        ])),
        state_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        timeline_url: z.optional(z.url()),
        title: z.string(),
        type: z.optional(zIssueType),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }).and(z.object({
        active_lock_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.optional(z.array(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]))),
        author_association: z.optional(z.string()),
        body: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        closed_at: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        comments: z.optional(z.int()),
        comments_url: z.optional(z.string()),
        created_at: z.optional(z.string()),
        events_url: z.optional(z.string()),
        html_url: z.optional(z.string()),
        id: z.optional(z.int()),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        labels_url: z.optional(z.string()),
        locked: z.boolean(),
        milestone: z.optional(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ])),
        node_id: z.optional(z.string()),
        number: z.optional(z.int()),
        performed_via_github_app: z.optional(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ])),
        reactions: z.optional(z.object({
            '+1': z.optional(z.int()),
            '-1': z.optional(z.int()),
            confused: z.optional(z.int()),
            eyes: z.optional(z.int()),
            heart: z.optional(z.int()),
            hooray: z.optional(z.int()),
            laugh: z.optional(z.int()),
            rocket: z.optional(z.int()),
            total_count: z.optional(z.int()),
            url: z.optional(z.string())
        })),
        repository_url: z.optional(z.string()),
        state: z.enum([
            'open',
            'closed'
        ]),
        timeline_url: z.optional(z.string()),
        title: z.optional(z.string()),
        updated_at: z.optional(z.string()),
        url: z.optional(z.string()),
        user: z.optional(z.object({
            avatar_url: z.optional(z.string()),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.string()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.string()),
            id: z.optional(z.coerce.bigint()),
            login: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.string()),
            received_events_url: z.optional(z.string()),
            repos_url: z.optional(z.string()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.string()),
            type: z.optional(z.string()),
            url: z.optional(z.string())
        }))
    })),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * blocked by issue added event
 */
export const zWebhookIssueDependenciesBlockedByAdded = z.object({
    action: z.enum([
        'blocked_by_added'
    ]),
    blocked_issue_id: z.number(),
    blocked_issue: zIssue,
    blocking_issue_id: z.number(),
    blocking_issue: zIssue,
    blocking_issue_repo: zRepository,
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * blocked by issue removed event
 */
export const zWebhookIssueDependenciesBlockedByRemoved = z.object({
    action: z.enum([
        'blocked_by_removed'
    ]),
    blocked_issue_id: z.number(),
    blocked_issue: zIssue,
    blocking_issue_id: z.number(),
    blocking_issue: zIssue,
    blocking_issue_repo: zRepository,
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * blocking issue added event
 */
export const zWebhookIssueDependenciesBlockingAdded = z.object({
    action: z.enum([
        'blocking_added'
    ]),
    blocked_issue_id: z.number(),
    blocked_issue: zIssue,
    blocked_issue_repo: zRepository,
    blocking_issue_id: z.number(),
    blocking_issue: zIssue,
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * blocking issue removed event
 */
export const zWebhookIssueDependenciesBlockingRemoved = z.object({
    action: z.enum([
        'blocking_removed'
    ]),
    blocked_issue_id: z.number(),
    blocked_issue: zIssue,
    blocked_issue_repo: zRepository,
    blocking_issue_id: z.number(),
    blocking_issue: zIssue,
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues assigned event
 */
export const zWebhookIssuesAssigned = z.object({
    action: z.enum([
        'assigned'
    ]),
    assignee: z.optional(zWebhooksUser),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: zWebhooksIssue,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues closed event
 */
export const zWebhookIssuesClosed = z.object({
    action: z.enum([
        'closed'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: z.object({
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.int(),
        comments_url: z.url(),
        created_at: z.iso.datetime(),
        draft: z.optional(z.boolean()),
        events_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        labels: z.optional(z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        }))),
        labels_url: z.string(),
        locked: z.optional(z.boolean()),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        performed_via_github_app: z.optional(z.union([
            z.object({
                created_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                events: z.optional(z.array(z.enum([
                    'branch_protection_rule',
                    'check_run',
                    'check_suite',
                    'code_scanning_alert',
                    'commit_comment',
                    'content_reference',
                    'create',
                    'delete',
                    'deployment',
                    'deployment_review',
                    'deployment_status',
                    'deploy_key',
                    'discussion',
                    'discussion_comment',
                    'fork',
                    'gollum',
                    'issues',
                    'issue_comment',
                    'label',
                    'member',
                    'membership',
                    'milestone',
                    'organization',
                    'org_block',
                    'page_build',
                    'project',
                    'project_card',
                    'project_column',
                    'public',
                    'pull_request',
                    'pull_request_review',
                    'pull_request_review_comment',
                    'push',
                    'registry_package',
                    'release',
                    'repository',
                    'repository_dispatch',
                    'secret_scanning_alert',
                    'star',
                    'status',
                    'team',
                    'team_add',
                    'watch',
                    'workflow_dispatch',
                    'workflow_run',
                    'security_and_analysis',
                    'reminder',
                    'pull_request_review_thread'
                ]))),
                external_url: z.union([
                    z.url(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    actions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    checks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    content_references: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    contents: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    deployments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    emails: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    environments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    issues: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    keys: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    members: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    metadata: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_plan: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_projects: z.optional(z.enum([
                        'read',
                        'write',
                        'admin'
                    ])),
                    organization_secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_self_hosted_runners: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_user_blocking: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pull_requests: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secret_scanning_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_events: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_scanning_alert: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    single_file: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    statuses: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    team_discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    vulnerability_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    workflows: z.optional(z.enum([
                        'read',
                        'write'
                    ]))
                })),
                slug: z.optional(z.string()),
                updated_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        pull_request: z.optional(z.object({
            diff_url: z.optional(z.url()),
            html_url: z.optional(z.url()),
            merged_at: z.optional(z.union([
                z.iso.datetime(),
                z.null()
            ])),
            patch_url: z.optional(z.url()),
            url: z.optional(z.url())
        })),
        reactions: z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        }),
        repository_url: z.url(),
        sub_issues_summary: z.optional(zSubIssuesSummary),
        issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
        issue_field_values: z.optional(z.array(zIssueFieldValue)),
        state: z.optional(z.enum([
            'open',
            'closed'
        ])),
        state_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        timeline_url: z.optional(z.url()),
        title: z.string(),
        type: z.optional(zIssueType),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }).and(z.object({
        active_lock_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        assignee: z.optional(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ])),
        assignees: z.optional(z.array(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]))),
        author_association: z.optional(z.string()),
        body: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        closed_at: z.union([
            z.string(),
            z.null()
        ]),
        comments: z.optional(z.int()),
        comments_url: z.optional(z.string()),
        created_at: z.optional(z.string()),
        events_url: z.optional(z.string()),
        html_url: z.optional(z.string()),
        id: z.optional(z.int()),
        labels: z.optional(z.array(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]))),
        labels_url: z.optional(z.string()),
        locked: z.optional(z.boolean()),
        milestone: z.optional(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ])),
        node_id: z.optional(z.string()),
        number: z.optional(z.int()),
        performed_via_github_app: z.optional(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ])),
        reactions: z.optional(z.object({
            '+1': z.optional(z.int()),
            '-1': z.optional(z.int()),
            confused: z.optional(z.int()),
            eyes: z.optional(z.int()),
            heart: z.optional(z.int()),
            hooray: z.optional(z.int()),
            laugh: z.optional(z.int()),
            rocket: z.optional(z.int()),
            total_count: z.optional(z.int()),
            url: z.optional(z.string())
        })),
        repository_url: z.optional(z.string()),
        state: z.enum([
            'closed',
            'open'
        ]),
        timeline_url: z.optional(z.string()),
        title: z.optional(z.string()),
        updated_at: z.optional(z.string()),
        url: z.optional(z.string()),
        user: z.optional(z.object({
            avatar_url: z.optional(z.string()),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.string()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.string()),
            id: z.optional(z.coerce.bigint()),
            login: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.string()),
            received_events_url: z.optional(z.string()),
            repos_url: z.optional(z.string()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.string()),
            type: z.optional(z.string()),
            url: z.optional(z.string()),
            user_view_type: z.optional(z.string())
        }))
    })),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues deleted event
 */
export const zWebhookIssuesDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: z.object({
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.int(),
        comments_url: z.url(),
        created_at: z.iso.datetime(),
        draft: z.optional(z.boolean()),
        events_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        labels: z.optional(z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        }))),
        labels_url: z.string(),
        locked: z.optional(z.boolean()),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        performed_via_github_app: z.optional(z.union([
            z.object({
                created_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                events: z.optional(z.array(z.enum([
                    'branch_protection_rule',
                    'check_run',
                    'check_suite',
                    'code_scanning_alert',
                    'commit_comment',
                    'content_reference',
                    'create',
                    'delete',
                    'deployment',
                    'deployment_review',
                    'deployment_status',
                    'deploy_key',
                    'discussion',
                    'discussion_comment',
                    'fork',
                    'gollum',
                    'issues',
                    'issue_comment',
                    'label',
                    'member',
                    'membership',
                    'milestone',
                    'organization',
                    'org_block',
                    'page_build',
                    'project',
                    'project_card',
                    'project_column',
                    'public',
                    'pull_request',
                    'pull_request_review',
                    'pull_request_review_comment',
                    'push',
                    'registry_package',
                    'release',
                    'repository',
                    'repository_dispatch',
                    'secret_scanning_alert',
                    'star',
                    'status',
                    'team',
                    'team_add',
                    'watch',
                    'workflow_dispatch',
                    'workflow_run',
                    'reminder'
                ]))),
                external_url: z.union([
                    z.url(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    actions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    checks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    content_references: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    contents: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    deployments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    emails: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    environments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    issues: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    keys: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    members: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    metadata: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_plan: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_self_hosted_runners: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_user_blocking: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pull_requests: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secret_scanning_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_events: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_scanning_alert: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    single_file: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    statuses: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    team_discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    vulnerability_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    workflows: z.optional(z.enum([
                        'read',
                        'write'
                    ]))
                })),
                slug: z.optional(z.string()),
                updated_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        pull_request: z.optional(z.object({
            diff_url: z.optional(z.url()),
            html_url: z.optional(z.url()),
            merged_at: z.optional(z.union([
                z.iso.datetime(),
                z.null()
            ])),
            patch_url: z.optional(z.url()),
            url: z.optional(z.url())
        })),
        reactions: z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        }),
        repository_url: z.url(),
        sub_issues_summary: z.optional(zSubIssuesSummary),
        issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
        issue_field_values: z.optional(z.array(zIssueFieldValue)),
        state: z.optional(z.enum([
            'open',
            'closed'
        ])),
        state_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        timeline_url: z.optional(z.url()),
        title: z.string(),
        type: z.optional(zIssueType),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues demilestoned event
 */
export const zWebhookIssuesDemilestoned = z.object({
    action: z.enum([
        'demilestoned'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: z.object({
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.int(),
        comments_url: z.url(),
        created_at: z.iso.datetime(),
        draft: z.optional(z.boolean()),
        events_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        labels: z.optional(z.array(z.union([
            z.object({
                color: z.string(),
                default: z.boolean(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                id: z.int(),
                name: z.string(),
                node_id: z.string(),
                url: z.url()
            }),
            z.null()
        ]))),
        labels_url: z.string(),
        locked: z.optional(z.boolean()),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        performed_via_github_app: z.optional(z.union([
            z.object({
                created_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                events: z.optional(z.array(z.enum([
                    'branch_protection_rule',
                    'check_run',
                    'check_suite',
                    'code_scanning_alert',
                    'commit_comment',
                    'content_reference',
                    'create',
                    'delete',
                    'deployment',
                    'deployment_review',
                    'deployment_status',
                    'deploy_key',
                    'discussion',
                    'discussion_comment',
                    'fork',
                    'gollum',
                    'issues',
                    'issue_comment',
                    'label',
                    'member',
                    'membership',
                    'milestone',
                    'organization',
                    'org_block',
                    'page_build',
                    'project',
                    'project_card',
                    'project_column',
                    'public',
                    'pull_request',
                    'pull_request_review',
                    'pull_request_review_comment',
                    'push',
                    'registry_package',
                    'release',
                    'repository',
                    'repository_dispatch',
                    'secret_scanning_alert',
                    'star',
                    'status',
                    'team',
                    'team_add',
                    'watch',
                    'workflow_dispatch',
                    'workflow_run'
                ]))),
                external_url: z.union([
                    z.url(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    actions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    checks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    content_references: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    contents: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    deployments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    emails: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    environments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    issues: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    keys: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    members: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    metadata: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_plan: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_projects: z.optional(z.enum([
                        'read',
                        'write',
                        'admin'
                    ])),
                    organization_secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_self_hosted_runners: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_user_blocking: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pull_requests: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secret_scanning_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_events: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_scanning_alert: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    single_file: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    statuses: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    team_discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    vulnerability_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    workflows: z.optional(z.enum([
                        'read',
                        'write'
                    ]))
                })),
                slug: z.optional(z.string()),
                updated_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        pull_request: z.optional(z.object({
            diff_url: z.optional(z.url()),
            html_url: z.optional(z.url()),
            merged_at: z.optional(z.union([
                z.iso.datetime(),
                z.null()
            ])),
            patch_url: z.optional(z.url()),
            url: z.optional(z.url())
        })),
        reactions: z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        }),
        repository_url: z.url(),
        sub_issues_summary: z.optional(zSubIssuesSummary),
        issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
        issue_field_values: z.optional(z.array(zIssueFieldValue)),
        state: z.optional(z.enum([
            'open',
            'closed'
        ])),
        state_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        timeline_url: z.optional(z.url()),
        title: z.string(),
        type: z.optional(zIssueType),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    milestone: z.optional(zWebhooksMilestone),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues edited event
 */
export const zWebhookIssuesEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.object({
        body: z.optional(z.object({
            from: z.string()
        })),
        title: z.optional(z.object({
            from: z.string()
        }))
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: z.object({
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.int(),
        comments_url: z.url(),
        created_at: z.iso.datetime(),
        draft: z.optional(z.boolean()),
        events_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        labels: z.optional(z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        }))),
        labels_url: z.string(),
        locked: z.optional(z.boolean()),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        performed_via_github_app: z.optional(z.union([
            z.object({
                created_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                events: z.optional(z.array(z.enum([
                    'branch_protection_rule',
                    'check_run',
                    'check_suite',
                    'code_scanning_alert',
                    'commit_comment',
                    'content_reference',
                    'create',
                    'delete',
                    'deployment',
                    'deployment_review',
                    'deployment_status',
                    'deploy_key',
                    'discussion',
                    'discussion_comment',
                    'fork',
                    'gollum',
                    'issues',
                    'issue_comment',
                    'label',
                    'member',
                    'membership',
                    'milestone',
                    'organization',
                    'org_block',
                    'page_build',
                    'project',
                    'project_card',
                    'project_column',
                    'public',
                    'pull_request',
                    'pull_request_review',
                    'pull_request_review_comment',
                    'push',
                    'registry_package',
                    'release',
                    'repository',
                    'repository_dispatch',
                    'secret_scanning_alert',
                    'star',
                    'status',
                    'team',
                    'team_add',
                    'watch',
                    'workflow_dispatch',
                    'workflow_run',
                    'security_and_analysis',
                    'pull_request_review_thread',
                    'reminder'
                ]))),
                external_url: z.union([
                    z.url(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    actions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    checks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    content_references: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    contents: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    deployments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    emails: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    environments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    issues: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    keys: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    members: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    metadata: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_plan: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_projects: z.optional(z.enum([
                        'read',
                        'write',
                        'admin'
                    ])),
                    organization_secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_self_hosted_runners: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_user_blocking: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pull_requests: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secret_scanning_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_events: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_scanning_alert: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    single_file: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    statuses: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    team_discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    vulnerability_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    workflows: z.optional(z.enum([
                        'read',
                        'write'
                    ]))
                })),
                slug: z.optional(z.string()),
                updated_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        pull_request: z.optional(z.object({
            diff_url: z.optional(z.url()),
            html_url: z.optional(z.url()),
            merged_at: z.optional(z.union([
                z.iso.datetime(),
                z.null()
            ])),
            patch_url: z.optional(z.url()),
            url: z.optional(z.url())
        })),
        reactions: z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        }),
        repository_url: z.url(),
        sub_issues_summary: z.optional(zSubIssuesSummary),
        issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
        issue_field_values: z.optional(z.array(zIssueFieldValue)),
        state: z.optional(z.enum([
            'open',
            'closed'
        ])),
        state_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        timeline_url: z.optional(z.url()),
        type: z.optional(zIssueType),
        title: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    label: z.optional(zWebhooksLabel),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues labeled event
 */
export const zWebhookIssuesLabeled = z.object({
    action: z.enum([
        'labeled'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: z.object({
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.int(),
        comments_url: z.url(),
        created_at: z.iso.datetime(),
        draft: z.optional(z.boolean()),
        events_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        labels: z.optional(z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        }))),
        labels_url: z.string(),
        locked: z.optional(z.boolean()),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        performed_via_github_app: z.optional(z.union([
            z.object({
                created_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                events: z.optional(z.array(z.enum([
                    'branch_protection_rule',
                    'check_run',
                    'check_suite',
                    'code_scanning_alert',
                    'commit_comment',
                    'content_reference',
                    'create',
                    'delete',
                    'deployment',
                    'deployment_review',
                    'deployment_status',
                    'deploy_key',
                    'discussion',
                    'discussion_comment',
                    'fork',
                    'gollum',
                    'issues',
                    'issue_comment',
                    'label',
                    'member',
                    'membership',
                    'milestone',
                    'organization',
                    'org_block',
                    'page_build',
                    'project',
                    'project_card',
                    'project_column',
                    'public',
                    'pull_request',
                    'pull_request_review',
                    'pull_request_review_comment',
                    'push',
                    'registry_package',
                    'release',
                    'repository',
                    'repository_dispatch',
                    'secret_scanning_alert',
                    'star',
                    'status',
                    'team',
                    'team_add',
                    'watch',
                    'workflow_dispatch',
                    'workflow_run',
                    'pull_request_review_thread',
                    'reminder'
                ]))),
                external_url: z.union([
                    z.url(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    actions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    checks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    content_references: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    contents: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    deployments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    emails: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    environments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    issues: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    keys: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    members: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    metadata: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_plan: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_projects: z.optional(z.enum([
                        'read',
                        'write',
                        'admin'
                    ])),
                    organization_secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_self_hosted_runners: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_user_blocking: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pull_requests: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secret_scanning_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_events: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_scanning_alert: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    single_file: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    statuses: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    team_discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    vulnerability_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    workflows: z.optional(z.enum([
                        'read',
                        'write'
                    ]))
                })),
                slug: z.optional(z.string()),
                updated_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        pull_request: z.optional(z.object({
            diff_url: z.optional(z.url()),
            html_url: z.optional(z.url()),
            merged_at: z.optional(z.union([
                z.iso.datetime(),
                z.null()
            ])),
            patch_url: z.optional(z.url()),
            url: z.optional(z.url())
        })),
        reactions: z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        }),
        repository_url: z.url(),
        sub_issues_summary: z.optional(zSubIssuesSummary),
        issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
        issue_field_values: z.optional(z.array(zIssueFieldValue)),
        state: z.optional(z.enum([
            'open',
            'closed'
        ])),
        state_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        timeline_url: z.optional(z.url()),
        type: z.optional(zIssueType),
        title: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    label: z.optional(zWebhooksLabel),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues locked event
 */
export const zWebhookIssuesLocked = z.object({
    action: z.enum([
        'locked'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: z.object({
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.int(),
        comments_url: z.url(),
        created_at: z.iso.datetime(),
        draft: z.optional(z.boolean()),
        events_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        labels: z.optional(z.array(z.union([
            z.object({
                color: z.string(),
                default: z.boolean(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                id: z.int(),
                name: z.string(),
                node_id: z.string(),
                url: z.url()
            }),
            z.null()
        ]))),
        labels_url: z.string(),
        locked: z.literal(true),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        performed_via_github_app: z.optional(z.union([
            z.object({
                created_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                events: z.optional(z.array(z.enum([
                    'branch_protection_rule',
                    'check_run',
                    'check_suite',
                    'code_scanning_alert',
                    'commit_comment',
                    'content_reference',
                    'create',
                    'delete',
                    'deployment',
                    'deployment_review',
                    'deployment_status',
                    'deploy_key',
                    'discussion',
                    'discussion_comment',
                    'fork',
                    'gollum',
                    'issues',
                    'issue_comment',
                    'label',
                    'member',
                    'membership',
                    'milestone',
                    'organization',
                    'org_block',
                    'page_build',
                    'project',
                    'project_card',
                    'project_column',
                    'public',
                    'pull_request',
                    'pull_request_review',
                    'pull_request_review_comment',
                    'push',
                    'registry_package',
                    'release',
                    'repository',
                    'repository_dispatch',
                    'secret_scanning_alert',
                    'star',
                    'status',
                    'team',
                    'team_add',
                    'watch',
                    'workflow_dispatch',
                    'workflow_run',
                    'reminder',
                    'security_and_analysis'
                ]))),
                external_url: z.union([
                    z.url(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    actions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    checks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    content_references: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    contents: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    deployments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    emails: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    environments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    issues: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    keys: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    members: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    metadata: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_plan: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_self_hosted_runners: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_user_blocking: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pull_requests: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secret_scanning_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_events: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_scanning_alert: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    single_file: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    statuses: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    team_discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    vulnerability_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    workflows: z.optional(z.enum([
                        'read',
                        'write'
                    ]))
                })),
                slug: z.optional(z.string()),
                updated_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        pull_request: z.optional(z.object({
            diff_url: z.optional(z.url()),
            html_url: z.optional(z.url()),
            merged_at: z.optional(z.union([
                z.iso.datetime(),
                z.null()
            ])),
            patch_url: z.optional(z.url()),
            url: z.optional(z.url())
        })),
        reactions: z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        }),
        repository_url: z.url(),
        sub_issues_summary: z.optional(zSubIssuesSummary),
        issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
        issue_field_values: z.optional(z.array(zIssueFieldValue)),
        state: z.optional(z.enum([
            'open',
            'closed'
        ])),
        state_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        timeline_url: z.optional(z.url()),
        type: z.optional(zIssueType),
        title: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues milestoned event
 */
export const zWebhookIssuesMilestoned = z.object({
    action: z.enum([
        'milestoned'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: z.object({
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.int(),
        comments_url: z.url(),
        created_at: z.iso.datetime(),
        draft: z.optional(z.boolean()),
        events_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        labels: z.optional(z.array(z.union([
            z.object({
                color: z.string(),
                default: z.boolean(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                id: z.int(),
                name: z.string(),
                node_id: z.string(),
                url: z.url()
            }),
            z.null()
        ]))),
        labels_url: z.string(),
        locked: z.optional(z.boolean()),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        performed_via_github_app: z.optional(z.union([
            z.object({
                created_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                events: z.optional(z.array(z.enum([
                    'branch_protection_rule',
                    'check_run',
                    'check_suite',
                    'code_scanning_alert',
                    'commit_comment',
                    'content_reference',
                    'create',
                    'delete',
                    'deployment',
                    'deployment_review',
                    'deployment_status',
                    'deploy_key',
                    'discussion',
                    'discussion_comment',
                    'fork',
                    'gollum',
                    'issues',
                    'issue_comment',
                    'label',
                    'member',
                    'membership',
                    'milestone',
                    'organization',
                    'org_block',
                    'page_build',
                    'project',
                    'project_card',
                    'project_column',
                    'public',
                    'pull_request',
                    'pull_request_review',
                    'pull_request_review_comment',
                    'push',
                    'registry_package',
                    'release',
                    'repository',
                    'repository_dispatch',
                    'secret_scanning_alert',
                    'star',
                    'status',
                    'team',
                    'team_add',
                    'watch',
                    'workflow_dispatch',
                    'workflow_run',
                    'reminder'
                ]))),
                external_url: z.union([
                    z.url(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    actions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    checks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    content_references: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    contents: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    deployments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    emails: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    environments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    issues: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    keys: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    members: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    metadata: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_plan: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_projects: z.optional(z.enum([
                        'read',
                        'write',
                        'admin'
                    ])),
                    organization_secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_self_hosted_runners: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_user_blocking: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pull_requests: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secret_scanning_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_events: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_scanning_alert: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    single_file: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    statuses: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    team_discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    vulnerability_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    workflows: z.optional(z.enum([
                        'read',
                        'write'
                    ]))
                })),
                slug: z.optional(z.string()),
                updated_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        pull_request: z.optional(z.object({
            diff_url: z.optional(z.url()),
            html_url: z.optional(z.url()),
            merged_at: z.optional(z.union([
                z.iso.datetime(),
                z.null()
            ])),
            patch_url: z.optional(z.url()),
            url: z.optional(z.url())
        })),
        reactions: z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        }),
        repository_url: z.url(),
        sub_issues_summary: z.optional(zSubIssuesSummary),
        issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
        issue_field_values: z.optional(z.array(zIssueFieldValue)),
        state: z.optional(z.enum([
            'open',
            'closed'
        ])),
        state_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        timeline_url: z.optional(z.url()),
        title: z.string(),
        type: z.optional(zIssueType),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    milestone: zWebhooksMilestone,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues opened event
 */
export const zWebhookIssuesOpened = z.object({
    action: z.enum([
        'opened'
    ]),
    changes: z.optional(z.object({
        old_issue: z.union([
            z.object({
                active_lock_reason: z.optional(z.nullable(z.enum([
                    'resolved',
                    'off-topic',
                    'too heated',
                    'spam'
                ]))),
                assignee: z.optional(z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ])),
                assignees: z.optional(z.array(z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]))),
                author_association: z.optional(z.enum([
                    'COLLABORATOR',
                    'CONTRIBUTOR',
                    'FIRST_TIMER',
                    'FIRST_TIME_CONTRIBUTOR',
                    'MANNEQUIN',
                    'MEMBER',
                    'NONE',
                    'OWNER'
                ])),
                body: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                closed_at: z.optional(z.union([
                    z.iso.datetime(),
                    z.null()
                ])),
                comments: z.optional(z.int()),
                comments_url: z.optional(z.url()),
                created_at: z.optional(z.iso.datetime()),
                draft: z.optional(z.boolean()),
                events_url: z.optional(z.url()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                labels: z.optional(z.array(z.object({
                    color: z.string(),
                    default: z.boolean(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    id: z.int(),
                    name: z.string(),
                    node_id: z.string(),
                    url: z.url()
                }))),
                labels_url: z.optional(z.string()),
                locked: z.optional(z.boolean()),
                milestone: z.optional(z.union([
                    z.object({
                        closed_at: z.union([
                            z.iso.datetime(),
                            z.null()
                        ]),
                        closed_issues: z.int(),
                        created_at: z.iso.datetime(),
                        creator: z.union([
                            z.object({
                                avatar_url: z.optional(z.url()),
                                deleted: z.optional(z.boolean()),
                                email: z.optional(z.union([
                                    z.string(),
                                    z.null()
                                ])),
                                events_url: z.optional(z.string()),
                                followers_url: z.optional(z.url()),
                                following_url: z.optional(z.string()),
                                gists_url: z.optional(z.string()),
                                gravatar_id: z.optional(z.string()),
                                html_url: z.optional(z.url()),
                                id: z.int(),
                                login: z.string(),
                                name: z.optional(z.string()),
                                node_id: z.optional(z.string()),
                                organizations_url: z.optional(z.url()),
                                received_events_url: z.optional(z.url()),
                                repos_url: z.optional(z.url()),
                                site_admin: z.optional(z.boolean()),
                                starred_url: z.optional(z.string()),
                                subscriptions_url: z.optional(z.url()),
                                type: z.optional(z.enum([
                                    'Bot',
                                    'User',
                                    'Organization'
                                ])),
                                url: z.optional(z.url()),
                                user_view_type: z.optional(z.string())
                            }),
                            z.null()
                        ]),
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        due_on: z.union([
                            z.iso.datetime(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        labels_url: z.url(),
                        node_id: z.string(),
                        number: z.int(),
                        open_issues: z.int(),
                        state: z.enum([
                            'open',
                            'closed'
                        ]),
                        title: z.string(),
                        updated_at: z.iso.datetime(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                node_id: z.optional(z.string()),
                number: z.int(),
                performed_via_github_app: z.optional(z.union([
                    z.object({
                        created_at: z.union([
                            z.iso.datetime(),
                            z.null()
                        ]),
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        events: z.optional(z.array(z.enum([
                            'branch_protection_rule',
                            'check_run',
                            'check_suite',
                            'code_scanning_alert',
                            'commit_comment',
                            'content_reference',
                            'create',
                            'delete',
                            'deployment',
                            'deployment_review',
                            'deployment_status',
                            'deploy_key',
                            'discussion',
                            'discussion_comment',
                            'fork',
                            'gollum',
                            'issues',
                            'issue_comment',
                            'label',
                            'member',
                            'membership',
                            'milestone',
                            'organization',
                            'org_block',
                            'page_build',
                            'project',
                            'project_card',
                            'project_column',
                            'public',
                            'pull_request',
                            'pull_request_review',
                            'pull_request_review_comment',
                            'push',
                            'registry_package',
                            'release',
                            'repository',
                            'repository_dispatch',
                            'secret_scanning_alert',
                            'star',
                            'status',
                            'team',
                            'team_add',
                            'watch',
                            'workflow_dispatch',
                            'workflow_run'
                        ]))),
                        external_url: z.union([
                            z.url(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.union([
                            z.int(),
                            z.null()
                        ]),
                        name: z.string(),
                        node_id: z.string(),
                        owner: z.union([
                            z.object({
                                avatar_url: z.optional(z.url()),
                                deleted: z.optional(z.boolean()),
                                email: z.optional(z.union([
                                    z.string(),
                                    z.null()
                                ])),
                                events_url: z.optional(z.string()),
                                followers_url: z.optional(z.url()),
                                following_url: z.optional(z.string()),
                                gists_url: z.optional(z.string()),
                                gravatar_id: z.optional(z.string()),
                                html_url: z.optional(z.url()),
                                id: z.int(),
                                login: z.string(),
                                name: z.optional(z.string()),
                                node_id: z.optional(z.string()),
                                organizations_url: z.optional(z.url()),
                                received_events_url: z.optional(z.url()),
                                repos_url: z.optional(z.url()),
                                site_admin: z.optional(z.boolean()),
                                starred_url: z.optional(z.string()),
                                subscriptions_url: z.optional(z.url()),
                                type: z.optional(z.enum([
                                    'Bot',
                                    'User',
                                    'Organization'
                                ])),
                                url: z.optional(z.url()),
                                user_view_type: z.optional(z.string())
                            }),
                            z.null()
                        ]),
                        permissions: z.optional(z.object({
                            actions: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            administration: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            checks: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            content_references: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            contents: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            deployments: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            discussions: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            emails: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            environments: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            issues: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            keys: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            members: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            metadata: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            organization_administration: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            organization_hooks: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            organization_packages: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            organization_plan: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            organization_projects: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            organization_secrets: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            organization_self_hosted_runners: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            organization_user_blocking: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            packages: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            pages: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            pull_requests: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            repository_hooks: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            repository_projects: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            secret_scanning_alerts: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            secrets: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            security_events: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            security_scanning_alert: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            single_file: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            statuses: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            team_discussions: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            vulnerability_alerts: z.optional(z.enum([
                                'read',
                                'write'
                            ])),
                            workflows: z.optional(z.enum([
                                'read',
                                'write'
                            ]))
                        })),
                        slug: z.optional(z.string()),
                        updated_at: z.union([
                            z.iso.datetime(),
                            z.null()
                        ])
                    }),
                    z.null()
                ])),
                pull_request: z.optional(z.object({
                    diff_url: z.optional(z.url()),
                    html_url: z.optional(z.url()),
                    merged_at: z.optional(z.union([
                        z.iso.datetime(),
                        z.null()
                    ])),
                    patch_url: z.optional(z.url()),
                    url: z.optional(z.url())
                })),
                reactions: z.optional(z.object({
                    '+1': z.int(),
                    '-1': z.int(),
                    confused: z.int(),
                    eyes: z.int(),
                    heart: z.int(),
                    hooray: z.int(),
                    laugh: z.int(),
                    rocket: z.int(),
                    total_count: z.int(),
                    url: z.url()
                })),
                repository_url: z.optional(z.url()),
                sub_issues_summary: z.optional(zSubIssuesSummary),
                issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
                issue_field_values: z.optional(z.array(zIssueFieldValue)),
                state: z.optional(z.enum([
                    'open',
                    'closed'
                ])),
                state_reason: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                timeline_url: z.optional(z.url()),
                title: z.optional(z.string()),
                updated_at: z.optional(z.iso.datetime()),
                url: z.optional(z.url()),
                user: z.optional(z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.coerce.bigint(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ])),
                type: z.optional(zIssueType)
            }),
            z.null()
        ]),
        old_repository: z.object({
            allow_auto_merge: z.optional(z.boolean()).default(false),
            allow_forking: z.optional(z.boolean()),
            allow_merge_commit: z.optional(z.boolean()).default(true),
            allow_rebase_merge: z.optional(z.boolean()).default(true),
            allow_squash_merge: z.optional(z.boolean()).default(true),
            allow_update_branch: z.optional(z.boolean()),
            archive_url: z.string(),
            archived: z.boolean().default(false),
            assignees_url: z.string(),
            blobs_url: z.string(),
            branches_url: z.string(),
            clone_url: z.url(),
            collaborators_url: z.string(),
            comments_url: z.string(),
            commits_url: z.string(),
            compare_url: z.string(),
            contents_url: z.string(),
            contributors_url: z.url(),
            created_at: z.union([
                z.int(),
                z.iso.datetime()
            ]),
            custom_properties: z.optional(z.record(z.string(), z.unknown())),
            default_branch: z.string(),
            delete_branch_on_merge: z.optional(z.boolean()).default(false),
            deployments_url: z.url(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            disabled: z.optional(z.boolean()),
            downloads_url: z.url(),
            events_url: z.url(),
            fork: z.boolean(),
            forks: z.int(),
            forks_count: z.int(),
            forks_url: z.url(),
            full_name: z.string(),
            git_commits_url: z.string(),
            git_refs_url: z.string(),
            git_tags_url: z.string(),
            git_url: z.url(),
            has_discussions: z.optional(z.boolean()),
            has_downloads: z.boolean().default(true),
            has_issues: z.boolean().default(true),
            has_pages: z.boolean(),
            has_projects: z.boolean().default(true),
            has_wiki: z.boolean().default(true),
            homepage: z.union([
                z.string(),
                z.null()
            ]),
            hooks_url: z.url(),
            html_url: z.url(),
            id: z.coerce.bigint(),
            is_template: z.optional(z.boolean()),
            issue_comment_url: z.string(),
            issue_events_url: z.string(),
            issues_url: z.string(),
            keys_url: z.string(),
            labels_url: z.string(),
            language: z.union([
                z.string(),
                z.null()
            ]),
            languages_url: z.url(),
            license: z.union([
                z.object({
                    key: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    spdx_id: z.string(),
                    url: z.union([
                        z.url(),
                        z.null()
                    ])
                }),
                z.null()
            ]),
            master_branch: z.optional(z.string()),
            merges_url: z.url(),
            milestones_url: z.string(),
            mirror_url: z.union([
                z.url(),
                z.null()
            ]),
            name: z.string(),
            node_id: z.string(),
            notifications_url: z.string(),
            open_issues: z.int(),
            open_issues_count: z.int(),
            organization: z.optional(z.string()),
            owner: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            permissions: z.optional(z.object({
                admin: z.boolean(),
                maintain: z.optional(z.boolean()),
                pull: z.boolean(),
                push: z.boolean(),
                triage: z.optional(z.boolean())
            })),
            private: z.boolean(),
            public: z.optional(z.boolean()),
            pulls_url: z.string(),
            pushed_at: z.union([
                z.int(),
                z.iso.datetime(),
                z.null()
            ]),
            releases_url: z.string(),
            role_name: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            size: z.int(),
            ssh_url: z.string(),
            stargazers: z.optional(z.int()),
            stargazers_count: z.int(),
            stargazers_url: z.url(),
            statuses_url: z.string(),
            subscribers_url: z.url(),
            subscription_url: z.url(),
            svn_url: z.url(),
            tags_url: z.url(),
            teams_url: z.url(),
            topics: z.array(z.string()),
            trees_url: z.string(),
            updated_at: z.iso.datetime(),
            url: z.url(),
            visibility: z.enum([
                'public',
                'private',
                'internal'
            ]),
            watchers: z.int(),
            watchers_count: z.int(),
            web_commit_signoff_required: z.optional(z.boolean())
        })
    })),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: z.object({
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.int(),
        comments_url: z.url(),
        created_at: z.iso.datetime(),
        draft: z.optional(z.boolean()),
        events_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        labels: z.optional(z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        }))),
        labels_url: z.string(),
        locked: z.optional(z.boolean()),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        performed_via_github_app: z.optional(z.union([
            z.object({
                created_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                events: z.optional(z.array(z.enum([
                    'branch_protection_rule',
                    'check_run',
                    'check_suite',
                    'code_scanning_alert',
                    'commit_comment',
                    'content_reference',
                    'create',
                    'delete',
                    'deployment',
                    'deployment_review',
                    'deployment_status',
                    'deploy_key',
                    'discussion',
                    'discussion_comment',
                    'fork',
                    'gollum',
                    'issues',
                    'issue_comment',
                    'label',
                    'member',
                    'membership',
                    'milestone',
                    'organization',
                    'org_block',
                    'page_build',
                    'project',
                    'project_card',
                    'project_column',
                    'public',
                    'pull_request',
                    'pull_request_review',
                    'pull_request_review_comment',
                    'push',
                    'registry_package',
                    'release',
                    'repository',
                    'repository_dispatch',
                    'secret_scanning_alert',
                    'star',
                    'status',
                    'team',
                    'team_add',
                    'watch',
                    'workflow_dispatch',
                    'workflow_run',
                    'security_and_analysis',
                    'pull_request_review_thread',
                    'reminder'
                ]))),
                external_url: z.union([
                    z.url(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    actions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    checks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    content_references: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    contents: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    deployments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    emails: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    environments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    issues: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    keys: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    members: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    metadata: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_plan: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_projects: z.optional(z.enum([
                        'read',
                        'write',
                        'admin'
                    ])),
                    organization_secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_self_hosted_runners: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_user_blocking: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pull_requests: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secret_scanning_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_events: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_scanning_alert: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    single_file: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    statuses: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    team_discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    vulnerability_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    workflows: z.optional(z.enum([
                        'read',
                        'write'
                    ]))
                })),
                slug: z.optional(z.string()),
                updated_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        pull_request: z.optional(z.object({
            diff_url: z.optional(z.url()),
            html_url: z.optional(z.url()),
            merged_at: z.optional(z.union([
                z.iso.datetime(),
                z.null()
            ])),
            patch_url: z.optional(z.url()),
            url: z.optional(z.url())
        })),
        reactions: z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        }),
        repository_url: z.url(),
        sub_issues_summary: z.optional(zSubIssuesSummary),
        issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
        issue_field_values: z.optional(z.array(zIssueFieldValue)),
        state: z.optional(z.enum([
            'open',
            'closed'
        ])),
        state_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        timeline_url: z.optional(z.url()),
        title: z.string(),
        type: z.optional(zIssueType),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues pinned event
 */
export const zWebhookIssuesPinned = z.object({
    action: z.enum([
        'pinned'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: zWebhooksIssue2,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues reopened event
 */
export const zWebhookIssuesReopened = z.object({
    action: z.enum([
        'reopened'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: z.object({
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.int(),
        comments_url: z.url(),
        created_at: z.iso.datetime(),
        draft: z.optional(z.boolean()),
        events_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        labels: z.optional(z.array(z.union([
            z.object({
                color: z.string(),
                default: z.boolean(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                id: z.int(),
                name: z.string(),
                node_id: z.string(),
                url: z.url()
            }),
            z.null()
        ]))),
        labels_url: z.string(),
        locked: z.optional(z.boolean()),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        performed_via_github_app: z.optional(z.union([
            z.object({
                created_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                events: z.optional(z.array(z.enum([
                    'branch_protection_rule',
                    'check_run',
                    'check_suite',
                    'code_scanning_alert',
                    'commit_comment',
                    'content_reference',
                    'create',
                    'delete',
                    'deployment',
                    'deployment_review',
                    'deployment_status',
                    'deploy_key',
                    'discussion',
                    'discussion_comment',
                    'fork',
                    'gollum',
                    'issues',
                    'issue_comment',
                    'label',
                    'member',
                    'membership',
                    'milestone',
                    'organization',
                    'org_block',
                    'page_build',
                    'project',
                    'project_card',
                    'project_column',
                    'public',
                    'pull_request',
                    'pull_request_review',
                    'pull_request_review_comment',
                    'push',
                    'registry_package',
                    'release',
                    'repository',
                    'repository_dispatch',
                    'secret_scanning_alert',
                    'star',
                    'status',
                    'team',
                    'team_add',
                    'watch',
                    'workflow_dispatch',
                    'workflow_run',
                    'pull_request_review_thread',
                    'reminder'
                ]))),
                external_url: z.union([
                    z.url(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    actions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    checks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    content_references: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    contents: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    deployments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    emails: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    environments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    issues: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    keys: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    members: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    metadata: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_plan: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_projects: z.optional(z.enum([
                        'read',
                        'write',
                        'admin'
                    ])),
                    organization_secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_self_hosted_runners: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_user_blocking: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pull_requests: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_projects: z.optional(z.enum([
                        'read',
                        'write',
                        'admin'
                    ])),
                    secret_scanning_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_events: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_scanning_alert: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    single_file: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    statuses: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    team_discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    vulnerability_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    workflows: z.optional(z.enum([
                        'read',
                        'write'
                    ]))
                })),
                slug: z.optional(z.string()),
                updated_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        pull_request: z.optional(z.object({
            diff_url: z.optional(z.url()),
            html_url: z.optional(z.url()),
            merged_at: z.optional(z.union([
                z.iso.datetime(),
                z.null()
            ])),
            patch_url: z.optional(z.url()),
            url: z.optional(z.url())
        })),
        reactions: z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        }),
        repository_url: z.url(),
        sub_issues_summary: z.optional(zSubIssuesSummary),
        issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
        issue_field_values: z.optional(z.array(zIssueFieldValue)),
        state: z.enum([
            'open',
            'closed'
        ]),
        state_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        timeline_url: z.optional(z.url()),
        title: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        type: z.optional(zIssueType)
    }),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues transferred event
 */
export const zWebhookIssuesTransferred = z.object({
    action: z.enum([
        'transferred'
    ]),
    changes: z.object({
        new_issue: z.object({
            active_lock_reason: z.nullable(z.enum([
                'resolved',
                'off-topic',
                'too heated',
                'spam'
            ])),
            assignee: z.optional(z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])),
            assignees: z.array(z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])),
            author_association: z.enum([
                'COLLABORATOR',
                'CONTRIBUTOR',
                'FIRST_TIMER',
                'FIRST_TIME_CONTRIBUTOR',
                'MANNEQUIN',
                'MEMBER',
                'NONE',
                'OWNER'
            ]),
            body: z.union([
                z.string(),
                z.null()
            ]),
            closed_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            comments: z.int(),
            comments_url: z.url(),
            created_at: z.iso.datetime(),
            draft: z.optional(z.boolean()),
            events_url: z.url(),
            html_url: z.url(),
            id: z.coerce.bigint(),
            labels: z.optional(z.array(z.object({
                color: z.string(),
                default: z.boolean(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                id: z.int(),
                name: z.string(),
                node_id: z.string(),
                url: z.url()
            }))),
            labels_url: z.string(),
            locked: z.optional(z.boolean()),
            milestone: z.union([
                z.object({
                    closed_at: z.union([
                        z.iso.datetime(),
                        z.null()
                    ]),
                    closed_issues: z.int(),
                    created_at: z.iso.datetime(),
                    creator: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    due_on: z.union([
                        z.iso.datetime(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    labels_url: z.url(),
                    node_id: z.string(),
                    number: z.int(),
                    open_issues: z.int(),
                    state: z.enum([
                        'open',
                        'closed'
                    ]),
                    title: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url()
                }),
                z.null()
            ]),
            node_id: z.string(),
            number: z.int(),
            performed_via_github_app: z.optional(z.union([
                z.object({
                    created_at: z.union([
                        z.iso.datetime(),
                        z.null()
                    ]),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    events: z.optional(z.array(z.enum([
                        'branch_protection_rule',
                        'check_run',
                        'check_suite',
                        'code_scanning_alert',
                        'commit_comment',
                        'content_reference',
                        'create',
                        'delete',
                        'deployment',
                        'deployment_review',
                        'deployment_status',
                        'deploy_key',
                        'discussion',
                        'discussion_comment',
                        'fork',
                        'gollum',
                        'issues',
                        'issue_comment',
                        'label',
                        'member',
                        'membership',
                        'milestone',
                        'organization',
                        'org_block',
                        'page_build',
                        'project',
                        'project_card',
                        'project_column',
                        'public',
                        'pull_request',
                        'pull_request_review',
                        'pull_request_review_comment',
                        'push',
                        'registry_package',
                        'release',
                        'repository',
                        'repository_dispatch',
                        'secret_scanning_alert',
                        'star',
                        'status',
                        'team',
                        'team_add',
                        'watch',
                        'workflow_dispatch',
                        'workflow_run'
                    ]))),
                    external_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.union([
                        z.int(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        actions: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        administration: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        checks: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        content_references: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        contents: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        deployments: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        discussions: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        emails: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        environments: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        issues: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        keys: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        members: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        metadata: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        organization_administration: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        organization_hooks: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        organization_packages: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        organization_plan: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        organization_projects: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        organization_secrets: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        organization_self_hosted_runners: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        organization_user_blocking: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        packages: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        pages: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        pull_requests: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        repository_hooks: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        repository_projects: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        secret_scanning_alerts: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        secrets: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        security_events: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        security_scanning_alert: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        single_file: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        statuses: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        team_discussions: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        vulnerability_alerts: z.optional(z.enum([
                            'read',
                            'write'
                        ])),
                        workflows: z.optional(z.enum([
                            'read',
                            'write'
                        ]))
                    })),
                    slug: z.optional(z.string()),
                    updated_at: z.union([
                        z.iso.datetime(),
                        z.null()
                    ])
                }),
                z.null()
            ])),
            pull_request: z.optional(z.object({
                diff_url: z.optional(z.url()),
                html_url: z.optional(z.url()),
                merged_at: z.optional(z.union([
                    z.iso.datetime(),
                    z.null()
                ])),
                patch_url: z.optional(z.url()),
                url: z.optional(z.url())
            })),
            reactions: z.object({
                '+1': z.int(),
                '-1': z.int(),
                confused: z.int(),
                eyes: z.int(),
                heart: z.int(),
                hooray: z.int(),
                laugh: z.int(),
                rocket: z.int(),
                total_count: z.int(),
                url: z.url()
            }),
            repository_url: z.url(),
            sub_issues_summary: z.optional(zSubIssuesSummary),
            issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
            issue_field_values: z.optional(z.array(zIssueFieldValue)),
            state: z.optional(z.enum([
                'open',
                'closed'
            ])),
            state_reason: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            timeline_url: z.optional(z.url()),
            title: z.string(),
            type: z.optional(zIssueType),
            updated_at: z.iso.datetime(),
            url: z.url(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        new_repository: z.object({
            allow_auto_merge: z.optional(z.boolean()).default(false),
            allow_forking: z.optional(z.boolean()),
            allow_merge_commit: z.optional(z.boolean()).default(true),
            allow_rebase_merge: z.optional(z.boolean()).default(true),
            allow_squash_merge: z.optional(z.boolean()).default(true),
            allow_update_branch: z.optional(z.boolean()),
            archive_url: z.string(),
            archived: z.boolean().default(false),
            assignees_url: z.string(),
            blobs_url: z.string(),
            branches_url: z.string(),
            clone_url: z.url(),
            collaborators_url: z.string(),
            comments_url: z.string(),
            commits_url: z.string(),
            compare_url: z.string(),
            contents_url: z.string(),
            contributors_url: z.url(),
            created_at: z.union([
                z.int(),
                z.iso.datetime()
            ]),
            custom_properties: z.optional(z.record(z.string(), z.unknown())),
            default_branch: z.string(),
            delete_branch_on_merge: z.optional(z.boolean()).default(false),
            deployments_url: z.url(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            disabled: z.optional(z.boolean()),
            downloads_url: z.url(),
            events_url: z.url(),
            fork: z.boolean(),
            forks: z.int(),
            forks_count: z.int(),
            forks_url: z.url(),
            full_name: z.string(),
            git_commits_url: z.string(),
            git_refs_url: z.string(),
            git_tags_url: z.string(),
            git_url: z.url(),
            has_downloads: z.boolean().default(true),
            has_issues: z.boolean().default(true),
            has_pages: z.boolean(),
            has_projects: z.boolean().default(true),
            has_wiki: z.boolean().default(true),
            has_discussions: z.boolean().default(false),
            homepage: z.union([
                z.string(),
                z.null()
            ]),
            hooks_url: z.url(),
            html_url: z.url(),
            id: z.coerce.bigint(),
            is_template: z.optional(z.boolean()),
            issue_comment_url: z.string(),
            issue_events_url: z.string(),
            issues_url: z.string(),
            keys_url: z.string(),
            labels_url: z.string(),
            language: z.union([
                z.string(),
                z.null()
            ]),
            languages_url: z.url(),
            license: z.union([
                z.object({
                    key: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    spdx_id: z.string(),
                    url: z.union([
                        z.url(),
                        z.null()
                    ])
                }),
                z.null()
            ]),
            master_branch: z.optional(z.string()),
            merges_url: z.url(),
            milestones_url: z.string(),
            mirror_url: z.union([
                z.url(),
                z.null()
            ]),
            name: z.string(),
            node_id: z.string(),
            notifications_url: z.string(),
            open_issues: z.int(),
            open_issues_count: z.int(),
            organization: z.optional(z.string()),
            owner: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            permissions: z.optional(z.object({
                admin: z.boolean(),
                maintain: z.optional(z.boolean()),
                pull: z.boolean(),
                push: z.boolean(),
                triage: z.optional(z.boolean())
            })),
            private: z.boolean(),
            public: z.optional(z.boolean()),
            pulls_url: z.string(),
            pushed_at: z.union([
                z.int(),
                z.iso.datetime(),
                z.null()
            ]),
            releases_url: z.string(),
            role_name: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            size: z.int(),
            ssh_url: z.string(),
            stargazers: z.optional(z.int()),
            stargazers_count: z.int(),
            stargazers_url: z.url(),
            statuses_url: z.string(),
            subscribers_url: z.url(),
            subscription_url: z.url(),
            svn_url: z.url(),
            tags_url: z.url(),
            teams_url: z.url(),
            topics: z.array(z.string()),
            trees_url: z.string(),
            updated_at: z.iso.datetime(),
            url: z.url(),
            visibility: z.enum([
                'public',
                'private',
                'internal'
            ]),
            watchers: z.int(),
            watchers_count: z.int(),
            web_commit_signoff_required: z.optional(z.boolean())
        })
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: zWebhooksIssue2,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues typed event
 */
export const zWebhookIssuesTyped = z.object({
    action: z.enum([
        'typed'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: zWebhooksIssue,
    type: zIssueType,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues unassigned event
 */
export const zWebhookIssuesUnassigned = z.object({
    action: z.enum([
        'unassigned'
    ]),
    assignee: z.optional(zWebhooksUserMannequin),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: zWebhooksIssue,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues unlabeled event
 */
export const zWebhookIssuesUnlabeled = z.object({
    action: z.enum([
        'unlabeled'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: zWebhooksIssue,
    label: z.optional(zWebhooksLabel),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues unlocked event
 */
export const zWebhookIssuesUnlocked = z.object({
    action: z.enum([
        'unlocked'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: z.object({
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.int(),
        comments_url: z.url(),
        created_at: z.iso.datetime(),
        draft: z.optional(z.boolean()),
        events_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        labels: z.optional(z.array(z.union([
            z.object({
                color: z.string(),
                default: z.boolean(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                id: z.int(),
                name: z.string(),
                node_id: z.string(),
                url: z.url()
            }),
            z.null()
        ]))),
        labels_url: z.string(),
        locked: z.literal(false),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        performed_via_github_app: z.optional(z.union([
            z.object({
                created_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                events: z.optional(z.array(z.enum([
                    'branch_protection_rule',
                    'check_run',
                    'check_suite',
                    'code_scanning_alert',
                    'commit_comment',
                    'content_reference',
                    'create',
                    'delete',
                    'deployment',
                    'deployment_review',
                    'deployment_status',
                    'deploy_key',
                    'discussion',
                    'discussion_comment',
                    'fork',
                    'gollum',
                    'issues',
                    'issue_comment',
                    'label',
                    'member',
                    'membership',
                    'milestone',
                    'organization',
                    'org_block',
                    'page_build',
                    'project',
                    'project_card',
                    'project_column',
                    'public',
                    'pull_request',
                    'pull_request_review',
                    'pull_request_review_comment',
                    'push',
                    'registry_package',
                    'release',
                    'repository',
                    'repository_dispatch',
                    'secret_scanning_alert',
                    'star',
                    'status',
                    'team',
                    'team_add',
                    'watch',
                    'workflow_dispatch',
                    'workflow_run'
                ]))),
                external_url: z.union([
                    z.url(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    actions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    checks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    content_references: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    contents: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    deployments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    emails: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    environments: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    issues: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    keys: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    members: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    metadata: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_administration: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_plan: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_self_hosted_runners: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    organization_user_blocking: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    packages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pages: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    pull_requests: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_hooks: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    repository_projects: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secret_scanning_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    secrets: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_events: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    security_scanning_alert: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    single_file: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    statuses: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    team_discussions: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    vulnerability_alerts: z.optional(z.enum([
                        'read',
                        'write'
                    ])),
                    workflows: z.optional(z.enum([
                        'read',
                        'write'
                    ]))
                })),
                slug: z.optional(z.string()),
                updated_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        pull_request: z.optional(z.object({
            diff_url: z.optional(z.url()),
            html_url: z.optional(z.url()),
            merged_at: z.optional(z.union([
                z.iso.datetime(),
                z.null()
            ])),
            patch_url: z.optional(z.url()),
            url: z.optional(z.url())
        })),
        reactions: z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        }),
        repository_url: z.url(),
        sub_issues_summary: z.optional(zSubIssuesSummary),
        issue_dependencies_summary: z.optional(zIssueDependenciesSummary),
        issue_field_values: z.optional(z.array(zIssueFieldValue)),
        state: z.optional(z.enum([
            'open',
            'closed'
        ])),
        state_reason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        timeline_url: z.optional(z.url()),
        title: z.string(),
        type: z.optional(zIssueType),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues unpinned event
 */
export const zWebhookIssuesUnpinned = z.object({
    action: z.enum([
        'unpinned'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: zWebhooksIssue2,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * issues untyped event
 */
export const zWebhookIssuesUntyped = z.object({
    action: z.enum([
        'untyped'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    issue: zWebhooksIssue,
    type: zIssueType,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * label created event
 */
export const zWebhookLabelCreated = z.object({
    action: z.enum([
        'created'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    label: zWebhooksLabel,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * label deleted event
 */
export const zWebhookLabelDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    label: zWebhooksLabel,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * label edited event
 */
export const zWebhookLabelEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.optional(z.object({
        color: z.optional(z.object({
            from: z.string()
        })),
        description: z.optional(z.object({
            from: z.string()
        })),
        name: z.optional(z.object({
            from: z.string()
        }))
    })),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    label: zWebhooksLabel,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * marketplace_purchase cancelled event
 */
export const zWebhookMarketplacePurchaseCancelled = z.object({
    action: z.enum([
        'cancelled'
    ]),
    effective_date: z.string(),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    marketplace_purchase: zWebhooksMarketplacePurchase,
    organization: z.optional(zOrganizationSimpleWebhooks),
    previous_marketplace_purchase: z.optional(zWebhooksPreviousMarketplacePurchase),
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * marketplace_purchase changed event
 */
export const zWebhookMarketplacePurchaseChanged = z.object({
    action: z.enum([
        'changed'
    ]),
    effective_date: z.string(),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    marketplace_purchase: zWebhooksMarketplacePurchase,
    organization: z.optional(zOrganizationSimpleWebhooks),
    previous_marketplace_purchase: z.optional(z.object({
        account: z.object({
            id: z.int(),
            login: z.string(),
            node_id: z.string(),
            organization_billing_email: z.union([
                z.string(),
                z.null()
            ]),
            type: z.string()
        }),
        billing_cycle: z.string(),
        free_trial_ends_on: z.union([
            z.string(),
            z.null()
        ]),
        next_billing_date: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        on_free_trial: z.union([
            z.boolean(),
            z.null()
        ]),
        plan: z.object({
            bullets: z.array(z.string()),
            description: z.string(),
            has_free_trial: z.boolean(),
            id: z.int(),
            monthly_price_in_cents: z.int(),
            name: z.string(),
            price_model: z.enum([
                'FREE',
                'FLAT_RATE',
                'PER_UNIT'
            ]),
            unit_name: z.union([
                z.string(),
                z.null()
            ]),
            yearly_price_in_cents: z.int()
        }),
        unit_count: z.int()
    })),
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * marketplace_purchase pending_change event
 */
export const zWebhookMarketplacePurchasePendingChange = z.object({
    action: z.enum([
        'pending_change'
    ]),
    effective_date: z.string(),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    marketplace_purchase: zWebhooksMarketplacePurchase,
    organization: z.optional(zOrganizationSimpleWebhooks),
    previous_marketplace_purchase: z.optional(z.object({
        account: z.object({
            id: z.int(),
            login: z.string(),
            node_id: z.string(),
            organization_billing_email: z.union([
                z.string(),
                z.null()
            ]),
            type: z.string()
        }),
        billing_cycle: z.string(),
        free_trial_ends_on: z.union([
            z.string(),
            z.null()
        ]),
        next_billing_date: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        on_free_trial: z.boolean(),
        plan: z.object({
            bullets: z.array(z.string()),
            description: z.string(),
            has_free_trial: z.boolean(),
            id: z.int(),
            monthly_price_in_cents: z.int(),
            name: z.string(),
            price_model: z.enum([
                'FREE',
                'FLAT_RATE',
                'PER_UNIT'
            ]),
            unit_name: z.union([
                z.string(),
                z.null()
            ]),
            yearly_price_in_cents: z.int()
        }),
        unit_count: z.int()
    })),
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * marketplace_purchase pending_change_cancelled event
 */
export const zWebhookMarketplacePurchasePendingChangeCancelled = z.object({
    action: z.enum([
        'pending_change_cancelled'
    ]),
    effective_date: z.string(),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    marketplace_purchase: z.object({
        account: z.object({
            id: z.int(),
            login: z.string(),
            node_id: z.string(),
            organization_billing_email: z.union([
                z.string(),
                z.null()
            ]),
            type: z.string()
        }),
        billing_cycle: z.string(),
        free_trial_ends_on: z.unknown(),
        next_billing_date: z.union([
            z.string(),
            z.null()
        ]),
        on_free_trial: z.boolean(),
        plan: z.object({
            bullets: z.array(z.string()),
            description: z.string(),
            has_free_trial: z.boolean(),
            id: z.int(),
            monthly_price_in_cents: z.int(),
            name: z.string(),
            price_model: z.enum([
                'FREE',
                'FLAT_RATE',
                'PER_UNIT'
            ]),
            unit_name: z.union([
                z.string(),
                z.null()
            ]),
            yearly_price_in_cents: z.int()
        }),
        unit_count: z.int()
    }),
    organization: z.optional(zOrganizationSimpleWebhooks),
    previous_marketplace_purchase: z.optional(zWebhooksPreviousMarketplacePurchase),
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * marketplace_purchase purchased event
 */
export const zWebhookMarketplacePurchasePurchased = z.object({
    action: z.enum([
        'purchased'
    ]),
    effective_date: z.string(),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    marketplace_purchase: zWebhooksMarketplacePurchase,
    organization: z.optional(zOrganizationSimpleWebhooks),
    previous_marketplace_purchase: z.optional(zWebhooksPreviousMarketplacePurchase),
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * member added event
 */
export const zWebhookMemberAdded = z.object({
    action: z.enum([
        'added'
    ]),
    changes: z.optional(z.object({
        permission: z.optional(z.object({
            to: z.enum([
                'write',
                'admin',
                'read'
            ])
        })),
        role_name: z.optional(z.object({
            to: z.string()
        }))
    })),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    member: zWebhooksUser,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * member edited event
 */
export const zWebhookMemberEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.object({
        old_permission: z.optional(z.object({
            from: z.string()
        })),
        permission: z.optional(z.object({
            from: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            to: z.optional(z.union([
                z.string(),
                z.null()
            ]))
        }))
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    member: zWebhooksUser,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * member removed event
 */
export const zWebhookMemberRemoved = z.object({
    action: z.enum([
        'removed'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    member: zWebhooksUser,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * membership added event
 */
export const zWebhookMembershipAdded = z.object({
    action: z.enum([
        'added'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    member: zWebhooksUser,
    organization: zOrganizationSimpleWebhooks,
    repository: z.optional(zRepositoryWebhooks),
    scope: z.enum([
        'team'
    ]),
    sender: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ]),
    team: zWebhooksTeam
});

/**
 * membership removed event
 */
export const zWebhookMembershipRemoved = z.object({
    action: z.enum([
        'removed'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    member: zWebhooksUser,
    organization: zOrganizationSimpleWebhooks,
    repository: z.optional(zRepositoryWebhooks),
    scope: z.enum([
        'team',
        'organization'
    ]),
    sender: z.union([
        z.object({
            avatar_url: z.optional(z.url()),
            deleted: z.optional(z.boolean()),
            email: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            events_url: z.optional(z.string()),
            followers_url: z.optional(z.url()),
            following_url: z.optional(z.string()),
            gists_url: z.optional(z.string()),
            gravatar_id: z.optional(z.string()),
            html_url: z.optional(z.url()),
            id: z.int(),
            login: z.string(),
            name: z.optional(z.string()),
            node_id: z.optional(z.string()),
            organizations_url: z.optional(z.url()),
            received_events_url: z.optional(z.url()),
            repos_url: z.optional(z.url()),
            site_admin: z.optional(z.boolean()),
            starred_url: z.optional(z.string()),
            subscriptions_url: z.optional(z.url()),
            type: z.optional(z.enum([
                'Bot',
                'User',
                'Organization'
            ])),
            url: z.optional(z.url()),
            user_view_type: z.optional(z.string())
        }),
        z.null()
    ]),
    team: zWebhooksTeam
});

export const zWebhookMergeGroupChecksRequested = z.object({
    action: z.enum([
        'checks_requested'
    ]),
    installation: z.optional(zSimpleInstallation),
    merge_group: zMergeGroup,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    sender: z.optional(zSimpleUser)
});

export const zWebhookMergeGroupDestroyed = z.object({
    action: z.enum([
        'destroyed'
    ]),
    reason: z.optional(z.enum([
        'merged',
        'invalidated',
        'dequeued'
    ])),
    installation: z.optional(zSimpleInstallation),
    merge_group: zMergeGroup,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    sender: z.optional(zSimpleUser)
});

/**
 * meta deleted event
 */
export const zWebhookMetaDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    hook: z.object({
        active: z.boolean(),
        config: z.object({
            content_type: z.enum([
                'json',
                'form'
            ]),
            insecure_ssl: z.string(),
            secret: z.optional(z.string()),
            url: z.url()
        }),
        created_at: z.string(),
        events: z.array(z.enum([
            '*',
            'branch_protection_rule',
            'check_run',
            'check_suite',
            'code_scanning_alert',
            'commit_comment',
            'create',
            'delete',
            'deployment',
            'deployment_status',
            'deploy_key',
            'discussion',
            'discussion_comment',
            'fork',
            'gollum',
            'issues',
            'issue_comment',
            'label',
            'member',
            'membership',
            'meta',
            'milestone',
            'organization',
            'org_block',
            'package',
            'page_build',
            'project',
            'project_card',
            'project_column',
            'public',
            'pull_request',
            'pull_request_review',
            'pull_request_review_comment',
            'pull_request_review_thread',
            'push',
            'registry_package',
            'release',
            'repository',
            'repository_import',
            'repository_vulnerability_alert',
            'secret_scanning_alert',
            'secret_scanning_alert_location',
            'security_and_analysis',
            'star',
            'status',
            'team',
            'team_add',
            'watch',
            'workflow_job',
            'workflow_run',
            'repository_dispatch',
            'projects_v2_item'
        ])),
        id: z.int(),
        name: z.string(),
        type: z.string(),
        updated_at: z.string()
    }),
    hook_id: z.int(),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zNullableRepositoryWebhooks),
    sender: z.optional(zSimpleUser)
});

/**
 * milestone closed event
 */
export const zWebhookMilestoneClosed = z.object({
    action: z.enum([
        'closed'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    milestone: zWebhooksMilestone,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * milestone created event
 */
export const zWebhookMilestoneCreated = z.object({
    action: z.enum([
        'created'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    milestone: zWebhooksMilestone3,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * milestone deleted event
 */
export const zWebhookMilestoneDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    milestone: zWebhooksMilestone,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * milestone edited event
 */
export const zWebhookMilestoneEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.object({
        description: z.optional(z.object({
            from: z.string()
        })),
        due_on: z.optional(z.object({
            from: z.string()
        })),
        title: z.optional(z.object({
            from: z.string()
        }))
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    milestone: zWebhooksMilestone,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * milestone opened event
 */
export const zWebhookMilestoneOpened = z.object({
    action: z.enum([
        'opened'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    milestone: zWebhooksMilestone3,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * org_block blocked event
 */
export const zWebhookOrgBlockBlocked = z.object({
    action: z.enum([
        'blocked'
    ]),
    blocked_user: zWebhooksUser,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * org_block unblocked event
 */
export const zWebhookOrgBlockUnblocked = z.object({
    action: z.enum([
        'unblocked'
    ]),
    blocked_user: zWebhooksUser,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * organization deleted event
 */
export const zWebhookOrganizationDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    membership: z.optional(zWebhooksMembership),
    organization: zOrganizationSimpleWebhooks,
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * organization member_added event
 */
export const zWebhookOrganizationMemberAdded = z.object({
    action: z.enum([
        'member_added'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    membership: zWebhooksMembership,
    organization: zOrganizationSimpleWebhooks,
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * organization member_invited event
 */
export const zWebhookOrganizationMemberInvited = z.object({
    action: z.enum([
        'member_invited'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    invitation: z.object({
        created_at: z.iso.datetime(),
        email: z.union([
            z.string(),
            z.null()
        ]),
        failed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        failed_reason: z.union([
            z.string(),
            z.null()
        ]),
        id: z.number(),
        invitation_teams_url: z.url(),
        inviter: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        login: z.union([
            z.string(),
            z.null()
        ]),
        node_id: z.string(),
        role: z.string(),
        team_count: z.number(),
        invitation_source: z.optional(z.string())
    }),
    organization: zOrganizationSimpleWebhooks,
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser,
    user: z.optional(zWebhooksUser)
});

/**
 * organization member_removed event
 */
export const zWebhookOrganizationMemberRemoved = z.object({
    action: z.enum([
        'member_removed'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    membership: zWebhooksMembership,
    organization: zOrganizationSimpleWebhooks,
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * organization renamed event
 */
export const zWebhookOrganizationRenamed = z.object({
    action: z.enum([
        'renamed'
    ]),
    changes: z.optional(z.object({
        login: z.optional(z.object({
            from: z.optional(z.string())
        }))
    })),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    membership: z.optional(zWebhooksMembership),
    organization: zOrganizationSimpleWebhooks,
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * Ruby Gems metadata
 */
export const zWebhookRubygemsMetadata = z.object({
    name: z.optional(z.string()),
    description: z.optional(z.string()),
    readme: z.optional(z.string()),
    homepage: z.optional(z.string()),
    version_info: z.optional(z.object({
        version: z.optional(z.string())
    })),
    platform: z.optional(z.string()),
    metadata: z.optional(z.record(z.string(), z.string())),
    repo: z.optional(z.string()),
    dependencies: z.optional(z.array(z.record(z.string(), z.string()))),
    commit_oid: z.optional(z.string())
});

/**
 * package published event
 */
export const zWebhookPackagePublished = z.object({
    action: z.enum([
        'published'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    package: z.object({
        created_at: z.union([
            z.string(),
            z.null()
        ]),
        description: z.union([
            z.string(),
            z.null()
        ]),
        ecosystem: z.string(),
        html_url: z.url(),
        id: z.int(),
        name: z.string(),
        namespace: z.string(),
        owner: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        package_type: z.string(),
        package_version: z.union([
            z.object({
                author: z.optional(z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ])),
                body: z.optional(z.union([
                    z.string(),
                    z.record(z.string(), z.unknown())
                ])),
                body_html: z.optional(z.string()),
                container_metadata: z.optional(z.union([
                    z.object({
                        labels: z.optional(z.union([
                            z.record(z.string(), z.unknown()),
                            z.null()
                        ])),
                        manifest: z.optional(z.union([
                            z.record(z.string(), z.unknown()),
                            z.null()
                        ])),
                        tag: z.optional(z.object({
                            digest: z.optional(z.string()),
                            name: z.optional(z.string())
                        }))
                    }),
                    z.null()
                ])),
                created_at: z.optional(z.string()),
                description: z.string(),
                docker_metadata: z.optional(z.array(z.object({
                    tags: z.optional(z.array(z.string()))
                }))),
                draft: z.optional(z.boolean()),
                html_url: z.url(),
                id: z.int(),
                installation_command: z.string(),
                manifest: z.optional(z.string()),
                metadata: z.array(z.record(z.string(), z.unknown())),
                name: z.string(),
                npm_metadata: z.optional(z.union([
                    z.object({
                        name: z.optional(z.string()),
                        version: z.optional(z.string()),
                        npm_user: z.optional(z.string()),
                        author: z.optional(z.union([
                            z.record(z.string(), z.unknown()),
                            z.null()
                        ])),
                        bugs: z.optional(z.union([
                            z.record(z.string(), z.unknown()),
                            z.null()
                        ])),
                        dependencies: z.optional(z.record(z.string(), z.unknown())),
                        dev_dependencies: z.optional(z.record(z.string(), z.unknown())),
                        peer_dependencies: z.optional(z.record(z.string(), z.unknown())),
                        optional_dependencies: z.optional(z.record(z.string(), z.unknown())),
                        description: z.optional(z.string()),
                        dist: z.optional(z.union([
                            z.record(z.string(), z.unknown()),
                            z.null()
                        ])),
                        git_head: z.optional(z.string()),
                        homepage: z.optional(z.string()),
                        license: z.optional(z.string()),
                        main: z.optional(z.string()),
                        repository: z.optional(z.union([
                            z.record(z.string(), z.unknown()),
                            z.null()
                        ])),
                        scripts: z.optional(z.record(z.string(), z.unknown())),
                        id: z.optional(z.string()),
                        node_version: z.optional(z.string()),
                        npm_version: z.optional(z.string()),
                        has_shrinkwrap: z.optional(z.boolean()),
                        maintainers: z.optional(z.array(z.record(z.string(), z.unknown()))),
                        contributors: z.optional(z.array(z.record(z.string(), z.unknown()))),
                        engines: z.optional(z.record(z.string(), z.unknown())),
                        keywords: z.optional(z.array(z.string())),
                        files: z.optional(z.array(z.string())),
                        bin: z.optional(z.record(z.string(), z.unknown())),
                        man: z.optional(z.record(z.string(), z.unknown())),
                        directories: z.optional(z.union([
                            z.record(z.string(), z.unknown()),
                            z.null()
                        ])),
                        os: z.optional(z.array(z.string())),
                        cpu: z.optional(z.array(z.string())),
                        readme: z.optional(z.string()),
                        installation_command: z.optional(z.string()),
                        release_id: z.optional(z.int()),
                        commit_oid: z.optional(z.string()),
                        published_via_actions: z.optional(z.boolean()),
                        deleted_by_id: z.optional(z.int())
                    }),
                    z.null()
                ])),
                nuget_metadata: z.optional(z.union([
                    z.array(z.object({
                        id: z.optional(z.union([
                            z.int(),
                            z.string()
                        ])),
                        name: z.optional(z.string()),
                        value: z.optional(z.union([
                            z.boolean(),
                            z.string(),
                            z.int(),
                            z.object({
                                url: z.optional(z.string()),
                                branch: z.optional(z.string()),
                                commit: z.optional(z.string()),
                                type: z.optional(z.string())
                            })
                        ]))
                    })),
                    z.null()
                ])),
                package_files: z.array(z.object({
                    content_type: z.string(),
                    created_at: z.string(),
                    download_url: z.url(),
                    id: z.int(),
                    md5: z.union([
                        z.string(),
                        z.null()
                    ]),
                    name: z.string(),
                    sha1: z.union([
                        z.string(),
                        z.null()
                    ]),
                    sha256: z.union([
                        z.string(),
                        z.null()
                    ]),
                    size: z.int(),
                    state: z.union([
                        z.string(),
                        z.null()
                    ]),
                    updated_at: z.string()
                })),
                package_url: z.optional(z.string()),
                prerelease: z.optional(z.boolean()),
                release: z.optional(z.object({
                    author: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    created_at: z.string(),
                    draft: z.boolean(),
                    html_url: z.url(),
                    id: z.int(),
                    name: z.union([
                        z.string(),
                        z.null()
                    ]),
                    prerelease: z.boolean(),
                    published_at: z.string(),
                    tag_name: z.string(),
                    target_commitish: z.string(),
                    url: z.url()
                })),
                rubygems_metadata: z.optional(z.array(zWebhookRubygemsMetadata)),
                source_url: z.optional(z.string()),
                summary: z.string(),
                tag_name: z.optional(z.string()),
                target_commitish: z.optional(z.string()),
                target_oid: z.optional(z.string()),
                updated_at: z.optional(z.string()),
                version: z.string()
            }),
            z.null()
        ]),
        registry: z.union([
            z.object({
                about_url: z.url(),
                name: z.string(),
                type: z.string(),
                url: z.url(),
                vendor: z.string()
            }),
            z.null()
        ]),
        updated_at: z.union([
            z.string(),
            z.null()
        ])
    }),
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * package updated event
 */
export const zWebhookPackageUpdated = z.object({
    action: z.enum([
        'updated'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    package: z.object({
        created_at: z.string(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        ecosystem: z.string(),
        html_url: z.url(),
        id: z.int(),
        name: z.string(),
        namespace: z.string(),
        owner: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        package_type: z.string(),
        package_version: z.object({
            author: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            body: z.string(),
            body_html: z.string(),
            created_at: z.string(),
            description: z.string(),
            docker_metadata: z.optional(z.array(z.object({
                tags: z.optional(z.array(z.string()))
            }))),
            draft: z.optional(z.boolean()),
            html_url: z.url(),
            id: z.int(),
            installation_command: z.string(),
            manifest: z.optional(z.string()),
            metadata: z.array(z.record(z.string(), z.unknown())),
            name: z.string(),
            package_files: z.array(z.object({
                content_type: z.string(),
                created_at: z.string(),
                download_url: z.url(),
                id: z.int(),
                md5: z.union([
                    z.string(),
                    z.null()
                ]),
                name: z.string(),
                sha1: z.union([
                    z.string(),
                    z.null()
                ]),
                sha256: z.string(),
                size: z.int(),
                state: z.string(),
                updated_at: z.string()
            })),
            package_url: z.optional(z.string()),
            prerelease: z.optional(z.boolean()),
            release: z.optional(z.object({
                author: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                created_at: z.string(),
                draft: z.boolean(),
                html_url: z.url(),
                id: z.int(),
                name: z.string(),
                prerelease: z.boolean(),
                published_at: z.string(),
                tag_name: z.string(),
                target_commitish: z.string(),
                url: z.url()
            })),
            rubygems_metadata: z.optional(z.array(zWebhookRubygemsMetadata)),
            source_url: z.optional(z.url()),
            summary: z.string(),
            tag_name: z.optional(z.string()),
            target_commitish: z.string(),
            target_oid: z.string(),
            updated_at: z.string(),
            version: z.string()
        }),
        registry: z.union([
            z.object({
                about_url: z.url(),
                name: z.string(),
                type: z.string(),
                url: z.url(),
                vendor: z.string()
            }),
            z.null()
        ]),
        updated_at: z.string()
    }),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * page_build event
 */
export const zWebhookPageBuild = z.object({
    build: z.object({
        commit: z.union([
            z.string(),
            z.null()
        ]),
        created_at: z.string(),
        duration: z.int(),
        error: z.object({
            message: z.union([
                z.string(),
                z.null()
            ])
        }),
        pusher: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        status: z.string(),
        updated_at: z.string(),
        url: z.url()
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    id: z.int(),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * personal_access_token_request approved event
 */
export const zWebhookPersonalAccessTokenRequestApproved = z.object({
    action: z.enum([
        'approved'
    ]),
    personal_access_token_request: zPersonalAccessTokenRequest,
    enterprise: z.optional(zEnterpriseWebhooks),
    organization: zOrganizationSimpleWebhooks,
    sender: zSimpleUser,
    installation: zSimpleInstallation
});

/**
 * personal_access_token_request cancelled event
 */
export const zWebhookPersonalAccessTokenRequestCancelled = z.object({
    action: z.enum([
        'cancelled'
    ]),
    personal_access_token_request: zPersonalAccessTokenRequest,
    enterprise: z.optional(zEnterpriseWebhooks),
    organization: zOrganizationSimpleWebhooks,
    sender: zSimpleUser,
    installation: zSimpleInstallation
});

/**
 * personal_access_token_request created event
 */
export const zWebhookPersonalAccessTokenRequestCreated = z.object({
    action: z.enum([
        'created'
    ]),
    personal_access_token_request: zPersonalAccessTokenRequest,
    enterprise: z.optional(zEnterpriseWebhooks),
    organization: zOrganizationSimpleWebhooks,
    sender: zSimpleUser,
    installation: z.optional(zSimpleInstallation)
});

/**
 * personal_access_token_request denied event
 */
export const zWebhookPersonalAccessTokenRequestDenied = z.object({
    action: z.enum([
        'denied'
    ]),
    personal_access_token_request: zPersonalAccessTokenRequest,
    organization: zOrganizationSimpleWebhooks,
    enterprise: z.optional(zEnterpriseWebhooks),
    sender: zSimpleUser,
    installation: zSimpleInstallation
});

export const zWebhookPing = z.object({
    hook: z.optional(z.object({
        active: z.boolean(),
        app_id: z.optional(z.int()),
        config: z.object({
            content_type: z.optional(zWebhookConfigContentType),
            insecure_ssl: z.optional(zWebhookConfigInsecureSsl),
            secret: z.optional(zWebhookConfigSecret),
            url: z.optional(zWebhookConfigUrl)
        }),
        created_at: z.iso.datetime(),
        deliveries_url: z.optional(z.url()),
        events: z.array(z.string()),
        id: z.int(),
        last_response: z.optional(zHookResponse),
        name: z.enum([
            'web'
        ]),
        ping_url: z.optional(z.url()),
        test_url: z.optional(z.url()),
        type: z.string(),
        updated_at: z.iso.datetime(),
        url: z.optional(z.url())
    })),
    hook_id: z.optional(z.int()),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    sender: z.optional(zSimpleUser),
    zen: z.optional(z.string())
});

/**
 * The webhooks ping payload encoded with URL encoding.
 */
export const zWebhookPingFormEncoded = z.object({
    payload: z.string()
});

/**
 * project_card converted event
 */
export const zWebhookProjectCardConverted = z.object({
    action: z.enum([
        'converted'
    ]),
    changes: z.object({
        note: z.object({
            from: z.string()
        })
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    project_card: zWebhooksProjectCard,
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * project_card created event
 */
export const zWebhookProjectCardCreated = z.object({
    action: z.enum([
        'created'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    project_card: zWebhooksProjectCard,
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * project_card deleted event
 */
export const zWebhookProjectCardDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    project_card: z.object({
        after_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        archived: z.boolean(),
        column_id: z.union([
            z.int(),
            z.null()
        ]),
        column_url: z.url(),
        content_url: z.optional(z.url()),
        created_at: z.iso.datetime(),
        creator: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        id: z.int(),
        node_id: z.string(),
        note: z.union([
            z.string(),
            z.null()
        ]),
        project_url: z.url(),
        updated_at: z.iso.datetime(),
        url: z.url()
    }),
    repository: z.optional(zNullableRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * project_card edited event
 */
export const zWebhookProjectCardEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.object({
        note: z.object({
            from: z.union([
                z.string(),
                z.null()
            ])
        })
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    project_card: zWebhooksProjectCard,
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * project_card moved event
 */
export const zWebhookProjectCardMoved = z.object({
    action: z.enum([
        'moved'
    ]),
    changes: z.optional(z.object({
        column_id: z.object({
            from: z.int()
        })
    })),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    project_card: z.object({
        after_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        archived: z.boolean(),
        column_id: z.int(),
        column_url: z.url(),
        content_url: z.optional(z.url()),
        created_at: z.iso.datetime(),
        creator: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        id: z.int(),
        node_id: z.string(),
        note: z.union([
            z.string(),
            z.null()
        ]),
        project_url: z.url(),
        updated_at: z.iso.datetime(),
        url: z.url()
    }).and(z.object({
        after_id: z.union([
            z.number(),
            z.null()
        ]),
        archived: z.optional(z.boolean()),
        column_id: z.optional(z.int()),
        column_url: z.optional(z.string()),
        created_at: z.optional(z.string()),
        creator: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.string()),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.string()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.string()),
                id: z.optional(z.int()),
                login: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.string()),
                received_events_url: z.optional(z.string()),
                repos_url: z.optional(z.string()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.string()),
                type: z.optional(z.string()),
                url: z.optional(z.string())
            }),
            z.null()
        ])),
        id: z.optional(z.int()),
        node_id: z.optional(z.string()),
        note: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        project_url: z.optional(z.string()),
        updated_at: z.optional(z.string()),
        url: z.optional(z.string())
    })),
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * project closed event
 */
export const zWebhookProjectClosed = z.object({
    action: z.enum([
        'closed'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    project: zWebhooksProject,
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * project_column created event
 */
export const zWebhookProjectColumnCreated = z.object({
    action: z.enum([
        'created'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    project_column: zWebhooksProjectColumn,
    repository: z.optional(zRepositoryWebhooks),
    sender: z.optional(zSimpleUser)
});

/**
 * project_column deleted event
 */
export const zWebhookProjectColumnDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    project_column: zWebhooksProjectColumn,
    repository: z.optional(zNullableRepositoryWebhooks),
    sender: z.optional(zSimpleUser)
});

/**
 * project_column edited event
 */
export const zWebhookProjectColumnEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.object({
        name: z.optional(z.object({
            from: z.string()
        }))
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    project_column: zWebhooksProjectColumn,
    repository: z.optional(zRepositoryWebhooks),
    sender: z.optional(zSimpleUser)
});

/**
 * project_column moved event
 */
export const zWebhookProjectColumnMoved = z.object({
    action: z.enum([
        'moved'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    project_column: zWebhooksProjectColumn,
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * project created event
 */
export const zWebhookProjectCreated = z.object({
    action: z.enum([
        'created'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    project: zWebhooksProject,
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * project deleted event
 */
export const zWebhookProjectDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    project: zWebhooksProject,
    repository: z.optional(zNullableRepositoryWebhooks),
    sender: z.optional(zSimpleUser)
});

/**
 * project edited event
 */
export const zWebhookProjectEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.optional(z.object({
        body: z.optional(z.object({
            from: z.string()
        })),
        name: z.optional(z.object({
            from: z.string()
        }))
    })),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    project: zWebhooksProject,
    repository: z.optional(zRepositoryWebhooks),
    sender: z.optional(zSimpleUser)
});

/**
 * project reopened event
 */
export const zWebhookProjectReopened = z.object({
    action: z.enum([
        'reopened'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    project: zWebhooksProject,
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * Projects v2 Project Closed Event
 */
export const zWebhookProjectsV2ProjectClosed = z.object({
    action: z.enum([
        'closed'
    ]),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    projects_v2: zProjectsV2,
    sender: zSimpleUser
});

/**
 * A project was created
 */
export const zWebhookProjectsV2ProjectCreated = z.object({
    action: z.enum([
        'created'
    ]),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    projects_v2: zProjectsV2,
    sender: zSimpleUser
});

/**
 * Projects v2 Project Deleted Event
 */
export const zWebhookProjectsV2ProjectDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    projects_v2: zProjectsV2,
    sender: zSimpleUser
});

/**
 * Projects v2 Project Edited Event
 */
export const zWebhookProjectsV2ProjectEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.object({
        description: z.optional(z.object({
            from: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            to: z.optional(z.union([
                z.string(),
                z.null()
            ]))
        })),
        public: z.optional(z.object({
            from: z.optional(z.boolean()),
            to: z.optional(z.boolean())
        })),
        short_description: z.optional(z.object({
            from: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            to: z.optional(z.union([
                z.string(),
                z.null()
            ]))
        })),
        title: z.optional(z.object({
            from: z.optional(z.string()),
            to: z.optional(z.string())
        }))
    }),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    projects_v2: zProjectsV2,
    sender: zSimpleUser
});

/**
 * Projects v2 Item Archived Event
 */
export const zWebhookProjectsV2ItemArchived = z.object({
    action: z.enum([
        'archived'
    ]),
    changes: zWebhooksProjectChanges,
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    projects_v2_item: zProjectsV2Item,
    sender: zSimpleUser
});

/**
 * Projects v2 Item Converted Event
 */
export const zWebhookProjectsV2ItemConverted = z.object({
    action: z.enum([
        'converted'
    ]),
    changes: z.object({
        content_type: z.optional(z.object({
            from: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            to: z.optional(z.string())
        }))
    }),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    projects_v2_item: zProjectsV2Item,
    sender: zSimpleUser
});

/**
 * Projects v2 Item Created Event
 */
export const zWebhookProjectsV2ItemCreated = z.object({
    action: z.enum([
        'created'
    ]),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    projects_v2_item: zProjectsV2Item,
    sender: zSimpleUser
});

/**
 * Projects v2 Item Deleted Event
 */
export const zWebhookProjectsV2ItemDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    projects_v2_item: zProjectsV2Item,
    sender: zSimpleUser
});

/**
 * Projects v2 Item Edited Event
 */
export const zWebhookProjectsV2ItemEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.optional(z.union([
        z.object({
            field_value: z.object({
                field_node_id: z.optional(z.string()),
                field_type: z.optional(z.string()),
                field_name: z.optional(z.string()),
                project_number: z.optional(z.int()),
                from: z.optional(z.union([
                    z.string(),
                    z.int(),
                    zProjectsV2SingleSelectOption,
                    zProjectsV2IterationSetting,
                    z.null()
                ])),
                to: z.optional(z.union([
                    z.string(),
                    z.int(),
                    zProjectsV2SingleSelectOption,
                    zProjectsV2IterationSetting,
                    z.null()
                ]))
            })
        }),
        z.object({
            body: z.object({
                from: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                to: z.optional(z.union([
                    z.string(),
                    z.null()
                ]))
            })
        })
    ])),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    projects_v2_item: zProjectsV2Item,
    sender: zSimpleUser
});

/**
 * Projects v2 Item Reordered Event
 */
export const zWebhookProjectsV2ItemReordered = z.object({
    action: z.enum([
        'reordered'
    ]),
    changes: z.object({
        previous_projects_v2_item_node_id: z.optional(z.object({
            from: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            to: z.optional(z.union([
                z.string(),
                z.null()
            ]))
        }))
    }),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    projects_v2_item: zProjectsV2Item,
    sender: zSimpleUser
});

/**
 * Projects v2 Item Restored Event
 */
export const zWebhookProjectsV2ItemRestored = z.object({
    action: z.enum([
        'restored'
    ]),
    changes: zWebhooksProjectChanges,
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    projects_v2_item: zProjectsV2Item,
    sender: zSimpleUser
});

/**
 * Projects v2 Project Reopened Event
 */
export const zWebhookProjectsV2ProjectReopened = z.object({
    action: z.enum([
        'reopened'
    ]),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    projects_v2: zProjectsV2,
    sender: zSimpleUser
});

/**
 * Projects v2 Status Update Created Event
 */
export const zWebhookProjectsV2StatusUpdateCreated = z.object({
    action: z.enum([
        'created'
    ]),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    projects_v2_status_update: zProjectsV2StatusUpdate,
    sender: zSimpleUser
});

/**
 * Projects v2 Status Update Deleted Event
 */
export const zWebhookProjectsV2StatusUpdateDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    projects_v2_status_update: zProjectsV2StatusUpdate,
    sender: zSimpleUser
});

/**
 * Projects v2 Status Update Edited Event
 */
export const zWebhookProjectsV2StatusUpdateEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.optional(z.object({
        body: z.optional(z.object({
            from: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            to: z.optional(z.union([
                z.string(),
                z.null()
            ]))
        })),
        status: z.optional(z.object({
            from: z.optional(z.enum([
                'INACTIVE',
                'ON_TRACK',
                'AT_RISK',
                'OFF_TRACK',
                'COMPLETE'
            ])),
            to: z.optional(z.enum([
                'INACTIVE',
                'ON_TRACK',
                'AT_RISK',
                'OFF_TRACK',
                'COMPLETE'
            ]))
        })),
        start_date: z.optional(z.object({
            from: z.optional(z.union([
                z.iso.date(),
                z.null()
            ])),
            to: z.optional(z.union([
                z.iso.date(),
                z.null()
            ]))
        })),
        target_date: z.optional(z.object({
            from: z.optional(z.union([
                z.iso.date(),
                z.null()
            ])),
            to: z.optional(z.union([
                z.iso.date(),
                z.null()
            ]))
        }))
    })),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    projects_v2_status_update: zProjectsV2StatusUpdate,
    sender: zSimpleUser
});

/**
 * public event
 */
export const zWebhookPublic = z.object({
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request assigned event
 */
export const zWebhookPullRequestAssigned = z.object({
    action: z.enum([
        'assigned'
    ]),
    assignee: zWebhooksUser,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    number: zWebhooksNumber,
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        additions: z.optional(z.int()),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ]),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        changed_files: z.optional(z.int()),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.optional(z.int()),
        comments_url: z.url(),
        commits: z.optional(z.int()),
        commits_url: z.url(),
        created_at: z.iso.datetime(),
        deletions: z.optional(z.int()),
        diff_url: z.url(),
        draft: z.boolean(),
        head: z.object({
            label: z.union([
                z.string(),
                z.null()
            ]),
            ref: z.string(),
            repo: z.union([
                z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                z.null()
            ]),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        maintainer_can_modify: z.optional(z.boolean()),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        mergeable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        mergeable_state: z.optional(z.string()),
        merged: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        merged_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        merged_by: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        rebaseable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                members_url: z.string(),
                name: z.string(),
                node_id: z.string(),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.string(),
                privacy: z.enum([
                    'open',
                    'closed',
                    'secret'
                ]),
                repositories_url: z.url(),
                slug: z.string(),
                url: z.url()
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments: z.optional(z.int()),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request auto_merge_disabled event
 */
export const zWebhookPullRequestAutoMergeDisabled = z.object({
    action: z.enum([
        'auto_merge_disabled'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    number: z.int(),
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        additions: z.optional(z.int()),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ]),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        changed_files: z.optional(z.int()),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.optional(z.int()),
        comments_url: z.url(),
        commits: z.optional(z.int()),
        commits_url: z.url(),
        created_at: z.iso.datetime(),
        deletions: z.optional(z.int()),
        diff_url: z.url(),
        draft: z.boolean(),
        head: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        maintainer_can_modify: z.optional(z.boolean()),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        mergeable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        mergeable_state: z.optional(z.string()),
        merged: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        merged_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        merged_by: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        rebaseable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                members_url: z.string(),
                name: z.string(),
                node_id: z.string(),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.string(),
                privacy: z.enum([
                    'open',
                    'closed',
                    'secret'
                ]),
                repositories_url: z.url(),
                slug: z.string(),
                url: z.url()
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments: z.optional(z.int()),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    reason: z.string(),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request auto_merge_enabled event
 */
export const zWebhookPullRequestAutoMergeEnabled = z.object({
    action: z.enum([
        'auto_merge_enabled'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    number: z.int(),
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        additions: z.optional(z.int()),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ]),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        changed_files: z.optional(z.int()),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.optional(z.int()),
        comments_url: z.url(),
        commits: z.optional(z.int()),
        commits_url: z.url(),
        created_at: z.iso.datetime(),
        deletions: z.optional(z.int()),
        diff_url: z.url(),
        draft: z.boolean(),
        head: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.int(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        maintainer_can_modify: z.optional(z.boolean()),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        mergeable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        mergeable_state: z.optional(z.string()),
        merged: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        merged_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        merged_by: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        rebaseable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                members_url: z.string(),
                name: z.string(),
                node_id: z.string(),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.string(),
                privacy: z.enum([
                    'open',
                    'closed',
                    'secret'
                ]),
                repositories_url: z.url(),
                slug: z.string(),
                url: z.url()
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments: z.optional(z.int()),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    reason: z.optional(z.string()),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request closed event
 */
export const zWebhookPullRequestClosed = z.object({
    action: z.enum([
        'closed'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    number: zWebhooksNumber,
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: zPullRequestWebhook,
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request converted_to_draft event
 */
export const zWebhookPullRequestConvertedToDraft = z.object({
    action: z.enum([
        'converted_to_draft'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    number: zWebhooksNumber,
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: zPullRequestWebhook,
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request demilestoned event
 */
export const zWebhookPullRequestDemilestoned = z.object({
    action: z.enum([
        'demilestoned'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    milestone: z.optional(zMilestone),
    number: zWebhooksNumber,
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: zWebhooksPullRequest5,
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * pull_request dequeued event
 */
export const zWebhookPullRequestDequeued = z.object({
    action: z.enum([
        'dequeued'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    number: z.int(),
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        additions: z.optional(z.int()),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ]),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        changed_files: z.optional(z.int()),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.optional(z.int()),
        comments_url: z.url(),
        commits: z.optional(z.int()),
        commits_url: z.url(),
        created_at: z.iso.datetime(),
        deletions: z.optional(z.int()),
        diff_url: z.url(),
        draft: z.boolean(),
        head: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        maintainer_can_modify: z.optional(z.boolean()),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        mergeable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        mergeable_state: z.optional(z.string()),
        merged: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        merged_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        merged_by: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        rebaseable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                html_url: z.optional(z.url()),
                id: z.int(),
                members_url: z.optional(z.string()),
                name: z.string(),
                node_id: z.optional(z.string()),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.optional(z.string()),
                privacy: z.optional(z.enum([
                    'open',
                    'closed',
                    'secret'
                ])),
                repositories_url: z.optional(z.url()),
                slug: z.optional(z.string()),
                url: z.optional(z.url())
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments: z.optional(z.int()),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    reason: z.enum([
        'UNKNOWN_REMOVAL_REASON',
        'MANUAL',
        'MERGE',
        'MERGE_CONFLICT',
        'CI_FAILURE',
        'CI_TIMEOUT',
        'ALREADY_MERGED',
        'QUEUE_CLEARED',
        'ROLL_BACK',
        'BRANCH_PROTECTIONS',
        'GIT_TREE_INVALID',
        'INVALID_MERGE_COMMIT'
    ]),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request edited event
 */
export const zWebhookPullRequestEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.object({
        base: z.optional(z.object({
            ref: z.object({
                from: z.string()
            }),
            sha: z.object({
                from: z.string()
            })
        })),
        body: z.optional(z.object({
            from: z.string()
        })),
        title: z.optional(z.object({
            from: z.string()
        }))
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    number: zWebhooksNumber,
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: zPullRequestWebhook,
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * pull_request enqueued event
 */
export const zWebhookPullRequestEnqueued = z.object({
    action: z.enum([
        'enqueued'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    number: z.int(),
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        additions: z.optional(z.int()),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ]),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        changed_files: z.optional(z.int()),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.optional(z.int()),
        comments_url: z.url(),
        commits: z.optional(z.int()),
        commits_url: z.url(),
        created_at: z.iso.datetime(),
        deletions: z.optional(z.int()),
        diff_url: z.url(),
        draft: z.boolean(),
        head: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        maintainer_can_modify: z.optional(z.boolean()),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        mergeable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        mergeable_state: z.optional(z.string()),
        merged: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        merged_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        merged_by: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        rebaseable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                html_url: z.optional(z.url()),
                id: z.int(),
                members_url: z.optional(z.string()),
                name: z.string(),
                node_id: z.optional(z.string()),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.optional(z.string()),
                privacy: z.optional(z.enum([
                    'open',
                    'closed',
                    'secret'
                ])),
                repositories_url: z.optional(z.url()),
                slug: z.optional(z.string()),
                url: z.optional(z.url())
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments: z.optional(z.int()),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request labeled event
 */
export const zWebhookPullRequestLabeled = z.object({
    action: z.enum([
        'labeled'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    label: z.optional(zWebhooksLabel),
    number: zWebhooksNumber,
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        additions: z.optional(z.int()),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ]),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        changed_files: z.optional(z.int()),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.optional(z.int()),
        comments_url: z.url(),
        commits: z.optional(z.int()),
        commits_url: z.url(),
        created_at: z.iso.datetime(),
        deletions: z.optional(z.int()),
        diff_url: z.url(),
        draft: z.boolean(),
        head: z.object({
            label: z.union([
                z.string(),
                z.null()
            ]),
            ref: z.string(),
            repo: z.union([
                z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                z.null()
            ]),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        maintainer_can_modify: z.optional(z.boolean()),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        mergeable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        mergeable_state: z.optional(z.string()),
        merged: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        merged_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        merged_by: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        rebaseable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                members_url: z.string(),
                name: z.string(),
                node_id: z.string(),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.string(),
                privacy: z.enum([
                    'open',
                    'closed',
                    'secret'
                ]),
                repositories_url: z.url(),
                slug: z.string(),
                url: z.url()
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments: z.optional(z.int()),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request locked event
 */
export const zWebhookPullRequestLocked = z.object({
    action: z.enum([
        'locked'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    number: zWebhooksNumber,
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        additions: z.optional(z.int()),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ]),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        changed_files: z.optional(z.int()),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.optional(z.int()),
        comments_url: z.url(),
        commits: z.optional(z.int()),
        commits_url: z.url(),
        created_at: z.iso.datetime(),
        deletions: z.optional(z.int()),
        diff_url: z.url(),
        draft: z.boolean(),
        head: z.object({
            label: z.union([
                z.string(),
                z.null()
            ]),
            ref: z.string(),
            repo: z.union([
                z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                z.null()
            ]),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        maintainer_can_modify: z.optional(z.boolean()),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        mergeable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        mergeable_state: z.optional(z.string()),
        merged: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        merged_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        merged_by: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        rebaseable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                members_url: z.string(),
                name: z.string(),
                node_id: z.string(),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.string(),
                privacy: z.enum([
                    'open',
                    'closed',
                    'secret'
                ]),
                repositories_url: z.url(),
                slug: z.string(),
                url: z.url()
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments: z.optional(z.int()),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request milestoned event
 */
export const zWebhookPullRequestMilestoned = z.object({
    action: z.enum([
        'milestoned'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    milestone: z.optional(zMilestone),
    number: zWebhooksNumber,
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: zWebhooksPullRequest5,
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * pull_request opened event
 */
export const zWebhookPullRequestOpened = z.object({
    action: z.enum([
        'opened'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    number: zWebhooksNumber,
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: zPullRequestWebhook,
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request ready_for_review event
 */
export const zWebhookPullRequestReadyForReview = z.object({
    action: z.enum([
        'ready_for_review'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    number: zWebhooksNumber,
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: zPullRequestWebhook,
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request reopened event
 */
export const zWebhookPullRequestReopened = z.object({
    action: z.enum([
        'reopened'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    number: zWebhooksNumber,
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: zPullRequestWebhook,
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request_review_comment created event
 */
export const zWebhookPullRequestReviewCommentCreated = z.object({
    action: z.enum([
        'created'
    ]),
    comment: z.object({
        _links: z.object({
            html: z.object({
                href: z.string()
            }),
            pull_request: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            })
        }),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.string(),
        commit_id: z.string(),
        created_at: z.iso.datetime(),
        diff_hunk: z.string(),
        html_url: z.url(),
        id: z.int(),
        in_reply_to_id: z.optional(z.int()),
        line: z.union([
            z.int(),
            z.null()
        ]),
        node_id: z.string(),
        original_commit_id: z.string(),
        original_line: z.union([
            z.int(),
            z.null()
        ]),
        original_position: z.int(),
        original_start_line: z.union([
            z.int(),
            z.null()
        ]),
        path: z.string(),
        position: z.union([
            z.int(),
            z.null()
        ]),
        pull_request_review_id: z.union([
            z.int(),
            z.null()
        ]),
        pull_request_url: z.url(),
        reactions: z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        }),
        side: z.enum([
            'LEFT',
            'RIGHT'
        ]),
        start_line: z.union([
            z.int(),
            z.null()
        ]),
        start_side: z.nullable(z.enum([
            'LEFT',
            'RIGHT'
        ])),
        subject_type: z.optional(z.enum([
            'line',
            'file'
        ])),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.optional(z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ])),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.string(),
            z.null()
        ]),
        comments_url: z.url(),
        commits_url: z.url(),
        created_at: z.string(),
        diff_url: z.url(),
        draft: z.optional(z.boolean()),
        head: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.union([
                z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.optional(z.boolean()).default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                z.null()
            ]),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        merged_at: z.union([
            z.string(),
            z.null()
        ]),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                members_url: z.string(),
                name: z.string(),
                node_id: z.string(),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.string(),
                privacy: z.enum([
                    'open',
                    'closed',
                    'secret'
                ]),
                repositories_url: z.url(),
                slug: z.string(),
                url: z.url()
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.string(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request_review_comment deleted event
 */
export const zWebhookPullRequestReviewCommentDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    comment: zWebhooksReviewComment,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.optional(z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ])),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.string(),
            z.null()
        ]),
        comments_url: z.url(),
        commits_url: z.url(),
        created_at: z.string(),
        diff_url: z.url(),
        draft: z.optional(z.boolean()),
        head: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.union([
                z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                z.null()
            ]),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        merged_at: z.union([
            z.string(),
            z.null()
        ]),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                html_url: z.optional(z.url()),
                id: z.int(),
                members_url: z.optional(z.string()),
                name: z.string(),
                node_id: z.optional(z.string()),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.optional(z.string()),
                privacy: z.optional(z.enum([
                    'open',
                    'closed',
                    'secret'
                ])),
                repositories_url: z.optional(z.url()),
                slug: z.optional(z.string()),
                url: z.optional(z.url())
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.string(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request_review_comment edited event
 */
export const zWebhookPullRequestReviewCommentEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: zWebhooksChanges,
    comment: zWebhooksReviewComment,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.optional(z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ])),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.string(),
            z.null()
        ]),
        comments_url: z.url(),
        commits_url: z.url(),
        created_at: z.string(),
        diff_url: z.url(),
        draft: z.optional(z.boolean()),
        head: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.union([
                z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                z.null()
            ]),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        merged_at: z.union([
            z.string(),
            z.null()
        ]),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                html_url: z.optional(z.url()),
                id: z.int(),
                members_url: z.optional(z.string()),
                name: z.string(),
                node_id: z.optional(z.string()),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.optional(z.string()),
                privacy: z.optional(z.enum([
                    'open',
                    'closed',
                    'secret'
                ])),
                repositories_url: z.optional(z.url()),
                slug: z.optional(z.string()),
                url: z.optional(z.url())
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.string(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                user_view_type: z.optional(z.string()),
                url: z.optional(z.url())
            }),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request_review dismissed event
 */
export const zWebhookPullRequestReviewDismissed = z.object({
    action: z.enum([
        'dismissed'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ]),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.string(),
            z.null()
        ]),
        comments_url: z.url(),
        commits_url: z.url(),
        created_at: z.string(),
        diff_url: z.url(),
        draft: z.boolean(),
        head: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.union([
                z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                z.null()
            ]),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        merged_at: z.union([
            z.string(),
            z.null()
        ]),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                members_url: z.string(),
                name: z.string(),
                node_id: z.string(),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.string(),
                privacy: z.enum([
                    'open',
                    'closed',
                    'secret'
                ]),
                repositories_url: z.url(),
                slug: z.string(),
                url: z.url()
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.string(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    review: z.object({
        _links: z.object({
            html: z.object({
                href: z.string()
            }),
            pull_request: z.object({
                href: z.string()
            })
        }),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        body: z.union([
            z.string(),
            z.null()
        ]),
        commit_id: z.string(),
        html_url: z.url(),
        id: z.int(),
        node_id: z.string(),
        pull_request_url: z.url(),
        state: z.enum([
            'dismissed',
            'approved',
            'changes_requested'
        ]),
        submitted_at: z.iso.datetime(),
        updated_at: z.optional(z.union([
            z.iso.datetime(),
            z.null()
        ])),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    sender: zSimpleUser
});

/**
 * pull_request_review edited event
 */
export const zWebhookPullRequestReviewEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.object({
        body: z.optional(z.object({
            from: z.string()
        }))
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ]),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int()
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.string(),
            z.null()
        ]),
        comments_url: z.url(),
        commits_url: z.url(),
        created_at: z.string(),
        diff_url: z.url(),
        draft: z.boolean(),
        head: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.union([
                z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int()
                }),
                z.null()
            ]),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        merged_at: z.union([
            z.string(),
            z.null()
        ]),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                members_url: z.string(),
                name: z.string(),
                node_id: z.string(),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.string(),
                privacy: z.enum([
                    'open',
                    'closed',
                    'secret'
                ]),
                repositories_url: z.url(),
                slug: z.string(),
                url: z.url()
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.string(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    review: zWebhooksReview,
    sender: zSimpleUser
});

/**
 * pull_request review_request_removed event
 */
export const zWebhookPullRequestReviewRequestRemoved = z.union([
    z.object({
        action: z.enum([
            'review_request_removed'
        ]),
        enterprise: z.optional(zEnterpriseWebhooks),
        installation: z.optional(zSimpleInstallation),
        number: z.int(),
        organization: z.optional(zOrganizationSimpleWebhooks),
        pull_request: z.object({
            _links: z.object({
                comments: z.object({
                    href: z.string()
                }),
                commits: z.object({
                    href: z.string()
                }),
                html: z.object({
                    href: z.string()
                }),
                issue: z.object({
                    href: z.string()
                }),
                review_comment: z.object({
                    href: z.string()
                }),
                review_comments: z.object({
                    href: z.string()
                }),
                self: z.object({
                    href: z.string()
                }),
                statuses: z.object({
                    href: z.string()
                })
            }),
            active_lock_reason: z.nullable(z.enum([
                'resolved',
                'off-topic',
                'too heated',
                'spam'
            ])),
            additions: z.optional(z.int()),
            assignee: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            assignees: z.array(z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])),
            author_association: z.enum([
                'COLLABORATOR',
                'CONTRIBUTOR',
                'FIRST_TIMER',
                'FIRST_TIME_CONTRIBUTOR',
                'MANNEQUIN',
                'MEMBER',
                'NONE',
                'OWNER'
            ]),
            auto_merge: z.union([
                z.object({
                    commit_message: z.union([
                        z.string(),
                        z.null()
                    ]),
                    commit_title: z.union([
                        z.string(),
                        z.null()
                    ]),
                    enabled_by: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    merge_method: z.enum([
                        'merge',
                        'squash',
                        'rebase'
                    ])
                }),
                z.null()
            ]),
            base: z.object({
                label: z.string(),
                ref: z.string(),
                repo: z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                sha: z.string(),
                user: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.coerce.bigint(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ])
            }),
            body: z.union([
                z.string(),
                z.null()
            ]),
            changed_files: z.optional(z.int()),
            closed_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            comments: z.optional(z.int()),
            comments_url: z.url(),
            commits: z.optional(z.int()),
            commits_url: z.url(),
            created_at: z.iso.datetime(),
            deletions: z.optional(z.int()),
            diff_url: z.url(),
            draft: z.boolean(),
            head: z.object({
                label: z.string(),
                ref: z.string(),
                repo: z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                sha: z.string(),
                user: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.coerce.bigint(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ])
            }),
            html_url: z.url(),
            id: z.int(),
            issue_url: z.url(),
            labels: z.array(z.object({
                color: z.string(),
                default: z.boolean(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                id: z.int(),
                name: z.string(),
                node_id: z.string(),
                url: z.url()
            })),
            locked: z.boolean(),
            maintainer_can_modify: z.optional(z.boolean()),
            merge_commit_sha: z.union([
                z.string(),
                z.null()
            ]),
            mergeable: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            mergeable_state: z.optional(z.string()),
            merged: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            merged_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            merged_by: z.optional(z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])),
            milestone: z.union([
                z.object({
                    closed_at: z.union([
                        z.iso.datetime(),
                        z.null()
                    ]),
                    closed_issues: z.int(),
                    created_at: z.iso.datetime(),
                    creator: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    due_on: z.union([
                        z.iso.datetime(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    labels_url: z.url(),
                    node_id: z.string(),
                    number: z.int(),
                    open_issues: z.int(),
                    state: z.enum([
                        'open',
                        'closed'
                    ]),
                    title: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url()
                }),
                z.null()
            ]),
            node_id: z.string(),
            number: z.int(),
            patch_url: z.url(),
            rebaseable: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            requested_reviewers: z.array(z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null(),
                z.object({
                    deleted: z.optional(z.boolean()),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    parent: z.optional(z.union([
                        z.object({
                            description: z.union([
                                z.string(),
                                z.null()
                            ]),
                            html_url: z.url(),
                            id: z.int(),
                            members_url: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            permission: z.string(),
                            privacy: z.enum([
                                'open',
                                'closed',
                                'secret'
                            ]),
                            repositories_url: z.url(),
                            slug: z.string(),
                            url: z.url()
                        }),
                        z.null()
                    ])),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                })
            ])),
            requested_teams: z.array(z.object({
                deleted: z.optional(z.boolean()),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                members_url: z.string(),
                name: z.string(),
                node_id: z.string(),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.string(),
                privacy: z.enum([
                    'open',
                    'closed',
                    'secret'
                ]),
                repositories_url: z.url(),
                slug: z.string(),
                url: z.url()
            })),
            review_comment_url: z.string(),
            review_comments: z.optional(z.int()),
            review_comments_url: z.url(),
            state: z.enum([
                'open',
                'closed'
            ]),
            statuses_url: z.url(),
            title: z.string(),
            updated_at: z.iso.datetime(),
            url: z.url(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        repository: zRepositoryWebhooks,
        requested_reviewer: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        sender: zSimpleUser
    }),
    z.object({
        action: z.enum([
            'review_request_removed'
        ]),
        enterprise: z.optional(zEnterpriseWebhooks),
        installation: z.optional(zSimpleInstallation),
        number: z.int(),
        organization: z.optional(zOrganizationSimpleWebhooks),
        pull_request: z.object({
            _links: z.object({
                comments: z.object({
                    href: z.string()
                }),
                commits: z.object({
                    href: z.string()
                }),
                html: z.object({
                    href: z.string()
                }),
                issue: z.object({
                    href: z.string()
                }),
                review_comment: z.object({
                    href: z.string()
                }),
                review_comments: z.object({
                    href: z.string()
                }),
                self: z.object({
                    href: z.string()
                }),
                statuses: z.object({
                    href: z.string()
                })
            }),
            active_lock_reason: z.nullable(z.enum([
                'resolved',
                'off-topic',
                'too heated',
                'spam'
            ])),
            additions: z.optional(z.int()),
            assignee: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            assignees: z.array(z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])),
            author_association: z.enum([
                'COLLABORATOR',
                'CONTRIBUTOR',
                'FIRST_TIMER',
                'FIRST_TIME_CONTRIBUTOR',
                'MANNEQUIN',
                'MEMBER',
                'NONE',
                'OWNER'
            ]),
            auto_merge: z.union([
                z.object({
                    commit_message: z.union([
                        z.string(),
                        z.null()
                    ]),
                    commit_title: z.union([
                        z.string(),
                        z.null()
                    ]),
                    enabled_by: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    merge_method: z.enum([
                        'merge',
                        'squash',
                        'rebase'
                    ])
                }),
                z.null()
            ]),
            base: z.object({
                label: z.string(),
                ref: z.string(),
                repo: z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                sha: z.string(),
                user: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.coerce.bigint(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ])
            }),
            body: z.union([
                z.string(),
                z.null()
            ]),
            changed_files: z.optional(z.int()),
            closed_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            comments: z.optional(z.int()),
            comments_url: z.url(),
            commits: z.optional(z.int()),
            commits_url: z.url(),
            created_at: z.iso.datetime(),
            deletions: z.optional(z.int()),
            diff_url: z.url(),
            draft: z.boolean(),
            head: z.object({
                label: z.string(),
                ref: z.string(),
                repo: z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                sha: z.string(),
                user: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.coerce.bigint(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ])
            }),
            html_url: z.url(),
            id: z.int(),
            issue_url: z.url(),
            labels: z.array(z.object({
                color: z.string(),
                default: z.boolean(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                id: z.int(),
                name: z.string(),
                node_id: z.string(),
                url: z.url()
            })),
            locked: z.boolean(),
            maintainer_can_modify: z.optional(z.boolean()),
            merge_commit_sha: z.union([
                z.string(),
                z.null()
            ]),
            mergeable: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            mergeable_state: z.optional(z.string()),
            merged: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            merged_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            merged_by: z.optional(z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])),
            milestone: z.union([
                z.object({
                    closed_at: z.union([
                        z.iso.datetime(),
                        z.null()
                    ]),
                    closed_issues: z.int(),
                    created_at: z.iso.datetime(),
                    creator: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    due_on: z.union([
                        z.iso.datetime(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    labels_url: z.url(),
                    node_id: z.string(),
                    number: z.int(),
                    open_issues: z.int(),
                    state: z.enum([
                        'open',
                        'closed'
                    ]),
                    title: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url()
                }),
                z.null()
            ]),
            node_id: z.string(),
            number: z.int(),
            patch_url: z.url(),
            rebaseable: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            requested_reviewers: z.array(z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null(),
                z.object({
                    deleted: z.optional(z.boolean()),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    parent: z.optional(z.union([
                        z.object({
                            description: z.union([
                                z.string(),
                                z.null()
                            ]),
                            html_url: z.url(),
                            id: z.int(),
                            members_url: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            permission: z.string(),
                            privacy: z.enum([
                                'open',
                                'closed',
                                'secret'
                            ]),
                            repositories_url: z.url(),
                            slug: z.string(),
                            url: z.url()
                        }),
                        z.null()
                    ])),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                })
            ])),
            requested_teams: z.array(z.object({
                deleted: z.optional(z.boolean()),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                members_url: z.string(),
                name: z.string(),
                node_id: z.string(),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.string(),
                privacy: z.enum([
                    'open',
                    'closed',
                    'secret'
                ]),
                repositories_url: z.url(),
                slug: z.string(),
                url: z.url()
            })),
            review_comment_url: z.string(),
            review_comments: z.optional(z.int()),
            review_comments_url: z.url(),
            state: z.enum([
                'open',
                'closed'
            ]),
            statuses_url: z.url(),
            title: z.string(),
            updated_at: z.iso.datetime(),
            url: z.url(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        repository: zRepositoryWebhooks,
        requested_team: z.object({
            deleted: z.optional(z.boolean()),
            description: z.union([
                z.string(),
                z.null()
            ]),
            html_url: z.url(),
            id: z.int(),
            members_url: z.string(),
            name: z.string(),
            node_id: z.string(),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.string(),
            privacy: z.enum([
                'open',
                'closed',
                'secret'
            ]),
            repositories_url: z.url(),
            slug: z.string(),
            url: z.url()
        }),
        sender: zSimpleUser
    })
]);

/**
 * pull_request review_requested event
 */
export const zWebhookPullRequestReviewRequested = z.union([
    z.object({
        action: z.enum([
            'review_requested'
        ]),
        enterprise: z.optional(zEnterpriseWebhooks),
        installation: z.optional(zSimpleInstallation),
        number: z.int(),
        organization: z.optional(zOrganizationSimpleWebhooks),
        pull_request: z.object({
            _links: z.object({
                comments: z.object({
                    href: z.string()
                }),
                commits: z.object({
                    href: z.string()
                }),
                html: z.object({
                    href: z.string()
                }),
                issue: z.object({
                    href: z.string()
                }),
                review_comment: z.object({
                    href: z.string()
                }),
                review_comments: z.object({
                    href: z.string()
                }),
                self: z.object({
                    href: z.string()
                }),
                statuses: z.object({
                    href: z.string()
                })
            }),
            active_lock_reason: z.nullable(z.enum([
                'resolved',
                'off-topic',
                'too heated',
                'spam'
            ])),
            additions: z.optional(z.int()),
            assignee: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization',
                        'Mannequin'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            assignees: z.array(z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization',
                        'Mannequin'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])),
            author_association: z.enum([
                'COLLABORATOR',
                'CONTRIBUTOR',
                'FIRST_TIMER',
                'FIRST_TIME_CONTRIBUTOR',
                'MANNEQUIN',
                'MEMBER',
                'NONE',
                'OWNER'
            ]),
            auto_merge: z.union([
                z.object({
                    commit_message: z.union([
                        z.string(),
                        z.null()
                    ]),
                    commit_title: z.union([
                        z.string(),
                        z.null()
                    ]),
                    enabled_by: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    merge_method: z.enum([
                        'merge',
                        'squash',
                        'rebase'
                    ])
                }),
                z.null()
            ]),
            base: z.object({
                label: z.string(),
                ref: z.string(),
                repo: z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                sha: z.string(),
                user: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.coerce.bigint(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ])
            }),
            body: z.union([
                z.string(),
                z.null()
            ]),
            changed_files: z.optional(z.int()),
            closed_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            comments: z.optional(z.int()),
            comments_url: z.url(),
            commits: z.optional(z.int()),
            commits_url: z.url(),
            created_at: z.iso.datetime(),
            deletions: z.optional(z.int()),
            diff_url: z.url(),
            draft: z.boolean(),
            head: z.object({
                label: z.string(),
                ref: z.string(),
                repo: z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                sha: z.string(),
                user: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.coerce.bigint(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ])
            }),
            html_url: z.url(),
            id: z.int(),
            issue_url: z.url(),
            labels: z.array(z.object({
                color: z.string(),
                default: z.boolean(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                id: z.int(),
                name: z.string(),
                node_id: z.string(),
                url: z.url()
            })),
            locked: z.boolean(),
            maintainer_can_modify: z.optional(z.boolean()),
            merge_commit_sha: z.union([
                z.string(),
                z.null()
            ]),
            mergeable: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            mergeable_state: z.optional(z.string()),
            merged: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            merged_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            merged_by: z.optional(z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])),
            milestone: z.union([
                z.object({
                    closed_at: z.union([
                        z.iso.datetime(),
                        z.null()
                    ]),
                    closed_issues: z.int(),
                    created_at: z.iso.datetime(),
                    creator: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization',
                                'Mannequin'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    due_on: z.union([
                        z.iso.datetime(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    labels_url: z.url(),
                    node_id: z.string(),
                    number: z.int(),
                    open_issues: z.int(),
                    state: z.enum([
                        'open',
                        'closed'
                    ]),
                    title: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url()
                }),
                z.null()
            ]),
            node_id: z.string(),
            number: z.int(),
            patch_url: z.url(),
            rebaseable: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            requested_reviewers: z.array(z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null(),
                z.object({
                    deleted: z.optional(z.boolean()),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    parent: z.optional(z.union([
                        z.object({
                            description: z.union([
                                z.string(),
                                z.null()
                            ]),
                            html_url: z.url(),
                            id: z.int(),
                            members_url: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            permission: z.string(),
                            privacy: z.enum([
                                'open',
                                'closed',
                                'secret'
                            ]),
                            repositories_url: z.url(),
                            slug: z.string(),
                            url: z.url()
                        }),
                        z.null()
                    ])),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                })
            ])),
            requested_teams: z.array(z.object({
                deleted: z.optional(z.boolean()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                html_url: z.optional(z.url()),
                id: z.int(),
                members_url: z.optional(z.string()),
                name: z.string(),
                node_id: z.optional(z.string()),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.optional(z.string()),
                privacy: z.optional(z.enum([
                    'open',
                    'closed',
                    'secret'
                ])),
                repositories_url: z.optional(z.url()),
                slug: z.optional(z.string()),
                url: z.optional(z.url())
            })),
            review_comment_url: z.string(),
            review_comments: z.optional(z.int()),
            review_comments_url: z.url(),
            state: z.enum([
                'open',
                'closed'
            ]),
            statuses_url: z.url(),
            title: z.string(),
            updated_at: z.iso.datetime(),
            url: z.url(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization',
                        'Mannequin'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        repository: zRepositoryWebhooks,
        requested_reviewer: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        sender: zSimpleUser
    }),
    z.object({
        action: z.enum([
            'review_requested'
        ]),
        enterprise: z.optional(zEnterpriseWebhooks),
        installation: z.optional(zSimpleInstallation),
        number: z.int(),
        organization: z.optional(zOrganizationSimpleWebhooks),
        pull_request: z.object({
            _links: z.object({
                comments: z.object({
                    href: z.string()
                }),
                commits: z.object({
                    href: z.string()
                }),
                html: z.object({
                    href: z.string()
                }),
                issue: z.object({
                    href: z.string()
                }),
                review_comment: z.object({
                    href: z.string()
                }),
                review_comments: z.object({
                    href: z.string()
                }),
                self: z.object({
                    href: z.string()
                }),
                statuses: z.object({
                    href: z.string()
                })
            }),
            active_lock_reason: z.nullable(z.enum([
                'resolved',
                'off-topic',
                'too heated',
                'spam'
            ])),
            additions: z.optional(z.int()),
            assignee: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization',
                        'Mannequin'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            assignees: z.array(z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization',
                        'Mannequin'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])),
            author_association: z.enum([
                'COLLABORATOR',
                'CONTRIBUTOR',
                'FIRST_TIMER',
                'FIRST_TIME_CONTRIBUTOR',
                'MANNEQUIN',
                'MEMBER',
                'NONE',
                'OWNER'
            ]),
            auto_merge: z.union([
                z.object({
                    commit_message: z.union([
                        z.string(),
                        z.null()
                    ]),
                    commit_title: z.union([
                        z.string(),
                        z.null()
                    ]),
                    enabled_by: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    merge_method: z.enum([
                        'merge',
                        'squash',
                        'rebase'
                    ])
                }),
                z.null()
            ]),
            base: z.object({
                label: z.string(),
                ref: z.string(),
                repo: z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                sha: z.string(),
                user: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.coerce.bigint(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ])
            }),
            body: z.union([
                z.string(),
                z.null()
            ]),
            changed_files: z.optional(z.int()),
            closed_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            comments: z.optional(z.int()),
            comments_url: z.url(),
            commits: z.optional(z.int()),
            commits_url: z.url(),
            created_at: z.iso.datetime(),
            deletions: z.optional(z.int()),
            diff_url: z.url(),
            draft: z.boolean(),
            head: z.object({
                label: z.string(),
                ref: z.string(),
                repo: z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                sha: z.string(),
                user: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.coerce.bigint(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ])
            }),
            html_url: z.url(),
            id: z.int(),
            issue_url: z.url(),
            labels: z.array(z.object({
                color: z.string(),
                default: z.boolean(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                id: z.int(),
                name: z.string(),
                node_id: z.string(),
                url: z.url()
            })),
            locked: z.boolean(),
            maintainer_can_modify: z.optional(z.boolean()),
            merge_commit_sha: z.union([
                z.string(),
                z.null()
            ]),
            mergeable: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            mergeable_state: z.optional(z.string()),
            merged: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            merged_at: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            merged_by: z.optional(z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])),
            milestone: z.union([
                z.object({
                    closed_at: z.union([
                        z.iso.datetime(),
                        z.null()
                    ]),
                    closed_issues: z.int(),
                    created_at: z.iso.datetime(),
                    creator: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization',
                                'Mannequin'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    due_on: z.union([
                        z.iso.datetime(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    labels_url: z.url(),
                    node_id: z.string(),
                    number: z.int(),
                    open_issues: z.int(),
                    state: z.enum([
                        'open',
                        'closed'
                    ]),
                    title: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url()
                }),
                z.null()
            ]),
            node_id: z.string(),
            number: z.int(),
            patch_url: z.url(),
            rebaseable: z.optional(z.union([
                z.boolean(),
                z.null()
            ])),
            requested_reviewers: z.array(z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null(),
                z.object({
                    deleted: z.optional(z.boolean()),
                    description: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    members_url: z.optional(z.string()),
                    name: z.string(),
                    node_id: z.optional(z.string()),
                    parent: z.optional(z.union([
                        z.object({
                            description: z.union([
                                z.string(),
                                z.null()
                            ]),
                            html_url: z.url(),
                            id: z.int(),
                            members_url: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            permission: z.string(),
                            privacy: z.enum([
                                'open',
                                'closed',
                                'secret'
                            ]),
                            repositories_url: z.url(),
                            slug: z.string(),
                            url: z.url()
                        }),
                        z.null()
                    ])),
                    permission: z.optional(z.string()),
                    privacy: z.optional(z.enum([
                        'open',
                        'closed',
                        'secret'
                    ])),
                    repositories_url: z.optional(z.url()),
                    slug: z.optional(z.string()),
                    url: z.optional(z.url())
                })
            ])),
            requested_teams: z.array(z.object({
                deleted: z.optional(z.boolean()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                html_url: z.optional(z.url()),
                id: z.int(),
                members_url: z.optional(z.string()),
                name: z.string(),
                node_id: z.optional(z.string()),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.optional(z.string()),
                privacy: z.optional(z.enum([
                    'open',
                    'closed',
                    'secret'
                ])),
                repositories_url: z.optional(z.url()),
                slug: z.optional(z.string()),
                url: z.optional(z.url())
            })),
            review_comment_url: z.string(),
            review_comments: z.optional(z.int()),
            review_comments_url: z.url(),
            state: z.enum([
                'open',
                'closed'
            ]),
            statuses_url: z.url(),
            title: z.string(),
            updated_at: z.iso.datetime(),
            url: z.url(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization',
                        'Mannequin'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        repository: zRepositoryWebhooks,
        requested_team: z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        }),
        sender: zSimpleUser
    })
]);

/**
 * pull_request_review submitted event
 */
export const zWebhookPullRequestReviewSubmitted = z.object({
    action: z.enum([
        'submitted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ]),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.string(),
            z.null()
        ]),
        comments_url: z.url(),
        commits_url: z.url(),
        created_at: z.string(),
        diff_url: z.url(),
        draft: z.boolean(),
        head: z.object({
            label: z.union([
                z.string(),
                z.null()
            ]),
            ref: z.string(),
            repo: z.union([
                z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                z.null()
            ]),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        merged_at: z.union([
            z.string(),
            z.null()
        ]),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                members_url: z.string(),
                name: z.string(),
                node_id: z.string(),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.string(),
                privacy: z.enum([
                    'open',
                    'closed',
                    'secret'
                ]),
                repositories_url: z.url(),
                slug: z.string(),
                url: z.url()
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.string(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    review: zWebhooksReview,
    sender: zSimpleUser
});

/**
 * pull_request_review_thread resolved event
 */
export const zWebhookPullRequestReviewThreadResolved = z.object({
    action: z.enum([
        'resolved'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ]),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.string(),
            z.null()
        ]),
        comments_url: z.url(),
        commits_url: z.url(),
        created_at: z.string(),
        diff_url: z.url(),
        draft: z.boolean(),
        head: z.object({
            label: z.union([
                z.string(),
                z.null()
            ]),
            ref: z.string(),
            repo: z.union([
                z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                z.null()
            ]),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        merged_at: z.union([
            z.string(),
            z.null()
        ]),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                members_url: z.string(),
                name: z.string(),
                node_id: z.string(),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.string(),
                privacy: z.enum([
                    'open',
                    'closed',
                    'secret'
                ]),
                repositories_url: z.url(),
                slug: z.string(),
                url: z.url()
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.string(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser),
    thread: z.object({
        comments: z.array(z.object({
            _links: z.object({
                html: z.object({
                    href: z.string()
                }),
                pull_request: z.object({
                    href: z.string()
                }),
                self: z.object({
                    href: z.string()
                })
            }),
            author_association: z.enum([
                'COLLABORATOR',
                'CONTRIBUTOR',
                'FIRST_TIMER',
                'FIRST_TIME_CONTRIBUTOR',
                'MANNEQUIN',
                'MEMBER',
                'NONE',
                'OWNER'
            ]),
            body: z.string(),
            commit_id: z.string(),
            created_at: z.iso.datetime(),
            diff_hunk: z.string(),
            html_url: z.url(),
            id: z.int(),
            in_reply_to_id: z.optional(z.int()),
            line: z.union([
                z.int(),
                z.null()
            ]),
            node_id: z.string(),
            original_commit_id: z.string(),
            original_line: z.union([
                z.int(),
                z.null()
            ]),
            original_position: z.int(),
            original_start_line: z.union([
                z.int(),
                z.null()
            ]),
            path: z.string(),
            position: z.union([
                z.int(),
                z.null()
            ]),
            pull_request_review_id: z.union([
                z.int(),
                z.null()
            ]),
            pull_request_url: z.url(),
            reactions: z.object({
                '+1': z.int(),
                '-1': z.int(),
                confused: z.int(),
                eyes: z.int(),
                heart: z.int(),
                hooray: z.int(),
                laugh: z.int(),
                rocket: z.int(),
                total_count: z.int(),
                url: z.url()
            }),
            side: z.enum([
                'LEFT',
                'RIGHT'
            ]),
            start_line: z.union([
                z.int(),
                z.null()
            ]),
            start_side: z.nullable(z.enum([
                'LEFT',
                'RIGHT'
            ])),
            subject_type: z.optional(z.enum([
                'line',
                'file'
            ])),
            updated_at: z.iso.datetime(),
            url: z.url(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization',
                        'Mannequin'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        })),
        node_id: z.string()
    }),
    updated_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ]))
});

/**
 * pull_request_review_thread unresolved event
 */
export const zWebhookPullRequestReviewThreadUnresolved = z.object({
    action: z.enum([
        'unresolved'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.string(),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ]),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        closed_at: z.union([
            z.string(),
            z.null()
        ]),
        comments_url: z.url(),
        commits_url: z.url(),
        created_at: z.string(),
        diff_url: z.url(),
        draft: z.boolean(),
        head: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        merged_at: z.union([
            z.string(),
            z.null()
        ]),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                html_url: z.optional(z.url()),
                id: z.int(),
                members_url: z.optional(z.string()),
                name: z.string(),
                node_id: z.optional(z.string()),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.optional(z.string()),
                privacy: z.optional(z.enum([
                    'open',
                    'closed',
                    'secret'
                ])),
                repositories_url: z.optional(z.url()),
                slug: z.optional(z.string()),
                url: z.optional(z.url())
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.string(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser),
    thread: z.object({
        comments: z.array(z.object({
            _links: z.object({
                html: z.object({
                    href: z.string()
                }),
                pull_request: z.object({
                    href: z.string()
                }),
                self: z.object({
                    href: z.string()
                })
            }),
            author_association: z.enum([
                'COLLABORATOR',
                'CONTRIBUTOR',
                'FIRST_TIMER',
                'FIRST_TIME_CONTRIBUTOR',
                'MANNEQUIN',
                'MEMBER',
                'NONE',
                'OWNER'
            ]),
            body: z.string(),
            commit_id: z.string(),
            created_at: z.iso.datetime(),
            diff_hunk: z.string(),
            html_url: z.url(),
            id: z.int(),
            in_reply_to_id: z.optional(z.int()),
            line: z.union([
                z.int(),
                z.null()
            ]),
            node_id: z.string(),
            original_commit_id: z.string(),
            original_line: z.int(),
            original_position: z.int(),
            original_start_line: z.union([
                z.int(),
                z.null()
            ]),
            path: z.string(),
            position: z.union([
                z.int(),
                z.null()
            ]),
            pull_request_review_id: z.union([
                z.int(),
                z.null()
            ]),
            pull_request_url: z.url(),
            reactions: z.object({
                '+1': z.int(),
                '-1': z.int(),
                confused: z.int(),
                eyes: z.int(),
                heart: z.int(),
                hooray: z.int(),
                laugh: z.int(),
                rocket: z.int(),
                total_count: z.int(),
                url: z.url()
            }),
            side: z.enum([
                'LEFT',
                'RIGHT'
            ]),
            start_line: z.union([
                z.int(),
                z.null()
            ]),
            start_side: z.nullable(z.enum([
                'LEFT',
                'RIGHT'
            ])),
            subject_type: z.optional(z.enum([
                'line',
                'file'
            ])),
            updated_at: z.iso.datetime(),
            url: z.url(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        })),
        node_id: z.string()
    }),
    updated_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ]))
});

/**
 * pull_request synchronize event
 */
export const zWebhookPullRequestSynchronize = z.object({
    action: z.enum([
        'synchronize'
    ]),
    after: z.string(),
    before: z.string(),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    number: zWebhooksNumber,
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        additions: z.optional(z.int()),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ]),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        changed_files: z.optional(z.int()),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.optional(z.int()),
        comments_url: z.url(),
        commits: z.optional(z.int()),
        commits_url: z.url(),
        created_at: z.iso.datetime(),
        deletions: z.optional(z.int()),
        diff_url: z.url(),
        draft: z.boolean(),
        head: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        maintainer_can_modify: z.optional(z.boolean()),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        mergeable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        mergeable_state: z.optional(z.string()),
        merged: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        merged_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        merged_by: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        rebaseable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                members_url: z.string(),
                name: z.string(),
                node_id: z.string(),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.string(),
                privacy: z.enum([
                    'open',
                    'closed',
                    'secret'
                ]),
                repositories_url: z.url(),
                slug: z.string(),
                url: z.url()
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments: z.optional(z.int()),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request unassigned event
 */
export const zWebhookPullRequestUnassigned = z.object({
    action: z.enum([
        'unassigned'
    ]),
    assignee: z.optional(zWebhooksUserMannequin),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    number: zWebhooksNumber,
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        additions: z.optional(z.int()),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ]),
        base: z.object({
            label: z.union([
                z.string(),
                z.null()
            ]),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        changed_files: z.optional(z.int()),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.optional(z.int()),
        comments_url: z.url(),
        commits: z.optional(z.int()),
        commits_url: z.url(),
        created_at: z.iso.datetime(),
        deletions: z.optional(z.int()),
        diff_url: z.url(),
        draft: z.boolean(),
        head: z.object({
            label: z.union([
                z.string(),
                z.null()
            ]),
            ref: z.string(),
            repo: z.union([
                z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                z.null()
            ]),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        maintainer_can_modify: z.optional(z.boolean()),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        mergeable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        mergeable_state: z.optional(z.string()),
        merged: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        merged_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        merged_by: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        rebaseable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                members_url: z.string(),
                name: z.string(),
                node_id: z.string(),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.string(),
                privacy: z.enum([
                    'open',
                    'closed',
                    'secret'
                ]),
                repositories_url: z.url(),
                slug: z.string(),
                url: z.url()
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments: z.optional(z.int()),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * pull_request unlabeled event
 */
export const zWebhookPullRequestUnlabeled = z.object({
    action: z.enum([
        'unlabeled'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    label: z.optional(zWebhooksLabel),
    number: zWebhooksNumber,
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        additions: z.optional(z.int()),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.union([
                    z.string(),
                    z.null()
                ]),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ]),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        changed_files: z.optional(z.int()),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.optional(z.int()),
        comments_url: z.url(),
        commits: z.optional(z.int()),
        commits_url: z.url(),
        created_at: z.iso.datetime(),
        deletions: z.optional(z.int()),
        diff_url: z.url(),
        draft: z.boolean(),
        head: z.object({
            label: z.union([
                z.string(),
                z.null()
            ]),
            ref: z.string(),
            repo: z.union([
                z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                z.null()
            ]),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        maintainer_can_modify: z.optional(z.boolean()),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        mergeable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        mergeable_state: z.optional(z.string()),
        merged: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        merged_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        merged_by: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization',
                            'Mannequin'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        rebaseable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                members_url: z.string(),
                name: z.string(),
                node_id: z.string(),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.string(),
                privacy: z.enum([
                    'open',
                    'closed',
                    'secret'
                ]),
                repositories_url: z.url(),
                slug: z.string(),
                url: z.url()
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments: z.optional(z.int()),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization',
                    'Mannequin'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * pull_request unlocked event
 */
export const zWebhookPullRequestUnlocked = z.object({
    action: z.enum([
        'unlocked'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    number: zWebhooksNumber,
    organization: z.optional(zOrganizationSimpleWebhooks),
    pull_request: z.object({
        _links: z.object({
            comments: z.object({
                href: z.string()
            }),
            commits: z.object({
                href: z.string()
            }),
            html: z.object({
                href: z.string()
            }),
            issue: z.object({
                href: z.string()
            }),
            review_comment: z.object({
                href: z.string()
            }),
            review_comments: z.object({
                href: z.string()
            }),
            self: z.object({
                href: z.string()
            }),
            statuses: z.object({
                href: z.string()
            })
        }),
        active_lock_reason: z.nullable(z.enum([
            'resolved',
            'off-topic',
            'too heated',
            'spam'
        ])),
        additions: z.optional(z.int()),
        assignee: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        assignees: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        author_association: z.enum([
            'COLLABORATOR',
            'CONTRIBUTOR',
            'FIRST_TIMER',
            'FIRST_TIME_CONTRIBUTOR',
            'MANNEQUIN',
            'MEMBER',
            'NONE',
            'OWNER'
        ]),
        auto_merge: z.union([
            z.object({
                commit_message: z.union([
                    z.string(),
                    z.null()
                ]),
                commit_title: z.string(),
                enabled_by: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                merge_method: z.enum([
                    'merge',
                    'squash',
                    'rebase'
                ])
            }),
            z.null()
        ]),
        base: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.object({
                allow_auto_merge: z.optional(z.boolean()).default(false),
                allow_forking: z.optional(z.boolean()),
                allow_merge_commit: z.optional(z.boolean()).default(true),
                allow_rebase_merge: z.optional(z.boolean()).default(true),
                allow_squash_merge: z.optional(z.boolean()).default(true),
                allow_update_branch: z.optional(z.boolean()),
                archive_url: z.string(),
                archived: z.boolean().default(false),
                assignees_url: z.string(),
                blobs_url: z.string(),
                branches_url: z.string(),
                clone_url: z.url(),
                collaborators_url: z.string(),
                comments_url: z.string(),
                commits_url: z.string(),
                compare_url: z.string(),
                contents_url: z.string(),
                contributors_url: z.url(),
                created_at: z.union([
                    z.int(),
                    z.iso.datetime()
                ]),
                default_branch: z.string(),
                delete_branch_on_merge: z.optional(z.boolean()).default(false),
                deployments_url: z.url(),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                disabled: z.optional(z.boolean()),
                downloads_url: z.url(),
                events_url: z.url(),
                fork: z.boolean(),
                forks: z.int(),
                forks_count: z.int(),
                forks_url: z.url(),
                full_name: z.string(),
                git_commits_url: z.string(),
                git_refs_url: z.string(),
                git_tags_url: z.string(),
                git_url: z.url(),
                has_downloads: z.boolean().default(true),
                has_issues: z.boolean().default(true),
                has_pages: z.boolean(),
                has_projects: z.boolean().default(true),
                has_wiki: z.boolean().default(true),
                has_discussions: z.boolean().default(false),
                homepage: z.union([
                    z.string(),
                    z.null()
                ]),
                hooks_url: z.url(),
                html_url: z.url(),
                id: z.coerce.bigint(),
                is_template: z.optional(z.boolean()),
                issue_comment_url: z.string(),
                issue_events_url: z.string(),
                issues_url: z.string(),
                keys_url: z.string(),
                labels_url: z.string(),
                language: z.union([
                    z.string(),
                    z.null()
                ]),
                languages_url: z.url(),
                license: z.union([
                    z.object({
                        key: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        spdx_id: z.string(),
                        url: z.union([
                            z.url(),
                            z.null()
                        ])
                    }),
                    z.null()
                ]),
                master_branch: z.optional(z.string()),
                merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'PR_TITLE',
                    'BLANK'
                ])),
                merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'MERGE_MESSAGE'
                ])),
                merges_url: z.url(),
                milestones_url: z.string(),
                mirror_url: z.union([
                    z.url(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                notifications_url: z.string(),
                open_issues: z.int(),
                open_issues_count: z.int(),
                organization: z.optional(z.string()),
                owner: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                permissions: z.optional(z.object({
                    admin: z.boolean(),
                    maintain: z.optional(z.boolean()),
                    pull: z.boolean(),
                    push: z.boolean(),
                    triage: z.optional(z.boolean())
                })),
                private: z.boolean(),
                public: z.optional(z.boolean()),
                pulls_url: z.string(),
                pushed_at: z.union([
                    z.int(),
                    z.iso.datetime(),
                    z.null()
                ]),
                releases_url: z.string(),
                role_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                size: z.int(),
                squash_merge_commit_message: z.optional(z.enum([
                    'PR_BODY',
                    'COMMIT_MESSAGES',
                    'BLANK'
                ])),
                squash_merge_commit_title: z.optional(z.enum([
                    'PR_TITLE',
                    'COMMIT_OR_PR_TITLE'
                ])),
                ssh_url: z.string(),
                stargazers: z.optional(z.int()),
                stargazers_count: z.int(),
                stargazers_url: z.url(),
                statuses_url: z.string(),
                subscribers_url: z.url(),
                subscription_url: z.url(),
                svn_url: z.url(),
                tags_url: z.url(),
                teams_url: z.url(),
                topics: z.array(z.string()),
                trees_url: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url(),
                use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                visibility: z.enum([
                    'public',
                    'private',
                    'internal'
                ]),
                watchers: z.int(),
                watchers_count: z.int(),
                web_commit_signoff_required: z.optional(z.boolean())
            }),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        body: z.union([
            z.string(),
            z.null()
        ]),
        changed_files: z.optional(z.int()),
        closed_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        comments: z.optional(z.int()),
        comments_url: z.url(),
        commits: z.optional(z.int()),
        commits_url: z.url(),
        created_at: z.iso.datetime(),
        deletions: z.optional(z.int()),
        diff_url: z.url(),
        draft: z.boolean(),
        head: z.object({
            label: z.string(),
            ref: z.string(),
            repo: z.union([
                z.object({
                    allow_auto_merge: z.optional(z.boolean()).default(false),
                    allow_forking: z.optional(z.boolean()),
                    allow_merge_commit: z.optional(z.boolean()).default(true),
                    allow_rebase_merge: z.optional(z.boolean()).default(true),
                    allow_squash_merge: z.optional(z.boolean()).default(true),
                    allow_update_branch: z.optional(z.boolean()),
                    archive_url: z.string(),
                    archived: z.boolean().default(false),
                    assignees_url: z.string(),
                    blobs_url: z.string(),
                    branches_url: z.string(),
                    clone_url: z.url(),
                    collaborators_url: z.string(),
                    comments_url: z.string(),
                    commits_url: z.string(),
                    compare_url: z.string(),
                    contents_url: z.string(),
                    contributors_url: z.url(),
                    created_at: z.union([
                        z.int(),
                        z.iso.datetime()
                    ]),
                    default_branch: z.string(),
                    delete_branch_on_merge: z.optional(z.boolean()).default(false),
                    deployments_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    disabled: z.optional(z.boolean()),
                    downloads_url: z.url(),
                    events_url: z.url(),
                    fork: z.boolean(),
                    forks: z.int(),
                    forks_count: z.int(),
                    forks_url: z.url(),
                    full_name: z.string(),
                    git_commits_url: z.string(),
                    git_refs_url: z.string(),
                    git_tags_url: z.string(),
                    git_url: z.url(),
                    has_downloads: z.boolean().default(true),
                    has_issues: z.boolean().default(true),
                    has_pages: z.boolean(),
                    has_projects: z.boolean().default(true),
                    has_wiki: z.boolean().default(true),
                    has_discussions: z.boolean().default(false),
                    homepage: z.union([
                        z.string(),
                        z.null()
                    ]),
                    hooks_url: z.url(),
                    html_url: z.url(),
                    id: z.coerce.bigint(),
                    is_template: z.optional(z.boolean()),
                    issue_comment_url: z.string(),
                    issue_events_url: z.string(),
                    issues_url: z.string(),
                    keys_url: z.string(),
                    labels_url: z.string(),
                    language: z.union([
                        z.string(),
                        z.null()
                    ]),
                    languages_url: z.url(),
                    license: z.union([
                        z.object({
                            key: z.string(),
                            name: z.string(),
                            node_id: z.string(),
                            spdx_id: z.string(),
                            url: z.union([
                                z.url(),
                                z.null()
                            ])
                        }),
                        z.null()
                    ]),
                    master_branch: z.optional(z.string()),
                    merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'PR_TITLE',
                        'BLANK'
                    ])),
                    merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'MERGE_MESSAGE'
                    ])),
                    merges_url: z.url(),
                    milestones_url: z.string(),
                    mirror_url: z.union([
                        z.url(),
                        z.null()
                    ]),
                    name: z.string(),
                    node_id: z.string(),
                    notifications_url: z.string(),
                    open_issues: z.int(),
                    open_issues_count: z.int(),
                    organization: z.optional(z.string()),
                    owner: z.union([
                        z.object({
                            avatar_url: z.optional(z.url()),
                            deleted: z.optional(z.boolean()),
                            email: z.optional(z.union([
                                z.string(),
                                z.null()
                            ])),
                            events_url: z.optional(z.string()),
                            followers_url: z.optional(z.url()),
                            following_url: z.optional(z.string()),
                            gists_url: z.optional(z.string()),
                            gravatar_id: z.optional(z.string()),
                            html_url: z.optional(z.url()),
                            id: z.int(),
                            login: z.string(),
                            name: z.optional(z.string()),
                            node_id: z.optional(z.string()),
                            organizations_url: z.optional(z.url()),
                            received_events_url: z.optional(z.url()),
                            repos_url: z.optional(z.url()),
                            site_admin: z.optional(z.boolean()),
                            starred_url: z.optional(z.string()),
                            subscriptions_url: z.optional(z.url()),
                            type: z.optional(z.enum([
                                'Bot',
                                'User',
                                'Organization'
                            ])),
                            url: z.optional(z.url()),
                            user_view_type: z.optional(z.string())
                        }),
                        z.null()
                    ]),
                    permissions: z.optional(z.object({
                        admin: z.boolean(),
                        maintain: z.optional(z.boolean()),
                        pull: z.boolean(),
                        push: z.boolean(),
                        triage: z.optional(z.boolean())
                    })),
                    private: z.boolean(),
                    public: z.optional(z.boolean()),
                    pulls_url: z.string(),
                    pushed_at: z.union([
                        z.int(),
                        z.iso.datetime(),
                        z.null()
                    ]),
                    releases_url: z.string(),
                    role_name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    size: z.int(),
                    squash_merge_commit_message: z.optional(z.enum([
                        'PR_BODY',
                        'COMMIT_MESSAGES',
                        'BLANK'
                    ])),
                    squash_merge_commit_title: z.optional(z.enum([
                        'PR_TITLE',
                        'COMMIT_OR_PR_TITLE'
                    ])),
                    ssh_url: z.string(),
                    stargazers: z.optional(z.int()),
                    stargazers_count: z.int(),
                    stargazers_url: z.url(),
                    statuses_url: z.string(),
                    subscribers_url: z.url(),
                    subscription_url: z.url(),
                    svn_url: z.url(),
                    tags_url: z.url(),
                    teams_url: z.url(),
                    topics: z.array(z.string()),
                    trees_url: z.string(),
                    updated_at: z.iso.datetime(),
                    url: z.url(),
                    use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
                    visibility: z.enum([
                        'public',
                        'private',
                        'internal'
                    ]),
                    watchers: z.int(),
                    watchers_count: z.int(),
                    web_commit_signoff_required: z.optional(z.boolean())
                }),
                z.null()
            ]),
            sha: z.string(),
            user: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.coerce.bigint(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ])
        }),
        html_url: z.url(),
        id: z.int(),
        issue_url: z.url(),
        labels: z.array(z.object({
            color: z.string(),
            default: z.boolean(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            id: z.int(),
            name: z.string(),
            node_id: z.string(),
            url: z.url()
        })),
        locked: z.boolean(),
        maintainer_can_modify: z.optional(z.boolean()),
        merge_commit_sha: z.union([
            z.string(),
            z.null()
        ]),
        mergeable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        mergeable_state: z.optional(z.string()),
        merged: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        merged_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        merged_by: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])),
        milestone: z.union([
            z.object({
                closed_at: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                closed_issues: z.int(),
                created_at: z.iso.datetime(),
                creator: z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]),
                description: z.union([
                    z.string(),
                    z.null()
                ]),
                due_on: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                html_url: z.url(),
                id: z.int(),
                labels_url: z.url(),
                node_id: z.string(),
                number: z.int(),
                open_issues: z.int(),
                state: z.enum([
                    'open',
                    'closed'
                ]),
                title: z.string(),
                updated_at: z.iso.datetime(),
                url: z.url()
            }),
            z.null()
        ]),
        node_id: z.string(),
        number: z.int(),
        patch_url: z.url(),
        rebaseable: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        requested_reviewers: z.array(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null(),
            z.object({
                deleted: z.optional(z.boolean()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                html_url: z.optional(z.url()),
                id: z.int(),
                members_url: z.optional(z.string()),
                name: z.string(),
                node_id: z.optional(z.string()),
                parent: z.optional(z.union([
                    z.object({
                        description: z.union([
                            z.string(),
                            z.null()
                        ]),
                        html_url: z.url(),
                        id: z.int(),
                        members_url: z.string(),
                        name: z.string(),
                        node_id: z.string(),
                        permission: z.string(),
                        privacy: z.enum([
                            'open',
                            'closed',
                            'secret'
                        ]),
                        repositories_url: z.url(),
                        slug: z.string(),
                        url: z.url()
                    }),
                    z.null()
                ])),
                permission: z.optional(z.string()),
                privacy: z.optional(z.enum([
                    'open',
                    'closed',
                    'secret'
                ])),
                repositories_url: z.optional(z.url()),
                slug: z.optional(z.string()),
                url: z.optional(z.url())
            })
        ])),
        requested_teams: z.array(z.object({
            deleted: z.optional(z.boolean()),
            description: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            html_url: z.optional(z.url()),
            id: z.int(),
            members_url: z.optional(z.string()),
            name: z.string(),
            node_id: z.optional(z.string()),
            parent: z.optional(z.union([
                z.object({
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    html_url: z.url(),
                    id: z.int(),
                    members_url: z.string(),
                    name: z.string(),
                    node_id: z.string(),
                    permission: z.string(),
                    privacy: z.enum([
                        'open',
                        'closed',
                        'secret'
                    ]),
                    repositories_url: z.url(),
                    slug: z.string(),
                    url: z.url()
                }),
                z.null()
            ])),
            permission: z.optional(z.string()),
            privacy: z.optional(z.enum([
                'open',
                'closed',
                'secret'
            ])),
            repositories_url: z.optional(z.url()),
            slug: z.optional(z.string()),
            url: z.optional(z.url())
        })),
        review_comment_url: z.string(),
        review_comments: z.optional(z.int()),
        review_comments_url: z.url(),
        state: z.enum([
            'open',
            'closed'
        ]),
        statuses_url: z.url(),
        title: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        user: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.coerce.bigint(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * push event
 */
export const zWebhookPush = z.object({
    after: z.string(),
    base_ref: zWebhooksNullableString,
    before: z.string(),
    commits: z.array(z.object({
        added: z.optional(z.array(z.string())),
        author: z.object({
            date: z.optional(z.iso.datetime()),
            email: z.union([
                z.email(),
                z.null()
            ]),
            name: z.string(),
            username: z.optional(z.string())
        }),
        committer: z.object({
            date: z.optional(z.iso.datetime()),
            email: z.union([
                z.email(),
                z.null()
            ]),
            name: z.string(),
            username: z.optional(z.string())
        }),
        distinct: z.boolean(),
        id: z.string(),
        message: z.string(),
        modified: z.optional(z.array(z.string())),
        removed: z.optional(z.array(z.string())),
        timestamp: z.iso.datetime(),
        tree_id: z.string(),
        url: z.url()
    })),
    compare: z.string(),
    created: z.boolean(),
    deleted: z.boolean(),
    enterprise: z.optional(zEnterpriseWebhooks),
    forced: z.boolean(),
    head_commit: z.union([
        z.object({
            added: z.optional(z.array(z.string())),
            author: z.object({
                date: z.optional(z.iso.datetime()),
                email: z.union([
                    z.email(),
                    z.null()
                ]),
                name: z.string(),
                username: z.optional(z.string())
            }),
            committer: z.object({
                date: z.optional(z.iso.datetime()),
                email: z.union([
                    z.email(),
                    z.null()
                ]),
                name: z.string(),
                username: z.optional(z.string())
            }),
            distinct: z.boolean(),
            id: z.string(),
            message: z.string(),
            modified: z.optional(z.array(z.string())),
            removed: z.optional(z.array(z.string())),
            timestamp: z.iso.datetime(),
            tree_id: z.string(),
            url: z.url()
        }),
        z.null()
    ]),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    pusher: z.object({
        date: z.optional(z.iso.datetime()),
        email: z.optional(z.union([
            z.email(),
            z.null()
        ])),
        name: z.string(),
        username: z.optional(z.string())
    }),
    ref: z.string(),
    repository: z.object({
        allow_auto_merge: z.optional(z.boolean()).default(false),
        allow_forking: z.optional(z.boolean()),
        allow_merge_commit: z.optional(z.boolean()).default(true),
        allow_rebase_merge: z.optional(z.boolean()).default(true),
        allow_squash_merge: z.optional(z.boolean()).default(true),
        allow_update_branch: z.optional(z.boolean()),
        archive_url: z.string(),
        archived: z.boolean().default(false),
        assignees_url: z.string(),
        blobs_url: z.string(),
        branches_url: z.string(),
        clone_url: z.url(),
        collaborators_url: z.string(),
        comments_url: z.string(),
        commits_url: z.string(),
        compare_url: z.string(),
        contents_url: z.string(),
        contributors_url: z.url(),
        created_at: z.union([
            z.int(),
            z.iso.datetime()
        ]),
        custom_properties: z.optional(z.record(z.string(), z.unknown())),
        default_branch: z.string(),
        delete_branch_on_merge: z.optional(z.boolean()).default(false),
        deployments_url: z.url(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        disabled: z.optional(z.boolean()),
        downloads_url: z.url(),
        events_url: z.url(),
        fork: z.boolean(),
        forks: z.int(),
        forks_count: z.int(),
        forks_url: z.url(),
        full_name: z.string(),
        git_commits_url: z.string(),
        git_refs_url: z.string(),
        git_tags_url: z.string(),
        git_url: z.url(),
        has_downloads: z.boolean().default(true),
        has_issues: z.boolean().default(true),
        has_pages: z.boolean(),
        has_projects: z.boolean().default(true),
        has_wiki: z.boolean().default(true),
        has_discussions: z.boolean().default(false),
        homepage: z.union([
            z.string(),
            z.null()
        ]),
        hooks_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        is_template: z.optional(z.boolean()),
        issue_comment_url: z.string(),
        issue_events_url: z.string(),
        issues_url: z.string(),
        keys_url: z.string(),
        labels_url: z.string(),
        language: z.union([
            z.string(),
            z.null()
        ]),
        languages_url: z.url(),
        license: z.union([
            z.object({
                key: z.string(),
                name: z.string(),
                node_id: z.string(),
                spdx_id: z.string(),
                url: z.union([
                    z.url(),
                    z.null()
                ])
            }),
            z.null()
        ]),
        master_branch: z.optional(z.string()),
        merges_url: z.url(),
        milestones_url: z.string(),
        mirror_url: z.union([
            z.url(),
            z.null()
        ]),
        name: z.string(),
        node_id: z.string(),
        notifications_url: z.string(),
        open_issues: z.int(),
        open_issues_count: z.int(),
        organization: z.optional(z.string()),
        owner: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        permissions: z.optional(z.object({
            admin: z.boolean(),
            maintain: z.optional(z.boolean()),
            pull: z.boolean(),
            push: z.boolean(),
            triage: z.optional(z.boolean())
        })),
        private: z.boolean(),
        public: z.optional(z.boolean()),
        pulls_url: z.string(),
        pushed_at: z.union([
            z.int(),
            z.iso.datetime(),
            z.null()
        ]),
        releases_url: z.string(),
        role_name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        size: z.int(),
        ssh_url: z.string(),
        stargazers: z.optional(z.int()),
        stargazers_count: z.int(),
        stargazers_url: z.url(),
        statuses_url: z.string(),
        subscribers_url: z.url(),
        subscription_url: z.url(),
        svn_url: z.url(),
        tags_url: z.url(),
        teams_url: z.url(),
        topics: z.array(z.string()),
        trees_url: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        visibility: z.enum([
            'public',
            'private',
            'internal'
        ]),
        watchers: z.int(),
        watchers_count: z.int(),
        web_commit_signoff_required: z.optional(z.boolean())
    }),
    sender: z.optional(zSimpleUser)
});

export const zWebhookRegistryPackagePublished = z.object({
    action: z.enum([
        'published'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    registry_package: z.object({
        created_at: z.union([
            z.string(),
            z.null()
        ]),
        description: z.union([
            z.string(),
            z.null()
        ]),
        ecosystem: z.string(),
        html_url: z.string(),
        id: z.int(),
        name: z.string(),
        namespace: z.string(),
        owner: z.object({
            avatar_url: z.string(),
            events_url: z.string(),
            followers_url: z.string(),
            following_url: z.string(),
            gists_url: z.string(),
            gravatar_id: z.string(),
            html_url: z.string(),
            id: z.int(),
            login: z.string(),
            node_id: z.string(),
            organizations_url: z.string(),
            received_events_url: z.string(),
            repos_url: z.string(),
            site_admin: z.boolean(),
            starred_url: z.string(),
            subscriptions_url: z.string(),
            type: z.string(),
            url: z.string(),
            user_view_type: z.optional(z.string())
        }),
        package_type: z.string(),
        package_version: z.union([
            z.object({
                author: z.optional(z.object({
                    avatar_url: z.string(),
                    events_url: z.string(),
                    followers_url: z.string(),
                    following_url: z.string(),
                    gists_url: z.string(),
                    gravatar_id: z.string(),
                    html_url: z.string(),
                    id: z.int(),
                    login: z.string(),
                    node_id: z.string(),
                    organizations_url: z.string(),
                    received_events_url: z.string(),
                    repos_url: z.string(),
                    site_admin: z.boolean(),
                    starred_url: z.string(),
                    subscriptions_url: z.string(),
                    type: z.string(),
                    url: z.string(),
                    user_view_type: z.optional(z.string())
                })),
                body: z.optional(z.union([
                    z.string(),
                    z.record(z.string(), z.unknown())
                ])),
                body_html: z.optional(z.string()),
                container_metadata: z.optional(z.object({
                    labels: z.optional(z.union([
                        z.record(z.string(), z.unknown()),
                        z.null()
                    ])),
                    manifest: z.optional(z.union([
                        z.record(z.string(), z.unknown()),
                        z.null()
                    ])),
                    tag: z.optional(z.object({
                        digest: z.optional(z.string()),
                        name: z.optional(z.string())
                    }))
                })),
                created_at: z.optional(z.string()),
                description: z.string(),
                docker_metadata: z.optional(z.array(z.object({
                    tags: z.optional(z.array(z.string()))
                }))),
                draft: z.optional(z.boolean()),
                html_url: z.string(),
                id: z.int(),
                installation_command: z.string(),
                manifest: z.optional(z.string()),
                metadata: z.array(z.record(z.string(), z.unknown())),
                name: z.string(),
                npm_metadata: z.optional(z.union([
                    z.object({
                        name: z.optional(z.string()),
                        version: z.optional(z.string()),
                        npm_user: z.optional(z.string()),
                        author: z.optional(z.union([
                            z.string(),
                            z.record(z.string(), z.unknown()),
                            z.null()
                        ])),
                        bugs: z.optional(z.union([
                            z.string(),
                            z.record(z.string(), z.unknown()),
                            z.null()
                        ])),
                        dependencies: z.optional(z.record(z.string(), z.unknown())),
                        dev_dependencies: z.optional(z.record(z.string(), z.unknown())),
                        peer_dependencies: z.optional(z.record(z.string(), z.unknown())),
                        optional_dependencies: z.optional(z.record(z.string(), z.unknown())),
                        description: z.optional(z.string()),
                        dist: z.optional(z.union([
                            z.string(),
                            z.record(z.string(), z.unknown()),
                            z.null()
                        ])),
                        git_head: z.optional(z.string()),
                        homepage: z.optional(z.string()),
                        license: z.optional(z.string()),
                        main: z.optional(z.string()),
                        repository: z.optional(z.union([
                            z.string(),
                            z.record(z.string(), z.unknown()),
                            z.null()
                        ])),
                        scripts: z.optional(z.record(z.string(), z.unknown())),
                        id: z.optional(z.string()),
                        node_version: z.optional(z.string()),
                        npm_version: z.optional(z.string()),
                        has_shrinkwrap: z.optional(z.boolean()),
                        maintainers: z.optional(z.array(z.string())),
                        contributors: z.optional(z.array(z.string())),
                        engines: z.optional(z.record(z.string(), z.unknown())),
                        keywords: z.optional(z.array(z.string())),
                        files: z.optional(z.array(z.string())),
                        bin: z.optional(z.record(z.string(), z.unknown())),
                        man: z.optional(z.record(z.string(), z.unknown())),
                        directories: z.optional(z.union([
                            z.string(),
                            z.record(z.string(), z.unknown()),
                            z.null()
                        ])),
                        os: z.optional(z.array(z.string())),
                        cpu: z.optional(z.array(z.string())),
                        readme: z.optional(z.string()),
                        installation_command: z.optional(z.string()),
                        release_id: z.optional(z.int()),
                        commit_oid: z.optional(z.string()),
                        published_via_actions: z.optional(z.boolean()),
                        deleted_by_id: z.optional(z.int())
                    }),
                    z.null()
                ])),
                nuget_metadata: z.optional(z.union([
                    z.array(z.object({
                        id: z.optional(z.union([
                            z.string(),
                            z.record(z.string(), z.unknown()),
                            z.int(),
                            z.null()
                        ])),
                        name: z.optional(z.string()),
                        value: z.optional(z.union([
                            z.boolean(),
                            z.string(),
                            z.int(),
                            z.object({
                                url: z.optional(z.string()),
                                branch: z.optional(z.string()),
                                commit: z.optional(z.string()),
                                type: z.optional(z.string())
                            })
                        ]))
                    })),
                    z.null()
                ])),
                package_files: z.array(z.object({
                    content_type: z.string(),
                    created_at: z.string(),
                    download_url: z.string(),
                    id: z.int(),
                    md5: z.union([
                        z.string(),
                        z.null()
                    ]),
                    name: z.string(),
                    sha1: z.union([
                        z.string(),
                        z.null()
                    ]),
                    sha256: z.union([
                        z.string(),
                        z.null()
                    ]),
                    size: z.int(),
                    state: z.union([
                        z.string(),
                        z.null()
                    ]),
                    updated_at: z.string()
                })),
                package_url: z.string(),
                prerelease: z.optional(z.boolean()),
                release: z.optional(z.object({
                    author: z.optional(z.object({
                        avatar_url: z.optional(z.string()),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.string()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.string()),
                        id: z.optional(z.int()),
                        login: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.string()),
                        received_events_url: z.optional(z.string()),
                        repos_url: z.optional(z.string()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.string()),
                        type: z.optional(z.string()),
                        url: z.optional(z.string()),
                        user_view_type: z.optional(z.string())
                    })),
                    created_at: z.optional(z.string()),
                    draft: z.optional(z.boolean()),
                    html_url: z.optional(z.string()),
                    id: z.optional(z.int()),
                    name: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    prerelease: z.optional(z.boolean()),
                    published_at: z.optional(z.string()),
                    tag_name: z.optional(z.string()),
                    target_commitish: z.optional(z.string()),
                    url: z.optional(z.string())
                })),
                rubygems_metadata: z.optional(z.array(zWebhookRubygemsMetadata)),
                summary: z.string(),
                tag_name: z.optional(z.string()),
                target_commitish: z.optional(z.string()),
                target_oid: z.optional(z.string()),
                updated_at: z.optional(z.string()),
                version: z.string()
            }),
            z.null()
        ]),
        registry: z.union([
            z.object({
                about_url: z.optional(z.string()),
                name: z.optional(z.string()),
                type: z.optional(z.string()),
                url: z.optional(z.string()),
                vendor: z.optional(z.string())
            }),
            z.null()
        ]),
        updated_at: z.union([
            z.string(),
            z.null()
        ])
    }),
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

export const zWebhookRegistryPackageUpdated = z.object({
    action: z.enum([
        'updated'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    registry_package: z.object({
        created_at: z.string(),
        description: z.unknown(),
        ecosystem: z.string(),
        html_url: z.string(),
        id: z.int(),
        name: z.string(),
        namespace: z.string(),
        owner: z.object({
            avatar_url: z.string(),
            events_url: z.string(),
            followers_url: z.string(),
            following_url: z.string(),
            gists_url: z.string(),
            gravatar_id: z.string(),
            html_url: z.string(),
            id: z.int(),
            login: z.string(),
            node_id: z.string(),
            organizations_url: z.string(),
            received_events_url: z.string(),
            repos_url: z.string(),
            site_admin: z.boolean(),
            starred_url: z.string(),
            subscriptions_url: z.string(),
            type: z.string(),
            url: z.string(),
            user_view_type: z.optional(z.string())
        }),
        package_type: z.string(),
        package_version: z.object({
            author: z.object({
                avatar_url: z.string(),
                events_url: z.string(),
                followers_url: z.string(),
                following_url: z.string(),
                gists_url: z.string(),
                gravatar_id: z.string(),
                html_url: z.string(),
                id: z.int(),
                login: z.string(),
                node_id: z.string(),
                organizations_url: z.string(),
                received_events_url: z.string(),
                repos_url: z.string(),
                site_admin: z.boolean(),
                starred_url: z.string(),
                subscriptions_url: z.string(),
                type: z.string(),
                url: z.string(),
                user_view_type: z.optional(z.string())
            }),
            body: z.string(),
            body_html: z.string(),
            created_at: z.string(),
            description: z.string(),
            docker_metadata: z.optional(z.array(z.union([
                z.object({
                    tags: z.optional(z.array(z.string()))
                }),
                z.null()
            ]))),
            draft: z.optional(z.boolean()),
            html_url: z.string(),
            id: z.int(),
            installation_command: z.string(),
            manifest: z.optional(z.string()),
            metadata: z.array(z.record(z.string(), z.unknown())),
            name: z.string(),
            package_files: z.array(z.object({
                content_type: z.optional(z.string()),
                created_at: z.optional(z.string()),
                download_url: z.optional(z.string()),
                id: z.optional(z.int()),
                md5: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                name: z.optional(z.string()),
                sha1: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                sha256: z.optional(z.string()),
                size: z.optional(z.int()),
                state: z.optional(z.string()),
                updated_at: z.optional(z.string())
            })),
            package_url: z.string(),
            prerelease: z.optional(z.boolean()),
            release: z.optional(z.object({
                author: z.object({
                    avatar_url: z.string(),
                    events_url: z.string(),
                    followers_url: z.string(),
                    following_url: z.string(),
                    gists_url: z.string(),
                    gravatar_id: z.string(),
                    html_url: z.string(),
                    id: z.int(),
                    login: z.string(),
                    node_id: z.string(),
                    organizations_url: z.string(),
                    received_events_url: z.string(),
                    repos_url: z.string(),
                    site_admin: z.boolean(),
                    starred_url: z.string(),
                    subscriptions_url: z.string(),
                    type: z.string(),
                    url: z.string(),
                    user_view_type: z.optional(z.string())
                }),
                created_at: z.string(),
                draft: z.boolean(),
                html_url: z.string(),
                id: z.int(),
                name: z.string(),
                prerelease: z.boolean(),
                published_at: z.string(),
                tag_name: z.string(),
                target_commitish: z.string(),
                url: z.string()
            })),
            rubygems_metadata: z.optional(z.array(zWebhookRubygemsMetadata)),
            summary: z.string(),
            tag_name: z.optional(z.string()),
            target_commitish: z.string(),
            target_oid: z.string(),
            updated_at: z.string(),
            version: z.string()
        }),
        registry: z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]),
        updated_at: z.string()
    }),
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser
});

/**
 * release created event
 */
export const zWebhookReleaseCreated = z.object({
    action: z.enum([
        'created'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    release: zWebhooksRelease,
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * release deleted event
 */
export const zWebhookReleaseDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    release: zWebhooksRelease,
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * release edited event
 */
export const zWebhookReleaseEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.object({
        body: z.optional(z.object({
            from: z.string()
        })),
        name: z.optional(z.object({
            from: z.string()
        })),
        tag_name: z.optional(z.object({
            from: z.string()
        })),
        make_latest: z.optional(z.object({
            to: z.boolean()
        }))
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    release: zWebhooksRelease,
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * release prereleased event
 */
export const zWebhookReleasePrereleased = z.object({
    action: z.enum([
        'prereleased'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    release: z.object({
        assets: z.array(z.union([
            z.object({
                browser_download_url: z.url(),
                content_type: z.string(),
                created_at: z.iso.datetime(),
                download_count: z.int(),
                id: z.int(),
                label: z.union([
                    z.string(),
                    z.null()
                ]),
                name: z.string(),
                node_id: z.string(),
                size: z.int(),
                digest: z.union([
                    z.string(),
                    z.null()
                ]),
                state: z.enum([
                    'uploaded'
                ]),
                updated_at: z.iso.datetime(),
                uploader: z.optional(z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.int(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url())
                    }),
                    z.null()
                ])),
                url: z.url()
            }),
            z.null()
        ])),
        assets_url: z.url(),
        author: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        body: z.union([
            z.string(),
            z.null()
        ]),
        created_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        discussion_url: z.optional(z.url()),
        draft: z.boolean(),
        html_url: z.url(),
        id: z.int(),
        immutable: z.boolean(),
        name: z.union([
            z.string(),
            z.null()
        ]),
        node_id: z.string(),
        prerelease: z.literal(true),
        published_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        reactions: z.optional(z.object({
            '+1': z.int(),
            '-1': z.int(),
            confused: z.int(),
            eyes: z.int(),
            heart: z.int(),
            hooray: z.int(),
            laugh: z.int(),
            rocket: z.int(),
            total_count: z.int(),
            url: z.url()
        })),
        tag_name: z.string(),
        tarball_url: z.union([
            z.url(),
            z.null()
        ]),
        target_commitish: z.string(),
        upload_url: z.string(),
        updated_at: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        url: z.url(),
        zipball_url: z.union([
            z.url(),
            z.null()
        ])
    }),
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * release published event
 */
export const zWebhookReleasePublished = z.object({
    action: z.enum([
        'published'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    release: zWebhooksRelease1,
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * release released event
 */
export const zWebhookReleaseReleased = z.object({
    action: z.enum([
        'released'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    release: zWebhooksRelease,
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * release unpublished event
 */
export const zWebhookReleaseUnpublished = z.object({
    action: z.enum([
        'unpublished'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    release: zWebhooksRelease1,
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * Repository advisory published event
 */
export const zWebhookRepositoryAdvisoryPublished = z.object({
    action: z.enum([
        'published'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    repository_advisory: zRepositoryAdvisory,
    sender: z.optional(zSimpleUser)
});

/**
 * Repository advisory reported event
 */
export const zWebhookRepositoryAdvisoryReported = z.object({
    action: z.enum([
        'reported'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    repository_advisory: zRepositoryAdvisory,
    sender: z.optional(zSimpleUser)
});

/**
 * repository archived event
 */
export const zWebhookRepositoryArchived = z.object({
    action: z.enum([
        'archived'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * repository created event
 */
export const zWebhookRepositoryCreated = z.object({
    action: z.enum([
        'created'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * repository deleted event
 */
export const zWebhookRepositoryDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * repository_dispatch event
 */
export const zWebhookRepositoryDispatchSample = z.object({
    action: z.string(),
    branch: z.string(),
    client_payload: z.union([
        z.record(z.string(), z.unknown()),
        z.null()
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: zSimpleInstallation,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * repository edited event
 */
export const zWebhookRepositoryEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.object({
        default_branch: z.optional(z.object({
            from: z.string()
        })),
        description: z.optional(z.object({
            from: z.union([
                z.string(),
                z.null()
            ])
        })),
        homepage: z.optional(z.object({
            from: z.union([
                z.string(),
                z.null()
            ])
        })),
        topics: z.optional(z.object({
            from: z.optional(z.union([
                z.array(z.string()),
                z.null()
            ]))
        }))
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * repository_import event
 */
export const zWebhookRepositoryImport = z.object({
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser,
    status: z.enum([
        'success',
        'cancelled',
        'failure'
    ])
});

/**
 * repository privatized event
 */
export const zWebhookRepositoryPrivatized = z.object({
    action: z.enum([
        'privatized'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * repository publicized event
 */
export const zWebhookRepositoryPublicized = z.object({
    action: z.enum([
        'publicized'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * repository renamed event
 */
export const zWebhookRepositoryRenamed = z.object({
    action: z.enum([
        'renamed'
    ]),
    changes: z.object({
        repository: z.object({
            name: z.object({
                from: z.string()
            })
        })
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * repository ruleset created event
 */
export const zWebhookRepositoryRulesetCreated = z.object({
    action: z.enum([
        'created'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    repository_ruleset: zRepositoryRuleset,
    sender: zSimpleUser
});

/**
 * repository ruleset deleted event
 */
export const zWebhookRepositoryRulesetDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    repository_ruleset: zRepositoryRuleset,
    sender: zSimpleUser
});

/**
 * repository ruleset edited event
 */
export const zWebhookRepositoryRulesetEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    repository_ruleset: zRepositoryRuleset,
    changes: z.optional(z.object({
        name: z.optional(z.object({
            from: z.optional(z.string())
        })),
        enforcement: z.optional(z.object({
            from: z.optional(z.string())
        })),
        conditions: z.optional(z.object({
            added: z.optional(z.array(zRepositoryRulesetConditions)),
            deleted: z.optional(z.array(zRepositoryRulesetConditions)),
            updated: z.optional(z.array(z.object({
                condition: z.optional(zRepositoryRulesetConditions),
                changes: z.optional(z.object({
                    condition_type: z.optional(z.object({
                        from: z.optional(z.string())
                    })),
                    target: z.optional(z.object({
                        from: z.optional(z.string())
                    })),
                    include: z.optional(z.object({
                        from: z.optional(z.array(z.string()))
                    })),
                    exclude: z.optional(z.object({
                        from: z.optional(z.array(z.string()))
                    }))
                }))
            })))
        })),
        rules: z.optional(z.object({
            added: z.optional(z.array(zRepositoryRule)),
            deleted: z.optional(z.array(zRepositoryRule)),
            updated: z.optional(z.array(z.object({
                rule: z.optional(zRepositoryRule),
                changes: z.optional(z.object({
                    configuration: z.optional(z.object({
                        from: z.optional(z.string())
                    })),
                    rule_type: z.optional(z.object({
                        from: z.optional(z.string())
                    })),
                    pattern: z.optional(z.object({
                        from: z.optional(z.string())
                    }))
                }))
            })))
        }))
    })),
    sender: zSimpleUser
});

/**
 * repository transferred event
 */
export const zWebhookRepositoryTransferred = z.object({
    action: z.enum([
        'transferred'
    ]),
    changes: z.object({
        owner: z.object({
            from: z.object({
                organization: z.optional(z.object({
                    avatar_url: z.url(),
                    description: z.union([
                        z.string(),
                        z.null()
                    ]),
                    events_url: z.url(),
                    hooks_url: z.url(),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    issues_url: z.url(),
                    login: z.string(),
                    members_url: z.string(),
                    node_id: z.string(),
                    public_members_url: z.string(),
                    repos_url: z.url(),
                    url: z.url()
                })),
                user: z.optional(z.union([
                    z.object({
                        avatar_url: z.optional(z.url()),
                        deleted: z.optional(z.boolean()),
                        email: z.optional(z.union([
                            z.string(),
                            z.null()
                        ])),
                        events_url: z.optional(z.string()),
                        followers_url: z.optional(z.url()),
                        following_url: z.optional(z.string()),
                        gists_url: z.optional(z.string()),
                        gravatar_id: z.optional(z.string()),
                        html_url: z.optional(z.url()),
                        id: z.coerce.bigint(),
                        login: z.string(),
                        name: z.optional(z.string()),
                        node_id: z.optional(z.string()),
                        organizations_url: z.optional(z.url()),
                        received_events_url: z.optional(z.url()),
                        repos_url: z.optional(z.url()),
                        site_admin: z.optional(z.boolean()),
                        starred_url: z.optional(z.string()),
                        subscriptions_url: z.optional(z.url()),
                        type: z.optional(z.enum([
                            'Bot',
                            'User',
                            'Organization'
                        ])),
                        url: z.optional(z.url()),
                        user_view_type: z.optional(z.string())
                    }),
                    z.null()
                ]))
            })
        })
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * repository unarchived event
 */
export const zWebhookRepositoryUnarchived = z.object({
    action: z.enum([
        'unarchived'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * repository_vulnerability_alert create event
 */
export const zWebhookRepositoryVulnerabilityAlertCreate = z.object({
    action: z.enum([
        'create'
    ]),
    alert: zWebhooksAlert,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * repository_vulnerability_alert dismiss event
 */
export const zWebhookRepositoryVulnerabilityAlertDismiss = z.object({
    action: z.enum([
        'dismiss'
    ]),
    alert: z.object({
        affected_package_name: z.string(),
        affected_range: z.string(),
        created_at: z.string(),
        dismiss_comment: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        dismiss_reason: z.string(),
        dismissed_at: z.string(),
        dismisser: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        external_identifier: z.string(),
        external_reference: z.union([
            z.url(),
            z.null()
        ]),
        fix_reason: z.optional(z.string()),
        fixed_at: z.optional(z.iso.datetime()),
        fixed_in: z.optional(z.string()),
        ghsa_id: z.string(),
        id: z.int(),
        node_id: z.string(),
        number: z.int(),
        severity: z.string(),
        state: z.enum([
            'dismissed'
        ])
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * repository_vulnerability_alert reopen event
 */
export const zWebhookRepositoryVulnerabilityAlertReopen = z.object({
    action: z.enum([
        'reopen'
    ]),
    alert: zWebhooksAlert,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * repository_vulnerability_alert resolve event
 */
export const zWebhookRepositoryVulnerabilityAlertResolve = z.object({
    action: z.enum([
        'resolve'
    ]),
    alert: z.object({
        affected_package_name: z.string(),
        affected_range: z.string(),
        created_at: z.string(),
        dismiss_reason: z.optional(z.string()),
        dismissed_at: z.optional(z.string()),
        dismisser: z.optional(z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ])),
        external_identifier: z.string(),
        external_reference: z.union([
            z.url(),
            z.null()
        ]),
        fix_reason: z.optional(z.string()),
        fixed_at: z.optional(z.iso.datetime()),
        fixed_in: z.optional(z.string()),
        ghsa_id: z.string(),
        id: z.int(),
        node_id: z.string(),
        number: z.int(),
        severity: z.string(),
        state: z.enum([
            'fixed',
            'open'
        ])
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * secret_scanning_alert created event
 */
export const zWebhookSecretScanningAlertCreated = z.object({
    action: z.enum([
        'created'
    ]),
    alert: zSecretScanningAlertWebhook,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * Secret Scanning Alert Location Created Event
 */
export const zWebhookSecretScanningAlertLocationCreated = z.object({
    action: z.optional(z.enum([
        'created'
    ])),
    alert: zSecretScanningAlertWebhook,
    installation: z.optional(zSimpleInstallation),
    location: zSecretScanningLocation,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Secret Scanning Alert Location Created Event
 */
export const zWebhookSecretScanningAlertLocationCreatedFormEncoded = z.object({
    payload: z.string()
});

/**
 * secret_scanning_alert publicly leaked event
 */
export const zWebhookSecretScanningAlertPubliclyLeaked = z.object({
    action: z.enum([
        'publicly_leaked'
    ]),
    alert: zSecretScanningAlertWebhook,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * secret_scanning_alert reopened event
 */
export const zWebhookSecretScanningAlertReopened = z.object({
    action: z.enum([
        'reopened'
    ]),
    alert: zSecretScanningAlertWebhook,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * secret_scanning_alert resolved event
 */
export const zWebhookSecretScanningAlertResolved = z.object({
    action: z.enum([
        'resolved'
    ]),
    alert: zSecretScanningAlertWebhook,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * secret_scanning_alert validated event
 */
export const zWebhookSecretScanningAlertValidated = z.object({
    action: z.enum([
        'validated'
    ]),
    alert: zSecretScanningAlertWebhook,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * secret_scanning_scan completed event
 */
export const zWebhookSecretScanningScanCompleted = z.object({
    action: z.enum([
        'completed'
    ]),
    type: z.enum([
        'backfill',
        'custom-pattern-backfill',
        'pattern-version-backfill'
    ]),
    source: z.enum([
        'git',
        'issues',
        'pull-requests',
        'discussions',
        'wiki'
    ]),
    started_at: z.iso.datetime(),
    completed_at: z.iso.datetime(),
    secret_types: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    custom_pattern_name: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    custom_pattern_scope: z.optional(z.enum([
        'repository',
        'organization',
        'enterprise'
    ])),
    repository: z.optional(zRepositoryWebhooks),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    sender: z.optional(zSimpleUser)
});

/**
 * security_advisory published event
 */
export const zWebhookSecurityAdvisoryPublished = z.object({
    action: z.enum([
        'published'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    security_advisory: zWebhooksSecurityAdvisory,
    sender: z.optional(zSimpleUser)
});

/**
 * security_advisory updated event
 */
export const zWebhookSecurityAdvisoryUpdated = z.object({
    action: z.enum([
        'updated'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    security_advisory: zWebhooksSecurityAdvisory,
    sender: z.optional(zSimpleUser)
});

/**
 * security_advisory withdrawn event
 */
export const zWebhookSecurityAdvisoryWithdrawn = z.object({
    action: z.enum([
        'withdrawn'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    security_advisory: z.object({
        cvss: z.object({
            score: z.number(),
            vector_string: z.union([
                z.string(),
                z.null()
            ])
        }),
        cvss_severities: z.optional(zCvssSeverities),
        cwes: z.array(z.object({
            cwe_id: z.string(),
            name: z.string()
        })),
        description: z.string(),
        ghsa_id: z.string(),
        identifiers: z.array(z.object({
            type: z.string(),
            value: z.string()
        })),
        published_at: z.string(),
        references: z.array(z.object({
            url: z.url()
        })),
        severity: z.string(),
        summary: z.string(),
        updated_at: z.string(),
        vulnerabilities: z.array(z.object({
            first_patched_version: z.union([
                z.object({
                    identifier: z.string()
                }),
                z.null()
            ]),
            package: z.object({
                ecosystem: z.string(),
                name: z.string()
            }),
            severity: z.string(),
            vulnerable_version_range: z.string()
        })),
        withdrawn_at: z.string()
    }),
    sender: z.optional(zSimpleUser)
});

/**
 * security_and_analysis event
 */
export const zWebhookSecurityAndAnalysis = z.object({
    changes: z.object({
        from: z.optional(z.object({
            security_and_analysis: z.optional(zSecurityAndAnalysis)
        }))
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zFullRepository,
    sender: z.optional(zSimpleUser)
});

/**
 * sponsorship cancelled event
 */
export const zWebhookSponsorshipCancelled = z.object({
    action: z.enum([
        'cancelled'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser,
    sponsorship: zWebhooksSponsorship
});

/**
 * sponsorship created event
 */
export const zWebhookSponsorshipCreated = z.object({
    action: z.enum([
        'created'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser,
    sponsorship: zWebhooksSponsorship
});

/**
 * sponsorship edited event
 */
export const zWebhookSponsorshipEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.object({
        privacy_level: z.optional(z.object({
            from: z.string()
        }))
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser,
    sponsorship: zWebhooksSponsorship
});

/**
 * sponsorship pending_cancellation event
 */
export const zWebhookSponsorshipPendingCancellation = z.object({
    action: z.enum([
        'pending_cancellation'
    ]),
    effective_date: z.optional(zWebhooksEffectiveDate),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser,
    sponsorship: zWebhooksSponsorship
});

/**
 * sponsorship pending_tier_change event
 */
export const zWebhookSponsorshipPendingTierChange = z.object({
    action: z.enum([
        'pending_tier_change'
    ]),
    changes: zWebhooksChanges8,
    effective_date: z.optional(zWebhooksEffectiveDate),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser,
    sponsorship: zWebhooksSponsorship
});

/**
 * sponsorship tier_changed event
 */
export const zWebhookSponsorshipTierChanged = z.object({
    action: z.enum([
        'tier_changed'
    ]),
    changes: zWebhooksChanges8,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    sender: zSimpleUser,
    sponsorship: zWebhooksSponsorship
});

/**
 * star created event
 */
export const zWebhookStarCreated = z.object({
    action: z.enum([
        'created'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser,
    starred_at: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * star deleted event
 */
export const zWebhookStarDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser,
    starred_at: z.unknown()
});

/**
 * status event
 */
export const zWebhookStatus = z.object({
    avatar_url: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    branches: z.array(z.object({
        commit: z.object({
            sha: z.union([
                z.string(),
                z.null()
            ]),
            url: z.union([
                z.url(),
                z.null()
            ])
        }),
        name: z.string(),
        protected: z.boolean()
    })),
    commit: z.object({
        author: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.optional(z.int()),
                login: z.optional(z.string()),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ]),
        comments_url: z.url(),
        commit: z.object({
            author: z.object({
                date: z.optional(z.iso.datetime()),
                email: z.union([
                    z.email(),
                    z.null()
                ]),
                name: z.string(),
                username: z.optional(z.string())
            }).and(z.object({
                date: z.string(),
                email: z.optional(z.string()),
                name: z.optional(z.string())
            })),
            comment_count: z.int(),
            committer: z.object({
                date: z.optional(z.iso.datetime()),
                email: z.union([
                    z.email(),
                    z.null()
                ]),
                name: z.string(),
                username: z.optional(z.string())
            }).and(z.object({
                date: z.string(),
                email: z.optional(z.string()),
                name: z.optional(z.string())
            })),
            message: z.string(),
            tree: z.object({
                sha: z.string(),
                url: z.url()
            }),
            url: z.url(),
            verification: z.object({
                payload: z.union([
                    z.string(),
                    z.null()
                ]),
                reason: z.enum([
                    'expired_key',
                    'not_signing_key',
                    'gpgverify_error',
                    'gpgverify_unavailable',
                    'unsigned',
                    'unknown_signature_type',
                    'no_user',
                    'unverified_email',
                    'bad_email',
                    'unknown_key',
                    'malformed_signature',
                    'invalid',
                    'valid',
                    'bad_cert',
                    'ocsp_pending'
                ]),
                signature: z.union([
                    z.string(),
                    z.null()
                ]),
                verified: z.boolean(),
                verified_at: z.union([
                    z.string(),
                    z.null()
                ])
            })
        }),
        committer: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.optional(z.int()),
                login: z.optional(z.string()),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ]),
        html_url: z.url(),
        node_id: z.string(),
        parents: z.array(z.object({
            html_url: z.url(),
            sha: z.string(),
            url: z.url()
        })),
        sha: z.string(),
        url: z.url()
    }),
    context: z.string(),
    created_at: z.string(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    id: z.int(),
    installation: z.optional(zSimpleInstallation),
    name: z.string(),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser,
    sha: z.string(),
    state: z.enum([
        'pending',
        'success',
        'failure',
        'error'
    ]),
    target_url: z.union([
        z.string(),
        z.null()
    ]),
    updated_at: z.string()
});

/**
 * parent issue added event
 */
export const zWebhookSubIssuesParentIssueAdded = z.object({
    action: z.enum([
        'parent_issue_added'
    ]),
    parent_issue_id: z.number(),
    parent_issue: zIssue,
    parent_issue_repo: zRepository,
    sub_issue_id: z.number(),
    sub_issue: zIssue,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    sender: z.optional(zSimpleUser)
});

/**
 * parent issue removed event
 */
export const zWebhookSubIssuesParentIssueRemoved = z.object({
    action: z.enum([
        'parent_issue_removed'
    ]),
    parent_issue_id: z.number(),
    parent_issue: zIssue,
    parent_issue_repo: zRepository,
    sub_issue_id: z.number(),
    sub_issue: zIssue,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    sender: z.optional(zSimpleUser)
});

/**
 * sub-issue added event
 */
export const zWebhookSubIssuesSubIssueAdded = z.object({
    action: z.enum([
        'sub_issue_added'
    ]),
    sub_issue_id: z.number(),
    sub_issue: zIssue,
    sub_issue_repo: zRepository,
    parent_issue_id: z.number(),
    parent_issue: zIssue,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    sender: z.optional(zSimpleUser)
});

/**
 * sub-issue removed event
 */
export const zWebhookSubIssuesSubIssueRemoved = z.object({
    action: z.enum([
        'sub_issue_removed'
    ]),
    sub_issue_id: z.number(),
    sub_issue: zIssue,
    sub_issue_repo: zRepository,
    parent_issue_id: z.number(),
    parent_issue: zIssue,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    sender: z.optional(zSimpleUser)
});

/**
 * team_add event
 */
export const zWebhookTeamAdd = z.object({
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser,
    team: zWebhooksTeam1
});

/**
 * team added_to_repository event
 */
export const zWebhookTeamAddedToRepository = z.object({
    action: z.enum([
        'added_to_repository'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    repository: z.optional(z.object({
        allow_auto_merge: z.optional(z.boolean()).default(false),
        allow_forking: z.optional(z.boolean()),
        allow_merge_commit: z.optional(z.boolean()).default(true),
        allow_rebase_merge: z.optional(z.boolean()).default(true),
        allow_squash_merge: z.optional(z.boolean()).default(true),
        allow_update_branch: z.optional(z.boolean()),
        archive_url: z.string(),
        archived: z.boolean().default(false),
        assignees_url: z.string(),
        blobs_url: z.string(),
        branches_url: z.string(),
        clone_url: z.url(),
        collaborators_url: z.string(),
        comments_url: z.string(),
        commits_url: z.string(),
        compare_url: z.string(),
        contents_url: z.string(),
        contributors_url: z.url(),
        created_at: z.union([
            z.int(),
            z.iso.datetime()
        ]),
        custom_properties: z.optional(z.record(z.string(), z.unknown())),
        default_branch: z.string(),
        delete_branch_on_merge: z.optional(z.boolean()).default(false),
        deployments_url: z.url(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        disabled: z.optional(z.boolean()),
        downloads_url: z.url(),
        events_url: z.url(),
        fork: z.boolean(),
        forks: z.int(),
        forks_count: z.int(),
        forks_url: z.url(),
        full_name: z.string(),
        git_commits_url: z.string(),
        git_refs_url: z.string(),
        git_tags_url: z.string(),
        git_url: z.url(),
        has_downloads: z.boolean().default(true),
        has_issues: z.boolean().default(true),
        has_pages: z.boolean(),
        has_projects: z.boolean().default(true),
        has_wiki: z.boolean().default(true),
        homepage: z.union([
            z.string(),
            z.null()
        ]),
        hooks_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        is_template: z.optional(z.boolean()),
        issue_comment_url: z.string(),
        issue_events_url: z.string(),
        issues_url: z.string(),
        keys_url: z.string(),
        labels_url: z.string(),
        language: z.union([
            z.string(),
            z.null()
        ]),
        languages_url: z.url(),
        license: z.union([
            z.object({
                key: z.string(),
                name: z.string(),
                node_id: z.string(),
                spdx_id: z.string(),
                url: z.union([
                    z.url(),
                    z.null()
                ])
            }),
            z.null()
        ]),
        master_branch: z.optional(z.string()),
        merges_url: z.url(),
        milestones_url: z.string(),
        mirror_url: z.union([
            z.url(),
            z.null()
        ]),
        name: z.string(),
        node_id: z.string(),
        notifications_url: z.string(),
        open_issues: z.int(),
        open_issues_count: z.int(),
        organization: z.optional(z.string()),
        owner: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        permissions: z.optional(z.object({
            admin: z.boolean(),
            maintain: z.optional(z.boolean()),
            pull: z.boolean(),
            push: z.boolean(),
            triage: z.optional(z.boolean())
        })),
        private: z.boolean(),
        public: z.optional(z.boolean()),
        pulls_url: z.string(),
        pushed_at: z.union([
            z.int(),
            z.iso.datetime(),
            z.null()
        ]),
        releases_url: z.string(),
        role_name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        size: z.int(),
        ssh_url: z.string(),
        stargazers: z.optional(z.int()),
        stargazers_count: z.int(),
        stargazers_url: z.url(),
        statuses_url: z.string(),
        subscribers_url: z.url(),
        subscription_url: z.url(),
        svn_url: z.url(),
        tags_url: z.url(),
        teams_url: z.url(),
        topics: z.array(z.string()),
        trees_url: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        visibility: z.enum([
            'public',
            'private',
            'internal'
        ]),
        watchers: z.int(),
        watchers_count: z.int()
    })),
    sender: z.optional(zSimpleUser),
    team: zWebhooksTeam1
});

/**
 * team created event
 */
export const zWebhookTeamCreated = z.object({
    action: z.enum([
        'created'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    repository: z.optional(z.object({
        allow_auto_merge: z.optional(z.boolean()).default(false),
        allow_forking: z.optional(z.boolean()),
        allow_merge_commit: z.optional(z.boolean()).default(true),
        allow_rebase_merge: z.optional(z.boolean()).default(true),
        allow_squash_merge: z.optional(z.boolean()).default(true),
        allow_update_branch: z.optional(z.boolean()),
        archive_url: z.string(),
        archived: z.boolean().default(false),
        assignees_url: z.string(),
        blobs_url: z.string(),
        branches_url: z.string(),
        clone_url: z.url(),
        collaborators_url: z.string(),
        comments_url: z.string(),
        commits_url: z.string(),
        compare_url: z.string(),
        contents_url: z.string(),
        contributors_url: z.url(),
        created_at: z.union([
            z.int(),
            z.iso.datetime()
        ]),
        custom_properties: z.optional(z.record(z.string(), z.unknown())),
        default_branch: z.string(),
        delete_branch_on_merge: z.optional(z.boolean()).default(false),
        deployments_url: z.url(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        disabled: z.optional(z.boolean()),
        downloads_url: z.url(),
        events_url: z.url(),
        fork: z.boolean(),
        forks: z.int(),
        forks_count: z.int(),
        forks_url: z.url(),
        full_name: z.string(),
        git_commits_url: z.string(),
        git_refs_url: z.string(),
        git_tags_url: z.string(),
        git_url: z.url(),
        has_downloads: z.boolean().default(true),
        has_issues: z.boolean().default(true),
        has_pages: z.boolean(),
        has_projects: z.boolean().default(true),
        has_wiki: z.boolean().default(true),
        homepage: z.union([
            z.string(),
            z.null()
        ]),
        hooks_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        is_template: z.optional(z.boolean()),
        issue_comment_url: z.string(),
        issue_events_url: z.string(),
        issues_url: z.string(),
        keys_url: z.string(),
        labels_url: z.string(),
        language: z.union([
            z.string(),
            z.null()
        ]),
        languages_url: z.url(),
        license: z.union([
            z.object({
                key: z.string(),
                name: z.string(),
                node_id: z.string(),
                spdx_id: z.string(),
                url: z.union([
                    z.url(),
                    z.null()
                ])
            }),
            z.null()
        ]),
        master_branch: z.optional(z.string()),
        merges_url: z.url(),
        milestones_url: z.string(),
        mirror_url: z.union([
            z.url(),
            z.null()
        ]),
        name: z.string(),
        node_id: z.string(),
        notifications_url: z.string(),
        open_issues: z.int(),
        open_issues_count: z.int(),
        organization: z.optional(z.string()),
        owner: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        permissions: z.optional(z.object({
            admin: z.boolean(),
            maintain: z.optional(z.boolean()),
            pull: z.boolean(),
            push: z.boolean(),
            triage: z.optional(z.boolean())
        })),
        private: z.boolean(),
        public: z.optional(z.boolean()),
        pulls_url: z.string(),
        pushed_at: z.union([
            z.int(),
            z.iso.datetime(),
            z.null()
        ]),
        releases_url: z.string(),
        role_name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        size: z.int(),
        ssh_url: z.string(),
        stargazers: z.optional(z.int()),
        stargazers_count: z.int(),
        stargazers_url: z.url(),
        statuses_url: z.string(),
        subscribers_url: z.url(),
        subscription_url: z.url(),
        svn_url: z.url(),
        tags_url: z.url(),
        teams_url: z.url(),
        topics: z.array(z.string()),
        trees_url: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        visibility: z.enum([
            'public',
            'private',
            'internal'
        ]),
        watchers: z.int(),
        watchers_count: z.int()
    })),
    sender: zSimpleUser,
    team: zWebhooksTeam1
});

/**
 * team deleted event
 */
export const zWebhookTeamDeleted = z.object({
    action: z.enum([
        'deleted'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    repository: z.optional(z.object({
        allow_auto_merge: z.optional(z.boolean()).default(false),
        allow_forking: z.optional(z.boolean()),
        allow_merge_commit: z.optional(z.boolean()).default(true),
        allow_rebase_merge: z.optional(z.boolean()).default(true),
        allow_squash_merge: z.optional(z.boolean()).default(true),
        allow_update_branch: z.optional(z.boolean()),
        archive_url: z.string(),
        archived: z.boolean().default(false),
        assignees_url: z.string(),
        blobs_url: z.string(),
        branches_url: z.string(),
        clone_url: z.url(),
        collaborators_url: z.string(),
        comments_url: z.string(),
        commits_url: z.string(),
        compare_url: z.string(),
        contents_url: z.string(),
        contributors_url: z.url(),
        created_at: z.union([
            z.int(),
            z.iso.datetime()
        ]),
        custom_properties: z.optional(z.record(z.string(), z.unknown())),
        default_branch: z.string(),
        delete_branch_on_merge: z.optional(z.boolean()).default(false),
        deployments_url: z.url(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        disabled: z.optional(z.boolean()),
        downloads_url: z.url(),
        events_url: z.url(),
        fork: z.boolean(),
        forks: z.int(),
        forks_count: z.int(),
        forks_url: z.url(),
        full_name: z.string(),
        git_commits_url: z.string(),
        git_refs_url: z.string(),
        git_tags_url: z.string(),
        git_url: z.url(),
        has_downloads: z.boolean().default(true),
        has_issues: z.boolean().default(true),
        has_pages: z.boolean(),
        has_projects: z.boolean().default(true),
        has_wiki: z.boolean().default(true),
        homepage: z.union([
            z.string(),
            z.null()
        ]),
        hooks_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        is_template: z.optional(z.boolean()),
        issue_comment_url: z.string(),
        issue_events_url: z.string(),
        issues_url: z.string(),
        keys_url: z.string(),
        labels_url: z.string(),
        language: z.union([
            z.string(),
            z.null()
        ]),
        languages_url: z.url(),
        license: z.union([
            z.object({
                key: z.string(),
                name: z.string(),
                node_id: z.string(),
                spdx_id: z.string(),
                url: z.union([
                    z.url(),
                    z.null()
                ])
            }),
            z.null()
        ]),
        master_branch: z.optional(z.string()),
        merges_url: z.url(),
        milestones_url: z.string(),
        mirror_url: z.union([
            z.url(),
            z.null()
        ]),
        name: z.string(),
        node_id: z.string(),
        notifications_url: z.string(),
        open_issues: z.int(),
        open_issues_count: z.int(),
        organization: z.optional(z.string()),
        owner: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        permissions: z.optional(z.object({
            admin: z.boolean(),
            maintain: z.optional(z.boolean()),
            pull: z.boolean(),
            push: z.boolean(),
            triage: z.optional(z.boolean())
        })),
        private: z.boolean(),
        public: z.optional(z.boolean()),
        pulls_url: z.string(),
        pushed_at: z.union([
            z.int(),
            z.iso.datetime(),
            z.null()
        ]),
        releases_url: z.string(),
        role_name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        size: z.int(),
        ssh_url: z.string(),
        stargazers: z.optional(z.int()),
        stargazers_count: z.int(),
        stargazers_url: z.url(),
        statuses_url: z.string(),
        subscribers_url: z.url(),
        subscription_url: z.url(),
        svn_url: z.url(),
        tags_url: z.url(),
        teams_url: z.url(),
        topics: z.array(z.string()),
        trees_url: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        visibility: z.enum([
            'public',
            'private',
            'internal'
        ]),
        watchers: z.int(),
        watchers_count: z.int()
    })),
    sender: z.optional(zSimpleUser),
    team: zWebhooksTeam1
});

/**
 * team edited event
 */
export const zWebhookTeamEdited = z.object({
    action: z.enum([
        'edited'
    ]),
    changes: z.object({
        description: z.optional(z.object({
            from: z.string()
        })),
        name: z.optional(z.object({
            from: z.string()
        })),
        privacy: z.optional(z.object({
            from: z.string()
        })),
        notification_setting: z.optional(z.object({
            from: z.string()
        })),
        repository: z.optional(z.object({
            permissions: z.object({
                from: z.object({
                    admin: z.optional(z.boolean()),
                    pull: z.optional(z.boolean()),
                    push: z.optional(z.boolean())
                })
            })
        }))
    }),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    repository: z.optional(z.object({
        allow_auto_merge: z.optional(z.boolean()).default(false),
        allow_forking: z.optional(z.boolean()),
        allow_merge_commit: z.optional(z.boolean()).default(true),
        allow_rebase_merge: z.optional(z.boolean()).default(true),
        allow_squash_merge: z.optional(z.boolean()).default(true),
        allow_update_branch: z.optional(z.boolean()),
        archive_url: z.string(),
        archived: z.boolean().default(false),
        assignees_url: z.string(),
        blobs_url: z.string(),
        branches_url: z.string(),
        clone_url: z.url(),
        collaborators_url: z.string(),
        comments_url: z.string(),
        commits_url: z.string(),
        compare_url: z.string(),
        contents_url: z.string(),
        contributors_url: z.url(),
        created_at: z.union([
            z.int(),
            z.iso.datetime()
        ]),
        custom_properties: z.optional(z.record(z.string(), z.unknown())),
        default_branch: z.string(),
        delete_branch_on_merge: z.optional(z.boolean()).default(false),
        deployments_url: z.url(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        disabled: z.optional(z.boolean()),
        downloads_url: z.url(),
        events_url: z.url(),
        fork: z.boolean(),
        forks: z.int(),
        forks_count: z.int(),
        forks_url: z.url(),
        full_name: z.string(),
        git_commits_url: z.string(),
        git_refs_url: z.string(),
        git_tags_url: z.string(),
        git_url: z.url(),
        has_downloads: z.boolean().default(true),
        has_issues: z.boolean().default(true),
        has_pages: z.boolean(),
        has_projects: z.boolean().default(true),
        has_wiki: z.boolean().default(true),
        homepage: z.union([
            z.string(),
            z.null()
        ]),
        hooks_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        is_template: z.optional(z.boolean()),
        issue_comment_url: z.string(),
        issue_events_url: z.string(),
        issues_url: z.string(),
        keys_url: z.string(),
        labels_url: z.string(),
        language: z.union([
            z.string(),
            z.null()
        ]),
        languages_url: z.url(),
        license: z.union([
            z.object({
                key: z.string(),
                name: z.string(),
                node_id: z.string(),
                spdx_id: z.string(),
                url: z.union([
                    z.url(),
                    z.null()
                ])
            }),
            z.null()
        ]),
        master_branch: z.optional(z.string()),
        merges_url: z.url(),
        milestones_url: z.string(),
        mirror_url: z.union([
            z.url(),
            z.null()
        ]),
        name: z.string(),
        node_id: z.string(),
        notifications_url: z.string(),
        open_issues: z.int(),
        open_issues_count: z.int(),
        organization: z.optional(z.string()),
        owner: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        permissions: z.optional(z.object({
            admin: z.boolean(),
            maintain: z.optional(z.boolean()),
            pull: z.boolean(),
            push: z.boolean(),
            triage: z.optional(z.boolean())
        })),
        private: z.boolean(),
        public: z.optional(z.boolean()),
        pulls_url: z.string(),
        pushed_at: z.union([
            z.int(),
            z.iso.datetime(),
            z.null()
        ]),
        releases_url: z.string(),
        role_name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        size: z.int(),
        ssh_url: z.string(),
        stargazers: z.optional(z.int()),
        stargazers_count: z.int(),
        stargazers_url: z.url(),
        statuses_url: z.string(),
        subscribers_url: z.url(),
        subscription_url: z.url(),
        svn_url: z.url(),
        tags_url: z.url(),
        teams_url: z.url(),
        topics: z.array(z.string()),
        trees_url: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        visibility: z.enum([
            'public',
            'private',
            'internal'
        ]),
        watchers: z.int(),
        watchers_count: z.int()
    })),
    sender: zSimpleUser,
    team: zWebhooksTeam1
});

/**
 * team removed_from_repository event
 */
export const zWebhookTeamRemovedFromRepository = z.object({
    action: z.enum([
        'removed_from_repository'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: zOrganizationSimpleWebhooks,
    repository: z.optional(z.object({
        allow_auto_merge: z.optional(z.boolean()).default(false),
        allow_forking: z.optional(z.boolean()),
        allow_merge_commit: z.optional(z.boolean()).default(true),
        allow_rebase_merge: z.optional(z.boolean()).default(true),
        allow_squash_merge: z.optional(z.boolean()).default(true),
        allow_update_branch: z.optional(z.boolean()),
        archive_url: z.string(),
        archived: z.boolean().default(false),
        assignees_url: z.string(),
        blobs_url: z.string(),
        branches_url: z.string(),
        clone_url: z.url(),
        collaborators_url: z.string(),
        comments_url: z.string(),
        commits_url: z.string(),
        compare_url: z.string(),
        contents_url: z.string(),
        contributors_url: z.url(),
        created_at: z.union([
            z.int(),
            z.iso.datetime()
        ]),
        custom_properties: z.optional(z.record(z.string(), z.unknown())),
        default_branch: z.string(),
        delete_branch_on_merge: z.optional(z.boolean()).default(false),
        deployments_url: z.url(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        disabled: z.optional(z.boolean()),
        downloads_url: z.url(),
        events_url: z.url(),
        fork: z.boolean(),
        forks: z.int(),
        forks_count: z.int(),
        forks_url: z.url(),
        full_name: z.string(),
        git_commits_url: z.string(),
        git_refs_url: z.string(),
        git_tags_url: z.string(),
        git_url: z.url(),
        has_downloads: z.boolean().default(true),
        has_issues: z.boolean().default(true),
        has_pages: z.boolean(),
        has_projects: z.boolean().default(true),
        has_wiki: z.boolean().default(true),
        homepage: z.union([
            z.string(),
            z.null()
        ]),
        hooks_url: z.url(),
        html_url: z.url(),
        id: z.coerce.bigint(),
        is_template: z.optional(z.boolean()),
        issue_comment_url: z.string(),
        issue_events_url: z.string(),
        issues_url: z.string(),
        keys_url: z.string(),
        labels_url: z.string(),
        language: z.union([
            z.string(),
            z.null()
        ]),
        languages_url: z.url(),
        license: z.union([
            z.object({
                key: z.string(),
                name: z.string(),
                node_id: z.string(),
                spdx_id: z.string(),
                url: z.union([
                    z.url(),
                    z.null()
                ])
            }),
            z.null()
        ]),
        master_branch: z.optional(z.string()),
        merges_url: z.url(),
        milestones_url: z.string(),
        mirror_url: z.union([
            z.url(),
            z.null()
        ]),
        name: z.string(),
        node_id: z.string(),
        notifications_url: z.string(),
        open_issues: z.int(),
        open_issues_count: z.int(),
        organization: z.optional(z.string()),
        owner: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        permissions: z.optional(z.object({
            admin: z.boolean(),
            maintain: z.optional(z.boolean()),
            pull: z.boolean(),
            push: z.boolean(),
            triage: z.optional(z.boolean())
        })),
        private: z.boolean(),
        public: z.optional(z.boolean()),
        pulls_url: z.string(),
        pushed_at: z.union([
            z.int(),
            z.iso.datetime(),
            z.null()
        ]),
        releases_url: z.string(),
        role_name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        size: z.int(),
        ssh_url: z.string(),
        stargazers: z.optional(z.int()),
        stargazers_count: z.int(),
        stargazers_url: z.url(),
        statuses_url: z.string(),
        subscribers_url: z.url(),
        subscription_url: z.url(),
        svn_url: z.url(),
        tags_url: z.url(),
        teams_url: z.url(),
        topics: z.array(z.string()),
        trees_url: z.string(),
        updated_at: z.iso.datetime(),
        url: z.url(),
        visibility: z.enum([
            'public',
            'private',
            'internal'
        ]),
        watchers: z.int(),
        watchers_count: z.int()
    })),
    sender: zSimpleUser,
    team: zWebhooksTeam1
});

/**
 * watch started event
 */
export const zWebhookWatchStarted = z.object({
    action: z.enum([
        'started'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * workflow_dispatch event
 */
export const zWebhookWorkflowDispatch = z.object({
    enterprise: z.optional(zEnterpriseWebhooks),
    inputs: z.union([
        z.record(z.string(), z.unknown()),
        z.null()
    ]),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    ref: z.string(),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser,
    workflow: z.string()
});

/**
 * workflow_job completed event
 */
export const zWebhookWorkflowJobCompleted = z.object({
    action: z.enum([
        'completed'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser,
    workflow_job: z.object({
        check_run_url: z.url(),
        completed_at: z.union([
            z.string(),
            z.null()
        ]),
        conclusion: z.nullable(z.enum([
            'success',
            'failure',
            'skipped',
            'cancelled',
            'action_required',
            'neutral',
            'timed_out'
        ])),
        created_at: z.string(),
        head_sha: z.string(),
        html_url: z.url(),
        id: z.int(),
        labels: z.array(z.string()),
        name: z.string(),
        node_id: z.string(),
        run_attempt: z.int(),
        run_id: z.number(),
        run_url: z.url(),
        runner_group_id: z.union([
            z.int(),
            z.null()
        ]),
        runner_group_name: z.union([
            z.string(),
            z.null()
        ]),
        runner_id: z.union([
            z.int(),
            z.null()
        ]),
        runner_name: z.union([
            z.string(),
            z.null()
        ]),
        started_at: z.string(),
        status: z.enum([
            'queued',
            'in_progress',
            'completed',
            'waiting'
        ]),
        head_branch: z.union([
            z.string(),
            z.null()
        ]),
        workflow_name: z.union([
            z.string(),
            z.null()
        ]),
        steps: z.array(z.object({
            completed_at: z.union([
                z.string(),
                z.null()
            ]),
            conclusion: z.nullable(z.enum([
                'failure',
                'skipped',
                'success',
                'cancelled'
            ])),
            name: z.string(),
            number: z.int(),
            started_at: z.union([
                z.string(),
                z.null()
            ]),
            status: z.enum([
                'in_progress',
                'completed',
                'queued'
            ])
        })),
        url: z.url()
    }).and(z.object({
        check_run_url: z.optional(z.string()),
        completed_at: z.optional(z.string()),
        conclusion: z.enum([
            'success',
            'failure',
            'skipped',
            'cancelled',
            'action_required',
            'neutral',
            'timed_out'
        ]),
        created_at: z.optional(z.string()),
        head_sha: z.optional(z.string()),
        html_url: z.optional(z.string()),
        id: z.optional(z.int()),
        labels: z.optional(z.array(z.union([
            z.string(),
            z.null()
        ]))),
        name: z.optional(z.string()),
        node_id: z.optional(z.string()),
        run_attempt: z.optional(z.int()),
        run_id: z.optional(z.int()),
        run_url: z.optional(z.string()),
        runner_group_id: z.optional(z.union([
            z.number(),
            z.null()
        ])),
        runner_group_name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        runner_id: z.optional(z.union([
            z.number(),
            z.null()
        ])),
        runner_name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        started_at: z.optional(z.string()),
        status: z.optional(z.string()),
        head_branch: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        workflow_name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        steps: z.optional(z.array(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]))),
        url: z.optional(z.string())
    })),
    deployment: z.optional(zDeployment)
});

/**
 * workflow_job in_progress event
 */
export const zWebhookWorkflowJobInProgress = z.object({
    action: z.enum([
        'in_progress'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser,
    workflow_job: z.object({
        check_run_url: z.url(),
        completed_at: z.union([
            z.string(),
            z.null()
        ]),
        conclusion: z.nullable(z.enum([
            'success',
            'failure',
            'cancelled',
            'neutral'
        ])),
        created_at: z.string(),
        head_sha: z.string(),
        html_url: z.url(),
        id: z.int(),
        labels: z.array(z.string()),
        name: z.string(),
        node_id: z.string(),
        run_attempt: z.int(),
        run_id: z.number(),
        run_url: z.url(),
        runner_group_id: z.union([
            z.int(),
            z.null()
        ]),
        runner_group_name: z.union([
            z.string(),
            z.null()
        ]),
        runner_id: z.union([
            z.int(),
            z.null()
        ]),
        runner_name: z.union([
            z.string(),
            z.null()
        ]),
        started_at: z.string(),
        status: z.enum([
            'queued',
            'in_progress',
            'completed'
        ]),
        head_branch: z.union([
            z.string(),
            z.null()
        ]),
        workflow_name: z.union([
            z.string(),
            z.null()
        ]),
        steps: z.array(z.object({
            completed_at: z.union([
                z.string(),
                z.null()
            ]),
            conclusion: z.nullable(z.enum([
                'failure',
                'skipped',
                'success',
                'cancelled'
            ])),
            name: z.string(),
            number: z.int(),
            started_at: z.union([
                z.string(),
                z.null()
            ]),
            status: z.enum([
                'in_progress',
                'completed',
                'queued',
                'pending'
            ])
        })),
        url: z.url()
    }).and(z.object({
        check_run_url: z.optional(z.string()),
        completed_at: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        conclusion: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        created_at: z.optional(z.string()),
        head_sha: z.optional(z.string()),
        html_url: z.optional(z.string()),
        id: z.optional(z.int()),
        labels: z.optional(z.array(z.string())),
        name: z.optional(z.string()),
        node_id: z.optional(z.string()),
        run_attempt: z.optional(z.int()),
        run_id: z.optional(z.int()),
        run_url: z.optional(z.string()),
        runner_group_id: z.optional(z.union([
            z.number(),
            z.null()
        ])),
        runner_group_name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        runner_id: z.optional(z.union([
            z.number(),
            z.null()
        ])),
        runner_name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        started_at: z.optional(z.string()),
        status: z.enum([
            'in_progress',
            'completed',
            'queued'
        ]),
        head_branch: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        workflow_name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        steps: z.array(z.object({
            completed_at: z.union([
                z.string(),
                z.null()
            ]),
            conclusion: z.union([
                z.string(),
                z.null()
            ]),
            name: z.string(),
            number: z.int(),
            started_at: z.union([
                z.string(),
                z.null()
            ]),
            status: z.enum([
                'in_progress',
                'completed',
                'pending',
                'queued'
            ])
        })),
        url: z.optional(z.string())
    })),
    deployment: z.optional(zDeployment)
});

/**
 * workflow_job queued event
 */
export const zWebhookWorkflowJobQueued = z.object({
    action: z.enum([
        'queued'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser,
    workflow_job: z.object({
        check_run_url: z.url(),
        completed_at: z.union([
            z.string(),
            z.null()
        ]),
        conclusion: z.union([
            z.string(),
            z.null()
        ]),
        created_at: z.string(),
        head_sha: z.string(),
        html_url: z.url(),
        id: z.int(),
        labels: z.array(z.string()),
        name: z.string(),
        node_id: z.string(),
        run_attempt: z.int(),
        run_id: z.number(),
        run_url: z.url(),
        runner_group_id: z.union([
            z.int(),
            z.null()
        ]),
        runner_group_name: z.union([
            z.string(),
            z.null()
        ]),
        runner_id: z.union([
            z.int(),
            z.null()
        ]),
        runner_name: z.union([
            z.string(),
            z.null()
        ]),
        started_at: z.iso.datetime(),
        status: z.enum([
            'queued',
            'in_progress',
            'completed',
            'waiting'
        ]),
        head_branch: z.union([
            z.string(),
            z.null()
        ]),
        workflow_name: z.union([
            z.string(),
            z.null()
        ]),
        steps: z.array(z.object({
            completed_at: z.union([
                z.string(),
                z.null()
            ]),
            conclusion: z.nullable(z.enum([
                'failure',
                'skipped',
                'success',
                'cancelled'
            ])),
            name: z.string(),
            number: z.int(),
            started_at: z.union([
                z.string(),
                z.null()
            ]),
            status: z.enum([
                'completed',
                'in_progress',
                'queued',
                'pending'
            ])
        })),
        url: z.url()
    }),
    deployment: z.optional(zDeployment)
});

/**
 * workflow_job waiting event
 */
export const zWebhookWorkflowJobWaiting = z.object({
    action: z.enum([
        'waiting'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser,
    workflow_job: z.object({
        check_run_url: z.url(),
        completed_at: z.union([
            z.string(),
            z.null()
        ]),
        conclusion: z.union([
            z.string(),
            z.null()
        ]),
        created_at: z.string(),
        head_sha: z.string(),
        html_url: z.url(),
        id: z.int(),
        labels: z.array(z.string()),
        name: z.string(),
        node_id: z.string(),
        run_attempt: z.int(),
        run_id: z.number(),
        run_url: z.url(),
        runner_group_id: z.union([
            z.int(),
            z.null()
        ]),
        runner_group_name: z.union([
            z.string(),
            z.null()
        ]),
        runner_id: z.union([
            z.int(),
            z.null()
        ]),
        runner_name: z.union([
            z.string(),
            z.null()
        ]),
        started_at: z.iso.datetime(),
        head_branch: z.union([
            z.string(),
            z.null()
        ]),
        workflow_name: z.union([
            z.string(),
            z.null()
        ]),
        status: z.enum([
            'queued',
            'in_progress',
            'completed',
            'waiting'
        ]),
        steps: z.array(z.object({
            completed_at: z.union([
                z.string(),
                z.null()
            ]),
            conclusion: z.nullable(z.enum([
                'failure',
                'skipped',
                'success',
                'cancelled'
            ])),
            name: z.string(),
            number: z.int(),
            started_at: z.union([
                z.string(),
                z.null()
            ]),
            status: z.enum([
                'completed',
                'in_progress',
                'queued',
                'pending',
                'waiting'
            ])
        })),
        url: z.url()
    }),
    deployment: z.optional(zDeployment)
});

/**
 * workflow_run completed event
 */
export const zWebhookWorkflowRunCompleted = z.object({
    action: z.enum([
        'completed'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser,
    workflow: zWebhooksWorkflow,
    workflow_run: z.object({
        actor: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        artifacts_url: z.url(),
        cancel_url: z.url(),
        check_suite_id: z.int(),
        check_suite_node_id: z.string(),
        check_suite_url: z.url(),
        conclusion: z.enum([
            'action_required',
            'cancelled',
            'failure',
            'neutral',
            'skipped',
            'stale',
            'success',
            'timed_out',
            'startup_failure'
        ]),
        created_at: z.iso.datetime(),
        event: z.string(),
        head_branch: z.union([
            z.string(),
            z.null()
        ]),
        head_commit: z.object({
            author: z.object({
                date: z.optional(z.iso.datetime()),
                email: z.union([
                    z.email(),
                    z.null()
                ]),
                name: z.string(),
                username: z.optional(z.string())
            }),
            committer: z.object({
                date: z.optional(z.iso.datetime()),
                email: z.union([
                    z.email(),
                    z.null()
                ]),
                name: z.string(),
                username: z.optional(z.string())
            }),
            id: z.string(),
            message: z.string(),
            timestamp: z.string(),
            tree_id: z.string()
        }),
        head_repository: z.object({
            archive_url: z.string(),
            assignees_url: z.string(),
            blobs_url: z.string(),
            branches_url: z.string(),
            collaborators_url: z.string(),
            comments_url: z.string(),
            commits_url: z.string(),
            compare_url: z.string(),
            contents_url: z.string(),
            contributors_url: z.url(),
            deployments_url: z.url(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            downloads_url: z.url(),
            events_url: z.url(),
            fork: z.boolean(),
            forks_url: z.url(),
            full_name: z.string(),
            git_commits_url: z.string(),
            git_refs_url: z.string(),
            git_tags_url: z.string(),
            hooks_url: z.url(),
            html_url: z.url(),
            id: z.int(),
            issue_comment_url: z.string(),
            issue_events_url: z.string(),
            issues_url: z.string(),
            keys_url: z.string(),
            labels_url: z.string(),
            languages_url: z.url(),
            merges_url: z.url(),
            milestones_url: z.string(),
            name: z.string(),
            node_id: z.string(),
            notifications_url: z.string(),
            owner: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            private: z.boolean(),
            pulls_url: z.string(),
            releases_url: z.string(),
            stargazers_url: z.url(),
            statuses_url: z.string(),
            subscribers_url: z.url(),
            subscription_url: z.url(),
            tags_url: z.url(),
            teams_url: z.url(),
            trees_url: z.string(),
            url: z.url()
        }),
        head_sha: z.string(),
        html_url: z.url(),
        id: z.int(),
        jobs_url: z.url(),
        logs_url: z.url(),
        name: z.union([
            z.string(),
            z.null()
        ]),
        node_id: z.string(),
        path: z.string(),
        previous_attempt_url: z.union([
            z.url(),
            z.null()
        ]),
        pull_requests: z.array(z.union([
            z.object({
                base: z.object({
                    ref: z.string(),
                    repo: z.object({
                        id: z.int(),
                        name: z.string(),
                        url: z.url()
                    }),
                    sha: z.string()
                }),
                head: z.object({
                    ref: z.string(),
                    repo: z.object({
                        id: z.int(),
                        name: z.string(),
                        url: z.url()
                    }),
                    sha: z.string()
                }),
                id: z.number(),
                number: z.number(),
                url: z.url()
            }),
            z.null()
        ])),
        referenced_workflows: z.optional(z.union([
            z.array(z.object({
                path: z.string(),
                ref: z.optional(z.string()),
                sha: z.string()
            })),
            z.null()
        ])),
        repository: z.object({
            archive_url: z.string(),
            assignees_url: z.string(),
            blobs_url: z.string(),
            branches_url: z.string(),
            collaborators_url: z.string(),
            comments_url: z.string(),
            commits_url: z.string(),
            compare_url: z.string(),
            contents_url: z.string(),
            contributors_url: z.url(),
            deployments_url: z.url(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            downloads_url: z.url(),
            events_url: z.url(),
            fork: z.boolean(),
            forks_url: z.url(),
            full_name: z.string(),
            git_commits_url: z.string(),
            git_refs_url: z.string(),
            git_tags_url: z.string(),
            hooks_url: z.url(),
            html_url: z.url(),
            id: z.int(),
            issue_comment_url: z.string(),
            issue_events_url: z.string(),
            issues_url: z.string(),
            keys_url: z.string(),
            labels_url: z.string(),
            languages_url: z.url(),
            merges_url: z.url(),
            milestones_url: z.string(),
            name: z.string(),
            node_id: z.string(),
            notifications_url: z.string(),
            owner: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            private: z.boolean(),
            pulls_url: z.string(),
            releases_url: z.string(),
            stargazers_url: z.url(),
            statuses_url: z.string(),
            subscribers_url: z.url(),
            subscription_url: z.url(),
            tags_url: z.url(),
            teams_url: z.url(),
            trees_url: z.string(),
            url: z.url()
        }),
        rerun_url: z.url(),
        run_attempt: z.int(),
        run_number: z.int(),
        run_started_at: z.iso.datetime(),
        status: z.enum([
            'requested',
            'in_progress',
            'completed',
            'queued',
            'pending',
            'waiting'
        ]),
        triggering_actor: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        updated_at: z.iso.datetime(),
        url: z.url(),
        workflow_id: z.int(),
        workflow_url: z.url(),
        display_title: z.optional(z.string())
    })
});

/**
 * workflow_run in_progress event
 */
export const zWebhookWorkflowRunInProgress = z.object({
    action: z.enum([
        'in_progress'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser,
    workflow: zWebhooksWorkflow,
    workflow_run: z.object({
        actor: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ]),
        artifacts_url: z.url(),
        cancel_url: z.url(),
        check_suite_id: z.int(),
        check_suite_node_id: z.string(),
        check_suite_url: z.url(),
        conclusion: z.enum([
            'action_required',
            'cancelled',
            'failure',
            'neutral',
            'skipped',
            'stale',
            'success',
            'timed_out'
        ]),
        created_at: z.iso.datetime(),
        event: z.string(),
        head_branch: z.union([
            z.string(),
            z.null()
        ]),
        head_commit: z.object({
            author: z.object({
                date: z.optional(z.iso.datetime()),
                email: z.union([
                    z.email(),
                    z.null()
                ]),
                name: z.string(),
                username: z.optional(z.string())
            }),
            committer: z.object({
                date: z.optional(z.iso.datetime()),
                email: z.union([
                    z.email(),
                    z.null()
                ]),
                name: z.string(),
                username: z.optional(z.string())
            }),
            id: z.string(),
            message: z.string(),
            timestamp: z.string(),
            tree_id: z.string()
        }),
        head_repository: z.object({
            archive_url: z.string(),
            assignees_url: z.string(),
            blobs_url: z.string(),
            branches_url: z.string(),
            collaborators_url: z.string(),
            comments_url: z.string(),
            commits_url: z.string(),
            compare_url: z.string(),
            contents_url: z.string(),
            contributors_url: z.url(),
            deployments_url: z.url(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            downloads_url: z.url(),
            events_url: z.url(),
            fork: z.boolean(),
            forks_url: z.url(),
            full_name: z.string(),
            git_commits_url: z.string(),
            git_refs_url: z.string(),
            git_tags_url: z.string(),
            hooks_url: z.url(),
            html_url: z.url(),
            id: z.int(),
            issue_comment_url: z.string(),
            issue_events_url: z.string(),
            issues_url: z.string(),
            keys_url: z.string(),
            labels_url: z.string(),
            languages_url: z.url(),
            merges_url: z.url(),
            milestones_url: z.string(),
            name: z.union([
                z.string(),
                z.null()
            ]),
            node_id: z.string(),
            notifications_url: z.string(),
            owner: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url())
                }),
                z.null()
            ]),
            private: z.boolean(),
            pulls_url: z.string(),
            releases_url: z.string(),
            stargazers_url: z.url(),
            statuses_url: z.string(),
            subscribers_url: z.url(),
            subscription_url: z.url(),
            tags_url: z.url(),
            teams_url: z.url(),
            trees_url: z.string(),
            url: z.url()
        }),
        head_sha: z.string(),
        html_url: z.url(),
        id: z.int(),
        jobs_url: z.url(),
        logs_url: z.url(),
        name: z.union([
            z.string(),
            z.null()
        ]),
        node_id: z.string(),
        path: z.string(),
        previous_attempt_url: z.union([
            z.url(),
            z.null()
        ]),
        pull_requests: z.array(z.union([
            z.object({
                base: z.object({
                    ref: z.string(),
                    repo: z.object({
                        id: z.int(),
                        name: z.string(),
                        url: z.url()
                    }),
                    sha: z.string()
                }),
                head: z.object({
                    ref: z.string(),
                    repo: z.object({
                        id: z.int(),
                        name: z.string(),
                        url: z.url()
                    }),
                    sha: z.string()
                }),
                id: z.number(),
                number: z.number(),
                url: z.url()
            }),
            z.null()
        ])),
        referenced_workflows: z.optional(z.union([
            z.array(z.object({
                path: z.string(),
                ref: z.optional(z.string()),
                sha: z.string()
            })),
            z.null()
        ])),
        repository: z.object({
            archive_url: z.string(),
            assignees_url: z.string(),
            blobs_url: z.string(),
            branches_url: z.string(),
            collaborators_url: z.string(),
            comments_url: z.string(),
            commits_url: z.string(),
            compare_url: z.string(),
            contents_url: z.string(),
            contributors_url: z.url(),
            deployments_url: z.url(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            downloads_url: z.url(),
            events_url: z.url(),
            fork: z.boolean(),
            forks_url: z.url(),
            full_name: z.string(),
            git_commits_url: z.string(),
            git_refs_url: z.string(),
            git_tags_url: z.string(),
            hooks_url: z.url(),
            html_url: z.url(),
            id: z.int(),
            issue_comment_url: z.string(),
            issue_events_url: z.string(),
            issues_url: z.string(),
            keys_url: z.string(),
            labels_url: z.string(),
            languages_url: z.url(),
            merges_url: z.url(),
            milestones_url: z.string(),
            name: z.string(),
            node_id: z.string(),
            notifications_url: z.string(),
            owner: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url())
                }),
                z.null()
            ]),
            private: z.boolean(),
            pulls_url: z.string(),
            releases_url: z.string(),
            stargazers_url: z.url(),
            statuses_url: z.string(),
            subscribers_url: z.url(),
            subscription_url: z.url(),
            tags_url: z.url(),
            teams_url: z.url(),
            trees_url: z.string(),
            url: z.url()
        }),
        rerun_url: z.url(),
        run_attempt: z.int(),
        run_number: z.int(),
        run_started_at: z.iso.datetime(),
        status: z.enum([
            'requested',
            'in_progress',
            'completed',
            'queued',
            'pending'
        ]),
        triggering_actor: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url())
            }),
            z.null()
        ]),
        updated_at: z.iso.datetime(),
        url: z.url(),
        workflow_id: z.int(),
        workflow_url: z.url()
    })
});

/**
 * workflow_run requested event
 */
export const zWebhookWorkflowRunRequested = z.object({
    action: z.enum([
        'requested'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser,
    workflow: zWebhooksWorkflow,
    workflow_run: z.object({
        actor: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        artifacts_url: z.url(),
        cancel_url: z.url(),
        check_suite_id: z.int(),
        check_suite_node_id: z.string(),
        check_suite_url: z.url(),
        conclusion: z.nullable(z.enum([
            'success',
            'failure',
            'neutral',
            'cancelled',
            'timed_out',
            'action_required',
            'stale',
            'skipped',
            'startup_failure'
        ])),
        created_at: z.iso.datetime(),
        event: z.string(),
        head_branch: z.union([
            z.string(),
            z.null()
        ]),
        head_commit: z.object({
            author: z.object({
                date: z.optional(z.iso.datetime()),
                email: z.union([
                    z.email(),
                    z.null()
                ]),
                name: z.string(),
                username: z.optional(z.string())
            }),
            committer: z.object({
                date: z.optional(z.iso.datetime()),
                email: z.union([
                    z.email(),
                    z.null()
                ]),
                name: z.string(),
                username: z.optional(z.string())
            }),
            id: z.string(),
            message: z.string(),
            timestamp: z.string(),
            tree_id: z.string()
        }),
        head_repository: z.object({
            archive_url: z.string(),
            assignees_url: z.string(),
            blobs_url: z.string(),
            branches_url: z.string(),
            collaborators_url: z.string(),
            comments_url: z.string(),
            commits_url: z.string(),
            compare_url: z.string(),
            contents_url: z.string(),
            contributors_url: z.url(),
            deployments_url: z.url(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            downloads_url: z.url(),
            events_url: z.url(),
            fork: z.boolean(),
            forks_url: z.url(),
            full_name: z.string(),
            git_commits_url: z.string(),
            git_refs_url: z.string(),
            git_tags_url: z.string(),
            hooks_url: z.url(),
            html_url: z.url(),
            id: z.int(),
            issue_comment_url: z.string(),
            issue_events_url: z.string(),
            issues_url: z.string(),
            keys_url: z.string(),
            labels_url: z.string(),
            languages_url: z.url(),
            merges_url: z.url(),
            milestones_url: z.string(),
            name: z.string(),
            node_id: z.string(),
            notifications_url: z.string(),
            owner: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            private: z.boolean(),
            pulls_url: z.string(),
            releases_url: z.string(),
            stargazers_url: z.url(),
            statuses_url: z.string(),
            subscribers_url: z.url(),
            subscription_url: z.url(),
            tags_url: z.url(),
            teams_url: z.url(),
            trees_url: z.string(),
            url: z.url()
        }),
        head_sha: z.string(),
        html_url: z.url(),
        id: z.int(),
        jobs_url: z.url(),
        logs_url: z.url(),
        name: z.union([
            z.string(),
            z.null()
        ]),
        node_id: z.string(),
        path: z.string(),
        previous_attempt_url: z.union([
            z.url(),
            z.null()
        ]),
        pull_requests: z.array(z.object({
            base: z.object({
                ref: z.string(),
                repo: z.object({
                    id: z.int(),
                    name: z.string(),
                    url: z.url()
                }),
                sha: z.string()
            }),
            head: z.object({
                ref: z.string(),
                repo: z.object({
                    id: z.int(),
                    name: z.string(),
                    url: z.url()
                }),
                sha: z.string()
            }),
            id: z.number(),
            number: z.number(),
            url: z.url()
        })),
        referenced_workflows: z.optional(z.union([
            z.array(z.object({
                path: z.string(),
                ref: z.optional(z.string()),
                sha: z.string()
            })),
            z.null()
        ])),
        repository: z.object({
            archive_url: z.string(),
            assignees_url: z.string(),
            blobs_url: z.string(),
            branches_url: z.string(),
            collaborators_url: z.string(),
            comments_url: z.string(),
            commits_url: z.string(),
            compare_url: z.string(),
            contents_url: z.string(),
            contributors_url: z.url(),
            deployments_url: z.url(),
            description: z.union([
                z.string(),
                z.null()
            ]),
            downloads_url: z.url(),
            events_url: z.url(),
            fork: z.boolean(),
            forks_url: z.url(),
            full_name: z.string(),
            git_commits_url: z.string(),
            git_refs_url: z.string(),
            git_tags_url: z.string(),
            hooks_url: z.url(),
            html_url: z.url(),
            id: z.int(),
            issue_comment_url: z.string(),
            issue_events_url: z.string(),
            issues_url: z.string(),
            keys_url: z.string(),
            labels_url: z.string(),
            languages_url: z.url(),
            merges_url: z.url(),
            milestones_url: z.string(),
            name: z.string(),
            node_id: z.string(),
            notifications_url: z.string(),
            owner: z.union([
                z.object({
                    avatar_url: z.optional(z.url()),
                    deleted: z.optional(z.boolean()),
                    email: z.optional(z.union([
                        z.string(),
                        z.null()
                    ])),
                    events_url: z.optional(z.string()),
                    followers_url: z.optional(z.url()),
                    following_url: z.optional(z.string()),
                    gists_url: z.optional(z.string()),
                    gravatar_id: z.optional(z.string()),
                    html_url: z.optional(z.url()),
                    id: z.int(),
                    login: z.string(),
                    name: z.optional(z.string()),
                    node_id: z.optional(z.string()),
                    organizations_url: z.optional(z.url()),
                    received_events_url: z.optional(z.url()),
                    repos_url: z.optional(z.url()),
                    site_admin: z.optional(z.boolean()),
                    starred_url: z.optional(z.string()),
                    subscriptions_url: z.optional(z.url()),
                    type: z.optional(z.enum([
                        'Bot',
                        'User',
                        'Organization'
                    ])),
                    url: z.optional(z.url()),
                    user_view_type: z.optional(z.string())
                }),
                z.null()
            ]),
            private: z.boolean(),
            pulls_url: z.string(),
            releases_url: z.string(),
            stargazers_url: z.url(),
            statuses_url: z.string(),
            subscribers_url: z.url(),
            subscription_url: z.url(),
            tags_url: z.url(),
            teams_url: z.url(),
            trees_url: z.string(),
            url: z.url()
        }),
        rerun_url: z.url(),
        run_attempt: z.int(),
        run_number: z.int(),
        run_started_at: z.iso.datetime(),
        status: z.enum([
            'requested',
            'in_progress',
            'completed',
            'queued',
            'pending',
            'waiting'
        ]),
        triggering_actor: z.union([
            z.object({
                avatar_url: z.optional(z.url()),
                deleted: z.optional(z.boolean()),
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                events_url: z.optional(z.string()),
                followers_url: z.optional(z.url()),
                following_url: z.optional(z.string()),
                gists_url: z.optional(z.string()),
                gravatar_id: z.optional(z.string()),
                html_url: z.optional(z.url()),
                id: z.int(),
                login: z.string(),
                name: z.optional(z.string()),
                node_id: z.optional(z.string()),
                organizations_url: z.optional(z.url()),
                received_events_url: z.optional(z.url()),
                repos_url: z.optional(z.url()),
                site_admin: z.optional(z.boolean()),
                starred_url: z.optional(z.string()),
                subscriptions_url: z.optional(z.url()),
                type: z.optional(z.enum([
                    'Bot',
                    'User',
                    'Organization'
                ])),
                url: z.optional(z.url()),
                user_view_type: z.optional(z.string())
            }),
            z.null()
        ]),
        updated_at: z.iso.datetime(),
        url: z.url(),
        workflow_id: z.int(),
        workflow_url: z.url(),
        display_title: z.string()
    })
});

/**
 * A vulnerability describing the product and its affected versions within a GitHub Security Advisory.
 */
export const zVulnerabilityWritable = z.object({
    package: z.union([
        z.object({
            ecosystem: zSecurityAdvisoryEcosystems,
            name: z.union([
                z.string(),
                z.null()
            ])
        }),
        z.null()
    ]),
    vulnerable_version_range: z.union([
        z.string(),
        z.null()
    ]),
    first_patched_version: z.union([
        z.string(),
        z.null()
    ])
});

export const zCvssSeveritiesWritable = z.union([
    z.object({
        cvss_v3: z.optional(z.union([
            z.object({
                vector_string: z.union([
                    z.string(),
                    z.null()
                ])
            }),
            z.null()
        ])),
        cvss_v4: z.optional(z.union([
            z.object({
                vector_string: z.union([
                    z.string(),
                    z.null()
                ])
            }),
            z.null()
        ]))
    }),
    z.null()
]);

/**
 * A GitHub Security Advisory.
 */
export const zGlobalAdvisoryWritable = z.object({
    summary: z.string().max(1024),
    description: z.union([
        z.string().max(65535),
        z.null()
    ]),
    severity: z.enum([
        'critical',
        'high',
        'medium',
        'low',
        'unknown'
    ]),
    source_code_location: z.union([
        z.url(),
        z.null()
    ]),
    references: z.union([
        z.array(z.string()),
        z.null()
    ]),
    vulnerabilities: z.union([
        z.array(zVulnerabilityWritable),
        z.null()
    ]),
    cvss: z.union([
        z.object({
            vector_string: z.union([
                z.string(),
                z.null()
            ])
        }),
        z.null()
    ]),
    cvss_severities: z.optional(zCvssSeveritiesWritable),
    epss: z.optional(zSecurityAdvisoryEpss),
    cwes: z.union([
        z.array(z.object({
            cwe_id: z.string()
        })),
        z.null()
    ])
});

/**
 * Details pertaining to one vulnerable version range for the advisory.
 */
export const zDependabotAlertSecurityVulnerabilityWritable = z.record(z.string(), z.never()).readonly();

/**
 * Details for the GitHub Security Advisory.
 */
export const zDependabotAlertSecurityAdvisoryWritable = z.object({
    cvss_severities: z.optional(zCvssSeveritiesWritable),
    epss: z.optional(zSecurityAdvisoryEpss)
}).readonly();

/**
 * A Dependabot alert.
 */
export const zDependabotAlertWithRepositoryWritable = z.object({
    security_advisory: zDependabotAlertSecurityAdvisoryWritable,
    security_vulnerability: zDependabotAlertSecurityVulnerabilityWritable,
    dismissed_by: zNullableSimpleUser,
    dismissed_reason: z.enum([
        'fix_started',
        'inaccurate',
        'no_bandwidth',
        'not_used',
        'tolerable_risk'
    ]),
    dismissed_comment: z.union([
        z.string().max(280),
        z.null()
    ]),
    repository: zSimpleRepository
});

/**
 * Empty Object
 *
 * An object without any properties.
 */
export const zEmptyObjectWritable = z.record(z.string(), z.never());

export const zCodeScanningOrganizationAlertItemsWritable = z.object({
    state: zCodeScanningAlertState,
    dismissed_by: zNullableSimpleUser,
    dismissed_reason: zCodeScanningAlertDismissedReason,
    dismissed_comment: z.optional(zCodeScanningAlertDismissedComment),
    rule: zCodeScanningAlertRuleSummary,
    tool: zCodeScanningAnalysisTool,
    most_recent_instance: zCodeScanningAlertInstance,
    repository: zSimpleRepository,
    dismissal_approved_by: z.optional(zNullableSimpleUser),
    assignees: z.optional(z.array(zSimpleUser))
});

export const zOrganizationSecretScanningAlertWritable = z.object({
    locations_url: z.optional(z.url()),
    state: z.optional(zSecretScanningAlertState),
    resolution: z.optional(zSecretScanningAlertResolution),
    resolved_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    resolved_by: z.optional(zNullableSimpleUser),
    secret_type: z.optional(z.string()),
    secret_type_display_name: z.optional(z.string()),
    secret: z.optional(z.string()),
    repository: z.optional(zSimpleRepository),
    push_protection_bypassed: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    push_protection_bypassed_by: z.optional(zNullableSimpleUser),
    push_protection_bypassed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    push_protection_bypass_request_reviewer: z.optional(zNullableSimpleUser),
    push_protection_bypass_request_reviewer_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    push_protection_bypass_request_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    push_protection_bypass_request_html_url: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    resolution_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    validity: z.optional(z.enum([
        'active',
        'inactive',
        'unknown'
    ])),
    publicly_leaked: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    multi_repo: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    is_base64_encoded: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    first_location_detected: z.optional(zNullableSecretScanningFirstDetectedLocation),
    has_more_locations: z.optional(z.boolean()),
    assigned_to: z.optional(zNullableSimpleUser)
});

/**
 * A repository security advisory.
 */
export const zRepositoryAdvisoryWritable = z.object({
    cve_id: z.union([
        z.string(),
        z.null()
    ]),
    summary: z.string().max(1024),
    description: z.union([
        z.string().max(65535),
        z.null()
    ]),
    severity: z.enum([
        'critical',
        'high',
        'medium',
        'low'
    ]),
    state: z.enum([
        'published',
        'closed',
        'withdrawn',
        'draft',
        'triage'
    ]),
    vulnerabilities: z.union([
        z.array(zRepositoryAdvisoryVulnerability),
        z.null()
    ]),
    cvss: z.union([
        z.object({
            vector_string: z.union([
                z.string(),
                z.null()
            ])
        }),
        z.null()
    ]),
    cvss_severities: z.optional(zCvssSeveritiesWritable),
    cwe_ids: z.union([
        z.array(z.string()),
        z.null()
    ]),
    credits: z.union([
        z.array(z.object({
            login: z.optional(z.string()),
            type: z.optional(zSecurityAdvisoryCreditTypes)
        })),
        z.null()
    ]),
    collaborating_users: z.union([
        z.array(zSimpleUser),
        z.null()
    ]),
    collaborating_teams: z.union([
        z.array(zTeam),
        z.null()
    ])
});

export const zCodeScanningAlertItemsWritable = z.object({
    state: zCodeScanningAlertState,
    dismissed_by: zNullableSimpleUser,
    dismissed_reason: zCodeScanningAlertDismissedReason,
    dismissed_comment: z.optional(zCodeScanningAlertDismissedComment),
    rule: zCodeScanningAlertRuleSummary,
    tool: zCodeScanningAnalysisTool,
    most_recent_instance: zCodeScanningAlertInstance,
    dismissal_approved_by: z.optional(zNullableSimpleUser),
    assignees: z.optional(z.array(zSimpleUser))
});

export const zCodeScanningAlertWritable = z.object({
    state: zCodeScanningAlertState,
    dismissed_by: zNullableSimpleUser,
    dismissed_reason: zCodeScanningAlertDismissedReason,
    dismissed_comment: z.optional(zCodeScanningAlertDismissedComment),
    rule: zCodeScanningAlertRule,
    tool: zCodeScanningAnalysisTool,
    most_recent_instance: zCodeScanningAlertInstance,
    dismissal_approved_by: z.optional(zNullableSimpleUser),
    assignees: z.optional(z.array(zSimpleUser))
});

export const zCodeScanningAutofixWritable = z.object({
    status: zCodeScanningAutofixStatus,
    description: zCodeScanningAutofixDescription
});

export const zCodeScanningAnalysisWritable = z.object({
    ref: zCodeScanningRef,
    commit_sha: zCodeScanningAnalysisCommitSha,
    analysis_key: zCodeScanningAnalysisAnalysisKey,
    environment: zCodeScanningAnalysisEnvironment,
    category: z.optional(zCodeScanningAnalysisCategory),
    error: z.string(),
    results_count: z.int(),
    rules_count: z.int(),
    id: z.int(),
    sarif_id: zCodeScanningAnalysisSarifId,
    tool: zCodeScanningAnalysisTool,
    deletable: z.boolean(),
    warning: z.string()
});

export const zCodeScanningSarifsReceiptWritable = z.object({
    id: z.optional(zCodeScanningAnalysisSarifId)
});

export const zCodeScanningSarifsStatusWritable = z.object({
    processing_status: z.optional(z.enum([
        'pending',
        'complete',
        'failed'
    ]))
});

/**
 * A Dependabot alert.
 */
export const zDependabotAlertWritable = z.object({
    security_advisory: zDependabotAlertSecurityAdvisoryWritable,
    security_vulnerability: zDependabotAlertSecurityVulnerabilityWritable,
    dismissed_by: zNullableSimpleUser,
    dismissed_reason: z.enum([
        'fix_started',
        'inaccurate',
        'no_bandwidth',
        'not_used',
        'tolerable_risk'
    ]),
    dismissed_comment: z.union([
        z.string().max(280),
        z.null()
    ])
});

export const zSecretScanningAlertWritable = z.object({
    locations_url: z.optional(z.url()),
    state: z.optional(zSecretScanningAlertState),
    resolution: z.optional(zSecretScanningAlertResolution),
    resolved_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    resolved_by: z.optional(zNullableSimpleUser),
    resolution_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    secret_type: z.optional(z.string()),
    secret_type_display_name: z.optional(z.string()),
    secret: z.optional(z.string()),
    push_protection_bypassed: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    push_protection_bypassed_by: z.optional(zNullableSimpleUser),
    push_protection_bypassed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    push_protection_bypass_request_reviewer: z.optional(zNullableSimpleUser),
    push_protection_bypass_request_reviewer_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    push_protection_bypass_request_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    push_protection_bypass_request_html_url: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    validity: z.optional(z.enum([
        'active',
        'inactive',
        'unknown'
    ])),
    publicly_leaked: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    multi_repo: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    is_base64_encoded: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    first_location_detected: z.optional(zNullableSecretScanningFirstDetectedLocation),
    has_more_locations: z.optional(z.boolean()),
    assigned_to: z.optional(zNullableSimpleUser)
});

export const zSecretScanningAlertWebhookWritable = z.object({
    locations_url: z.optional(z.url()),
    resolution: z.optional(zSecretScanningAlertResolutionWebhook),
    resolved_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    resolved_by: z.optional(zNullableSimpleUser),
    resolution_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    secret_type: z.optional(z.string()),
    secret_type_display_name: z.optional(z.string()),
    validity: z.optional(z.enum([
        'active',
        'inactive',
        'unknown'
    ])),
    push_protection_bypassed: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    push_protection_bypassed_by: z.optional(zNullableSimpleUser),
    push_protection_bypassed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    push_protection_bypass_request_reviewer: z.optional(zNullableSimpleUser),
    push_protection_bypass_request_reviewer_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    push_protection_bypass_request_comment: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    push_protection_bypass_request_html_url: z.optional(z.union([
        z.url(),
        z.null()
    ])),
    publicly_leaked: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    multi_repo: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    assigned_to: z.optional(zNullableSimpleUser)
});

/**
 * The details of the security advisory, including summary, description, and severity.
 */
export const zWebhooksSecurityAdvisoryWritable = z.object({
    cvss: z.object({
        score: z.number(),
        vector_string: z.union([
            z.string(),
            z.null()
        ])
    }),
    cvss_severities: z.optional(zCvssSeveritiesWritable),
    cwes: z.array(z.object({
        cwe_id: z.string(),
        name: z.string()
    })),
    description: z.string(),
    ghsa_id: z.string(),
    identifiers: z.array(z.object({
        type: z.string(),
        value: z.string()
    })),
    published_at: z.string(),
    references: z.array(z.object({
        url: z.url()
    })),
    severity: z.string(),
    summary: z.string(),
    updated_at: z.string(),
    vulnerabilities: z.array(z.object({
        first_patched_version: z.union([
            z.object({
                identifier: z.string()
            }),
            z.null()
        ]),
        package: z.object({
            ecosystem: z.string(),
            name: z.string()
        }),
        severity: z.string(),
        vulnerable_version_range: z.string()
    })),
    withdrawn_at: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Dependabot alert auto-dismissed event
 */
export const zWebhookDependabotAlertAutoDismissedWritable = z.object({
    action: z.enum([
        'auto_dismissed'
    ]),
    alert: zDependabotAlertWritable,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    enterprise: z.optional(zEnterpriseWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Dependabot alert auto-reopened event
 */
export const zWebhookDependabotAlertAutoReopenedWritable = z.object({
    action: z.enum([
        'auto_reopened'
    ]),
    alert: zDependabotAlertWritable,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    enterprise: z.optional(zEnterpriseWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Dependabot alert created event
 */
export const zWebhookDependabotAlertCreatedWritable = z.object({
    action: z.enum([
        'created'
    ]),
    alert: zDependabotAlertWritable,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    enterprise: z.optional(zEnterpriseWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Dependabot alert dismissed event
 */
export const zWebhookDependabotAlertDismissedWritable = z.object({
    action: z.enum([
        'dismissed'
    ]),
    alert: zDependabotAlertWritable,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    enterprise: z.optional(zEnterpriseWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Dependabot alert fixed event
 */
export const zWebhookDependabotAlertFixedWritable = z.object({
    action: z.enum([
        'fixed'
    ]),
    alert: zDependabotAlertWritable,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    enterprise: z.optional(zEnterpriseWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Dependabot alert reintroduced event
 */
export const zWebhookDependabotAlertReintroducedWritable = z.object({
    action: z.enum([
        'reintroduced'
    ]),
    alert: zDependabotAlertWritable,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    enterprise: z.optional(zEnterpriseWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Dependabot alert reopened event
 */
export const zWebhookDependabotAlertReopenedWritable = z.object({
    action: z.enum([
        'reopened'
    ]),
    alert: zDependabotAlertWritable,
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    enterprise: z.optional(zEnterpriseWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * Repository advisory published event
 */
export const zWebhookRepositoryAdvisoryPublishedWritable = z.object({
    action: z.enum([
        'published'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    repository_advisory: zRepositoryAdvisoryWritable,
    sender: z.optional(zSimpleUser)
});

/**
 * Repository advisory reported event
 */
export const zWebhookRepositoryAdvisoryReportedWritable = z.object({
    action: z.enum([
        'reported'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    repository_advisory: zRepositoryAdvisoryWritable,
    sender: z.optional(zSimpleUser)
});

/**
 * secret_scanning_alert created event
 */
export const zWebhookSecretScanningAlertCreatedWritable = z.object({
    action: z.enum([
        'created'
    ]),
    alert: zSecretScanningAlertWebhookWritable,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * Secret Scanning Alert Location Created Event
 */
export const zWebhookSecretScanningAlertLocationCreatedWritable = z.object({
    action: z.optional(z.enum([
        'created'
    ])),
    alert: zSecretScanningAlertWebhookWritable,
    installation: z.optional(zSimpleInstallation),
    location: zSecretScanningLocation,
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: zSimpleUser
});

/**
 * secret_scanning_alert publicly leaked event
 */
export const zWebhookSecretScanningAlertPubliclyLeakedWritable = z.object({
    action: z.enum([
        'publicly_leaked'
    ]),
    alert: zSecretScanningAlertWebhookWritable,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * secret_scanning_alert reopened event
 */
export const zWebhookSecretScanningAlertReopenedWritable = z.object({
    action: z.enum([
        'reopened'
    ]),
    alert: zSecretScanningAlertWebhookWritable,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * secret_scanning_alert resolved event
 */
export const zWebhookSecretScanningAlertResolvedWritable = z.object({
    action: z.enum([
        'resolved'
    ]),
    alert: zSecretScanningAlertWebhookWritable,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * secret_scanning_alert validated event
 */
export const zWebhookSecretScanningAlertValidatedWritable = z.object({
    action: z.enum([
        'validated'
    ]),
    alert: zSecretScanningAlertWebhookWritable,
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: zRepositoryWebhooks,
    sender: z.optional(zSimpleUser)
});

/**
 * security_advisory published event
 */
export const zWebhookSecurityAdvisoryPublishedWritable = z.object({
    action: z.enum([
        'published'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    security_advisory: zWebhooksSecurityAdvisoryWritable,
    sender: z.optional(zSimpleUser)
});

/**
 * security_advisory updated event
 */
export const zWebhookSecurityAdvisoryUpdatedWritable = z.object({
    action: z.enum([
        'updated'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    security_advisory: zWebhooksSecurityAdvisoryWritable,
    sender: z.optional(zSimpleUser)
});

/**
 * security_advisory withdrawn event
 */
export const zWebhookSecurityAdvisoryWithdrawnWritable = z.object({
    action: z.enum([
        'withdrawn'
    ]),
    enterprise: z.optional(zEnterpriseWebhooks),
    installation: z.optional(zSimpleInstallation),
    organization: z.optional(zOrganizationSimpleWebhooks),
    repository: z.optional(zRepositoryWebhooks),
    security_advisory: z.object({
        cvss: z.object({
            score: z.number(),
            vector_string: z.union([
                z.string(),
                z.null()
            ])
        }),
        cvss_severities: z.optional(zCvssSeveritiesWritable),
        cwes: z.array(z.object({
            cwe_id: z.string(),
            name: z.string()
        })),
        description: z.string(),
        ghsa_id: z.string(),
        identifiers: z.array(z.object({
            type: z.string(),
            value: z.string()
        })),
        published_at: z.string(),
        references: z.array(z.object({
            url: z.url()
        })),
        severity: z.string(),
        summary: z.string(),
        updated_at: z.string(),
        vulnerabilities: z.array(z.object({
            first_patched_version: z.union([
                z.object({
                    identifier: z.string()
                }),
                z.null()
            ]),
            package: z.object({
                ecosystem: z.string(),
                name: z.string()
            }),
            severity: z.string(),
            vulnerable_version_range: z.string()
        })),
        withdrawn_at: z.string()
    }),
    sender: z.optional(zSimpleUser)
});

/**
 * A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
 */
export const zPaginationBefore = z.string();

/**
 * A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
 */
export const zPaginationAfter = z.string();

/**
 * The direction to sort the results by.
 */
export const zDirection = z.enum([
    'asc',
    'desc'
]);

/**
 * The GHSA (GitHub Security Advisory) identifier of the advisory.
 */
export const zGhsaId = z.string();

/**
 * The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
 */
export const zPerPage = z.int().default(30);

/**
 * Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.
 */
export const zCursor = z.string();

export const zDeliveryId = z.int();

/**
 * The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
 */
export const zPage2 = z.int().default(1);

/**
 * Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const zSince = z.iso.datetime();

/**
 * The unique identifier of the installation.
 */
export const zInstallationId = z.int();

/**
 * The client ID of the GitHub app.
 */
export const zClientId = z.string();

export const zAppSlug = z.string();

/**
 * The unique identifier of the classroom assignment.
 */
export const zAssignmentId = z.int();

/**
 * The unique identifier of the classroom.
 */
export const zClassroomId = z.int();

/**
 * The slug version of the enterprise name.
 */
export const zEnterprise2 = z.string();

/**
 * The unique identifier of the code security configuration.
 */
export const zConfigurationId = z.int();

/**
 * A comma-separated list of states. If specified, only alerts with these states will be returned.
 *
 * Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
 */
export const zDependabotAlertCommaSeparatedStates = z.string();

/**
 * A comma-separated list of severities. If specified, only alerts with these severities will be returned.
 *
 * Can be: `low`, `medium`, `high`, `critical`
 */
export const zDependabotAlertCommaSeparatedSeverities = z.string();

/**
 * A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.
 *
 * Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
 */
export const zDependabotAlertCommaSeparatedEcosystems = z.string();

/**
 * A comma-separated list of package names. If specified, only alerts for these packages will be returned.
 */
export const zDependabotAlertCommaSeparatedPackages = z.string();

/**
 * CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as:
 * - An exact number (`n`)
 * - Comparators such as `>n`, `<n`, `>=n`, `<=n`
 * - A range like `n..n`, where `n` is a number from 0.0 to 1.0
 *
 * Filters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned.
 */
export const zDependabotAlertCommaSeparatedEpss = z.string();

/**
 * Filters the list of alerts based on whether the alert has the given value. If specified, only alerts meeting this criterion will be returned.
 * Multiple `has` filters can be passed to filter for alerts that have all of the values. Currently, only `patch` is supported.
 */
export const zDependabotAlertCommaSeparatedHas = z.union([
    z.string(),
    z.array(z.enum([
        'patch'
    ]))
]);

/**
 * The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
 */
export const zDependabotAlertScope = z.enum([
    'development',
    'runtime'
]);

/**
 * The property by which to sort the results.
 * `created` means when the alert was created.
 * `updated` means when the alert's state last changed.
 * `epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage.
 */
export const zDependabotAlertSort = z.enum([
    'created',
    'updated',
    'epss_percentage'
]);

/**
 * The slug version of the enterprise team name. You can also substitute this value with the enterprise team id.
 */
export const zEnterpriseTeam2 = z.string();

/**
 * The handle for the GitHub user account.
 */
export const zUsername = z.string();

/**
 * The organization name. The name is not case sensitive.
 */
export const zOrg = z.string();

/**
 * The slug of the team name.
 */
export const zTeamSlug = z.string();

/**
 * The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
 */
export const zPublicEventsPerPage = z.int().default(15);

/**
 * The unique identifier of the gist.
 */
export const zGistId = z.string();

/**
 * The unique identifier of the comment.
 */
export const zCommentId = z.coerce.bigint();

/**
 * A list of comma separated label names. Example: `bug,ui,@high`
 */
export const zLabels = z.string();

/**
 * account_id parameter
 */
export const zAccountId = z.int();

/**
 * The unique identifier of the plan.
 */
export const zPlanId = z.int();

/**
 * The property to sort the results by.
 */
export const zSort = z.enum([
    'created',
    'updated'
]);

/**
 * The account owner of the repository. The name is not case sensitive.
 */
export const zOwner = z.string();

/**
 * The name of the repository without the `.git` extension. The name is not case sensitive.
 */
export const zRepo = z.string();

/**
 * If `true`, show notifications marked as read.
 */
export const zAll = z.boolean().default(false);

/**
 * If `true`, only shows notifications in which the user is directly participating or mentioned.
 */
export const zParticipating = z.boolean().default(false);

/**
 * Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const zBefore = z.iso.datetime();

/**
 * The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).
 */
export const zThreadId = z.int();

/**
 * An organization ID. Only return organizations with an ID greater than this ID.
 */
export const zSinceOrg = z.int();

/**
 * If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year.
 */
export const zBillingUsageReportYear = z.int();

/**
 * If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. Default value is the current month. If no year is specified the default `year` is used.
 */
export const zBillingUsageReportMonthDefault = z.int();

/**
 * If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used.
 */
export const zBillingUsageReportDay = z.int();

/**
 * The user name to query usage for. The name is not case sensitive.
 */
export const zBillingUsageReportUser2 = z.string();

/**
 * The model name to query usage for. The name is not case sensitive.
 */
export const zBillingUsageReportModel = z.string();

/**
 * The product name to query usage for. The name is not case sensitive.
 */
export const zBillingUsageReportProduct = z.string();

/**
 * If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. If no year is specified the default `year` is used.
 */
export const zBillingUsageReportMonth = z.int();

/**
 * If specified, only return results for a single hour. The value of `hour` is an integer between `0` and `23`. If no `year`, `month`, or `day` is specified, the default `year`, `month`, and `day` are used.
 */
export const zBillingUsageReportHour = z.int();

/**
 * Image definition ID of custom image
 */
export const zActionsCustomImageDefinitionId = z.int();

/**
 * Version of a custom image
 */
export const zActionsCustomImageVersion = z.string().regex(/^\d+\.\d+\.\d+$/);

/**
 * Unique identifier of the GitHub-hosted runner.
 */
export const zHostedRunnerId = z.int();

/**
 * The unique identifier of the repository.
 */
export const zRepositoryId = z.int();

/**
 * Only return runner groups that are allowed to be used by this repository.
 */
export const zVisibleToRepository = z.string();

/**
 * Unique identifier of the self-hosted runner group.
 */
export const zRunnerGroupId = z.int();

/**
 * Unique identifier of the self-hosted runner.
 */
export const zRunnerId = z.int();

/**
 * The name of a self-hosted runner's custom label.
 */
export const zRunnerLabelName = z.string();

/**
 * The name of the secret.
 */
export const zSecretName = z.string();

/**
 * The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
 */
export const zVariablesPerPage = z.int().default(10);

/**
 * The name of the variable.
 */
export const zVariableName = z.string();

/**
 * The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.
 */
export const zToolName = zCodeScanningAnalysisToolName;

/**
 * The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.
 */
export const zToolGuid = zCodeScanningAnalysisToolGuid;

/**
 * A comma-separated list of artifact registry URLs. If specified, only alerts for repositories with storage records matching these URLs will be returned.
 */
export const zDependabotAlertCommaSeparatedArtifactRegistryUrls = z.string();

/**
 * A comma-separated list of Artifact Registry name strings. If specified, only alerts for repositories with storage records matching these registries will be returned.
 *
 * Can be: `jfrog-artifactory`
 */
export const zDependabotAlertCommaSeparatedArtifactRegistry = z.string();

/**
 * Filters the list of alerts based on whether the alert has the given value. If specified, only alerts meeting this criterion will be returned.
 * Multiple `has` filters can be passed to filter for alerts that have all of the values.
 */
export const zDependabotAlertOrgScopeCommaSeparatedHas = z.union([
    z.string(),
    z.array(z.enum([
        'patch',
        'deployment'
    ]))
]);

/**
 * A comma-separated list of runtime risk strings. If specified, only alerts for repositories with deployment records matching these risks will be returned.
 *
 * Can be: `critical-resource`, `internet-exposed`, `sensitive-data`, `lateral-movement`
 */
export const zDependabotAlertCommaSeparatedRuntimeRisk = z.string();

/**
 * The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
 */
export const zHookId = z.int();

/**
 * The type of the actor
 */
export const zApiInsightsActorType = z.enum([
    'installation',
    'classic_pat',
    'fine_grained_pat',
    'oauth_app',
    'github_app_user_to_server'
]);

/**
 * The ID of the actor
 */
export const zApiInsightsActorId = z.int();

/**
 * The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const zApiInsightsMinTimestamp = z.string();

/**
 * The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const zApiInsightsMaxTimestamp = z.string();

/**
 * The property to sort the results by.
 */
export const zApiInsightsRouteStatsSort = z.array(z.enum([
    'last_rate_limited_timestamp',
    'last_request_timestamp',
    'rate_limited_request_count',
    'http_method',
    'api_route',
    'total_request_count'
]));

/**
 * Providing a substring will filter results where the API route contains the substring. This is a case-insensitive search.
 */
export const zApiInsightsApiRouteSubstring = z.string();

/**
 * The property to sort the results by.
 */
export const zApiInsightsSort = z.array(z.enum([
    'last_rate_limited_timestamp',
    'last_request_timestamp',
    'rate_limited_request_count',
    'subject_name',
    'total_request_count'
]));

/**
 * Providing a substring will filter results where the subject name contains the substring. This is a case-insensitive search.
 */
export const zApiInsightsSubjectNameSubstring = z.string();

/**
 * The ID of the user to query for stats
 */
export const zApiInsightsUserId = z.string();

/**
 * The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)
 */
export const zApiInsightsTimestampIncrement = z.string();

/**
 * Providing a substring will filter results where the actor name contains the substring. This is a case-insensitive search.
 */
export const zApiInsightsActorNameSubstring = z.string();

/**
 * The unique identifier of the invitation.
 */
export const zInvitationId = z.int();

/**
 * The unique identifier of the issue type.
 */
export const zIssueTypeId = z.int();

/**
 * The name of the codespace.
 */
export const zCodespaceName = z.string();

/**
 * The unique identifier of the migration.
 */
export const zMigrationId = z.int();

/**
 * repo_name parameter
 */
export const zRepoName = z.string();

/**
 * The unique identifier of the role.
 */
export const zRoleId = z.int();

/**
 * The selected visibility of the packages.  This parameter is optional and only filters an existing result set.
 *
 * The `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.
 * For the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."
 */
export const zPackageVisibility = z.enum([
    'public',
    'private',
    'internal'
]);

/**
 * The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 */
export const zPackageType = z.enum([
    'npm',
    'maven',
    'rubygems',
    'docker',
    'nuget',
    'container'
]);

/**
 * The name of the package.
 */
export const zPackageName = z.string();

/**
 * Unique identifier of the package version.
 */
export const zPackageVersionId = z.int();

/**
 * The property by which to sort the results.
 */
export const zPersonalAccessTokenSort = z.enum([
    'created_at'
]);

/**
 * A list of owner usernames to use to filter the results.
 */
export const zPersonalAccessTokenOwner = z.array(z.string()).max(10);

/**
 * The name of the repository to use to filter the results.
 */
export const zPersonalAccessTokenRepository = z.string();

/**
 * The permission to use to filter the results.
 */
export const zPersonalAccessTokenPermission = z.string();

/**
 * Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const zPersonalAccessTokenBefore = z.iso.datetime();

/**
 * Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const zPersonalAccessTokenAfter = z.iso.datetime();

/**
 * The ID of the token
 */
export const zPersonalAccessTokenTokenId = z.array(z.string()).max(50);

/**
 * The unique identifier of the fine-grained personal access token.
 */
export const zFineGrainedPersonalAccessTokenId = z.int();

/**
 * The project's number.
 */
export const zProjectNumber = z.int();

/**
 * The unique identifier of the field.
 */
export const zFieldId = z.int();

/**
 * The unique identifier of the project item.
 */
export const zItemId = z.int();

/**
 * The custom property name
 */
export const zCustomPropertyName = z.string();

/**
 * A comma-separated list of rule targets to filter by.
 * If provided, only rulesets that apply to the specified targets will be returned.
 * For example, `branch,tag,push`.
 *
 */
export const zRulesetTargets = z.string();

/**
 * The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.
 */
export const zRefInQuery = z.string();

/**
 * The name of the repository to filter on.
 */
export const zRepositoryNameInQuery = z.string();

/**
 * The time period to filter by.
 *
 * For example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for rule suites that occurred in the past 7 days (168 hours).
 */
export const zTimePeriod = z.enum([
    'hour',
    'day',
    'week',
    'month'
]);

/**
 * The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.
 */
export const zActorNameInQuery = z.string();

/**
 * The rule suite results to filter on. When specified, only suites with this result will be returned.
 */
export const zRuleSuiteResult = z.enum([
    'pass',
    'fail',
    'bypass',
    'all'
]);

/**
 * The unique identifier of the rule suite result.
 * To get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)
 * for repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites)
 * for organizations.
 */
export const zRuleSuiteId = z.int();

/**
 * Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
 */
export const zSecretScanningAlertState2 = z.enum([
    'open',
    'resolved'
]);

/**
 * A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter. See "[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)" for a complete list of secret types.
 */
export const zSecretScanningAlertSecretType = z.string();

/**
 * A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.
 */
export const zSecretScanningAlertResolution2 = z.string();

/**
 * The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.
 */
export const zSecretScanningAlertSort = z.enum([
    'created',
    'updated'
]);

/**
 * A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty "before" query string.
 */
export const zSecretScanningPaginationBeforeOrgRepo = z.string();

/**
 * A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty "after" query string.
 */
export const zSecretScanningPaginationAfterOrgRepo = z.string();

/**
 * A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.
 */
export const zSecretScanningAlertValidity = z.string();

/**
 * A boolean value representing whether or not to filter alerts by the publicly-leaked tag being present.
 */
export const zSecretScanningAlertPubliclyLeaked = z.boolean().default(false);

/**
 * A boolean value representing whether or not to filter alerts by the multi-repo tag being present.
 */
export const zSecretScanningAlertMultiRepo = z.boolean().default(false);

/**
 * A boolean value representing whether or not to hide literal secrets in the results.
 */
export const zSecretScanningAlertHideSecret = z.boolean().default(false);

/**
 * Unique identifier of the hosted compute network configuration.
 */
export const zNetworkConfigurationId = z.string();

/**
 * Unique identifier of the hosted compute network settings.
 */
export const zNetworkSettingsId = z.string();

/**
 * The number that identifies the discussion.
 */
export const zDiscussionNumber = z.int();

/**
 * The number that identifies the comment.
 */
export const zCommentNumber = z.int();

/**
 * The unique identifier of the reaction.
 */
export const zReactionId = z.int();

/**
 * The unique identifier of the project.
 */
export const zProjectId = z.int();

/**
 * The security feature to enable or disable.
 */
export const zSecurityProduct = z.enum([
    'dependency_graph',
    'dependabot_alerts',
    'dependabot_security_updates',
    'advanced_security',
    'code_scanning_default_setup',
    'secret_scanning',
    'secret_scanning_push_protection'
]);

/**
 * The action to take.
 *
 * `enable_all` means to enable the specified security feature for all repositories in the organization.
 * `disable_all` means to disable the specified security feature for all repositories in the organization.
 */
export const zOrgSecurityProductEnablement = z.enum([
    'enable_all',
    'disable_all'
]);

/**
 * The unique identifier of the column.
 */
export const zColumnId = z.int();

/**
 * The name field of an artifact. When specified, only artifacts with this name will be returned.
 */
export const zArtifactName = z.string();

/**
 * The unique identifier of the artifact.
 */
export const zArtifactId = z.int();

/**
 * The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
 */
export const zActionsCacheGitRefFull = z.string();

/**
 * An explicit key or prefix for identifying the cache
 */
export const zActionsCacheKey = z.string();

/**
 * The property to sort the results by. `created_at` means when the cache was created. `last_accessed_at` means when the cache was last accessed. `size_in_bytes` is the size of the cache in bytes.
 */
export const zActionsCacheListSort = z.enum([
    'created_at',
    'last_accessed_at',
    'size_in_bytes'
]);

/**
 * A key for identifying the cache.
 */
export const zActionsCacheKeyRequired = z.string();

/**
 * The unique identifier of the GitHub Actions cache.
 */
export const zCacheId = z.int();

/**
 * The unique identifier of the job.
 */
export const zJobId = z.int();

/**
 * Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run.
 */
export const zActor2 = z.string();

/**
 * Returns workflow runs associated with a branch. Use the name of the branch of the `push`.
 */
export const zWorkflowRunBranch = z.string();

/**
 * Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
 */
export const zEvent2 = z.string();

/**
 * Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.
 */
export const zWorkflowRunStatus = z.enum([
    'completed',
    'action_required',
    'cancelled',
    'failure',
    'neutral',
    'skipped',
    'stale',
    'success',
    'timed_out',
    'in_progress',
    'queued',
    'requested',
    'waiting',
    'pending'
]);

/**
 * Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
 */
export const zCreated = z.iso.datetime();

/**
 * If `true` pull requests are omitted from the response (empty array).
 */
export const zExcludePullRequests = z.boolean().default(false);

/**
 * Returns workflow runs with the `check_suite_id` that you specify.
 */
export const zWorkflowRunCheckSuiteId = z.int();

/**
 * Only returns workflow runs that are associated with the specified `head_sha`.
 */
export const zWorkflowRunHeadSha = z.string();

/**
 * The unique identifier of the workflow run.
 */
export const zRunId = z.int();

/**
 * The attempt number of the workflow run.
 */
export const zAttemptNumber = z.int();

/**
 * The ID of the workflow. You can also pass the workflow file name as a string.
 */
export const zWorkflowId = z.union([
    z.int(),
    z.string()
]);

/**
 * The unique identifier of the autolink.
 */
export const zAutolinkId = z.int();

/**
 * The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
 */
export const zBranch = z.string();

/**
 * The unique identifier of the check run.
 */
export const zCheckRunId = z.int();

/**
 * The unique identifier of the check suite.
 */
export const zCheckSuiteId = z.int();

/**
 * Returns check runs with the specified `name`.
 */
export const zCheckName = z.string();

/**
 * Returns check runs with the specified `status`.
 */
export const zStatus2 = z.enum([
    'queued',
    'in_progress',
    'completed'
]);

/**
 * The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
 */
export const zGitRef2 = zCodeScanningRef;

/**
 * The number of the pull request for the results you want to list.
 */
export const zPrAlias = z.int();

/**
 * The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.
 */
export const zAlertNumber2 = zAlertNumber;

/**
 * The SHA of the commit.
 */
export const zCommitSha = z.string();

/**
 * The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
 */
export const zCommitRef = z.string();

/**
 * A comma-separated list of full manifest paths. If specified, only alerts for these manifests will be returned.
 */
export const zDependabotAlertCommaSeparatedManifests = z.string();

/**
 * The number that identifies a Dependabot alert in its repository.
 * You can find this at the end of the URL for a Dependabot alert within GitHub,
 * or in `number` fields in the response from the
 * `GET /repos/{owner}/{repo}/dependabot/alerts` operation.
 */
export const zDependabotAlertNumber = zAlertNumber;

/**
 * The full path, relative to the repository root, of the dependency manifest file.
 */
export const zManifestPath = z.string();

/**
 * deployment_id parameter
 */
export const zDeploymentId = z.int();

/**
 * The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
 */
export const zEnvironmentName = z.string();

/**
 * The unique identifier of the branch policy.
 */
export const zBranchPolicyId = z.int();

/**
 * The unique identifier of the protection rule.
 */
export const zProtectionRuleId = z.int();

/**
 * The Git reference. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
 */
export const zGitRefOnly = z.string();

/**
 * A user ID. Only return users with an ID greater than this ID.
 */
export const zSinceUser = z.int();

/**
 * The number that identifies the issue.
 */
export const zIssueNumber = z.int();

/**
 * The unique identifier of the key.
 */
export const zKeyId = z.int();

/**
 * The number that identifies the milestone.
 */
export const zMilestoneNumber = z.int();

/**
 * The ID of the Pages deployment. You can also give the commit SHA of the deployment.
 */
export const zPagesDeploymentId = z.union([
    z.int(),
    z.string()
]);

/**
 * The number that identifies the pull request.
 */
export const zPullNumber = z.int();

/**
 * The unique identifier of the review.
 */
export const zReviewId = z.int();

/**
 * The unique identifier of the asset.
 */
export const zAssetId = z.int();

/**
 * The unique identifier of the release.
 */
export const zReleaseId = z.int();

/**
 * The unique identifier of the tag protection.
 */
export const zTagProtectionId = z.int();

/**
 * The time frame to display results for.
 */
export const zPer = z.enum([
    'day',
    'week'
]);

/**
 * A repository ID. Only return repositories with an ID greater than this ID.
 */
export const zSinceRepo = z.int();

/**
 * Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
 */
export const zOrder = z.enum([
    'desc',
    'asc'
]);

/**
 * Set to `true` to use advanced search.
 * Example: `http://api.github.com/search/issues?q={query}&advanced_search=true`
 */
export const zIssuesAdvancedSearch = z.string();

/**
 * The unique identifier of the team.
 */
export const zTeamId = z.int();

/**
 * ID of the Repository to filter on
 */
export const zRepositoryIdInQuery = z.int();

/**
 * The ID of the export operation, or `latest`. Currently only `latest` is currently supported.
 */
export const zExportId = z.string();

/**
 * The unique identifier of the GPG key.
 */
export const zGpgKeyId = z.int();

/**
 * Only show repositories updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const zSinceRepoDate = z.iso.datetime();

/**
 * Only show repositories updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const zBeforeRepoDate = z.iso.datetime();

/**
 * The unique identifier of the SSH signing key.
 */
export const zSshSigningKeyId = z.int();

/**
 * The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.
 */
export const zSortStarred = z.enum([
    'created',
    'updated'
]);

export const zMetaRootData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMetaRootResponse = zRoot;

export const zSecurityAdvisoriesListGlobalAdvisoriesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        ghsa_id: z.optional(z.string()),
        type: z.optional(z.enum([
            'reviewed',
            'malware',
            'unreviewed'
        ])),
        cve_id: z.optional(z.string()),
        ecosystem: z.optional(zSecurityAdvisoryEcosystems),
        severity: z.optional(z.enum([
            'unknown',
            'low',
            'medium',
            'high',
            'critical'
        ])),
        cwes: z.optional(z.union([
            z.string(),
            z.array(z.string())
        ])),
        is_withdrawn: z.optional(z.boolean()),
        affects: z.optional(z.union([
            z.string(),
            z.array(z.string()).max(1000)
        ])),
        published: z.optional(z.string()),
        updated: z.optional(z.string()),
        modified: z.optional(z.string()),
        epss_percentage: z.optional(z.string()),
        epss_percentile: z.optional(z.string()),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        per_page: z.optional(z.int().gte(1).lte(100)).default(30),
        sort: z.optional(z.enum([
            'updated',
            'published',
            'epss_percentage',
            'epss_percentile'
        ]))
    }))
});

/**
 * Response
 */
export const zSecurityAdvisoriesListGlobalAdvisoriesResponse = z.array(zGlobalAdvisory);

export const zSecurityAdvisoriesGetGlobalAdvisoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        ghsa_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zSecurityAdvisoriesGetGlobalAdvisoryResponse = zGlobalAdvisory;

export const zAppsGetAuthenticatedData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsGetAuthenticatedResponse = zIntegration;

export const zAppsCreateFromManifestData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        code: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsCreateFromManifestResponse = zIntegration.and(z.object({
    client_id: z.string(),
    client_secret: z.string(),
    webhook_secret: z.union([
        z.string(),
        z.null()
    ]),
    pem: z.string()
}));

export const zAppsGetWebhookConfigForAppData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsGetWebhookConfigForAppResponse = zWebhookConfig;

export const zAppsUpdateWebhookConfigForAppData = z.object({
    body: z.object({
        url: z.optional(zWebhookConfigUrl),
        content_type: z.optional(zWebhookConfigContentType),
        secret: z.optional(zWebhookConfigSecret),
        insecure_ssl: z.optional(zWebhookConfigInsecureSsl)
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsUpdateWebhookConfigForAppResponse = zWebhookConfig;

export const zAppsListWebhookDeliveriesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        cursor: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zAppsListWebhookDeliveriesResponse = z.array(zHookDeliveryItem);

export const zAppsGetWebhookDeliveryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        delivery_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsGetWebhookDeliveryResponse = zHookDelivery;

export const zAppsRedeliverWebhookDeliveryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        delivery_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Accepted
 */
export const zAppsRedeliverWebhookDeliveryResponse = z.record(z.string(), z.unknown());

export const zAppsListInstallationRequestsForAuthenticatedAppData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * List of integration installation requests
 */
export const zAppsListInstallationRequestsForAuthenticatedAppResponse = z.array(zIntegrationInstallationRequest);

export const zAppsListInstallationsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        since: z.optional(z.iso.datetime()),
        outdated: z.optional(z.string())
    }))
});

/**
 * The permissions the installation has are included under the `permissions` key.
 */
export const zAppsListInstallationsResponse = z.array(zInstallation);

export const zAppsDeleteInstallationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        installation_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsDeleteInstallationResponse = z.void();

export const zAppsGetInstallationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        installation_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsGetInstallationResponse = zInstallation;

export const zAppsCreateInstallationAccessTokenData = z.object({
    body: z.optional(z.object({
        repositories: z.optional(z.array(z.string())),
        repository_ids: z.optional(z.array(z.int())),
        permissions: z.optional(zAppPermissions)
    })),
    path: z.object({
        installation_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsCreateInstallationAccessTokenResponse = zInstallationToken;

export const zAppsUnsuspendInstallationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        installation_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsUnsuspendInstallationResponse = z.void();

export const zAppsSuspendInstallationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        installation_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsSuspendInstallationResponse = z.void();

export const zAppsDeleteAuthorizationData = z.object({
    body: z.object({
        access_token: z.string()
    }),
    path: z.object({
        client_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsDeleteAuthorizationResponse = z.void();

export const zAppsDeleteTokenData = z.object({
    body: z.object({
        access_token: z.string()
    }),
    path: z.object({
        client_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsDeleteTokenResponse = z.void();

export const zAppsResetTokenData = z.object({
    body: z.object({
        access_token: z.string()
    }),
    path: z.object({
        client_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsResetTokenResponse = zAuthorization;

export const zAppsCheckTokenData = z.object({
    body: z.object({
        access_token: z.string()
    }),
    path: z.object({
        client_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsCheckTokenResponse = zAuthorization;

export const zAppsScopeTokenData = z.object({
    body: z.object({
        access_token: z.string(),
        target: z.optional(z.string()),
        target_id: z.optional(z.int()),
        repositories: z.optional(z.array(z.string())),
        repository_ids: z.optional(z.array(z.int())),
        permissions: z.optional(zAppPermissions)
    }),
    path: z.object({
        client_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsScopeTokenResponse = zAuthorization;

export const zAppsGetBySlugData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        app_slug: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsGetBySlugResponse = zIntegration;

export const zClassroomGetAnAssignmentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        assignment_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zClassroomGetAnAssignmentResponse = zClassroomAssignment;

export const zClassroomListAcceptedAssignmentsForAnAssignmentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        assignment_id: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zClassroomListAcceptedAssignmentsForAnAssignmentResponse = z.array(zClassroomAcceptedAssignment);

export const zClassroomGetAssignmentGradesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        assignment_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zClassroomGetAssignmentGradesResponse = z.array(zClassroomAssignmentGrade);

export const zClassroomListClassroomsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zClassroomListClassroomsResponse = z.array(zSimpleClassroom);

export const zClassroomGetAClassroomData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        classroom_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zClassroomGetAClassroomResponse = zClassroom;

export const zClassroomListAssignmentsForAClassroomData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        classroom_id: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zClassroomListAssignmentsForAClassroomResponse = z.array(zSimpleClassroomAssignment);

export const zCodesOfConductGetAllCodesOfConductData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodesOfConductGetAllCodesOfConductResponse = z.array(zCodeOfConduct);

export const zCodesOfConductGetConductCodeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        key: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodesOfConductGetConductCodeResponse = zCodeOfConduct;

export const zCredentialsRevokeData = z.object({
    body: z.object({
        credentials: z.array(z.string()).min(1).max(1000)
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Accepted
 */
export const zCredentialsRevokeResponse = z.record(z.string(), z.unknown());

export const zEmojisGetData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zEmojisGetResponse = z.record(z.string(), z.string());

export const zCodeSecurityGetConfigurationsForEnterpriseData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        before: z.optional(z.string()),
        after: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zCodeSecurityGetConfigurationsForEnterpriseResponse = z.array(zCodeSecurityConfiguration);

export const zCodeSecurityCreateConfigurationForEnterpriseData = z.object({
    body: z.object({
        name: z.string(),
        description: z.string().max(255),
        advanced_security: z.optional(z.enum([
            'enabled',
            'disabled',
            'code_security',
            'secret_protection'
        ])),
        code_security: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        dependency_graph: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        dependency_graph_autosubmit_action: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        dependency_graph_autosubmit_action_options: z.optional(z.object({
            labeled_runners: z.optional(z.boolean()).default(false)
        })),
        dependabot_alerts: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        dependabot_security_updates: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        code_scanning_options: z.optional(zCodeScanningOptions),
        code_scanning_default_setup: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        code_scanning_default_setup_options: z.optional(zCodeScanningDefaultSetupOptions),
        code_scanning_delegated_alert_dismissal: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_protection: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_push_protection: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_validity_checks: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_non_provider_patterns: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_generic_secrets: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_delegated_alert_dismissal: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        private_vulnerability_reporting: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        enforcement: z.optional(z.enum([
            'enforced',
            'unenforced'
        ]))
    }),
    path: z.object({
        enterprise: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Successfully created code security configuration
 */
export const zCodeSecurityCreateConfigurationForEnterpriseResponse = zCodeSecurityConfiguration;

export const zCodeSecurityGetDefaultConfigurationsForEnterpriseData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeSecurityGetDefaultConfigurationsForEnterpriseResponse = zCodeSecurityDefaultConfigurations;

export const zCodeSecurityDeleteConfigurationForEnterpriseData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string(),
        configuration_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A header with no content is returned.
 */
export const zCodeSecurityDeleteConfigurationForEnterpriseResponse = z.void();

export const zCodeSecurityGetSingleConfigurationForEnterpriseData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string(),
        configuration_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeSecurityGetSingleConfigurationForEnterpriseResponse = zCodeSecurityConfiguration;

export const zCodeSecurityUpdateEnterpriseConfigurationData = z.object({
    body: z.object({
        name: z.optional(z.string()),
        description: z.optional(z.string().max(255)),
        advanced_security: z.optional(z.enum([
            'enabled',
            'disabled',
            'code_security',
            'secret_protection'
        ])),
        code_security: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        dependency_graph: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        dependency_graph_autosubmit_action: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        dependency_graph_autosubmit_action_options: z.optional(z.object({
            labeled_runners: z.optional(z.boolean())
        })),
        dependabot_alerts: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        dependabot_security_updates: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        code_scanning_default_setup: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        code_scanning_default_setup_options: z.optional(zCodeScanningDefaultSetupOptions),
        code_scanning_delegated_alert_dismissal: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_protection: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_push_protection: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_validity_checks: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_non_provider_patterns: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_generic_secrets: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_delegated_alert_dismissal: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        private_vulnerability_reporting: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        enforcement: z.optional(z.enum([
            'enforced',
            'unenforced'
        ]))
    }),
    path: z.object({
        enterprise: z.string(),
        configuration_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeSecurityUpdateEnterpriseConfigurationResponse = zCodeSecurityConfiguration;

export const zCodeSecurityAttachEnterpriseConfigurationData = z.object({
    body: z.object({
        scope: z.enum([
            'all',
            'all_without_configurations'
        ])
    }),
    path: z.object({
        enterprise: z.string(),
        configuration_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Accepted
 */
export const zCodeSecurityAttachEnterpriseConfigurationResponse = z.record(z.string(), z.unknown());

export const zCodeSecuritySetConfigurationAsDefaultForEnterpriseData = z.object({
    body: z.object({
        default_for_new_repos: z.optional(z.enum([
            'all',
            'none',
            'private_and_internal',
            'public'
        ]))
    }),
    path: z.object({
        enterprise: z.string(),
        configuration_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Default successfully changed.
 */
export const zCodeSecuritySetConfigurationAsDefaultForEnterpriseResponse = z.object({
    default_for_new_repos: z.optional(z.enum([
        'all',
        'none',
        'private_and_internal',
        'public'
    ])),
    configuration: z.optional(zCodeSecurityConfiguration)
});

export const zCodeSecurityGetRepositoriesForEnterpriseConfigurationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string(),
        configuration_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        status: z.optional(z.string()).default('all')
    }))
});

/**
 * Response
 */
export const zCodeSecurityGetRepositoriesForEnterpriseConfigurationResponse = z.array(zCodeSecurityConfigurationRepositories);

export const zDependabotListAlertsForEnterpriseData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string()
    }),
    query: z.optional(z.object({
        state: z.optional(z.string()),
        severity: z.optional(z.string()),
        ecosystem: z.optional(z.string()),
        package: z.optional(z.string()),
        epss_percentage: z.optional(z.string()),
        has: z.optional(z.union([
            z.string(),
            z.array(z.enum([
                'patch'
            ]))
        ])),
        scope: z.optional(z.enum([
            'development',
            'runtime'
        ])),
        sort: z.optional(z.enum([
            'created',
            'updated',
            'epss_percentage'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zDependabotListAlertsForEnterpriseResponse = z.array(zDependabotAlertWithRepository);

export const zEnterpriseTeamsListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zEnterpriseTeamsListResponse = z.array(zEnterpriseTeam);

export const zEnterpriseTeamsCreateData = z.object({
    body: z.object({
        name: z.string(),
        description: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        sync_to_organizations: z.optional(z.enum([
            'all',
            'disabled'
        ])),
        organization_selection_type: z.optional(z.enum([
            'disabled',
            'selected',
            'all'
        ])),
        group_id: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    }),
    path: z.object({
        enterprise: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zEnterpriseTeamsCreateResponse = zEnterpriseTeam;

export const zEnterpriseTeamMembershipsListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string(),
        'enterprise-team': z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zEnterpriseTeamMembershipsListResponse = z.array(zSimpleUser);

export const zEnterpriseTeamMembershipsBulkAddData = z.object({
    body: z.object({
        usernames: z.array(z.string())
    }),
    path: z.object({
        enterprise: z.string(),
        'enterprise-team': z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Successfully added team members.
 */
export const zEnterpriseTeamMembershipsBulkAddResponse = z.array(zSimpleUser);

export const zEnterpriseTeamMembershipsBulkRemoveData = z.object({
    body: z.object({
        usernames: z.array(z.string())
    }),
    path: z.object({
        enterprise: z.string(),
        'enterprise-team': z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Successfully removed team members.
 */
export const zEnterpriseTeamMembershipsBulkRemoveResponse = z.array(zSimpleUser);

export const zEnterpriseTeamMembershipsRemoveData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string(),
        'enterprise-team': z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zEnterpriseTeamMembershipsRemoveResponse = z.void();

export const zEnterpriseTeamMembershipsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string(),
        'enterprise-team': z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * User is a member of the enterprise team.
 */
export const zEnterpriseTeamMembershipsGetResponse = zSimpleUser;

export const zEnterpriseTeamMembershipsAddData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string(),
        'enterprise-team': z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Successfully added team member
 */
export const zEnterpriseTeamMembershipsAddResponse = zSimpleUser;

export const zEnterpriseTeamOrganizationsGetAssignmentsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string(),
        'enterprise-team': z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * An array of organizations the team is assigned to
 */
export const zEnterpriseTeamOrganizationsGetAssignmentsResponse = z.array(zOrganizationSimple);

export const zEnterpriseTeamOrganizationsBulkAddData = z.object({
    body: z.object({
        organization_slugs: z.array(z.string())
    }),
    path: z.object({
        enterprise: z.string(),
        'enterprise-team': z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Successfully assigned the enterprise team to organizations.
 */
export const zEnterpriseTeamOrganizationsBulkAddResponse = z.array(zOrganizationSimple);

export const zEnterpriseTeamOrganizationsBulkRemoveData = z.object({
    body: z.object({
        organization_slugs: z.array(z.string())
    }),
    path: z.object({
        enterprise: z.string(),
        'enterprise-team': z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Successfully unassigned the enterprise team from organizations.
 */
export const zEnterpriseTeamOrganizationsBulkRemoveResponse = z.void();

export const zEnterpriseTeamOrganizationsDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string(),
        'enterprise-team': z.string(),
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Successfully unassigned the enterprise team from the organization.
 */
export const zEnterpriseTeamOrganizationsDeleteResponse = z.void();

export const zEnterpriseTeamOrganizationsGetAssignmentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string(),
        'enterprise-team': z.string(),
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The team is assigned to the organization
 */
export const zEnterpriseTeamOrganizationsGetAssignmentResponse = zOrganizationSimple;

export const zEnterpriseTeamOrganizationsAddData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string(),
        'enterprise-team': z.string(),
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Successfully assigned the enterprise team to the organization.
 */
export const zEnterpriseTeamOrganizationsAddResponse = zOrganizationSimple;

export const zEnterpriseTeamsDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zEnterpriseTeamsDeleteResponse = z.void();

export const zEnterpriseTeamsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        enterprise: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zEnterpriseTeamsGetResponse = zEnterpriseTeam;

export const zEnterpriseTeamsUpdateData = z.object({
    body: z.object({
        name: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        description: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        sync_to_organizations: z.optional(z.enum([
            'all',
            'disabled'
        ])),
        organization_selection_type: z.optional(z.enum([
            'disabled',
            'selected',
            'all'
        ])),
        group_id: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    }),
    path: z.object({
        enterprise: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zEnterpriseTeamsUpdateResponse = zEnterpriseTeam;

export const zActivityListPublicEventsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(15),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActivityListPublicEventsResponse = z.array(zEvent);

export const zActivityGetFeedsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActivityGetFeedsResponse = zFeed;

export const zGistsListData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        since: z.optional(z.iso.datetime()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zGistsListResponse = z.array(zBaseGist);

export const zGistsCreateData = z.object({
    body: z.object({
        description: z.optional(z.string()),
        files: z.record(z.string(), z.object({
            content: z.string()
        })),
        public: z.optional(z.union([
            z.boolean().default(false),
            z.literal('true'),
            z.literal('false')
        ]))
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGistsCreateResponse = zGistSimple;

export const zGistsListPublicData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        since: z.optional(z.iso.datetime()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zGistsListPublicResponse = z.array(zBaseGist);

export const zGistsListStarredData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        since: z.optional(z.iso.datetime()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zGistsListStarredResponse = z.array(zBaseGist);

export const zGistsDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        gist_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGistsDeleteResponse = z.void();

export const zGistsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        gist_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGistsGetResponse = zGistSimple;

export const zGistsUpdateData = z.object({
    body: z.union([
        z.object({
            description: z.optional(z.string()),
            files: z.optional(z.record(z.string(), z.union([
                z.object({
                    content: z.optional(z.string()),
                    filename: z.optional(z.union([
                        z.string(),
                        z.null()
                    ]))
                }),
                z.null()
            ])))
        }),
        z.null()
    ]),
    path: z.object({
        gist_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGistsUpdateResponse = zGistSimple;

export const zGistsListCommentsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        gist_id: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zGistsListCommentsResponse = z.array(zGistComment);

export const zGistsCreateCommentData = z.object({
    body: z.object({
        body: z.string().max(65535)
    }),
    path: z.object({
        gist_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGistsCreateCommentResponse = zGistComment;

export const zGistsDeleteCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        gist_id: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGistsDeleteCommentResponse = z.void();

export const zGistsGetCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        gist_id: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGistsGetCommentResponse = zGistComment;

export const zGistsUpdateCommentData = z.object({
    body: z.object({
        body: z.string().max(65535)
    }),
    path: z.object({
        gist_id: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGistsUpdateCommentResponse = zGistComment;

export const zGistsListCommitsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        gist_id: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zGistsListCommitsResponse = z.array(zGistCommit);

export const zGistsListForksData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        gist_id: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zGistsListForksResponse = z.array(zGistSimple);

export const zGistsForkData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        gist_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGistsForkResponse = zBaseGist;

export const zGistsUnstarData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        gist_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGistsUnstarResponse = z.void();

export const zGistsCheckIsStarredData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        gist_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response if gist is starred
 */
export const zGistsCheckIsStarredResponse = z.void();

export const zGistsStarData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        gist_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGistsStarResponse = z.void();

export const zGistsGetRevisionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        gist_id: z.string(),
        sha: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGistsGetRevisionResponse = zGistSimple;

export const zGitignoreGetAllTemplatesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGitignoreGetAllTemplatesResponse = z.array(z.string());

export const zGitignoreGetTemplateData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGitignoreGetTemplateResponse = zGitignoreTemplate;

export const zAppsListReposAccessibleToInstallationData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zAppsListReposAccessibleToInstallationResponse = z.object({
    total_count: z.int(),
    repositories: z.array(zRepository),
    repository_selection: z.optional(z.string())
});

export const zAppsRevokeInstallationAccessTokenData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsRevokeInstallationAccessTokenResponse = z.void();

export const zIssuesListData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        filter: z.optional(z.enum([
            'assigned',
            'created',
            'mentioned',
            'subscribed',
            'repos',
            'all'
        ])),
        state: z.optional(z.enum([
            'open',
            'closed',
            'all'
        ])),
        labels: z.optional(z.string()),
        sort: z.optional(z.enum([
            'created',
            'updated',
            'comments'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        since: z.optional(z.iso.datetime()),
        collab: z.optional(z.boolean()),
        orgs: z.optional(z.boolean()),
        owned: z.optional(z.boolean()),
        pulls: z.optional(z.boolean()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListResponse = z.array(zIssue);

export const zLicensesGetAllCommonlyUsedData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        featured: z.optional(z.boolean()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zLicensesGetAllCommonlyUsedResponse = z.array(zLicenseSimple);

export const zLicensesGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        license: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zLicensesGetResponse = zLicense;

export const zMarkdownRenderData = z.object({
    body: z.object({
        text: z.string(),
        mode: z.optional(z.enum([
            'markdown',
            'gfm'
        ])),
        context: z.optional(z.string())
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMarkdownRenderResponse = z.string();

export const zMarkdownRenderRawData = z.object({
    body: z.optional(z.string()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMarkdownRenderRawResponse = z.string();

export const zAppsGetSubscriptionPlanForAccountData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        account_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsGetSubscriptionPlanForAccountResponse = zMarketplacePurchase;

export const zAppsListPlansData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zAppsListPlansResponse = z.array(zMarketplaceListingPlan);

export const zAppsListAccountsForPlanData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        plan_id: z.int()
    }),
    query: z.optional(z.object({
        sort: z.optional(z.enum([
            'created',
            'updated'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zAppsListAccountsForPlanResponse = z.array(zMarketplacePurchase);

export const zAppsGetSubscriptionPlanForAccountStubbedData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        account_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsGetSubscriptionPlanForAccountStubbedResponse = zMarketplacePurchase;

export const zAppsListPlansStubbedData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zAppsListPlansStubbedResponse = z.array(zMarketplaceListingPlan);

export const zAppsListAccountsForPlanStubbedData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        plan_id: z.int()
    }),
    query: z.optional(z.object({
        sort: z.optional(z.enum([
            'created',
            'updated'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zAppsListAccountsForPlanStubbedResponse = z.array(zMarketplacePurchase);

export const zMetaGetData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMetaGetResponse = zApiOverview;

export const zActivityListPublicEventsForRepoNetworkData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActivityListPublicEventsForRepoNetworkResponse = z.array(zEvent);

export const zActivityListNotificationsForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        all: z.optional(z.boolean()).default(false),
        participating: z.optional(z.boolean()).default(false),
        since: z.optional(z.iso.datetime()),
        before: z.optional(z.iso.datetime()),
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(50)
    }))
});

/**
 * Response
 */
export const zActivityListNotificationsForAuthenticatedUserResponse = z.array(zThread);

export const zActivityMarkNotificationsAsReadData = z.object({
    body: z.optional(z.object({
        last_read_at: z.optional(z.iso.datetime()),
        read: z.optional(z.boolean())
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zActivityMarkNotificationsAsReadResponse = z.union([
    z.object({
        message: z.optional(z.string())
    }),
    z.unknown()
]);

export const zActivityMarkThreadAsDoneData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        thread_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * No content
 */
export const zActivityMarkThreadAsDoneResponse = z.void();

export const zActivityGetThreadData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        thread_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActivityGetThreadResponse = zThread;

export const zActivityMarkThreadAsReadData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        thread_id: z.int()
    }),
    query: z.optional(z.never())
});

export const zActivityDeleteThreadSubscriptionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        thread_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActivityDeleteThreadSubscriptionResponse = z.void();

export const zActivityGetThreadSubscriptionForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        thread_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActivityGetThreadSubscriptionForAuthenticatedUserResponse = zThreadSubscription;

export const zActivitySetThreadSubscriptionData = z.object({
    body: z.optional(z.object({
        ignored: z.optional(z.boolean()).default(false)
    })),
    path: z.object({
        thread_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActivitySetThreadSubscriptionResponse = zThreadSubscription;

export const zMetaGetOctocatData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        s: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zMetaGetOctocatResponse = z.string();

export const zOrgsListData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        since: z.optional(z.int()),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zOrgsListResponse = z.array(zOrganizationSimple);

export const zDependabotRepositoryAccessForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        per_page: z.optional(z.int().gte(1).lte(100)).default(30)
    }))
});

/**
 * Response
 */
export const zDependabotRepositoryAccessForOrgResponse = zDependabotRepositoryAccessDetails;

export const zDependabotUpdateRepositoryAccessForOrgData = z.object({
    body: z.object({
        repository_ids_to_add: z.optional(z.array(z.int())),
        repository_ids_to_remove: z.optional(z.array(z.int()))
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zDependabotUpdateRepositoryAccessForOrgResponse = z.void();

export const zDependabotSetRepositoryAccessDefaultLevelData = z.object({
    body: z.object({
        default_level: z.enum([
            'public',
            'internal'
        ])
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zDependabotSetRepositoryAccessDefaultLevelResponse = z.void();

export const zOrgsCustomPropertiesForOrgsGetOrganizationValuesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsCustomPropertiesForOrgsGetOrganizationValuesResponse = z.array(zCustomPropertyValue);

export const zOrgsCustomPropertiesForOrgsCreateOrUpdateOrganizationValuesData = z.object({
    body: z.object({
        properties: z.array(zCustomPropertyValue)
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * No Content when custom property values are successfully created or updated
 */
export const zOrgsCustomPropertiesForOrgsCreateOrUpdateOrganizationValuesResponse = z.void();

export const zBillingGetGithubBillingPremiumRequestUsageReportOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        year: z.optional(z.int()),
        month: z.optional(z.int()),
        day: z.optional(z.int()),
        user: z.optional(z.string()),
        model: z.optional(z.string()),
        product: z.optional(z.string())
    }))
});

/**
 * Response when getting a billing premium request usage report
 */
export const zBillingGetGithubBillingPremiumRequestUsageReportOrgResponse = zBillingPremiumRequestUsageReportOrg;

export const zBillingGetGithubBillingUsageReportOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        year: z.optional(z.int()),
        month: z.optional(z.int()),
        day: z.optional(z.int()),
        hour: z.optional(z.int())
    }))
});

/**
 * Billing usage report response for an organization
 */
export const zBillingGetGithubBillingUsageReportOrgResponse = zBillingUsageReport;

export const zOrgsDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Accepted
 */
export const zOrgsDeleteResponse = z.record(z.string(), z.unknown());

export const zOrgsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsGetResponse = zOrganizationFull;

export const zOrgsUpdateData = z.object({
    body: z.optional(z.object({
        billing_email: z.optional(z.string()),
        company: z.optional(z.string()),
        email: z.optional(z.string()),
        twitter_username: z.optional(z.string()),
        location: z.optional(z.string()),
        name: z.optional(z.string()),
        description: z.optional(z.string()),
        has_organization_projects: z.optional(z.boolean()),
        has_repository_projects: z.optional(z.boolean()),
        default_repository_permission: z.optional(z.enum([
            'read',
            'write',
            'admin',
            'none'
        ])),
        members_can_create_repositories: z.optional(z.boolean()).default(true),
        members_can_create_internal_repositories: z.optional(z.boolean()),
        members_can_create_private_repositories: z.optional(z.boolean()),
        members_can_create_public_repositories: z.optional(z.boolean()),
        members_allowed_repository_creation_type: z.optional(z.enum([
            'all',
            'private',
            'none'
        ])),
        members_can_create_pages: z.optional(z.boolean()).default(true),
        members_can_create_public_pages: z.optional(z.boolean()).default(true),
        members_can_create_private_pages: z.optional(z.boolean()).default(true),
        members_can_fork_private_repositories: z.optional(z.boolean()).default(false),
        web_commit_signoff_required: z.optional(z.boolean()).default(false),
        blog: z.optional(z.string()),
        advanced_security_enabled_for_new_repositories: z.optional(z.boolean()),
        dependabot_alerts_enabled_for_new_repositories: z.optional(z.boolean()),
        dependabot_security_updates_enabled_for_new_repositories: z.optional(z.boolean()),
        dependency_graph_enabled_for_new_repositories: z.optional(z.boolean()),
        secret_scanning_enabled_for_new_repositories: z.optional(z.boolean()),
        secret_scanning_push_protection_enabled_for_new_repositories: z.optional(z.boolean()),
        secret_scanning_push_protection_custom_link_enabled: z.optional(z.boolean()),
        secret_scanning_push_protection_custom_link: z.optional(z.string()),
        deploy_keys_enabled_for_repositories: z.optional(z.boolean())
    })),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsUpdateResponse = zOrganizationFull;

export const zActionsGetActionsCacheUsageForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetActionsCacheUsageForOrgResponse = zActionsCacheUsageOrgEnterprise;

export const zActionsGetActionsCacheUsageByRepoForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsGetActionsCacheUsageByRepoForOrgResponse = z.object({
    total_count: z.int(),
    repository_cache_usages: z.array(zActionsCacheUsageByRepository)
});

export const zActionsListHostedRunnersForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListHostedRunnersForOrgResponse = z.object({
    total_count: z.int(),
    runners: z.array(zActionsHostedRunner)
});

export const zActionsCreateHostedRunnerForOrgData = z.object({
    body: z.object({
        name: z.string(),
        image: z.object({
            id: z.optional(z.string()),
            source: z.optional(z.enum([
                'github',
                'partner',
                'custom'
            ])),
            version: z.optional(z.union([
                z.string(),
                z.null()
            ]))
        }),
        size: z.string(),
        runner_group_id: z.int(),
        maximum_runners: z.optional(z.int()),
        enable_static_ip: z.optional(z.boolean()),
        image_gen: z.optional(z.boolean()).default(false)
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsCreateHostedRunnerForOrgResponse = zActionsHostedRunner;

export const zActionsListCustomImagesForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsListCustomImagesForOrgResponse = z.object({
    total_count: z.int(),
    images: z.array(zActionsHostedRunnerCustomImage)
});

export const zActionsDeleteCustomImageFromOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        image_definition_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDeleteCustomImageFromOrgResponse = z.void();

export const zActionsGetCustomImageForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        image_definition_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetCustomImageForOrgResponse = zActionsHostedRunnerCustomImage;

export const zActionsListCustomImageVersionsForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        image_definition_id: z.int(),
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsListCustomImageVersionsForOrgResponse = z.object({
    total_count: z.int(),
    image_versions: z.array(zActionsHostedRunnerCustomImageVersion)
});

export const zActionsDeleteCustomImageVersionFromOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        image_definition_id: z.int(),
        version: z.string().regex(/^\d+\.\d+\.\d+$/)
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDeleteCustomImageVersionFromOrgResponse = z.void();

export const zActionsGetCustomImageVersionForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        image_definition_id: z.int(),
        version: z.string().regex(/^\d+\.\d+\.\d+$/)
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetCustomImageVersionForOrgResponse = zActionsHostedRunnerCustomImageVersion;

export const zActionsGetHostedRunnersGithubOwnedImagesForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetHostedRunnersGithubOwnedImagesForOrgResponse = z.object({
    total_count: z.int(),
    images: z.array(zActionsHostedRunnerCuratedImage)
});

export const zActionsGetHostedRunnersPartnerImagesForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetHostedRunnersPartnerImagesForOrgResponse = z.object({
    total_count: z.int(),
    images: z.array(zActionsHostedRunnerCuratedImage)
});

export const zActionsGetHostedRunnersLimitsForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetHostedRunnersLimitsForOrgResponse = zActionsHostedRunnerLimits;

export const zActionsGetHostedRunnersMachineSpecsForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetHostedRunnersMachineSpecsForOrgResponse = z.object({
    total_count: z.int(),
    machine_specs: z.array(zActionsHostedRunnerMachineSpec)
});

export const zActionsGetHostedRunnersPlatformsForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetHostedRunnersPlatformsForOrgResponse = z.object({
    total_count: z.int(),
    platforms: z.array(z.string())
});

export const zActionsDeleteHostedRunnerForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        hosted_runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDeleteHostedRunnerForOrgResponse = zActionsHostedRunner;

export const zActionsGetHostedRunnerForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        hosted_runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetHostedRunnerForOrgResponse = zActionsHostedRunner;

export const zActionsUpdateHostedRunnerForOrgData = z.object({
    body: z.object({
        name: z.optional(z.string()),
        runner_group_id: z.optional(z.int()),
        maximum_runners: z.optional(z.int()),
        enable_static_ip: z.optional(z.boolean()),
        image_version: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    }),
    path: z.object({
        org: z.string(),
        hosted_runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsUpdateHostedRunnerForOrgResponse = zActionsHostedRunner;

export const zOidcGetOidcCustomSubTemplateForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * A JSON serialized template for OIDC subject claim customization
 */
export const zOidcGetOidcCustomSubTemplateForOrgResponse = zOidcCustomSub;

export const zOidcUpdateOidcCustomSubTemplateForOrgData = z.object({
    body: zOidcCustomSub,
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Empty response
 */
export const zOidcUpdateOidcCustomSubTemplateForOrgResponse = zEmptyObject;

export const zActionsGetGithubActionsPermissionsOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetGithubActionsPermissionsOrganizationResponse = zActionsOrganizationPermissions;

export const zActionsSetGithubActionsPermissionsOrganizationData = z.object({
    body: z.object({
        enabled_repositories: zEnabledRepositories,
        allowed_actions: z.optional(zAllowedActions),
        sha_pinning_required: z.optional(zShaPinningRequired)
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsSetGithubActionsPermissionsOrganizationResponse = z.void();

export const zActionsGetArtifactAndLogRetentionSettingsOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetArtifactAndLogRetentionSettingsOrganizationResponse = zActionsArtifactAndLogRetentionResponse;

export const zActionsSetArtifactAndLogRetentionSettingsOrganizationData = z.object({
    body: zActionsArtifactAndLogRetention,
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * No content
 */
export const zActionsSetArtifactAndLogRetentionSettingsOrganizationResponse = z.void();

export const zActionsGetForkPrContributorApprovalPermissionsOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetForkPrContributorApprovalPermissionsOrganizationResponse = zActionsForkPrContributorApproval;

export const zActionsSetForkPrContributorApprovalPermissionsOrganizationData = z.object({
    body: zActionsForkPrContributorApproval,
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsSetForkPrContributorApprovalPermissionsOrganizationResponse = z.void();

export const zActionsGetPrivateRepoForkPrWorkflowsSettingsOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetPrivateRepoForkPrWorkflowsSettingsOrganizationResponse = zActionsForkPrWorkflowsPrivateRepos;

export const zActionsSetPrivateRepoForkPrWorkflowsSettingsOrganizationData = z.object({
    body: zActionsForkPrWorkflowsPrivateReposRequest,
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Empty response for successful settings update
 */
export const zActionsSetPrivateRepoForkPrWorkflowsSettingsOrganizationResponse = z.void();

export const zActionsListSelectedRepositoriesEnabledGithubActionsOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse = z.object({
    total_count: z.number(),
    repositories: z.array(zRepository)
});

export const zActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationData = z.object({
    body: z.object({
        selected_repository_ids: z.array(z.int())
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse = z.void();

export const zActionsDisableSelectedRepositoryGithubActionsOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDisableSelectedRepositoryGithubActionsOrganizationResponse = z.void();

export const zActionsEnableSelectedRepositoryGithubActionsOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsEnableSelectedRepositoryGithubActionsOrganizationResponse = z.void();

export const zActionsGetAllowedActionsOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetAllowedActionsOrganizationResponse = zSelectedActions;

export const zActionsSetAllowedActionsOrganizationData = z.object({
    body: z.optional(zSelectedActions),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsSetAllowedActionsOrganizationResponse = z.void();

export const zActionsGetSelfHostedRunnersPermissionsOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetSelfHostedRunnersPermissionsOrganizationResponse = zSelfHostedRunnersSettings;

export const zActionsSetSelfHostedRunnersPermissionsOrganizationData = z.object({
    body: z.object({
        enabled_repositories: z.enum([
            'all',
            'selected',
            'none'
        ])
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * No content
 */
export const zActionsSetSelfHostedRunnersPermissionsOrganizationResponse = z.void();

export const zActionsListSelectedRepositoriesSelfHostedRunnersOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListSelectedRepositoriesSelfHostedRunnersOrganizationResponse = z.object({
    total_count: z.optional(z.int()),
    repositories: z.optional(z.array(zRepository))
});

export const zActionsSetSelectedRepositoriesSelfHostedRunnersOrganizationData = z.object({
    body: z.object({
        selected_repository_ids: z.array(z.int())
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * No content
 */
export const zActionsSetSelectedRepositoriesSelfHostedRunnersOrganizationResponse = z.void();

export const zActionsDisableSelectedRepositorySelfHostedRunnersOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * No content
 */
export const zActionsDisableSelectedRepositorySelfHostedRunnersOrganizationResponse = z.void();

export const zActionsEnableSelectedRepositorySelfHostedRunnersOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * No content
 */
export const zActionsEnableSelectedRepositorySelfHostedRunnersOrganizationResponse = z.void();

export const zActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse = zActionsGetDefaultWorkflowPermissions;

export const zActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationData = z.object({
    body: z.optional(zActionsSetDefaultWorkflowPermissions),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Success response
 */
export const zActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponse = z.void();

export const zActionsListSelfHostedRunnerGroupsForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        visible_to_repository: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zActionsListSelfHostedRunnerGroupsForOrgResponse = z.object({
    total_count: z.number(),
    runner_groups: z.array(zRunnerGroupsOrg)
});

export const zActionsCreateSelfHostedRunnerGroupForOrgData = z.object({
    body: z.object({
        name: z.string(),
        visibility: z.optional(z.enum([
            'selected',
            'all',
            'private'
        ])),
        selected_repository_ids: z.optional(z.array(z.int())),
        runners: z.optional(z.array(z.int())),
        allows_public_repositories: z.optional(z.boolean()).default(false),
        restricted_to_workflows: z.optional(z.boolean()).default(false),
        selected_workflows: z.optional(z.array(z.string())),
        network_configuration_id: z.optional(z.string())
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsCreateSelfHostedRunnerGroupForOrgResponse = zRunnerGroupsOrg;

export const zActionsDeleteSelfHostedRunnerGroupFromOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        runner_group_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDeleteSelfHostedRunnerGroupFromOrgResponse = z.void();

export const zActionsGetSelfHostedRunnerGroupForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        runner_group_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetSelfHostedRunnerGroupForOrgResponse = zRunnerGroupsOrg;

export const zActionsUpdateSelfHostedRunnerGroupForOrgData = z.object({
    body: z.object({
        name: z.string(),
        visibility: z.optional(z.enum([
            'selected',
            'all',
            'private'
        ])),
        allows_public_repositories: z.optional(z.boolean()).default(false),
        restricted_to_workflows: z.optional(z.boolean()).default(false),
        selected_workflows: z.optional(z.array(z.string())),
        network_configuration_id: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    }),
    path: z.object({
        org: z.string(),
        runner_group_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsUpdateSelfHostedRunnerGroupForOrgResponse = zRunnerGroupsOrg;

export const zActionsListGithubHostedRunnersInGroupForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        runner_group_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListGithubHostedRunnersInGroupForOrgResponse = z.object({
    total_count: z.number(),
    runners: z.array(zActionsHostedRunner)
});

export const zActionsListRepoAccessToSelfHostedRunnerGroupInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        runner_group_id: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse = z.object({
    total_count: z.number(),
    repositories: z.array(zMinimalRepository)
});

export const zActionsSetRepoAccessToSelfHostedRunnerGroupInOrgData = z.object({
    body: z.object({
        selected_repository_ids: z.array(z.int())
    }),
    path: z.object({
        org: z.string(),
        runner_group_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse = z.void();

export const zActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        runner_group_id: z.int(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse = z.void();

export const zActionsAddRepoAccessToSelfHostedRunnerGroupInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        runner_group_id: z.int(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponse = z.void();

export const zActionsListSelfHostedRunnersInGroupForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        runner_group_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListSelfHostedRunnersInGroupForOrgResponse = z.object({
    total_count: z.number(),
    runners: z.array(zRunner)
});

export const zActionsSetSelfHostedRunnersInGroupForOrgData = z.object({
    body: z.object({
        runners: z.array(z.int())
    }),
    path: z.object({
        org: z.string(),
        runner_group_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsSetSelfHostedRunnersInGroupForOrgResponse = z.void();

export const zActionsRemoveSelfHostedRunnerFromGroupForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        runner_group_id: z.int(),
        runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsRemoveSelfHostedRunnerFromGroupForOrgResponse = z.void();

export const zActionsAddSelfHostedRunnerToGroupForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        runner_group_id: z.int(),
        runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsAddSelfHostedRunnerToGroupForOrgResponse = z.void();

export const zActionsListSelfHostedRunnersForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        name: z.optional(z.string()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListSelfHostedRunnersForOrgResponse = z.object({
    total_count: z.int(),
    runners: z.array(zRunner)
});

export const zActionsListRunnerApplicationsForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsListRunnerApplicationsForOrgResponse = z.array(zRunnerApplication);

export const zActionsGenerateRunnerJitconfigForOrgData = z.object({
    body: z.object({
        name: z.string(),
        runner_group_id: z.int(),
        labels: z.array(z.string()).min(1).max(100),
        work_folder: z.optional(z.string()).default('_work')
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGenerateRunnerJitconfigForOrgResponse = z.object({
    runner: zRunner,
    encoded_jit_config: z.string()
});

export const zActionsCreateRegistrationTokenForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsCreateRegistrationTokenForOrgResponse = zAuthenticationToken;

export const zActionsCreateRemoveTokenForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsCreateRemoveTokenForOrgResponse = zAuthenticationToken;

export const zActionsDeleteSelfHostedRunnerFromOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDeleteSelfHostedRunnerFromOrgResponse = z.void();

export const zActionsGetSelfHostedRunnerForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetSelfHostedRunnerForOrgResponse = zRunner;

export const zActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse = z.object({
    total_count: z.int(),
    labels: z.array(zRunnerLabel)
});

export const zActionsListLabelsForSelfHostedRunnerForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsListLabelsForSelfHostedRunnerForOrgResponse = z.object({
    total_count: z.int(),
    labels: z.array(zRunnerLabel)
});

export const zActionsAddCustomLabelsToSelfHostedRunnerForOrgData = z.object({
    body: z.object({
        labels: z.array(z.string()).min(1).max(100)
    }),
    path: z.object({
        org: z.string(),
        runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse = z.object({
    total_count: z.int(),
    labels: z.array(zRunnerLabel)
});

export const zActionsSetCustomLabelsForSelfHostedRunnerForOrgData = z.object({
    body: z.object({
        labels: z.array(z.string()).min(0).max(100)
    }),
    path: z.object({
        org: z.string(),
        runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse = z.object({
    total_count: z.int(),
    labels: z.array(zRunnerLabel)
});

export const zActionsRemoveCustomLabelFromSelfHostedRunnerForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        runner_id: z.int(),
        name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse = z.object({
    total_count: z.int(),
    labels: z.array(zRunnerLabel)
});

export const zActionsListOrgSecretsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListOrgSecretsResponse = z.object({
    total_count: z.int(),
    secrets: z.array(zOrganizationActionsSecret)
});

export const zActionsGetOrgPublicKeyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetOrgPublicKeyResponse = zActionsPublicKey;

export const zActionsDeleteOrgSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDeleteOrgSecretResponse = z.void();

export const zActionsGetOrgSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetOrgSecretResponse = zOrganizationActionsSecret;

export const zActionsCreateOrUpdateOrgSecretData = z.object({
    body: z.object({
        encrypted_value: z.string().regex(/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})$/),
        key_id: z.string(),
        visibility: z.enum([
            'all',
            'private',
            'selected'
        ]),
        selected_repository_ids: z.optional(z.array(z.int()))
    }),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

export const zActionsCreateOrUpdateOrgSecretResponse = z.union([
    zEmptyObject,
    z.void()
]);

export const zActionsListSelectedReposForOrgSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zActionsListSelectedReposForOrgSecretResponse = z.object({
    total_count: z.int(),
    repositories: z.array(zMinimalRepository)
});

export const zActionsSetSelectedReposForOrgSecretData = z.object({
    body: z.object({
        selected_repository_ids: z.array(z.int())
    }),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsSetSelectedReposForOrgSecretResponse = z.void();

export const zActionsRemoveSelectedRepoFromOrgSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response when repository was removed from the selected list
 */
export const zActionsRemoveSelectedRepoFromOrgSecretResponse = z.void();

export const zActionsAddSelectedRepoToOrgSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * No Content when repository was added to the selected list
 */
export const zActionsAddSelectedRepoToOrgSecretResponse = z.void();

export const zActionsListOrgVariablesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(10),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListOrgVariablesResponse = z.object({
    total_count: z.int(),
    variables: z.array(zOrganizationActionsVariable)
});

export const zActionsCreateOrgVariableData = z.object({
    body: z.object({
        name: z.string(),
        value: z.string(),
        visibility: z.enum([
            'all',
            'private',
            'selected'
        ]),
        selected_repository_ids: z.optional(z.array(z.int()))
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response when creating a variable
 */
export const zActionsCreateOrgVariableResponse = zEmptyObject;

export const zActionsDeleteOrgVariableData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDeleteOrgVariableResponse = z.void();

export const zActionsGetOrgVariableData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetOrgVariableResponse = zOrganizationActionsVariable;

export const zActionsUpdateOrgVariableData = z.object({
    body: z.object({
        name: z.optional(z.string()),
        value: z.optional(z.string()),
        visibility: z.optional(z.enum([
            'all',
            'private',
            'selected'
        ])),
        selected_repository_ids: z.optional(z.array(z.int()))
    }),
    path: z.object({
        org: z.string(),
        name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsUpdateOrgVariableResponse = z.void();

export const zActionsListSelectedReposForOrgVariableData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        name: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zActionsListSelectedReposForOrgVariableResponse = z.object({
    total_count: z.int(),
    repositories: z.array(zMinimalRepository)
});

export const zActionsSetSelectedReposForOrgVariableData = z.object({
    body: z.object({
        selected_repository_ids: z.array(z.int())
    }),
    path: z.object({
        org: z.string(),
        name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsSetSelectedReposForOrgVariableResponse = z.void();

export const zActionsRemoveSelectedRepoFromOrgVariableData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        name: z.string(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsRemoveSelectedRepoFromOrgVariableResponse = z.void();

export const zActionsAddSelectedRepoToOrgVariableData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        name: z.string(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsAddSelectedRepoToOrgVariableResponse = z.void();

export const zOrgsCreateArtifactStorageRecordData = z.object({
    body: z.object({
        name: z.string().min(1),
        digest: z.string().length(71).regex(/^sha256:[a-f0-9]{64}$/),
        artifact_url: z.optional(z.url().regex(/^https:\/\//)),
        path: z.optional(z.url()),
        registry_url: z.url().min(1).regex(/^https:\/\//),
        repository: z.optional(z.string()),
        status: z.optional(z.enum([
            'active',
            'eol',
            'deleted'
        ]))
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Artifact metadata storage record stored successfully.
 */
export const zOrgsCreateArtifactStorageRecordResponse = z.object({
    total_count: z.optional(z.int()),
    storage_records: z.optional(z.array(z.object({
        id: z.optional(z.int()),
        name: z.optional(z.string()),
        digest: z.optional(z.string()),
        artifact_url: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        registry_url: z.optional(z.string()),
        repository: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        status: z.optional(z.string()),
        created_at: z.optional(z.string()),
        updated_at: z.optional(z.string())
    })))
});

export const zOrgsListArtifactStorageRecordsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        subject_digest: z.string().length(71).regex(/^sha256:[a-f0-9]{64}$/)
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsListArtifactStorageRecordsResponse = z.object({
    total_count: z.optional(z.int()),
    storage_records: z.optional(z.array(z.object({
        id: z.optional(z.int()),
        name: z.optional(z.string()),
        digest: z.optional(z.string()),
        artifact_url: z.optional(z.string()),
        registry_url: z.optional(z.string()),
        repository: z.optional(z.string()),
        status: z.optional(z.string()),
        created_at: z.optional(z.string()),
        updated_at: z.optional(z.string())
    })))
});

export const zOrgsListAttestationsBulkData = z.object({
    body: z.object({
        subject_digests: z.array(z.string()).min(1).max(1024),
        predicate_type: z.optional(z.string())
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        before: z.optional(z.string()),
        after: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zOrgsListAttestationsBulkResponse = z.object({
    attestations_subject_digests: z.optional(z.record(z.string(), z.union([
        z.array(z.object({
            bundle: z.optional(z.object({
                mediaType: z.optional(z.string()),
                verificationMaterial: z.optional(z.record(z.string(), z.unknown())),
                dsseEnvelope: z.optional(z.record(z.string(), z.unknown()))
            })),
            repository_id: z.optional(z.int()),
            bundle_url: z.optional(z.string())
        })),
        z.null()
    ]))),
    page_info: z.optional(z.object({
        has_next: z.optional(z.boolean()),
        has_previous: z.optional(z.boolean()),
        next: z.optional(z.string()),
        previous: z.optional(z.string())
    }))
});

export const zOrgsDeleteAttestationsBulkData = z.object({
    body: z.union([
        z.object({
            subject_digests: z.array(z.string()).min(1).max(1024)
        }),
        z.object({
            attestation_ids: z.array(z.int()).min(1).max(1024)
        })
    ]),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

export const zOrgsDeleteAttestationsBySubjectDigestData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        subject_digest: z.string()
    }),
    query: z.optional(z.never())
});

export const zOrgsDeleteAttestationsBySubjectDigestResponse = z.union([
    z.unknown(),
    z.void()
]);

export const zOrgsListAttestationRepositoriesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        predicate_type: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zOrgsListAttestationRepositoriesResponse = z.array(z.object({
    id: z.optional(z.int()),
    name: z.optional(z.string())
}));

export const zOrgsDeleteAttestationsByIdData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        attestation_id: z.int()
    }),
    query: z.optional(z.never())
});

export const zOrgsDeleteAttestationsByIdResponse = z.union([
    z.unknown(),
    z.void()
]);

export const zOrgsListAttestationsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        subject_digest: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        predicate_type: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zOrgsListAttestationsResponse = z.object({
    attestations: z.optional(z.array(z.object({
        bundle: z.optional(z.object({
            mediaType: z.optional(z.string()),
            verificationMaterial: z.optional(z.record(z.string(), z.unknown())),
            dsseEnvelope: z.optional(z.record(z.string(), z.unknown()))
        })),
        repository_id: z.optional(z.int()),
        bundle_url: z.optional(z.string()),
        initiator: z.optional(z.string())
    })))
});

export const zOrgsListBlockedUsersData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zOrgsListBlockedUsersResponse = z.array(zSimpleUser);

export const zOrgsUnblockUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsUnblockUserResponse = z.void();

export const zOrgsCheckBlockedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * If the user is blocked
 */
export const zOrgsCheckBlockedUserResponse = z.void();

export const zOrgsBlockUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsBlockUserResponse = z.void();

export const zCampaignsListOrgCampaignsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        state: z.optional(zCampaignState),
        sort: z.optional(z.enum([
            'created',
            'updated',
            'ends_at',
            'published'
        ]))
    }))
});

/**
 * Response
 */
export const zCampaignsListOrgCampaignsResponse = z.array(zCampaignSummary);

export const zCampaignsCreateCampaignData = z.object({
    body: z.intersection(z.unknown(), z.object({
        name: z.string().min(1).max(50),
        description: z.string().min(1).max(255),
        managers: z.optional(z.array(z.string()).max(10)),
        team_managers: z.optional(z.array(z.string()).max(10)),
        ends_at: z.iso.datetime(),
        contact_link: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        code_scanning_alerts: z.optional(z.union([
            z.array(z.object({
                repository_id: z.int(),
                alert_numbers: z.array(z.int()).min(1)
            })).min(1),
            z.null()
        ])),
        generate_issues: z.optional(z.boolean()).default(false)
    })),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCampaignsCreateCampaignResponse = zCampaignSummary;

export const zCampaignsDeleteCampaignData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        campaign_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Deletion successful
 */
export const zCampaignsDeleteCampaignResponse = z.void();

export const zCampaignsGetCampaignSummaryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        campaign_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCampaignsGetCampaignSummaryResponse = zCampaignSummary;

export const zCampaignsUpdateCampaignData = z.object({
    body: z.object({
        name: z.optional(z.string().min(1).max(50)),
        description: z.optional(z.string().min(1).max(255)),
        managers: z.optional(z.array(z.string()).max(10)),
        team_managers: z.optional(z.array(z.string()).max(10)),
        ends_at: z.optional(z.iso.datetime()),
        contact_link: z.optional(z.union([
            z.url(),
            z.null()
        ])),
        state: z.optional(zCampaignState)
    }),
    path: z.object({
        org: z.string(),
        campaign_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCampaignsUpdateCampaignResponse = zCampaignSummary;

export const zCodeScanningListAlertsForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        tool_name: z.optional(zCodeScanningAnalysisToolName),
        tool_guid: z.optional(zCodeScanningAnalysisToolGuid),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        state: z.optional(zCodeScanningAlertStateQuery),
        sort: z.optional(z.enum([
            'created',
            'updated'
        ])),
        severity: z.optional(zCodeScanningAlertSeverity)
    }))
});

/**
 * Response
 */
export const zCodeScanningListAlertsForOrgResponse = z.array(zCodeScanningOrganizationAlertItems);

export const zCodeSecurityGetConfigurationsForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        target_type: z.optional(z.enum([
            'global',
            'all'
        ])),
        per_page: z.optional(z.int()).default(30),
        before: z.optional(z.string()),
        after: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zCodeSecurityGetConfigurationsForOrgResponse = z.array(zCodeSecurityConfiguration);

export const zCodeSecurityCreateConfigurationData = z.object({
    body: z.object({
        name: z.string(),
        description: z.string().max(255),
        advanced_security: z.optional(z.enum([
            'enabled',
            'disabled',
            'code_security',
            'secret_protection'
        ])),
        code_security: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        dependency_graph: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        dependency_graph_autosubmit_action: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        dependency_graph_autosubmit_action_options: z.optional(z.object({
            labeled_runners: z.optional(z.boolean()).default(false)
        })),
        dependabot_alerts: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        dependabot_security_updates: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        code_scanning_options: z.optional(zCodeScanningOptions),
        code_scanning_default_setup: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        code_scanning_default_setup_options: z.optional(zCodeScanningDefaultSetupOptions),
        code_scanning_delegated_alert_dismissal: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_protection: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_push_protection: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_delegated_bypass: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_delegated_bypass_options: z.optional(z.object({
            reviewers: z.optional(z.array(z.object({
                reviewer_id: z.int(),
                reviewer_type: z.enum([
                    'TEAM',
                    'ROLE'
                ])
            })))
        })),
        secret_scanning_validity_checks: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_non_provider_patterns: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_generic_secrets: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_delegated_alert_dismissal: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        private_vulnerability_reporting: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        enforcement: z.optional(z.enum([
            'enforced',
            'unenforced'
        ]))
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Successfully created code security configuration
 */
export const zCodeSecurityCreateConfigurationResponse = zCodeSecurityConfiguration;

export const zCodeSecurityGetDefaultConfigurationsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeSecurityGetDefaultConfigurationsResponse = zCodeSecurityDefaultConfigurations;

export const zCodeSecurityDetachConfigurationData = z.object({
    body: z.object({
        selected_repository_ids: z.optional(z.array(z.int()).min(1).max(250))
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * A header with no content is returned.
 */
export const zCodeSecurityDetachConfigurationResponse = z.void();

export const zCodeSecurityDeleteConfigurationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        configuration_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A header with no content is returned.
 */
export const zCodeSecurityDeleteConfigurationResponse = z.void();

export const zCodeSecurityGetConfigurationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        configuration_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeSecurityGetConfigurationResponse = zCodeSecurityConfiguration;

export const zCodeSecurityUpdateConfigurationData = z.object({
    body: z.object({
        name: z.optional(z.string()),
        description: z.optional(z.string().max(255)),
        advanced_security: z.optional(z.enum([
            'enabled',
            'disabled',
            'code_security',
            'secret_protection'
        ])),
        code_security: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        dependency_graph: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        dependency_graph_autosubmit_action: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        dependency_graph_autosubmit_action_options: z.optional(z.object({
            labeled_runners: z.optional(z.boolean())
        })),
        dependabot_alerts: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        dependabot_security_updates: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        code_scanning_default_setup: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        code_scanning_default_setup_options: z.optional(zCodeScanningDefaultSetupOptions),
        code_scanning_delegated_alert_dismissal: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_protection: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_push_protection: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_delegated_bypass: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_delegated_bypass_options: z.optional(z.object({
            reviewers: z.optional(z.array(z.object({
                reviewer_id: z.int(),
                reviewer_type: z.enum([
                    'TEAM',
                    'ROLE'
                ])
            })))
        })),
        secret_scanning_validity_checks: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_non_provider_patterns: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_generic_secrets: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        secret_scanning_delegated_alert_dismissal: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        private_vulnerability_reporting: z.optional(z.enum([
            'enabled',
            'disabled',
            'not_set'
        ])),
        enforcement: z.optional(z.enum([
            'enforced',
            'unenforced'
        ]))
    }),
    path: z.object({
        org: z.string(),
        configuration_id: z.int()
    }),
    query: z.optional(z.never())
});

export const zCodeSecurityUpdateConfigurationResponse = z.union([
    zCodeSecurityConfiguration,
    z.void()
]);

export const zCodeSecurityAttachConfigurationData = z.object({
    body: z.object({
        scope: z.enum([
            'all',
            'all_without_configurations',
            'public',
            'private_or_internal',
            'selected'
        ]),
        selected_repository_ids: z.optional(z.array(z.int()))
    }),
    path: z.object({
        org: z.string(),
        configuration_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Accepted
 */
export const zCodeSecurityAttachConfigurationResponse = z.record(z.string(), z.unknown());

export const zCodeSecuritySetConfigurationAsDefaultData = z.object({
    body: z.object({
        default_for_new_repos: z.optional(z.enum([
            'all',
            'none',
            'private_and_internal',
            'public'
        ]))
    }),
    path: z.object({
        org: z.string(),
        configuration_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Default successfully changed.
 */
export const zCodeSecuritySetConfigurationAsDefaultResponse = z.object({
    default_for_new_repos: z.optional(z.enum([
        'all',
        'none',
        'private_and_internal',
        'public'
    ])),
    configuration: z.optional(zCodeSecurityConfiguration)
});

export const zCodeSecurityGetRepositoriesForConfigurationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        configuration_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        status: z.optional(z.string()).default('all')
    }))
});

/**
 * Response
 */
export const zCodeSecurityGetRepositoriesForConfigurationResponse = z.array(zCodeSecurityConfigurationRepositories);

export const zCodespacesListInOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zCodespacesListInOrganizationResponse = z.object({
    total_count: z.int(),
    codespaces: z.array(zCodespace)
});

export const zCodespacesSetCodespacesAccessData = z.object({
    body: z.object({
        visibility: z.enum([
            'disabled',
            'selected_members',
            'all_members',
            'all_members_and_outside_collaborators'
        ]),
        selected_usernames: z.optional(z.array(z.string()).max(100))
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response when successfully modifying permissions.
 */
export const zCodespacesSetCodespacesAccessResponse = z.void();

export const zCodespacesDeleteCodespacesAccessUsersData = z.object({
    body: z.object({
        selected_usernames: z.array(z.string()).max(100)
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response when successfully modifying permissions.
 */
export const zCodespacesDeleteCodespacesAccessUsersResponse = z.void();

export const zCodespacesSetCodespacesAccessUsersData = z.object({
    body: z.object({
        selected_usernames: z.array(z.string()).max(100)
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response when successfully modifying permissions.
 */
export const zCodespacesSetCodespacesAccessUsersResponse = z.void();

export const zCodespacesListOrgSecretsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zCodespacesListOrgSecretsResponse = z.object({
    total_count: z.int(),
    secrets: z.array(zCodespacesOrgSecret)
});

export const zCodespacesGetOrgPublicKeyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesGetOrgPublicKeyResponse = zCodespacesPublicKey;

export const zCodespacesDeleteOrgSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesDeleteOrgSecretResponse = z.void();

export const zCodespacesGetOrgSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesGetOrgSecretResponse = zCodespacesOrgSecret;

export const zCodespacesCreateOrUpdateOrgSecretData = z.object({
    body: z.object({
        encrypted_value: z.optional(z.string().regex(/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})$/)),
        key_id: z.optional(z.string()),
        visibility: z.enum([
            'all',
            'private',
            'selected'
        ]),
        selected_repository_ids: z.optional(z.array(z.int()))
    }),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

export const zCodespacesCreateOrUpdateOrgSecretResponse = z.union([
    zEmptyObject,
    z.void()
]);

export const zCodespacesListSelectedReposForOrgSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zCodespacesListSelectedReposForOrgSecretResponse = z.object({
    total_count: z.int(),
    repositories: z.array(zMinimalRepository)
});

export const zCodespacesSetSelectedReposForOrgSecretData = z.object({
    body: z.object({
        selected_repository_ids: z.array(z.int())
    }),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesSetSelectedReposForOrgSecretResponse = z.void();

export const zCodespacesRemoveSelectedRepoFromOrgSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response when repository was removed from the selected list
 */
export const zCodespacesRemoveSelectedRepoFromOrgSecretResponse = z.void();

export const zCodespacesAddSelectedRepoToOrgSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * No Content when repository was added to the selected list
 */
export const zCodespacesAddSelectedRepoToOrgSecretResponse = z.void();

export const zCopilotGetCopilotOrganizationDetailsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * OK
 */
export const zCopilotGetCopilotOrganizationDetailsResponse = zCopilotOrganizationDetails;

export const zCopilotListCopilotSeatsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(50)
    }))
});

/**
 * Response
 */
export const zCopilotListCopilotSeatsResponse = z.object({
    total_seats: z.optional(z.int()),
    seats: z.optional(z.array(zCopilotSeatDetails))
});

export const zCopilotCancelCopilotSeatAssignmentForTeamsData = z.object({
    body: z.object({
        selected_teams: z.array(z.string()).min(1)
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The total number of seats set to "pending cancellation" for members of the specified team(s).
 */
export const zCopilotCancelCopilotSeatAssignmentForTeamsResponse = z.object({
    seats_cancelled: z.int()
});

export const zCopilotAddCopilotSeatsForTeamsData = z.object({
    body: z.object({
        selected_teams: z.array(z.string()).min(1)
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The total number of seats created for members of the specified team(s).
 */
export const zCopilotAddCopilotSeatsForTeamsResponse = z.object({
    seats_created: z.int()
});

export const zCopilotCancelCopilotSeatAssignmentForUsersData = z.object({
    body: z.object({
        selected_usernames: z.array(z.string()).min(1)
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The total number of seats set to "pending cancellation" for the specified users.
 */
export const zCopilotCancelCopilotSeatAssignmentForUsersResponse = z.object({
    seats_cancelled: z.int()
});

export const zCopilotAddCopilotSeatsForUsersData = z.object({
    body: z.object({
        selected_usernames: z.array(z.string()).min(1)
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The total number of seats created for the specified user(s).
 */
export const zCopilotAddCopilotSeatsForUsersResponse = z.object({
    seats_created: z.int()
});

export const zCopilotCopilotMetricsForOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        since: z.optional(z.string()),
        until: z.optional(z.string()),
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(100)
    }))
});

/**
 * Response
 */
export const zCopilotCopilotMetricsForOrganizationResponse = z.array(zCopilotUsageMetricsDay);

export const zDependabotListAlertsForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        state: z.optional(z.string()),
        severity: z.optional(z.string()),
        ecosystem: z.optional(z.string()),
        package: z.optional(z.string()),
        epss_percentage: z.optional(z.string()),
        artifact_registry_url: z.optional(z.string()),
        artifact_registry: z.optional(z.string()),
        has: z.optional(z.union([
            z.string(),
            z.array(z.enum([
                'patch',
                'deployment'
            ]))
        ])),
        runtime_risk: z.optional(z.string()),
        scope: z.optional(z.enum([
            'development',
            'runtime'
        ])),
        sort: z.optional(z.enum([
            'created',
            'updated',
            'epss_percentage'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zDependabotListAlertsForOrgResponse = z.array(zDependabotAlertWithRepository);

export const zDependabotListOrgSecretsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zDependabotListOrgSecretsResponse = z.object({
    total_count: z.int(),
    secrets: z.array(zOrganizationDependabotSecret)
});

export const zDependabotGetOrgPublicKeyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zDependabotGetOrgPublicKeyResponse = zDependabotPublicKey;

export const zDependabotDeleteOrgSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zDependabotDeleteOrgSecretResponse = z.void();

export const zDependabotGetOrgSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zDependabotGetOrgSecretResponse = zOrganizationDependabotSecret;

export const zDependabotCreateOrUpdateOrgSecretData = z.object({
    body: z.object({
        encrypted_value: z.optional(z.string().regex(/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})$/)),
        key_id: z.optional(z.string()),
        visibility: z.enum([
            'all',
            'private',
            'selected'
        ]),
        selected_repository_ids: z.optional(z.array(z.union([
            z.int(),
            z.string()
        ])))
    }),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

export const zDependabotCreateOrUpdateOrgSecretResponse = z.union([
    zEmptyObject,
    z.void()
]);

export const zDependabotListSelectedReposForOrgSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zDependabotListSelectedReposForOrgSecretResponse = z.object({
    total_count: z.int(),
    repositories: z.array(zMinimalRepository)
});

export const zDependabotSetSelectedReposForOrgSecretData = z.object({
    body: z.object({
        selected_repository_ids: z.array(z.int())
    }),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zDependabotSetSelectedReposForOrgSecretResponse = z.void();

export const zDependabotRemoveSelectedRepoFromOrgSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response when repository was removed from the selected list
 */
export const zDependabotRemoveSelectedRepoFromOrgSecretResponse = z.void();

export const zDependabotAddSelectedRepoToOrgSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * No Content when repository was added to the selected list
 */
export const zDependabotAddSelectedRepoToOrgSecretResponse = z.void();

export const zPackagesListDockerMigrationConflictingPackagesForOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesListDockerMigrationConflictingPackagesForOrganizationResponse = z.array(zPackage);

export const zActivityListPublicOrgEventsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActivityListPublicOrgEventsResponse = z.array(zEvent);

export const zOrgsListFailedInvitationsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zOrgsListFailedInvitationsResponse = z.array(zOrganizationInvitation);

export const zOrgsListWebhooksData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zOrgsListWebhooksResponse = z.array(zOrgHook);

export const zOrgsCreateWebhookData = z.object({
    body: z.object({
        name: z.string(),
        config: z.object({
            url: zWebhookConfigUrl,
            content_type: z.optional(zWebhookConfigContentType),
            secret: z.optional(zWebhookConfigSecret),
            insecure_ssl: z.optional(zWebhookConfigInsecureSsl),
            username: z.optional(z.string()),
            password: z.optional(z.string())
        }),
        events: z.optional(z.array(z.string())).default(['push']),
        active: z.optional(z.boolean()).default(true)
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsCreateWebhookResponse = zOrgHook;

export const zOrgsDeleteWebhookData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        hook_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsDeleteWebhookResponse = z.void();

export const zOrgsGetWebhookData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        hook_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsGetWebhookResponse = zOrgHook;

export const zOrgsUpdateWebhookData = z.object({
    body: z.optional(z.object({
        config: z.optional(z.object({
            url: zWebhookConfigUrl,
            content_type: z.optional(zWebhookConfigContentType),
            secret: z.optional(zWebhookConfigSecret),
            insecure_ssl: z.optional(zWebhookConfigInsecureSsl)
        })),
        events: z.optional(z.array(z.string())).default(['push']),
        active: z.optional(z.boolean()).default(true),
        name: z.optional(z.string())
    })),
    path: z.object({
        org: z.string(),
        hook_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsUpdateWebhookResponse = zOrgHook;

export const zOrgsGetWebhookConfigForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        hook_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsGetWebhookConfigForOrgResponse = zWebhookConfig;

export const zOrgsUpdateWebhookConfigForOrgData = z.object({
    body: z.optional(z.object({
        url: z.optional(zWebhookConfigUrl),
        content_type: z.optional(zWebhookConfigContentType),
        secret: z.optional(zWebhookConfigSecret),
        insecure_ssl: z.optional(zWebhookConfigInsecureSsl)
    })),
    path: z.object({
        org: z.string(),
        hook_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsUpdateWebhookConfigForOrgResponse = zWebhookConfig;

export const zOrgsListWebhookDeliveriesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        hook_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        cursor: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zOrgsListWebhookDeliveriesResponse = z.array(zHookDeliveryItem);

export const zOrgsGetWebhookDeliveryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        hook_id: z.int(),
        delivery_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsGetWebhookDeliveryResponse = zHookDelivery;

export const zOrgsRedeliverWebhookDeliveryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        hook_id: z.int(),
        delivery_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Accepted
 */
export const zOrgsRedeliverWebhookDeliveryResponse = z.record(z.string(), z.unknown());

export const zOrgsPingWebhookData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        hook_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsPingWebhookResponse = z.void();

export const zApiInsightsGetRouteStatsByActorData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        actor_type: z.enum([
            'installation',
            'classic_pat',
            'fine_grained_pat',
            'oauth_app',
            'github_app_user_to_server'
        ]),
        actor_id: z.int()
    }),
    query: z.object({
        min_timestamp: z.string(),
        max_timestamp: z.optional(z.string()),
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        sort: z.optional(z.array(z.enum([
            'last_rate_limited_timestamp',
            'last_request_timestamp',
            'rate_limited_request_count',
            'http_method',
            'api_route',
            'total_request_count'
        ]))),
        api_route_substring: z.optional(z.string())
    })
});

/**
 * Response
 */
export const zApiInsightsGetRouteStatsByActorResponse = zApiInsightsRouteStats;

export const zApiInsightsGetSubjectStatsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.object({
        min_timestamp: z.string(),
        max_timestamp: z.optional(z.string()),
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        sort: z.optional(z.array(z.enum([
            'last_rate_limited_timestamp',
            'last_request_timestamp',
            'rate_limited_request_count',
            'subject_name',
            'total_request_count'
        ]))),
        subject_name_substring: z.optional(z.string())
    })
});

/**
 * Response
 */
export const zApiInsightsGetSubjectStatsResponse = zApiInsightsSubjectStats;

export const zApiInsightsGetSummaryStatsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.object({
        min_timestamp: z.string(),
        max_timestamp: z.optional(z.string())
    })
});

/**
 * Response
 */
export const zApiInsightsGetSummaryStatsResponse = zApiInsightsSummaryStats;

export const zApiInsightsGetSummaryStatsByUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        user_id: z.string()
    }),
    query: z.object({
        min_timestamp: z.string(),
        max_timestamp: z.optional(z.string())
    })
});

/**
 * Response
 */
export const zApiInsightsGetSummaryStatsByUserResponse = zApiInsightsSummaryStats;

export const zApiInsightsGetSummaryStatsByActorData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        actor_type: z.enum([
            'installation',
            'classic_pat',
            'fine_grained_pat',
            'oauth_app',
            'github_app_user_to_server'
        ]),
        actor_id: z.int()
    }),
    query: z.object({
        min_timestamp: z.string(),
        max_timestamp: z.optional(z.string())
    })
});

/**
 * Response
 */
export const zApiInsightsGetSummaryStatsByActorResponse = zApiInsightsSummaryStats;

export const zApiInsightsGetTimeStatsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.object({
        min_timestamp: z.string(),
        max_timestamp: z.optional(z.string()),
        timestamp_increment: z.string()
    })
});

/**
 * Response
 */
export const zApiInsightsGetTimeStatsResponse = zApiInsightsTimeStats;

export const zApiInsightsGetTimeStatsByUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        user_id: z.string()
    }),
    query: z.object({
        min_timestamp: z.string(),
        max_timestamp: z.optional(z.string()),
        timestamp_increment: z.string()
    })
});

/**
 * Response
 */
export const zApiInsightsGetTimeStatsByUserResponse = zApiInsightsTimeStats;

export const zApiInsightsGetTimeStatsByActorData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        actor_type: z.enum([
            'installation',
            'classic_pat',
            'fine_grained_pat',
            'oauth_app',
            'github_app_user_to_server'
        ]),
        actor_id: z.int()
    }),
    query: z.object({
        min_timestamp: z.string(),
        max_timestamp: z.optional(z.string()),
        timestamp_increment: z.string()
    })
});

/**
 * Response
 */
export const zApiInsightsGetTimeStatsByActorResponse = zApiInsightsTimeStats;

export const zApiInsightsGetUserStatsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        user_id: z.string()
    }),
    query: z.object({
        min_timestamp: z.string(),
        max_timestamp: z.optional(z.string()),
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        sort: z.optional(z.array(z.enum([
            'last_rate_limited_timestamp',
            'last_request_timestamp',
            'rate_limited_request_count',
            'subject_name',
            'total_request_count'
        ]))),
        actor_name_substring: z.optional(z.string())
    })
});

/**
 * Response
 */
export const zApiInsightsGetUserStatsResponse = zApiInsightsUserStats;

export const zAppsGetOrgInstallationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsGetOrgInstallationResponse = zInstallation;

export const zOrgsListAppInstallationsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zOrgsListAppInstallationsResponse = z.object({
    total_count: z.int(),
    installations: z.array(zInstallation)
});

export const zInteractionsRemoveRestrictionsForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zInteractionsRemoveRestrictionsForOrgResponse = z.void();

export const zInteractionsGetRestrictionsForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zInteractionsGetRestrictionsForOrgResponse = z.union([
    zInteractionLimitResponse,
    z.record(z.string(), z.never())
]);

export const zInteractionsSetRestrictionsForOrgData = z.object({
    body: zInteractionLimit,
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zInteractionsSetRestrictionsForOrgResponse = zInteractionLimitResponse;

export const zOrgsListPendingInvitationsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        role: z.optional(z.enum([
            'all',
            'admin',
            'direct_member',
            'billing_manager',
            'hiring_manager'
        ])),
        invitation_source: z.optional(z.enum([
            'all',
            'member',
            'scim'
        ]))
    }))
});

/**
 * Response
 */
export const zOrgsListPendingInvitationsResponse = z.array(zOrganizationInvitation);

export const zOrgsCreateInvitationData = z.object({
    body: z.optional(z.object({
        invitee_id: z.optional(z.int()),
        email: z.optional(z.string()),
        role: z.optional(z.enum([
            'admin',
            'direct_member',
            'billing_manager',
            'reinstate'
        ])),
        team_ids: z.optional(z.array(z.int()))
    })),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsCreateInvitationResponse = zOrganizationInvitation;

export const zOrgsCancelInvitationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        invitation_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsCancelInvitationResponse = z.void();

export const zOrgsListInvitationTeamsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        invitation_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zOrgsListInvitationTeamsResponse = z.array(zTeam);

export const zOrgsListIssueTypesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsListIssueTypesResponse = z.array(zIssueType);

export const zOrgsCreateIssueTypeData = z.object({
    body: zOrganizationCreateIssueType,
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsCreateIssueTypeResponse = zIssueType;

export const zOrgsDeleteIssueTypeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        issue_type_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsDeleteIssueTypeResponse = z.void();

export const zOrgsUpdateIssueTypeData = z.object({
    body: zOrganizationUpdateIssueType,
    path: z.object({
        org: z.string(),
        issue_type_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsUpdateIssueTypeResponse = zIssueType;

export const zIssuesListForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        filter: z.optional(z.enum([
            'assigned',
            'created',
            'mentioned',
            'subscribed',
            'repos',
            'all'
        ])),
        state: z.optional(z.enum([
            'open',
            'closed',
            'all'
        ])),
        labels: z.optional(z.string()),
        type: z.optional(z.string()),
        sort: z.optional(z.enum([
            'created',
            'updated',
            'comments'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        since: z.optional(z.iso.datetime()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListForOrgResponse = z.array(zIssue);

export const zOrgsListMembersData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        filter: z.optional(z.enum([
            '2fa_disabled',
            '2fa_insecure',
            'all'
        ])),
        role: z.optional(z.enum([
            'all',
            'admin',
            'member'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zOrgsListMembersResponse = z.array(zSimpleUser);

export const zOrgsRemoveMemberData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsRemoveMemberResponse = z.void();

export const zOrgsCheckMembershipForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response if requester is an organization member and user is a member
 */
export const zOrgsCheckMembershipForUserResponse = z.void();

export const zCodespacesGetCodespacesForUserInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zCodespacesGetCodespacesForUserInOrgResponse = z.object({
    total_count: z.int(),
    codespaces: z.array(zCodespace)
});

export const zCodespacesDeleteFromOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string(),
        codespace_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Accepted
 */
export const zCodespacesDeleteFromOrganizationResponse = z.record(z.string(), z.unknown());

export const zCodespacesStopInOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string(),
        codespace_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesStopInOrganizationResponse = zCodespace;

export const zCopilotGetCopilotSeatDetailsForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The user's GitHub Copilot seat details, including usage.
 */
export const zCopilotGetCopilotSeatDetailsForUserResponse = zCopilotSeatDetails;

export const zOrgsRemoveMembershipForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsRemoveMembershipForUserResponse = z.void();

export const zOrgsGetMembershipForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsGetMembershipForUserResponse = zOrgMembership;

export const zOrgsSetMembershipForUserData = z.object({
    body: z.optional(z.object({
        role: z.optional(z.enum([
            'admin',
            'member'
        ]))
    })),
    path: z.object({
        org: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsSetMembershipForUserResponse = zOrgMembership;

export const zMigrationsListForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        exclude: z.optional(z.array(z.enum([
            'repositories'
        ])))
    }))
});

/**
 * Response
 */
export const zMigrationsListForOrgResponse = z.array(zMigration);

export const zMigrationsStartForOrgData = z.object({
    body: z.object({
        repositories: z.array(z.string()),
        lock_repositories: z.optional(z.boolean()).default(false),
        exclude_metadata: z.optional(z.boolean()).default(false),
        exclude_git_data: z.optional(z.boolean()).default(false),
        exclude_attachments: z.optional(z.boolean()).default(false),
        exclude_releases: z.optional(z.boolean()).default(false),
        exclude_owner_projects: z.optional(z.boolean()).default(false),
        org_metadata_only: z.optional(z.boolean()).default(false),
        exclude: z.optional(z.array(z.enum([
            'repositories'
        ])))
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMigrationsStartForOrgResponse = zMigration;

export const zMigrationsGetStatusForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        migration_id: z.int()
    }),
    query: z.optional(z.object({
        exclude: z.optional(z.array(z.enum([
            'repositories'
        ])))
    }))
});

/**
 * *   `pending`, which means the migration hasn't started yet.
 * *   `exporting`, which means the migration is in progress.
 * *   `exported`, which means the migration finished successfully.
 * *   `failed`, which means the migration failed.
 */
export const zMigrationsGetStatusForOrgResponse = zMigration;

export const zMigrationsDeleteArchiveForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        migration_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMigrationsDeleteArchiveForOrgResponse = z.void();

export const zMigrationsDownloadArchiveForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        migration_id: z.int()
    }),
    query: z.optional(z.never())
});

export const zMigrationsUnlockRepoForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        migration_id: z.int(),
        repo_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMigrationsUnlockRepoForOrgResponse = z.void();

export const zMigrationsListReposForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        migration_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zMigrationsListReposForOrgResponse = z.array(zMinimalRepository);

export const zOrgsListOrgRolesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response - list of organization roles
 */
export const zOrgsListOrgRolesResponse = z.object({
    total_count: z.optional(z.int()),
    roles: z.optional(z.array(zOrganizationRole))
});

export const zOrgsRevokeAllOrgRolesTeamData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsRevokeAllOrgRolesTeamResponse = z.void();

export const zOrgsRevokeOrgRoleTeamData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        role_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsRevokeOrgRoleTeamResponse = z.void();

export const zOrgsAssignTeamToOrgRoleData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        role_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsAssignTeamToOrgRoleResponse = z.void();

export const zOrgsRevokeAllOrgRolesUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsRevokeAllOrgRolesUserResponse = z.void();

export const zOrgsRevokeOrgRoleUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string(),
        role_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsRevokeOrgRoleUserResponse = z.void();

export const zOrgsAssignUserToOrgRoleData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string(),
        role_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsAssignUserToOrgRoleResponse = z.void();

export const zOrgsGetOrgRoleData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        role_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsGetOrgRoleResponse = zOrganizationRole;

export const zOrgsListOrgRoleTeamsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        role_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * List of teams assigned to the organization role
 */
export const zOrgsListOrgRoleTeamsResponse = z.array(zTeamRoleAssignment);

export const zOrgsListOrgRoleUsersData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        role_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * List of users assigned to the organization role
 */
export const zOrgsListOrgRoleUsersResponse = z.array(zUserRoleAssignment);

export const zOrgsListOutsideCollaboratorsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        filter: z.optional(z.enum([
            '2fa_disabled',
            '2fa_insecure',
            'all'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zOrgsListOutsideCollaboratorsResponse = z.array(zSimpleUser);

export const zOrgsRemoveOutsideCollaboratorData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsRemoveOutsideCollaboratorResponse = z.void();

export const zOrgsConvertMemberToOutsideCollaboratorData = z.object({
    body: z.optional(z.object({
        async: z.optional(z.boolean()).default(false)
    })),
    path: z.object({
        org: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

export const zOrgsConvertMemberToOutsideCollaboratorResponse = z.union([
    z.record(z.string(), z.never()),
    z.void()
]);

export const zPackagesListPackagesForOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        visibility: z.optional(z.enum([
            'public',
            'private',
            'internal'
        ])),
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    })
});

/**
 * Response
 */
export const zPackagesListPackagesForOrganizationResponse = z.array(zPackage);

export const zPackagesDeletePackageForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesDeletePackageForOrgResponse = z.void();

export const zPackagesGetPackageForOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesGetPackageForOrganizationResponse = zPackage;

export const zPackagesRestorePackageForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        org: z.string()
    }),
    query: z.optional(z.object({
        token: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zPackagesRestorePackageForOrgResponse = z.void();

export const zPackagesGetAllPackageVersionsForPackageOwnedByOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        org: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30),
        state: z.optional(z.enum([
            'active',
            'deleted'
        ]))
    }))
});

/**
 * Response
 */
export const zPackagesGetAllPackageVersionsForPackageOwnedByOrgResponse = z.array(zPackageVersion);

export const zPackagesDeletePackageVersionForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        org: z.string(),
        package_version_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesDeletePackageVersionForOrgResponse = z.void();

export const zPackagesGetPackageVersionForOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        org: z.string(),
        package_version_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesGetPackageVersionForOrganizationResponse = zPackageVersion;

export const zPackagesRestorePackageVersionForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        org: z.string(),
        package_version_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesRestorePackageVersionForOrgResponse = z.void();

export const zOrgsListPatGrantRequestsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        sort: z.optional(z.enum([
            'created_at'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        owner: z.optional(z.array(z.string()).max(10)),
        repository: z.optional(z.string()),
        permission: z.optional(z.string()),
        last_used_before: z.optional(z.iso.datetime()),
        last_used_after: z.optional(z.iso.datetime()),
        token_id: z.optional(z.array(z.string()).max(50))
    }))
});

/**
 * Response
 */
export const zOrgsListPatGrantRequestsResponse = z.array(zOrganizationProgrammaticAccessGrantRequest);

export const zOrgsReviewPatGrantRequestsInBulkData = z.object({
    body: z.object({
        pat_request_ids: z.optional(z.array(z.int()).min(1).max(100)),
        action: z.enum([
            'approve',
            'deny'
        ]),
        reason: z.optional(z.union([
            z.string().max(1024),
            z.null()
        ]))
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Accepted
 */
export const zOrgsReviewPatGrantRequestsInBulkResponse = z.record(z.string(), z.unknown());

export const zOrgsReviewPatGrantRequestData = z.object({
    body: z.object({
        action: z.enum([
            'approve',
            'deny'
        ]),
        reason: z.optional(z.union([
            z.string().max(1024),
            z.null()
        ]))
    }),
    path: z.object({
        org: z.string(),
        pat_request_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A header with no content is returned.
 */
export const zOrgsReviewPatGrantRequestResponse = z.void();

export const zOrgsListPatGrantRequestRepositoriesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        pat_request_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zOrgsListPatGrantRequestRepositoriesResponse = z.array(zMinimalRepository);

export const zOrgsListPatGrantsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        sort: z.optional(z.enum([
            'created_at'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        owner: z.optional(z.array(z.string()).max(10)),
        repository: z.optional(z.string()),
        permission: z.optional(z.string()),
        last_used_before: z.optional(z.iso.datetime()),
        last_used_after: z.optional(z.iso.datetime()),
        token_id: z.optional(z.array(z.string()).max(50))
    }))
});

/**
 * Response
 */
export const zOrgsListPatGrantsResponse = z.array(zOrganizationProgrammaticAccessGrant);

export const zOrgsUpdatePatAccessesData = z.object({
    body: z.object({
        action: z.enum([
            'revoke'
        ]),
        pat_ids: z.array(z.int()).min(1).max(100)
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Accepted
 */
export const zOrgsUpdatePatAccessesResponse = z.record(z.string(), z.unknown());

export const zOrgsUpdatePatAccessData = z.object({
    body: z.object({
        action: z.enum([
            'revoke'
        ])
    }),
    path: z.object({
        org: z.string(),
        pat_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A header with no content is returned.
 */
export const zOrgsUpdatePatAccessResponse = z.void();

export const zOrgsListPatGrantRepositoriesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        pat_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zOrgsListPatGrantRepositoriesResponse = z.array(zMinimalRepository);

export const zPrivateRegistriesListOrgPrivateRegistriesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zPrivateRegistriesListOrgPrivateRegistriesResponse = z.object({
    total_count: z.int(),
    configurations: z.array(zOrgPrivateRegistryConfiguration)
});

export const zPrivateRegistriesCreateOrgPrivateRegistryData = z.object({
    body: z.object({
        registry_type: z.enum([
            'maven_repository',
            'nuget_feed',
            'goproxy_server',
            'npm_registry',
            'rubygems_server',
            'cargo_registry',
            'composer_repository',
            'docker_registry',
            'git_source',
            'helm_registry',
            'hex_organization',
            'hex_repository',
            'pub_repository',
            'python_index',
            'terraform_registry'
        ]),
        url: z.url(),
        username: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        encrypted_value: z.string().regex(/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})$/),
        key_id: z.string(),
        visibility: z.enum([
            'all',
            'private',
            'selected'
        ]),
        selected_repository_ids: z.optional(z.array(z.int()))
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The organization private registry configuration
 */
export const zPrivateRegistriesCreateOrgPrivateRegistryResponse = zOrgPrivateRegistryConfigurationWithSelectedRepositories;

export const zPrivateRegistriesGetOrgPublicKeyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPrivateRegistriesGetOrgPublicKeyResponse = z.object({
    key_id: z.string(),
    key: z.string()
});

export const zPrivateRegistriesDeleteOrgPrivateRegistryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPrivateRegistriesDeleteOrgPrivateRegistryResponse = z.void();

export const zPrivateRegistriesGetOrgPrivateRegistryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The specified private registry configuration for the organization
 */
export const zPrivateRegistriesGetOrgPrivateRegistryResponse = zOrgPrivateRegistryConfiguration;

export const zPrivateRegistriesUpdateOrgPrivateRegistryData = z.object({
    body: z.object({
        registry_type: z.optional(z.enum([
            'maven_repository',
            'nuget_feed',
            'goproxy_server',
            'npm_registry',
            'rubygems_server',
            'cargo_registry',
            'composer_repository',
            'docker_registry',
            'git_source',
            'helm_registry',
            'hex_organization',
            'hex_repository',
            'pub_repository',
            'python_index',
            'terraform_registry'
        ])),
        url: z.optional(z.url()),
        username: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        encrypted_value: z.optional(z.string().regex(/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})$/)),
        key_id: z.optional(z.string()),
        visibility: z.optional(z.enum([
            'all',
            'private',
            'selected'
        ])),
        selected_repository_ids: z.optional(z.array(z.int()))
    }),
    path: z.object({
        org: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPrivateRegistriesUpdateOrgPrivateRegistryResponse = z.void();

export const zProjectsClassicListForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        state: z.optional(z.enum([
            'open',
            'closed',
            'all'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zProjectsClassicListForOrgResponse = z.array(zProject);

export const zProjectsClassicCreateForOrgData = z.object({
    body: z.object({
        name: z.string(),
        body: z.optional(z.string())
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsClassicCreateForOrgResponse = zProject;

export const zProjectsListForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        q: z.optional(z.string()),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zProjectsListForOrgResponse = z.array(zProjectsV2);

export const zProjectsGetForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_number: z.int(),
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsGetForOrgResponse = zProjectsV2;

export const zProjectsListFieldsForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_number: z.int(),
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        before: z.optional(z.string()),
        after: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zProjectsListFieldsForOrgResponse = z.array(zProjectsV2Field);

export const zProjectsGetFieldForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_number: z.int(),
        field_id: z.int(),
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsGetFieldForOrgResponse = zProjectsV2Field;

export const zProjectsListItemsForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_number: z.int(),
        org: z.string()
    }),
    query: z.optional(z.object({
        q: z.optional(z.string()),
        fields: z.optional(z.union([
            z.string(),
            z.array(z.string()).max(50)
        ])),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zProjectsListItemsForOrgResponse = z.array(zProjectsV2ItemWithContent);

export const zProjectsAddItemForOrgData = z.object({
    body: z.object({
        type: z.enum([
            'Issue',
            'PullRequest'
        ]),
        id: z.int()
    }),
    path: z.object({
        org: z.string(),
        project_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsAddItemForOrgResponse = zProjectsV2ItemSimple;

export const zProjectsDeleteItemForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_number: z.int(),
        org: z.string(),
        item_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsDeleteItemForOrgResponse = z.void();

export const zProjectsGetOrgItemData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_number: z.int(),
        org: z.string(),
        item_id: z.int()
    }),
    query: z.optional(z.object({
        fields: z.optional(z.union([
            z.string(),
            z.array(z.string()).max(50)
        ]))
    }))
});

/**
 * Response
 */
export const zProjectsGetOrgItemResponse = zProjectsV2ItemWithContent;

export const zProjectsUpdateItemForOrgData = z.object({
    body: z.object({
        fields: z.array(z.object({
            id: z.int(),
            value: z.union([
                z.string(),
                z.number(),
                z.null()
            ])
        }))
    }),
    path: z.object({
        project_number: z.int(),
        org: z.string(),
        item_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsUpdateItemForOrgResponse = zProjectsV2ItemWithContent;

export const zOrgsCustomPropertiesForReposGetOrganizationDefinitionsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsCustomPropertiesForReposGetOrganizationDefinitionsResponse = z.array(zCustomProperty);

export const zOrgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinitionsData = z.object({
    body: z.object({
        properties: z.array(zCustomProperty).min(1).max(100)
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinitionsResponse = z.array(zCustomProperty);

export const zOrgsCustomPropertiesForReposDeleteOrganizationDefinitionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        custom_property_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * A header with no content is returned.
 */
export const zOrgsCustomPropertiesForReposDeleteOrganizationDefinitionResponse = z.void();

export const zOrgsCustomPropertiesForReposGetOrganizationDefinitionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        custom_property_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsCustomPropertiesForReposGetOrganizationDefinitionResponse = zCustomProperty;

export const zOrgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinitionData = z.object({
    body: zCustomPropertySetPayload,
    path: z.object({
        org: z.string(),
        custom_property_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinitionResponse = zCustomProperty;

export const zOrgsCustomPropertiesForReposGetOrganizationValuesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        repository_query: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zOrgsCustomPropertiesForReposGetOrganizationValuesResponse = z.array(zOrgRepoCustomPropertyValues);

export const zOrgsCustomPropertiesForReposCreateOrUpdateOrganizationValuesData = z.object({
    body: z.object({
        repository_names: z.array(z.string()).min(1).max(30),
        properties: z.array(zCustomPropertyValue)
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * No Content when custom property values are successfully created or updated
 */
export const zOrgsCustomPropertiesForReposCreateOrUpdateOrganizationValuesResponse = z.void();

export const zOrgsListPublicMembersData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zOrgsListPublicMembersResponse = z.array(zSimpleUser);

export const zOrgsRemovePublicMembershipForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsRemovePublicMembershipForAuthenticatedUserResponse = z.void();

export const zOrgsCheckPublicMembershipForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response if user is a public member
 */
export const zOrgsCheckPublicMembershipForUserResponse = z.void();

export const zOrgsSetPublicMembershipForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsSetPublicMembershipForAuthenticatedUserResponse = z.void();

export const zReposListForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        type: z.optional(z.enum([
            'all',
            'public',
            'private',
            'forks',
            'sources',
            'member'
        ])),
        sort: z.optional(z.enum([
            'created',
            'updated',
            'pushed',
            'full_name'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListForOrgResponse = z.array(zMinimalRepository);

export const zReposCreateInOrgData = z.object({
    body: z.object({
        name: z.string(),
        description: z.optional(z.string()),
        homepage: z.optional(z.string()),
        private: z.optional(z.boolean()).default(false),
        visibility: z.optional(z.enum([
            'public',
            'private'
        ])),
        has_issues: z.optional(z.boolean()).default(true),
        has_projects: z.optional(z.boolean()).default(true),
        has_wiki: z.optional(z.boolean()).default(true),
        has_downloads: z.optional(z.boolean()).default(true),
        is_template: z.optional(z.boolean()).default(false),
        team_id: z.optional(z.int()),
        auto_init: z.optional(z.boolean()).default(false),
        gitignore_template: z.optional(z.string()),
        license_template: z.optional(z.string()),
        allow_squash_merge: z.optional(z.boolean()).default(true),
        allow_merge_commit: z.optional(z.boolean()).default(true),
        allow_rebase_merge: z.optional(z.boolean()).default(true),
        allow_auto_merge: z.optional(z.boolean()).default(false),
        delete_branch_on_merge: z.optional(z.boolean()).default(false),
        use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
        squash_merge_commit_title: z.optional(z.enum([
            'PR_TITLE',
            'COMMIT_OR_PR_TITLE'
        ])),
        squash_merge_commit_message: z.optional(z.enum([
            'PR_BODY',
            'COMMIT_MESSAGES',
            'BLANK'
        ])),
        merge_commit_title: z.optional(z.enum([
            'PR_TITLE',
            'MERGE_MESSAGE'
        ])),
        merge_commit_message: z.optional(z.enum([
            'PR_BODY',
            'PR_TITLE',
            'BLANK'
        ])),
        custom_properties: z.optional(z.record(z.string(), z.unknown()))
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateInOrgResponse = zFullRepository;

export const zReposGetOrgRulesetsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        targets: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zReposGetOrgRulesetsResponse = z.array(zRepositoryRuleset);

export const zReposCreateOrgRulesetData = z.object({
    body: z.object({
        name: z.string(),
        target: z.optional(z.enum([
            'branch',
            'tag',
            'push',
            'repository'
        ])),
        enforcement: zRepositoryRuleEnforcement,
        bypass_actors: z.optional(z.array(zRepositoryRulesetBypassActor)),
        conditions: z.optional(zOrgRulesetConditions),
        rules: z.optional(z.array(zOrgRules))
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateOrgRulesetResponse = zRepositoryRuleset;

export const zReposGetOrgRuleSuitesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        ref: z.optional(z.string()),
        repository_name: z.optional(z.string()),
        time_period: z.optional(z.enum([
            'hour',
            'day',
            'week',
            'month'
        ])),
        actor_name: z.optional(z.string()),
        rule_suite_result: z.optional(z.enum([
            'pass',
            'fail',
            'bypass',
            'all'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposGetOrgRuleSuitesResponse = zRuleSuites;

export const zReposGetOrgRuleSuiteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        rule_suite_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetOrgRuleSuiteResponse = zRuleSuite;

export const zReposDeleteOrgRulesetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        ruleset_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteOrgRulesetResponse = z.void();

export const zReposGetOrgRulesetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        ruleset_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetOrgRulesetResponse = zRepositoryRuleset;

export const zReposUpdateOrgRulesetData = z.object({
    body: z.optional(z.object({
        name: z.optional(z.string()),
        target: z.optional(z.enum([
            'branch',
            'tag',
            'push',
            'repository'
        ])),
        enforcement: z.optional(zRepositoryRuleEnforcement),
        bypass_actors: z.optional(z.array(zRepositoryRulesetBypassActor)),
        conditions: z.optional(zOrgRulesetConditions),
        rules: z.optional(z.array(zOrgRules))
    })),
    path: z.object({
        org: z.string(),
        ruleset_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposUpdateOrgRulesetResponse = zRepositoryRuleset;

export const zOrgsGetOrgRulesetHistoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        ruleset_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zOrgsGetOrgRulesetHistoryResponse = z.array(zRulesetVersion);

export const zOrgsGetOrgRulesetVersionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        ruleset_id: z.int(),
        version_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsGetOrgRulesetVersionResponse = zRulesetVersionWithState;

export const zSecretScanningListAlertsForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        state: z.optional(z.enum([
            'open',
            'resolved'
        ])),
        secret_type: z.optional(z.string()),
        resolution: z.optional(z.string()),
        sort: z.optional(z.enum([
            'created',
            'updated'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        validity: z.optional(z.string()),
        is_publicly_leaked: z.optional(z.boolean()).default(false),
        is_multi_repo: z.optional(z.boolean()).default(false),
        hide_secret: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Response
 */
export const zSecretScanningListAlertsForOrgResponse = z.array(zOrganizationSecretScanningAlert);

export const zSecretScanningListOrgPatternConfigsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zSecretScanningListOrgPatternConfigsResponse = zSecretScanningPatternConfiguration;

export const zSecretScanningUpdateOrgPatternConfigsData = z.object({
    body: z.object({
        pattern_config_version: z.optional(zSecretScanningRowVersion),
        provider_pattern_settings: z.optional(z.array(z.object({
            token_type: z.optional(z.string()),
            push_protection_setting: z.optional(z.enum([
                'not-set',
                'disabled',
                'enabled'
            ]))
        }))),
        custom_pattern_settings: z.optional(z.array(z.object({
            token_type: z.optional(z.string()),
            custom_pattern_version: z.optional(zSecretScanningRowVersion),
            push_protection_setting: z.optional(z.enum([
                'disabled',
                'enabled'
            ]))
        })))
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zSecretScanningUpdateOrgPatternConfigsResponse = z.object({
    pattern_config_version: z.optional(z.string())
});

export const zSecurityAdvisoriesListOrgRepositoryAdvisoriesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        sort: z.optional(z.enum([
            'created',
            'updated',
            'published'
        ])),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        per_page: z.optional(z.int().gte(1).lte(100)).default(30),
        state: z.optional(z.enum([
            'triage',
            'draft',
            'published',
            'closed'
        ]))
    }))
});

/**
 * Response
 */
export const zSecurityAdvisoriesListOrgRepositoryAdvisoriesResponse = z.array(zRepositoryAdvisory);

export const zOrgsListSecurityManagerTeamsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsListSecurityManagerTeamsResponse = z.array(zTeamSimple);

export const zOrgsRemoveSecurityManagerTeamData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsRemoveSecurityManagerTeamResponse = z.void();

export const zOrgsAddSecurityManagerTeamData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsAddSecurityManagerTeamResponse = z.void();

export const zBillingGetGithubActionsBillingOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zBillingGetGithubActionsBillingOrgResponse = zActionsBillingUsage;

export const zBillingGetGithubPackagesBillingOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zBillingGetGithubPackagesBillingOrgResponse = zPackagesBillingUsage;

export const zBillingGetSharedStorageBillingOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zBillingGetSharedStorageBillingOrgResponse = zCombinedBillingUsage;

export const zOrgsGetImmutableReleasesSettingsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Immutable releases settings response
 */
export const zOrgsGetImmutableReleasesSettingsResponse = zImmutableReleasesOrganizationSettings;

export const zOrgsSetImmutableReleasesSettingsData = z.object({
    body: z.object({
        enforced_repositories: z.enum([
            'all',
            'none',
            'selected'
        ]),
        selected_repository_ids: z.optional(z.array(z.int()))
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsSetImmutableReleasesSettingsResponse = z.void();

export const zOrgsGetImmutableReleasesSettingsRepositoriesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zOrgsGetImmutableReleasesSettingsRepositoriesResponse = z.object({
    total_count: z.int(),
    repositories: z.array(zMinimalRepository)
});

export const zOrgsSetImmutableReleasesSettingsRepositoriesData = z.object({
    body: z.object({
        selected_repository_ids: z.array(z.int())
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsSetImmutableReleasesSettingsRepositoriesResponse = z.void();

export const zOrgsDisableSelectedRepositoryImmutableReleasesOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsDisableSelectedRepositoryImmutableReleasesOrganizationResponse = z.void();

export const zOrgsEnableSelectedRepositoryImmutableReleasesOrganizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsEnableSelectedRepositoryImmutableReleasesOrganizationResponse = z.void();

export const zHostedComputeListNetworkConfigurationsForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zHostedComputeListNetworkConfigurationsForOrgResponse = z.object({
    total_count: z.int(),
    network_configurations: z.array(zNetworkConfiguration)
});

export const zHostedComputeCreateNetworkConfigurationForOrgData = z.object({
    body: z.object({
        name: z.string(),
        compute_service: z.optional(z.enum([
            'none',
            'actions'
        ])),
        network_settings_ids: z.tuple([
            z.string()
        ])
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zHostedComputeCreateNetworkConfigurationForOrgResponse = zNetworkConfiguration;

export const zHostedComputeDeleteNetworkConfigurationFromOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        network_configuration_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zHostedComputeDeleteNetworkConfigurationFromOrgResponse = z.void();

export const zHostedComputeGetNetworkConfigurationForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        network_configuration_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zHostedComputeGetNetworkConfigurationForOrgResponse = zNetworkConfiguration;

export const zHostedComputeUpdateNetworkConfigurationForOrgData = z.object({
    body: z.object({
        name: z.optional(z.string()),
        compute_service: z.optional(z.enum([
            'none',
            'actions'
        ])),
        network_settings_ids: z.optional(z.array(z.string()).min(0).max(1))
    }),
    path: z.object({
        org: z.string(),
        network_configuration_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zHostedComputeUpdateNetworkConfigurationForOrgResponse = zNetworkConfiguration;

export const zHostedComputeGetNetworkSettingsForOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        network_settings_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zHostedComputeGetNetworkSettingsForOrgResponse = zNetworkSettings;

export const zCopilotCopilotMetricsForTeamData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.object({
        since: z.optional(z.string()),
        until: z.optional(z.string()),
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(100)
    }))
});

/**
 * Response
 */
export const zCopilotCopilotMetricsForTeamResponse = z.array(zCopilotUsageMetricsDay);

export const zTeamsListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zTeamsListResponse = z.array(zTeam);

export const zTeamsCreateData = z.object({
    body: z.object({
        name: z.string(),
        description: z.optional(z.string()),
        maintainers: z.optional(z.array(z.string())),
        repo_names: z.optional(z.array(z.string())),
        privacy: z.optional(z.enum([
            'secret',
            'closed'
        ])),
        notification_setting: z.optional(z.enum([
            'notifications_enabled',
            'notifications_disabled'
        ])),
        permission: z.optional(z.enum([
            'pull',
            'push'
        ])),
        parent_team_id: z.optional(z.int())
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsCreateResponse = zTeamFull;

export const zTeamsDeleteInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsDeleteInOrgResponse = z.void();

export const zTeamsGetByNameData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsGetByNameResponse = zTeamFull;

export const zTeamsUpdateInOrgData = z.object({
    body: z.optional(z.object({
        name: z.optional(z.string()),
        description: z.optional(z.string()),
        privacy: z.optional(z.enum([
            'secret',
            'closed'
        ])),
        notification_setting: z.optional(z.enum([
            'notifications_enabled',
            'notifications_disabled'
        ])),
        permission: z.optional(z.enum([
            'pull',
            'push',
            'admin'
        ])),
        parent_team_id: z.optional(z.union([
            z.int(),
            z.null()
        ]))
    })),
    path: z.object({
        org: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response when the updated information already exists
 */
export const zTeamsUpdateInOrgResponse = zTeamFull;

export const zTeamsListDiscussionsInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.object({
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        pinned: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zTeamsListDiscussionsInOrgResponse = z.array(zTeamDiscussion);

export const zTeamsCreateDiscussionInOrgData = z.object({
    body: z.object({
        title: z.string(),
        body: z.string(),
        private: z.optional(z.boolean()).default(false)
    }),
    path: z.object({
        org: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsCreateDiscussionInOrgResponse = zTeamDiscussion;

export const zTeamsDeleteDiscussionInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        discussion_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsDeleteDiscussionInOrgResponse = z.void();

export const zTeamsGetDiscussionInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        discussion_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsGetDiscussionInOrgResponse = zTeamDiscussion;

export const zTeamsUpdateDiscussionInOrgData = z.object({
    body: z.optional(z.object({
        title: z.optional(z.string()),
        body: z.optional(z.string())
    })),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        discussion_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsUpdateDiscussionInOrgResponse = zTeamDiscussion;

export const zTeamsListDiscussionCommentsInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        discussion_number: z.int()
    }),
    query: z.optional(z.object({
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zTeamsListDiscussionCommentsInOrgResponse = z.array(zTeamDiscussionComment);

export const zTeamsCreateDiscussionCommentInOrgData = z.object({
    body: z.object({
        body: z.string()
    }),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        discussion_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsCreateDiscussionCommentInOrgResponse = zTeamDiscussionComment;

export const zTeamsDeleteDiscussionCommentInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        discussion_number: z.int(),
        comment_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsDeleteDiscussionCommentInOrgResponse = z.void();

export const zTeamsGetDiscussionCommentInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        discussion_number: z.int(),
        comment_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsGetDiscussionCommentInOrgResponse = zTeamDiscussionComment;

export const zTeamsUpdateDiscussionCommentInOrgData = z.object({
    body: z.object({
        body: z.string()
    }),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        discussion_number: z.int(),
        comment_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsUpdateDiscussionCommentInOrgResponse = zTeamDiscussionComment;

export const zReactionsListForTeamDiscussionCommentInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        discussion_number: z.int(),
        comment_number: z.int()
    }),
    query: z.optional(z.object({
        content: z.optional(z.enum([
            '+1',
            '-1',
            'laugh',
            'confused',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReactionsListForTeamDiscussionCommentInOrgResponse = z.array(zReaction);

export const zReactionsCreateForTeamDiscussionCommentInOrgData = z.object({
    body: z.object({
        content: z.enum([
            '+1',
            '-1',
            'laugh',
            'confused',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])
    }),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        discussion_number: z.int(),
        comment_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response when the reaction type has already been added to this team discussion comment
 */
export const zReactionsCreateForTeamDiscussionCommentInOrgResponse = zReaction;

export const zReactionsDeleteForTeamDiscussionCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        discussion_number: z.int(),
        comment_number: z.int(),
        reaction_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReactionsDeleteForTeamDiscussionCommentResponse = z.void();

export const zReactionsListForTeamDiscussionInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        discussion_number: z.int()
    }),
    query: z.optional(z.object({
        content: z.optional(z.enum([
            '+1',
            '-1',
            'laugh',
            'confused',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReactionsListForTeamDiscussionInOrgResponse = z.array(zReaction);

export const zReactionsCreateForTeamDiscussionInOrgData = z.object({
    body: z.object({
        content: z.enum([
            '+1',
            '-1',
            'laugh',
            'confused',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])
    }),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        discussion_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReactionsCreateForTeamDiscussionInOrgResponse = zReaction;

export const zReactionsDeleteForTeamDiscussionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        discussion_number: z.int(),
        reaction_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReactionsDeleteForTeamDiscussionResponse = z.void();

export const zTeamsListPendingInvitationsInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zTeamsListPendingInvitationsInOrgResponse = z.array(zOrganizationInvitation);

export const zTeamsListMembersInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.object({
        role: z.optional(z.enum([
            'member',
            'maintainer',
            'all'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zTeamsListMembersInOrgResponse = z.array(zSimpleUser);

export const zTeamsRemoveMembershipForUserInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsRemoveMembershipForUserInOrgResponse = z.void();

export const zTeamsGetMembershipForUserInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsGetMembershipForUserInOrgResponse = zTeamMembership;

export const zTeamsAddOrUpdateMembershipForUserInOrgData = z.object({
    body: z.optional(z.object({
        role: z.optional(z.enum([
            'member',
            'maintainer'
        ]))
    })),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsAddOrUpdateMembershipForUserInOrgResponse = zTeamMembership;

export const zTeamsListProjectsInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zTeamsListProjectsInOrgResponse = z.array(zTeamProject);

export const zTeamsRemoveProjectInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        project_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsRemoveProjectInOrgResponse = z.void();

export const zTeamsCheckPermissionsForProjectInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        project_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsCheckPermissionsForProjectInOrgResponse = zTeamProject;

export const zTeamsAddOrUpdateProjectPermissionsInOrgData = z.object({
    body: z.optional(z.union([
        z.object({
            permission: z.optional(z.enum([
                'read',
                'write',
                'admin'
            ]))
        }),
        z.null()
    ])),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        project_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsAddOrUpdateProjectPermissionsInOrgResponse = z.void();

export const zTeamsListReposInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zTeamsListReposInOrgResponse = z.array(zMinimalRepository);

export const zTeamsRemoveRepoInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsRemoveRepoInOrgResponse = z.void();

export const zTeamsCheckPermissionsForRepoInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

export const zTeamsCheckPermissionsForRepoInOrgResponse = z.union([
    zTeamRepository,
    z.void()
]);

export const zTeamsAddOrUpdateRepoPermissionsInOrgData = z.object({
    body: z.optional(z.object({
        permission: z.optional(z.string())
    })),
    path: z.object({
        org: z.string(),
        team_slug: z.string(),
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsAddOrUpdateRepoPermissionsInOrgResponse = z.void();

export const zTeamsListChildInOrgData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string(),
        team_slug: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * if child teams exist
 */
export const zTeamsListChildInOrgResponse = z.array(zTeam);

export const zOrgsEnableOrDisableSecurityProductOnAllOrgReposData = z.object({
    body: z.optional(z.object({
        query_suite: z.optional(z.enum([
            'default',
            'extended'
        ]))
    })),
    path: z.object({
        org: z.string(),
        security_product: z.enum([
            'dependency_graph',
            'dependabot_alerts',
            'dependabot_security_updates',
            'advanced_security',
            'code_scanning_default_setup',
            'secret_scanning',
            'secret_scanning_push_protection'
        ]),
        enablement: z.enum([
            'enable_all',
            'disable_all'
        ])
    }),
    query: z.optional(z.never())
});

/**
 * Action started
 */
export const zOrgsEnableOrDisableSecurityProductOnAllOrgReposResponse = z.void();

export const zProjectsClassicDeleteColumnData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        column_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsClassicDeleteColumnResponse = z.void();

export const zProjectsClassicGetColumnData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        column_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsClassicGetColumnResponse = zProjectColumn;

export const zProjectsClassicUpdateColumnData = z.object({
    body: z.object({
        name: z.string()
    }),
    path: z.object({
        column_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsClassicUpdateColumnResponse = zProjectColumn;

export const zProjectsClassicMoveColumnData = z.object({
    body: z.object({
        position: z.string().regex(/^(?:first|last|after:\d+)$/)
    }),
    path: z.object({
        column_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsClassicMoveColumnResponse = z.record(z.string(), z.never());

export const zProjectsClassicDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Delete Success
 */
export const zProjectsClassicDeleteResponse = z.void();

export const zProjectsClassicGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsClassicGetResponse = zProject;

export const zProjectsClassicUpdateData = z.object({
    body: z.optional(z.object({
        name: z.optional(z.string()),
        body: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        state: z.optional(z.string()),
        organization_permission: z.optional(z.enum([
            'read',
            'write',
            'admin',
            'none'
        ])),
        private: z.optional(z.boolean())
    })),
    path: z.object({
        project_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsClassicUpdateResponse = zProject;

export const zProjectsClassicListCollaboratorsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_id: z.int()
    }),
    query: z.optional(z.object({
        affiliation: z.optional(z.enum([
            'outside',
            'direct',
            'all'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zProjectsClassicListCollaboratorsResponse = z.array(zSimpleUser);

export const zProjectsClassicRemoveCollaboratorData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_id: z.int(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsClassicRemoveCollaboratorResponse = z.void();

export const zProjectsClassicAddCollaboratorData = z.object({
    body: z.optional(z.union([
        z.object({
            permission: z.optional(z.enum([
                'read',
                'write',
                'admin'
            ]))
        }),
        z.null()
    ])),
    path: z.object({
        project_id: z.int(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsClassicAddCollaboratorResponse = z.void();

export const zProjectsClassicGetPermissionForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_id: z.int(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsClassicGetPermissionForUserResponse = zProjectCollaboratorPermission;

export const zProjectsClassicListColumnsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zProjectsClassicListColumnsResponse = z.array(zProjectColumn);

export const zProjectsClassicCreateColumnData = z.object({
    body: z.object({
        name: z.string()
    }),
    path: z.object({
        project_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsClassicCreateColumnResponse = zProjectColumn;

export const zRateLimitGetData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zRateLimitGetResponse = zRateLimitOverview;

export const zReposDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteResponse = z.void();

export const zReposGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetResponse = zFullRepository;

export const zReposUpdateData = z.object({
    body: z.optional(z.object({
        name: z.optional(z.string()),
        description: z.optional(z.string()),
        homepage: z.optional(z.string()),
        private: z.optional(z.boolean()).default(false),
        visibility: z.optional(z.enum([
            'public',
            'private'
        ])),
        security_and_analysis: z.optional(z.union([
            z.object({
                advanced_security: z.optional(z.object({
                    status: z.optional(z.string())
                })),
                code_security: z.optional(z.object({
                    status: z.optional(z.string())
                })),
                secret_scanning: z.optional(z.object({
                    status: z.optional(z.string())
                })),
                secret_scanning_push_protection: z.optional(z.object({
                    status: z.optional(z.string())
                })),
                secret_scanning_ai_detection: z.optional(z.object({
                    status: z.optional(z.string())
                })),
                secret_scanning_non_provider_patterns: z.optional(z.object({
                    status: z.optional(z.string())
                }))
            }),
            z.null()
        ])),
        has_issues: z.optional(z.boolean()).default(true),
        has_projects: z.optional(z.boolean()).default(true),
        has_wiki: z.optional(z.boolean()).default(true),
        is_template: z.optional(z.boolean()).default(false),
        default_branch: z.optional(z.string()),
        allow_squash_merge: z.optional(z.boolean()).default(true),
        allow_merge_commit: z.optional(z.boolean()).default(true),
        allow_rebase_merge: z.optional(z.boolean()).default(true),
        allow_auto_merge: z.optional(z.boolean()).default(false),
        delete_branch_on_merge: z.optional(z.boolean()).default(false),
        allow_update_branch: z.optional(z.boolean()).default(false),
        use_squash_pr_title_as_default: z.optional(z.boolean()).default(false),
        squash_merge_commit_title: z.optional(z.enum([
            'PR_TITLE',
            'COMMIT_OR_PR_TITLE'
        ])),
        squash_merge_commit_message: z.optional(z.enum([
            'PR_BODY',
            'COMMIT_MESSAGES',
            'BLANK'
        ])),
        merge_commit_title: z.optional(z.enum([
            'PR_TITLE',
            'MERGE_MESSAGE'
        ])),
        merge_commit_message: z.optional(z.enum([
            'PR_BODY',
            'PR_TITLE',
            'BLANK'
        ])),
        archived: z.optional(z.boolean()).default(false),
        allow_forking: z.optional(z.boolean()).default(false),
        web_commit_signoff_required: z.optional(z.boolean()).default(false)
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposUpdateResponse = zFullRepository;

export const zActionsListArtifactsForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        name: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zActionsListArtifactsForRepoResponse = z.object({
    total_count: z.int(),
    artifacts: z.array(zArtifact)
});

export const zActionsDeleteArtifactData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        artifact_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDeleteArtifactResponse = z.void();

export const zActionsGetArtifactData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        artifact_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetArtifactResponse = zArtifact;

export const zActionsDownloadArtifactData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        artifact_id: z.int(),
        archive_format: z.string()
    }),
    query: z.optional(z.never())
});

export const zActionsGetActionsCacheUsageData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetActionsCacheUsageResponse = zActionsCacheUsageByRepository;

export const zActionsDeleteActionsCacheByKeyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.object({
        key: z.string(),
        ref: z.optional(z.string())
    })
});

/**
 * Response
 */
export const zActionsDeleteActionsCacheByKeyResponse = zActionsCacheList;

export const zActionsGetActionsCacheListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        ref: z.optional(z.string()),
        key: z.optional(z.string()),
        sort: z.optional(z.enum([
            'created_at',
            'last_accessed_at',
            'size_in_bytes'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ]))
    }))
});

/**
 * Response
 */
export const zActionsGetActionsCacheListResponse = zActionsCacheList;

export const zActionsDeleteActionsCacheByIdData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        cache_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDeleteActionsCacheByIdResponse = z.void();

export const zActionsGetJobForWorkflowRunData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        job_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetJobForWorkflowRunResponse = zJob;

export const zActionsDownloadJobLogsForWorkflowRunData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        job_id: z.int()
    }),
    query: z.optional(z.never())
});

export const zActionsReRunJobForWorkflowRunData = z.object({
    body: z.optional(z.union([
        z.object({
            enable_debug_logging: z.optional(z.boolean()).default(false)
        }),
        z.null()
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        job_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsReRunJobForWorkflowRunResponse = zEmptyObject;

export const zActionsGetCustomOidcSubClaimForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Status response
 */
export const zActionsGetCustomOidcSubClaimForRepoResponse = zOidcCustomSubRepo;

export const zActionsSetCustomOidcSubClaimForRepoData = z.object({
    body: z.object({
        use_default: z.boolean(),
        include_claim_keys: z.optional(z.array(z.string()))
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Empty response
 */
export const zActionsSetCustomOidcSubClaimForRepoResponse = zEmptyObject;

export const zActionsListRepoOrganizationSecretsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListRepoOrganizationSecretsResponse = z.object({
    total_count: z.int(),
    secrets: z.array(zActionsSecret)
});

export const zActionsListRepoOrganizationVariablesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(10),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListRepoOrganizationVariablesResponse = z.object({
    total_count: z.int(),
    variables: z.array(zActionsVariable)
});

export const zActionsGetGithubActionsPermissionsRepositoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetGithubActionsPermissionsRepositoryResponse = zActionsRepositoryPermissions;

export const zActionsSetGithubActionsPermissionsRepositoryData = z.object({
    body: z.object({
        enabled: zActionsEnabled,
        allowed_actions: z.optional(zAllowedActions),
        sha_pinning_required: z.optional(zShaPinningRequired)
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsSetGithubActionsPermissionsRepositoryResponse = z.void();

export const zActionsGetWorkflowAccessToRepositoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetWorkflowAccessToRepositoryResponse = zActionsWorkflowAccessToRepository;

export const zActionsSetWorkflowAccessToRepositoryData = z.object({
    body: zActionsWorkflowAccessToRepository,
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsSetWorkflowAccessToRepositoryResponse = z.void();

export const zActionsGetArtifactAndLogRetentionSettingsRepositoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetArtifactAndLogRetentionSettingsRepositoryResponse = zActionsArtifactAndLogRetentionResponse;

export const zActionsSetArtifactAndLogRetentionSettingsRepositoryData = z.object({
    body: zActionsArtifactAndLogRetention,
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Empty response for successful settings update
 */
export const zActionsSetArtifactAndLogRetentionSettingsRepositoryResponse = z.void();

export const zActionsGetForkPrContributorApprovalPermissionsRepositoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetForkPrContributorApprovalPermissionsRepositoryResponse = zActionsForkPrContributorApproval;

export const zActionsSetForkPrContributorApprovalPermissionsRepositoryData = z.object({
    body: zActionsForkPrContributorApproval,
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsSetForkPrContributorApprovalPermissionsRepositoryResponse = z.void();

export const zActionsGetPrivateRepoForkPrWorkflowsSettingsRepositoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetPrivateRepoForkPrWorkflowsSettingsRepositoryResponse = zActionsForkPrWorkflowsPrivateRepos;

export const zActionsSetPrivateRepoForkPrWorkflowsSettingsRepositoryData = z.object({
    body: zActionsForkPrWorkflowsPrivateReposRequest,
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Empty response for successful settings update
 */
export const zActionsSetPrivateRepoForkPrWorkflowsSettingsRepositoryResponse = z.void();

export const zActionsGetAllowedActionsRepositoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetAllowedActionsRepositoryResponse = zSelectedActions;

export const zActionsSetAllowedActionsRepositoryData = z.object({
    body: z.optional(zSelectedActions),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsSetAllowedActionsRepositoryResponse = z.void();

export const zActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse = zActionsGetDefaultWorkflowPermissions;

export const zActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryData = z.object({
    body: zActionsSetDefaultWorkflowPermissions,
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Success response
 */
export const zActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponse = z.void();

export const zActionsListSelfHostedRunnersForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        name: z.optional(z.string()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListSelfHostedRunnersForRepoResponse = z.object({
    total_count: z.int(),
    runners: z.array(zRunner)
});

export const zActionsListRunnerApplicationsForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsListRunnerApplicationsForRepoResponse = z.array(zRunnerApplication);

export const zActionsGenerateRunnerJitconfigForRepoData = z.object({
    body: z.object({
        name: z.string(),
        runner_group_id: z.int(),
        labels: z.array(z.string()).min(1).max(100),
        work_folder: z.optional(z.string()).default('_work')
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGenerateRunnerJitconfigForRepoResponse = z.object({
    runner: zRunner,
    encoded_jit_config: z.string()
});

export const zActionsCreateRegistrationTokenForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsCreateRegistrationTokenForRepoResponse = zAuthenticationToken;

export const zActionsCreateRemoveTokenForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsCreateRemoveTokenForRepoResponse = zAuthenticationToken;

export const zActionsDeleteSelfHostedRunnerFromRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDeleteSelfHostedRunnerFromRepoResponse = z.void();

export const zActionsGetSelfHostedRunnerForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetSelfHostedRunnerForRepoResponse = zRunner;

export const zActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse = z.object({
    total_count: z.int(),
    labels: z.array(zRunnerLabel)
});

export const zActionsListLabelsForSelfHostedRunnerForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsListLabelsForSelfHostedRunnerForRepoResponse = z.object({
    total_count: z.int(),
    labels: z.array(zRunnerLabel)
});

export const zActionsAddCustomLabelsToSelfHostedRunnerForRepoData = z.object({
    body: z.object({
        labels: z.array(z.string()).min(1).max(100)
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse = z.object({
    total_count: z.int(),
    labels: z.array(zRunnerLabel)
});

export const zActionsSetCustomLabelsForSelfHostedRunnerForRepoData = z.object({
    body: z.object({
        labels: z.array(z.string()).min(0).max(100)
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        runner_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse = z.object({
    total_count: z.int(),
    labels: z.array(zRunnerLabel)
});

export const zActionsRemoveCustomLabelFromSelfHostedRunnerForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        runner_id: z.int(),
        name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse = z.object({
    total_count: z.int(),
    labels: z.array(zRunnerLabel)
});

export const zActionsListWorkflowRunsForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        actor: z.optional(z.string()),
        branch: z.optional(z.string()),
        event: z.optional(z.string()),
        status: z.optional(z.enum([
            'completed',
            'action_required',
            'cancelled',
            'failure',
            'neutral',
            'skipped',
            'stale',
            'success',
            'timed_out',
            'in_progress',
            'queued',
            'requested',
            'waiting',
            'pending'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        created: z.optional(z.iso.datetime()),
        exclude_pull_requests: z.optional(z.boolean()).default(false),
        check_suite_id: z.optional(z.int()),
        head_sha: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zActionsListWorkflowRunsForRepoResponse = z.object({
    total_count: z.int(),
    workflow_runs: z.array(zWorkflowRun)
});

export const zActionsDeleteWorkflowRunData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDeleteWorkflowRunResponse = z.void();

export const zActionsGetWorkflowRunData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int()
    }),
    query: z.optional(z.object({
        exclude_pull_requests: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Response
 */
export const zActionsGetWorkflowRunResponse = zWorkflowRun;

export const zActionsGetReviewsForRunData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetReviewsForRunResponse = z.array(zEnvironmentApprovals);

export const zActionsApproveWorkflowRunData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsApproveWorkflowRunResponse = zEmptyObject;

export const zActionsListWorkflowRunArtifactsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        name: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zActionsListWorkflowRunArtifactsResponse = z.object({
    total_count: z.int(),
    artifacts: z.array(zArtifact)
});

export const zActionsGetWorkflowRunAttemptData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int(),
        attempt_number: z.int()
    }),
    query: z.optional(z.object({
        exclude_pull_requests: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Response
 */
export const zActionsGetWorkflowRunAttemptResponse = zWorkflowRun;

export const zActionsListJobsForWorkflowRunAttemptData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int(),
        attempt_number: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListJobsForWorkflowRunAttemptResponse = z.object({
    total_count: z.int(),
    jobs: z.array(zJob)
});

export const zActionsDownloadWorkflowRunAttemptLogsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int(),
        attempt_number: z.int()
    }),
    query: z.optional(z.never())
});

export const zActionsCancelWorkflowRunData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsCancelWorkflowRunResponse = zEmptyObject;

export const zActionsReviewCustomGatesForRunData = z.object({
    body: z.union([
        zReviewCustomGatesCommentRequired,
        zReviewCustomGatesStateRequired
    ]),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsReviewCustomGatesForRunResponse = z.void();

export const zActionsForceCancelWorkflowRunData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsForceCancelWorkflowRunResponse = zEmptyObject;

export const zActionsListJobsForWorkflowRunData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int()
    }),
    query: z.optional(z.object({
        filter: z.optional(z.enum([
            'latest',
            'all'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListJobsForWorkflowRunResponse = z.object({
    total_count: z.int(),
    jobs: z.array(zJob)
});

export const zActionsDeleteWorkflowRunLogsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDeleteWorkflowRunLogsResponse = z.void();

export const zActionsDownloadWorkflowRunLogsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int()
    }),
    query: z.optional(z.never())
});

export const zActionsGetPendingDeploymentsForRunData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetPendingDeploymentsForRunResponse = z.array(zPendingDeployment);

export const zActionsReviewPendingDeploymentsForRunData = z.object({
    body: z.object({
        environment_ids: z.array(z.int()),
        state: z.enum([
            'approved',
            'rejected'
        ]),
        comment: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsReviewPendingDeploymentsForRunResponse = z.array(zDeployment);

export const zActionsReRunWorkflowData = z.object({
    body: z.optional(z.union([
        z.object({
            enable_debug_logging: z.optional(z.boolean()).default(false)
        }),
        z.null()
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsReRunWorkflowResponse = zEmptyObject;

export const zActionsReRunWorkflowFailedJobsData = z.object({
    body: z.optional(z.union([
        z.object({
            enable_debug_logging: z.optional(z.boolean()).default(false)
        }),
        z.null()
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsReRunWorkflowFailedJobsResponse = zEmptyObject;

export const zActionsGetWorkflowRunUsageData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        run_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetWorkflowRunUsageResponse = zWorkflowRunUsage;

export const zActionsListRepoSecretsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListRepoSecretsResponse = z.object({
    total_count: z.int(),
    secrets: z.array(zActionsSecret)
});

export const zActionsGetRepoPublicKeyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetRepoPublicKeyResponse = zActionsPublicKey;

export const zActionsDeleteRepoSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDeleteRepoSecretResponse = z.void();

export const zActionsGetRepoSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetRepoSecretResponse = zActionsSecret;

export const zActionsCreateOrUpdateRepoSecretData = z.object({
    body: z.object({
        encrypted_value: z.string().regex(/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})$/),
        key_id: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

export const zActionsCreateOrUpdateRepoSecretResponse = z.union([
    zEmptyObject,
    z.void()
]);

export const zActionsListRepoVariablesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(10),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListRepoVariablesResponse = z.object({
    total_count: z.int(),
    variables: z.array(zActionsVariable)
});

export const zActionsCreateRepoVariableData = z.object({
    body: z.object({
        name: z.string(),
        value: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsCreateRepoVariableResponse = zEmptyObject;

export const zActionsDeleteRepoVariableData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDeleteRepoVariableResponse = z.void();

export const zActionsGetRepoVariableData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetRepoVariableResponse = zActionsVariable;

export const zActionsUpdateRepoVariableData = z.object({
    body: z.object({
        name: z.optional(z.string()),
        value: z.optional(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsUpdateRepoVariableResponse = z.void();

export const zActionsListRepoWorkflowsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListRepoWorkflowsResponse = z.object({
    total_count: z.int(),
    workflows: z.array(zWorkflow)
});

export const zActionsGetWorkflowData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        workflow_id: z.union([
            z.int(),
            z.string()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetWorkflowResponse = zWorkflow;

export const zActionsDisableWorkflowData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        workflow_id: z.union([
            z.int(),
            z.string()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDisableWorkflowResponse = z.void();

export const zActionsCreateWorkflowDispatchData = z.object({
    body: z.object({
        ref: z.string(),
        inputs: z.optional(z.record(z.string(), z.unknown()))
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        workflow_id: z.union([
            z.int(),
            z.string()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsCreateWorkflowDispatchResponse = z.void();

export const zActionsEnableWorkflowData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        workflow_id: z.union([
            z.int(),
            z.string()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsEnableWorkflowResponse = z.void();

export const zActionsListWorkflowRunsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        workflow_id: z.union([
            z.int(),
            z.string()
        ])
    }),
    query: z.optional(z.object({
        actor: z.optional(z.string()),
        branch: z.optional(z.string()),
        event: z.optional(z.string()),
        status: z.optional(z.enum([
            'completed',
            'action_required',
            'cancelled',
            'failure',
            'neutral',
            'skipped',
            'stale',
            'success',
            'timed_out',
            'in_progress',
            'queued',
            'requested',
            'waiting',
            'pending'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        created: z.optional(z.iso.datetime()),
        exclude_pull_requests: z.optional(z.boolean()).default(false),
        check_suite_id: z.optional(z.int()),
        head_sha: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zActionsListWorkflowRunsResponse = z.object({
    total_count: z.int(),
    workflow_runs: z.array(zWorkflowRun)
});

export const zActionsGetWorkflowUsageData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        workflow_id: z.union([
            z.int(),
            z.string()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetWorkflowUsageResponse = zWorkflowUsage;

export const zReposListActivitiesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        per_page: z.optional(z.int()).default(30),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        ref: z.optional(z.string()),
        actor: z.optional(z.string()),
        time_period: z.optional(z.enum([
            'day',
            'week',
            'month',
            'quarter',
            'year'
        ])),
        activity_type: z.optional(z.enum([
            'push',
            'force_push',
            'branch_creation',
            'branch_deletion',
            'pr_merge',
            'merge_queue_merge'
        ]))
    }))
});

/**
 * Response
 */
export const zReposListActivitiesResponse = z.array(zActivity);

export const zIssuesListAssigneesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListAssigneesResponse = z.array(zSimpleUser);

export const zIssuesCheckUserCanBeAssignedData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        assignee: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.
 */
export const zIssuesCheckUserCanBeAssignedResponse = z.void();

export const zReposCreateAttestationData = z.object({
    body: z.object({
        bundle: z.object({
            mediaType: z.optional(z.string()),
            verificationMaterial: z.optional(z.record(z.string(), z.unknown())),
            dsseEnvelope: z.optional(z.record(z.string(), z.unknown()))
        })
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * response
 */
export const zReposCreateAttestationResponse = z.object({
    id: z.optional(z.int())
});

export const zReposListAttestationsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        subject_digest: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        predicate_type: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zReposListAttestationsResponse = z.object({
    attestations: z.optional(z.array(z.object({
        bundle: z.optional(z.object({
            mediaType: z.optional(z.string()),
            verificationMaterial: z.optional(z.record(z.string(), z.unknown())),
            dsseEnvelope: z.optional(z.record(z.string(), z.unknown()))
        })),
        repository_id: z.optional(z.int()),
        bundle_url: z.optional(z.string()),
        initiator: z.optional(z.string())
    })))
});

export const zReposListAutolinksData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposListAutolinksResponse = z.array(zAutolink);

export const zReposCreateAutolinkData = z.object({
    body: z.object({
        key_prefix: z.string(),
        url_template: z.string(),
        is_alphanumeric: z.optional(z.boolean()).default(true)
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * response
 */
export const zReposCreateAutolinkResponse = zAutolink;

export const zReposDeleteAutolinkData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        autolink_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteAutolinkResponse = z.void();

export const zReposGetAutolinkData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        autolink_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetAutolinkResponse = zAutolink;

export const zReposDisableAutomatedSecurityFixesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDisableAutomatedSecurityFixesResponse = z.void();

export const zReposCheckAutomatedSecurityFixesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response if Dependabot is enabled
 */
export const zReposCheckAutomatedSecurityFixesResponse = zCheckAutomatedSecurityFixes;

export const zReposEnableAutomatedSecurityFixesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposEnableAutomatedSecurityFixesResponse = z.void();

export const zReposListBranchesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        protected: z.optional(z.boolean()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListBranchesResponse = z.array(zShortBranch);

export const zReposGetBranchData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetBranchResponse = zBranchWithProtection;

export const zReposDeleteBranchProtectionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteBranchProtectionResponse = z.void();

export const zReposGetBranchProtectionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetBranchProtectionResponse = zBranchProtection;

export const zReposUpdateBranchProtectionData = z.object({
    body: z.object({
        required_status_checks: z.union([
            z.object({
                strict: z.boolean(),
                contexts: z.array(z.string()),
                checks: z.optional(z.array(z.object({
                    context: z.string(),
                    app_id: z.optional(z.int())
                })))
            }),
            z.null()
        ]),
        enforce_admins: z.union([
            z.boolean(),
            z.null()
        ]),
        required_pull_request_reviews: z.union([
            z.object({
                dismissal_restrictions: z.optional(z.object({
                    users: z.optional(z.array(z.string())),
                    teams: z.optional(z.array(z.string())),
                    apps: z.optional(z.array(z.string()))
                })),
                dismiss_stale_reviews: z.optional(z.boolean()),
                require_code_owner_reviews: z.optional(z.boolean()),
                required_approving_review_count: z.optional(z.int()),
                require_last_push_approval: z.optional(z.boolean()).default(false),
                bypass_pull_request_allowances: z.optional(z.object({
                    users: z.optional(z.array(z.string())),
                    teams: z.optional(z.array(z.string())),
                    apps: z.optional(z.array(z.string()))
                }))
            }),
            z.null()
        ]),
        restrictions: z.union([
            z.object({
                users: z.array(z.string()),
                teams: z.array(z.string()),
                apps: z.optional(z.array(z.string()))
            }),
            z.null()
        ]),
        required_linear_history: z.optional(z.boolean()),
        allow_force_pushes: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        allow_deletions: z.optional(z.boolean()),
        block_creations: z.optional(z.boolean()),
        required_conversation_resolution: z.optional(z.boolean()),
        lock_branch: z.optional(z.boolean()).default(false),
        allow_fork_syncing: z.optional(z.boolean()).default(false)
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposUpdateBranchProtectionResponse = zProtectedBranch;

export const zReposDeleteAdminBranchProtectionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteAdminBranchProtectionResponse = z.void();

export const zReposGetAdminBranchProtectionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetAdminBranchProtectionResponse = zProtectedBranchAdminEnforced;

export const zReposSetAdminBranchProtectionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposSetAdminBranchProtectionResponse = zProtectedBranchAdminEnforced;

export const zReposDeletePullRequestReviewProtectionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeletePullRequestReviewProtectionResponse = z.void();

export const zReposGetPullRequestReviewProtectionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetPullRequestReviewProtectionResponse = zProtectedBranchPullRequestReview;

export const zReposUpdatePullRequestReviewProtectionData = z.object({
    body: z.optional(z.object({
        dismissal_restrictions: z.optional(z.object({
            users: z.optional(z.array(z.string())),
            teams: z.optional(z.array(z.string())),
            apps: z.optional(z.array(z.string()))
        })),
        dismiss_stale_reviews: z.optional(z.boolean()),
        require_code_owner_reviews: z.optional(z.boolean()),
        required_approving_review_count: z.optional(z.int()),
        require_last_push_approval: z.optional(z.boolean()).default(false),
        bypass_pull_request_allowances: z.optional(z.object({
            users: z.optional(z.array(z.string())),
            teams: z.optional(z.array(z.string())),
            apps: z.optional(z.array(z.string()))
        }))
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposUpdatePullRequestReviewProtectionResponse = zProtectedBranchPullRequestReview;

export const zReposDeleteCommitSignatureProtectionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteCommitSignatureProtectionResponse = z.void();

export const zReposGetCommitSignatureProtectionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetCommitSignatureProtectionResponse = zProtectedBranchAdminEnforced;

export const zReposCreateCommitSignatureProtectionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateCommitSignatureProtectionResponse = zProtectedBranchAdminEnforced;

export const zReposRemoveStatusCheckProtectionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposRemoveStatusCheckProtectionResponse = z.void();

export const zReposGetStatusChecksProtectionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetStatusChecksProtectionResponse = zStatusCheckPolicy;

export const zReposUpdateStatusCheckProtectionData = z.object({
    body: z.optional(z.object({
        strict: z.optional(z.boolean()),
        contexts: z.optional(z.array(z.string())),
        checks: z.optional(z.array(z.object({
            context: z.string(),
            app_id: z.optional(z.int())
        })))
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposUpdateStatusCheckProtectionResponse = zStatusCheckPolicy;

export const zReposRemoveStatusCheckContextsData = z.object({
    body: z.optional(z.union([
        z.object({
            contexts: z.array(z.string())
        }),
        z.array(z.string())
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposRemoveStatusCheckContextsResponse = z.array(z.string());

export const zReposGetAllStatusCheckContextsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetAllStatusCheckContextsResponse = z.array(z.string());

export const zReposAddStatusCheckContextsData = z.object({
    body: z.optional(z.union([
        z.object({
            contexts: z.array(z.string())
        }),
        z.array(z.string())
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposAddStatusCheckContextsResponse = z.array(z.string());

export const zReposSetStatusCheckContextsData = z.object({
    body: z.optional(z.union([
        z.object({
            contexts: z.array(z.string())
        }),
        z.array(z.string())
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposSetStatusCheckContextsResponse = z.array(z.string());

export const zReposDeleteAccessRestrictionsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteAccessRestrictionsResponse = z.void();

export const zReposGetAccessRestrictionsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetAccessRestrictionsResponse = zBranchRestrictionPolicy;

export const zReposRemoveAppAccessRestrictionsData = z.object({
    body: z.object({
        apps: z.array(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposRemoveAppAccessRestrictionsResponse = z.array(zIntegration);

export const zReposGetAppsWithAccessToProtectedBranchData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetAppsWithAccessToProtectedBranchResponse = z.array(zIntegration);

export const zReposAddAppAccessRestrictionsData = z.object({
    body: z.object({
        apps: z.array(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposAddAppAccessRestrictionsResponse = z.array(zIntegration);

export const zReposSetAppAccessRestrictionsData = z.object({
    body: z.object({
        apps: z.array(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposSetAppAccessRestrictionsResponse = z.array(zIntegration);

export const zReposRemoveTeamAccessRestrictionsData = z.object({
    body: z.optional(z.union([
        z.object({
            teams: z.array(z.string())
        }),
        z.array(z.string())
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposRemoveTeamAccessRestrictionsResponse = z.array(zTeam);

export const zReposGetTeamsWithAccessToProtectedBranchData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetTeamsWithAccessToProtectedBranchResponse = z.array(zTeam);

export const zReposAddTeamAccessRestrictionsData = z.object({
    body: z.optional(z.union([
        z.object({
            teams: z.array(z.string())
        }),
        z.array(z.string())
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposAddTeamAccessRestrictionsResponse = z.array(zTeam);

export const zReposSetTeamAccessRestrictionsData = z.object({
    body: z.optional(z.union([
        z.object({
            teams: z.array(z.string())
        }),
        z.array(z.string())
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposSetTeamAccessRestrictionsResponse = z.array(zTeam);

export const zReposRemoveUserAccessRestrictionsData = z.object({
    body: z.object({
        users: z.array(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposRemoveUserAccessRestrictionsResponse = z.array(zSimpleUser);

export const zReposGetUsersWithAccessToProtectedBranchData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetUsersWithAccessToProtectedBranchResponse = z.array(zSimpleUser);

export const zReposAddUserAccessRestrictionsData = z.object({
    body: z.object({
        users: z.array(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposAddUserAccessRestrictionsResponse = z.array(zSimpleUser);

export const zReposSetUserAccessRestrictionsData = z.object({
    body: z.object({
        users: z.array(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposSetUserAccessRestrictionsResponse = z.array(zSimpleUser);

export const zReposRenameBranchData = z.object({
    body: z.object({
        new_name: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposRenameBranchResponse = zBranchWithProtection;

export const zChecksCreateData = z.object({
    body: z.intersection(z.union([
        z.object({
            status: z.enum([
                'completed'
            ])
        }),
        z.object({
            status: z.optional(z.enum([
                'queued',
                'in_progress'
            ]))
        })
    ]), z.object({
        name: z.string(),
        head_sha: z.string(),
        details_url: z.optional(z.string()),
        external_id: z.optional(z.string()),
        status: z.optional(z.enum([
            'queued',
            'in_progress',
            'completed',
            'waiting',
            'requested',
            'pending'
        ])),
        started_at: z.optional(z.iso.datetime()),
        conclusion: z.optional(z.enum([
            'action_required',
            'cancelled',
            'failure',
            'neutral',
            'success',
            'skipped',
            'stale',
            'timed_out'
        ])),
        completed_at: z.optional(z.iso.datetime()),
        output: z.optional(z.object({
            title: z.string(),
            summary: z.string().max(65535),
            text: z.optional(z.string().max(65535)),
            annotations: z.optional(z.array(z.object({
                path: z.string(),
                start_line: z.int(),
                end_line: z.int(),
                start_column: z.optional(z.int()),
                end_column: z.optional(z.int()),
                annotation_level: z.enum([
                    'notice',
                    'warning',
                    'failure'
                ]),
                message: z.string(),
                title: z.optional(z.string()),
                raw_details: z.optional(z.string())
            })).max(50)),
            images: z.optional(z.array(z.object({
                alt: z.string(),
                image_url: z.string(),
                caption: z.optional(z.string())
            })))
        })),
        actions: z.optional(z.array(z.object({
            label: z.string().max(20),
            description: z.string().max(40),
            identifier: z.string().max(20)
        })).max(3))
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zChecksCreateResponse = zCheckRun;

export const zChecksGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        check_run_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zChecksGetResponse = zCheckRun;

export const zChecksUpdateData = z.object({
    body: z.intersection(z.union([
        z.object({
            status: z.optional(z.enum([
                'completed'
            ]))
        }),
        z.object({
            status: z.optional(z.enum([
                'queued',
                'in_progress'
            ]))
        })
    ]), z.object({
        name: z.optional(z.string()),
        details_url: z.optional(z.string()),
        external_id: z.optional(z.string()),
        started_at: z.optional(z.iso.datetime()),
        status: z.optional(z.enum([
            'queued',
            'in_progress',
            'completed',
            'waiting',
            'requested',
            'pending'
        ])),
        conclusion: z.optional(z.enum([
            'action_required',
            'cancelled',
            'failure',
            'neutral',
            'success',
            'skipped',
            'stale',
            'timed_out'
        ])),
        completed_at: z.optional(z.iso.datetime()),
        output: z.optional(z.object({
            title: z.optional(z.string()),
            summary: z.string().max(65535),
            text: z.optional(z.string().max(65535)),
            annotations: z.optional(z.array(z.object({
                path: z.string(),
                start_line: z.int(),
                end_line: z.int(),
                start_column: z.optional(z.int()),
                end_column: z.optional(z.int()),
                annotation_level: z.enum([
                    'notice',
                    'warning',
                    'failure'
                ]),
                message: z.string(),
                title: z.optional(z.string()),
                raw_details: z.optional(z.string())
            })).max(50)),
            images: z.optional(z.array(z.object({
                alt: z.string(),
                image_url: z.string(),
                caption: z.optional(z.string())
            })))
        })),
        actions: z.optional(z.array(z.object({
            label: z.string().max(20),
            description: z.string().max(40),
            identifier: z.string().max(20)
        })).max(3))
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        check_run_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zChecksUpdateResponse = zCheckRun;

export const zChecksListAnnotationsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        check_run_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zChecksListAnnotationsResponse = z.array(zCheckAnnotation);

export const zChecksRerequestRunData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        check_run_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zChecksRerequestRunResponse = zEmptyObject;

export const zChecksCreateSuiteData = z.object({
    body: z.object({
        head_sha: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response when the suite already exists
 */
export const zChecksCreateSuiteResponse = zCheckSuite;

export const zChecksSetSuitesPreferencesData = z.object({
    body: z.object({
        auto_trigger_checks: z.optional(z.array(z.object({
            app_id: z.int(),
            setting: z.boolean().default(true)
        })))
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zChecksSetSuitesPreferencesResponse = zCheckSuitePreference;

export const zChecksGetSuiteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        check_suite_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zChecksGetSuiteResponse = zCheckSuite;

export const zChecksListForSuiteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        check_suite_id: z.int()
    }),
    query: z.optional(z.object({
        check_name: z.optional(z.string()),
        status: z.optional(z.enum([
            'queued',
            'in_progress',
            'completed'
        ])),
        filter: z.optional(z.enum([
            'latest',
            'all'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zChecksListForSuiteResponse = z.object({
    total_count: z.int(),
    check_runs: z.array(zCheckRun)
});

export const zChecksRerequestSuiteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        check_suite_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zChecksRerequestSuiteResponse = zEmptyObject;

export const zCodeScanningListAlertsForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        tool_name: z.optional(zCodeScanningAnalysisToolName),
        tool_guid: z.optional(zCodeScanningAnalysisToolGuid),
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30),
        ref: z.optional(zCodeScanningRef),
        pr: z.optional(z.int()),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        sort: z.optional(z.enum([
            'created',
            'updated'
        ])),
        state: z.optional(zCodeScanningAlertStateQuery),
        severity: z.optional(zCodeScanningAlertSeverity)
    }))
});

/**
 * Response
 */
export const zCodeScanningListAlertsForRepoResponse = z.array(zCodeScanningAlertItems);

export const zCodeScanningGetAlertData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        alert_number: zAlertNumber
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeScanningGetAlertResponse = zCodeScanningAlert;

export const zCodeScanningUpdateAlertData = z.object({
    body: z.object({
        state: zCodeScanningAlertSetState,
        dismissed_reason: z.optional(zCodeScanningAlertDismissedReason),
        dismissed_comment: z.optional(zCodeScanningAlertDismissedComment),
        create_request: z.optional(zCodeScanningAlertCreateRequest)
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        alert_number: zAlertNumber
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeScanningUpdateAlertResponse = zCodeScanningAlert;

export const zCodeScanningGetAutofixData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        alert_number: zAlertNumber
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeScanningGetAutofixResponse = zCodeScanningAutofix;

export const zCodeScanningCreateAutofixData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        alert_number: zAlertNumber
    }),
    query: z.optional(z.never())
});

/**
 * OK
 */
export const zCodeScanningCreateAutofixResponse = zCodeScanningAutofix;

export const zCodeScanningCommitAutofixData = z.object({
    body: z.optional(zCodeScanningAutofixCommits),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        alert_number: zAlertNumber
    }),
    query: z.optional(z.never())
});

/**
 * Created
 */
export const zCodeScanningCommitAutofixResponse = zCodeScanningAutofixCommitsResponse;

export const zCodeScanningListAlertInstancesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        alert_number: zAlertNumber
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30),
        ref: z.optional(zCodeScanningRef),
        pr: z.optional(z.int())
    }))
});

/**
 * Response
 */
export const zCodeScanningListAlertInstancesResponse = z.array(zCodeScanningAlertInstance);

export const zCodeScanningListRecentAnalysesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        tool_name: z.optional(zCodeScanningAnalysisToolName),
        tool_guid: z.optional(zCodeScanningAnalysisToolGuid),
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30),
        pr: z.optional(z.int()),
        ref: z.optional(zCodeScanningRef),
        sarif_id: z.optional(zCodeScanningAnalysisSarifId),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        sort: z.optional(z.enum([
            'created'
        ]))
    }))
});

/**
 * Response
 */
export const zCodeScanningListRecentAnalysesResponse = z.array(zCodeScanningAnalysis);

export const zCodeScanningDeleteAnalysisData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        analysis_id: z.int()
    }),
    query: z.optional(z.object({
        confirm_delete: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    }))
});

/**
 * Response
 */
export const zCodeScanningDeleteAnalysisResponse = zCodeScanningAnalysisDeletion;

export const zCodeScanningGetAnalysisData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        analysis_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeScanningGetAnalysisResponse = zCodeScanningAnalysis;

export const zCodeScanningListCodeqlDatabasesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeScanningListCodeqlDatabasesResponse = z.array(zCodeScanningCodeqlDatabase);

export const zCodeScanningDeleteCodeqlDatabaseData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        language: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeScanningDeleteCodeqlDatabaseResponse = z.void();

export const zCodeScanningGetCodeqlDatabaseData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        language: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeScanningGetCodeqlDatabaseResponse = zCodeScanningCodeqlDatabase;

export const zCodeScanningCreateVariantAnalysisData = z.object({
    body: z.intersection(z.unknown(), z.object({
        language: zCodeScanningVariantAnalysisLanguage,
        query_pack: z.string(),
        repositories: z.optional(z.array(z.string())),
        repository_lists: z.optional(z.array(z.string()).max(1)),
        repository_owners: z.optional(z.array(z.string()).max(1))
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Variant analysis submitted for processing
 */
export const zCodeScanningCreateVariantAnalysisResponse = zCodeScanningVariantAnalysis;

export const zCodeScanningGetVariantAnalysisData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        codeql_variant_analysis_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeScanningGetVariantAnalysisResponse = zCodeScanningVariantAnalysis;

export const zCodeScanningGetVariantAnalysisRepoTaskData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        codeql_variant_analysis_id: z.int(),
        repo_owner: z.string(),
        repo_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeScanningGetVariantAnalysisRepoTaskResponse = zCodeScanningVariantAnalysisRepoTask;

export const zCodeScanningGetDefaultSetupData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeScanningGetDefaultSetupResponse = zCodeScanningDefaultSetup;

export const zCodeScanningUpdateDefaultSetupData = z.object({
    body: zCodeScanningDefaultSetupUpdate,
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

export const zCodeScanningUpdateDefaultSetupResponse = z.union([
    zEmptyObject,
    zCodeScanningDefaultSetupUpdateResponse
]);

export const zCodeScanningUploadSarifData = z.object({
    body: z.object({
        commit_sha: zCodeScanningAnalysisCommitSha,
        ref: zCodeScanningRefFull,
        sarif: zCodeScanningAnalysisSarifFile,
        checkout_uri: z.optional(z.url()),
        started_at: z.optional(z.iso.datetime()),
        tool_name: z.optional(z.string()),
        validate: z.optional(z.boolean())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeScanningUploadSarifResponse = zCodeScanningSarifsReceipt;

export const zCodeScanningGetSarifData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        sarif_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodeScanningGetSarifResponse = zCodeScanningSarifsStatus;

export const zCodeSecurityGetConfigurationForRepositoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

export const zCodeSecurityGetConfigurationForRepositoryResponse = z.union([
    zCodeSecurityConfigurationForRepository,
    z.void()
]);

export const zReposCodeownersErrorsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        ref: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zReposCodeownersErrorsResponse = zCodeownersErrors;

export const zCodespacesListInRepositoryForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zCodespacesListInRepositoryForAuthenticatedUserResponse = z.object({
    total_count: z.int(),
    codespaces: z.array(zCodespace)
});

export const zCodespacesCreateWithRepoForAuthenticatedUserData = z.object({
    body: z.union([
        z.object({
            ref: z.optional(z.string()),
            location: z.optional(z.string()),
            geo: z.optional(z.enum([
                'EuropeWest',
                'SoutheastAsia',
                'UsEast',
                'UsWest'
            ])),
            client_ip: z.optional(z.string()),
            machine: z.optional(z.string()),
            devcontainer_path: z.optional(z.string()),
            multi_repo_permissions_opt_out: z.optional(z.boolean()),
            working_directory: z.optional(z.string()),
            idle_timeout_minutes: z.optional(z.int()),
            display_name: z.optional(z.string()),
            retention_period_minutes: z.optional(z.int())
        }),
        z.null()
    ]),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response when the codespace was successfully created
 */
export const zCodespacesCreateWithRepoForAuthenticatedUserResponse = zCodespace;

export const zCodespacesListDevcontainersInRepositoryForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse = z.object({
    total_count: z.int(),
    devcontainers: z.array(z.object({
        path: z.string(),
        name: z.optional(z.string()),
        display_name: z.optional(z.string())
    }))
});

export const zCodespacesRepoMachinesForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        location: z.optional(z.string()),
        client_ip: z.optional(z.string()),
        ref: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zCodespacesRepoMachinesForAuthenticatedUserResponse = z.object({
    total_count: z.int(),
    machines: z.array(zCodespaceMachine)
});

export const zCodespacesPreFlightWithRepoForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        ref: z.optional(z.string()),
        client_ip: z.optional(z.string())
    }))
});

/**
 * Response when a user is able to create codespaces from the repository.
 */
export const zCodespacesPreFlightWithRepoForAuthenticatedUserResponse = z.object({
    billable_owner: z.optional(zSimpleUser),
    defaults: z.optional(z.object({
        location: z.string(),
        devcontainer_path: z.union([
            z.string(),
            z.null()
        ])
    }))
});

export const zCodespacesCheckPermissionsForDevcontainerData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.object({
        ref: z.string(),
        devcontainer_path: z.string()
    })
});

/**
 * Response when the permission check is successful
 */
export const zCodespacesCheckPermissionsForDevcontainerResponse = zCodespacesPermissionsCheckForDevcontainer;

export const zCodespacesListRepoSecretsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zCodespacesListRepoSecretsResponse = z.object({
    total_count: z.int(),
    secrets: z.array(zRepoCodespacesSecret)
});

export const zCodespacesGetRepoPublicKeyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesGetRepoPublicKeyResponse = zCodespacesPublicKey;

export const zCodespacesDeleteRepoSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesDeleteRepoSecretResponse = z.void();

export const zCodespacesGetRepoSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesGetRepoSecretResponse = zRepoCodespacesSecret;

export const zCodespacesCreateOrUpdateRepoSecretData = z.object({
    body: z.object({
        encrypted_value: z.optional(z.string().regex(/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})$/)),
        key_id: z.optional(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

export const zCodespacesCreateOrUpdateRepoSecretResponse = z.union([
    zEmptyObject,
    z.void()
]);

export const zReposListCollaboratorsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        affiliation: z.optional(z.enum([
            'outside',
            'direct',
            'all'
        ])),
        permission: z.optional(z.enum([
            'pull',
            'triage',
            'push',
            'maintain',
            'admin'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListCollaboratorsResponse = z.array(zCollaborator);

export const zReposRemoveCollaboratorData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * No Content when collaborator was removed from the repository.
 */
export const zReposRemoveCollaboratorResponse = z.void();

export const zReposCheckCollaboratorData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response if user is a collaborator
 */
export const zReposCheckCollaboratorResponse = z.void();

export const zReposAddCollaboratorData = z.object({
    body: z.optional(z.object({
        permission: z.optional(z.string()).default('push')
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

export const zReposAddCollaboratorResponse = z.union([
    zRepositoryInvitation,
    z.void()
]);

export const zReposGetCollaboratorPermissionLevelData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * if user has admin permissions
 */
export const zReposGetCollaboratorPermissionLevelResponse = zRepositoryCollaboratorPermission;

export const zReposListCommitCommentsForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListCommitCommentsForRepoResponse = z.array(zCommitComment);

export const zReposDeleteCommitCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteCommitCommentResponse = z.void();

export const zReposGetCommitCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetCommitCommentResponse = zCommitComment;

export const zReposUpdateCommitCommentData = z.object({
    body: z.object({
        body: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposUpdateCommitCommentResponse = zCommitComment;

export const zReactionsListForCommitCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.object({
        content: z.optional(z.enum([
            '+1',
            '-1',
            'laugh',
            'confused',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReactionsListForCommitCommentResponse = z.array(zReaction);

export const zReactionsCreateForCommitCommentData = z.object({
    body: z.object({
        content: z.enum([
            '+1',
            '-1',
            'laugh',
            'confused',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.never())
});

/**
 * Reaction exists
 */
export const zReactionsCreateForCommitCommentResponse = zReaction;

export const zReactionsDeleteForCommitCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint(),
        reaction_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReactionsDeleteForCommitCommentResponse = z.void();

export const zReposListCommitsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        sha: z.optional(z.string()),
        path: z.optional(z.string()),
        author: z.optional(z.string()),
        committer: z.optional(z.string()),
        since: z.optional(z.iso.datetime()),
        until: z.optional(z.iso.datetime()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListCommitsResponse = z.array(zCommit);

export const zReposListBranchesForHeadCommitData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        commit_sha: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposListBranchesForHeadCommitResponse = z.array(zBranchShort);

export const zReposListCommentsForCommitData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        commit_sha: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListCommentsForCommitResponse = z.array(zCommitComment);

export const zReposCreateCommitCommentData = z.object({
    body: z.object({
        body: z.string(),
        path: z.optional(z.string()),
        position: z.optional(z.int()),
        line: z.optional(z.int())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        commit_sha: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateCommitCommentResponse = zCommitComment;

export const zReposListPullRequestsAssociatedWithCommitData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        commit_sha: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListPullRequestsAssociatedWithCommitResponse = z.array(zPullRequestSimple);

export const zReposGetCommitData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ref: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zReposGetCommitResponse = zCommit;

export const zChecksListForRefData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ref: z.string()
    }),
    query: z.optional(z.object({
        check_name: z.optional(z.string()),
        status: z.optional(z.enum([
            'queued',
            'in_progress',
            'completed'
        ])),
        filter: z.optional(z.enum([
            'latest',
            'all'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        app_id: z.optional(z.int())
    }))
});

/**
 * Response
 */
export const zChecksListForRefResponse = z.object({
    total_count: z.int(),
    check_runs: z.array(zCheckRun)
});

export const zChecksListSuitesForRefData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ref: z.string()
    }),
    query: z.optional(z.object({
        app_id: z.optional(z.int()),
        check_name: z.optional(z.string()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zChecksListSuitesForRefResponse = z.object({
    total_count: z.int(),
    check_suites: z.array(zCheckSuite)
});

export const zReposGetCombinedStatusForRefData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ref: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposGetCombinedStatusForRefResponse = zCombinedCommitStatus;

export const zReposListCommitStatusesForRefData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ref: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListCommitStatusesForRefResponse = z.array(zStatus);

export const zReposGetCommunityProfileMetricsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetCommunityProfileMetricsResponse = zCommunityProfile;

export const zReposCompareCommitsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        basehead: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zReposCompareCommitsResponse = zCommitComparison;

export const zReposDeleteFileData = z.object({
    body: z.object({
        message: z.string(),
        sha: z.string(),
        branch: z.optional(z.string()),
        committer: z.optional(z.object({
            name: z.optional(z.string()),
            email: z.optional(z.string())
        })),
        author: z.optional(z.object({
            name: z.optional(z.string()),
            email: z.optional(z.string())
        }))
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        path: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteFileResponse = zFileCommit;

export const zReposGetContentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        path: z.string()
    }),
    query: z.optional(z.object({
        ref: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zReposGetContentResponse = z.union([
    z.object({
        type: z.literal('array')
    }).and(zContentDirectory),
    z.object({
        type: z.literal('file')
    }).and(zContentFile),
    z.object({
        type: z.literal('symlink')
    }).and(zContentSymlink),
    z.object({
        type: z.literal('submodule')
    }).and(zContentSubmodule)
]);

export const zReposCreateOrUpdateFileContentsData = z.object({
    body: z.object({
        message: z.string(),
        content: z.string(),
        sha: z.optional(z.string()),
        branch: z.optional(z.string()),
        committer: z.optional(z.object({
            name: z.string(),
            email: z.string(),
            date: z.optional(z.string())
        })),
        author: z.optional(z.object({
            name: z.string(),
            email: z.string(),
            date: z.optional(z.string())
        }))
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        path: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateOrUpdateFileContentsResponse = zFileCommit;

export const zReposListContributorsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        anon: z.optional(z.string()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

export const zReposListContributorsResponse = z.union([
    z.array(zContributor),
    z.void()
]);

export const zDependabotListAlertsForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        state: z.optional(z.string()),
        severity: z.optional(z.string()),
        ecosystem: z.optional(z.string()),
        package: z.optional(z.string()),
        manifest: z.optional(z.string()),
        epss_percentage: z.optional(z.string()),
        has: z.optional(z.union([
            z.string(),
            z.array(z.enum([
                'patch'
            ]))
        ])),
        scope: z.optional(z.enum([
            'development',
            'runtime'
        ])),
        sort: z.optional(z.enum([
            'created',
            'updated',
            'epss_percentage'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        per_page: z.optional(z.int()).default(30),
        before: z.optional(z.string()),
        after: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zDependabotListAlertsForRepoResponse = z.array(zDependabotAlert);

export const zDependabotGetAlertData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        alert_number: zAlertNumber
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zDependabotGetAlertResponse = zDependabotAlert;

export const zDependabotUpdateAlertData = z.object({
    body: z.object({
        state: z.enum([
            'dismissed',
            'open'
        ]),
        dismissed_reason: z.optional(z.enum([
            'fix_started',
            'inaccurate',
            'no_bandwidth',
            'not_used',
            'tolerable_risk'
        ])),
        dismissed_comment: z.optional(z.string().max(280))
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        alert_number: zAlertNumber
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zDependabotUpdateAlertResponse = zDependabotAlert;

export const zDependabotListRepoSecretsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zDependabotListRepoSecretsResponse = z.object({
    total_count: z.int(),
    secrets: z.array(zDependabotSecret)
});

export const zDependabotGetRepoPublicKeyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zDependabotGetRepoPublicKeyResponse = zDependabotPublicKey;

export const zDependabotDeleteRepoSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zDependabotDeleteRepoSecretResponse = z.void();

export const zDependabotGetRepoSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zDependabotGetRepoSecretResponse = zDependabotSecret;

export const zDependabotCreateOrUpdateRepoSecretData = z.object({
    body: z.object({
        encrypted_value: z.optional(z.string().regex(/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})$/)),
        key_id: z.optional(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

export const zDependabotCreateOrUpdateRepoSecretResponse = z.union([
    zEmptyObject,
    z.void()
]);

export const zDependencyGraphDiffRangeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        basehead: z.string()
    }),
    query: z.optional(z.object({
        name: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zDependencyGraphDiffRangeResponse = zDependencyGraphDiff;

export const zDependencyGraphExportSbomData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zDependencyGraphExportSbomResponse = zDependencyGraphSpdxSbom;

export const zDependencyGraphCreateRepositorySnapshotData = z.object({
    body: zSnapshot,
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zDependencyGraphCreateRepositorySnapshotResponse = z.object({
    id: z.int(),
    created_at: z.string(),
    result: z.string(),
    message: z.string()
});

export const zReposListDeploymentsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        sha: z.optional(z.string()).default('none'),
        ref: z.optional(z.string()).default('none'),
        task: z.optional(z.string()).default('none'),
        environment: z.optional(z.union([
            z.string().default('none'),
            z.null()
        ])).default('none'),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListDeploymentsResponse = z.array(zDeployment);

export const zReposCreateDeploymentData = z.object({
    body: z.object({
        ref: z.string(),
        task: z.optional(z.string()).default('deploy'),
        auto_merge: z.optional(z.boolean()).default(true),
        required_contexts: z.optional(z.array(z.string())),
        payload: z.optional(z.union([
            z.record(z.string(), z.unknown()),
            z.string().default('')
        ])),
        environment: z.optional(z.string()).default('production'),
        description: z.optional(z.union([
            z.string().default(''),
            z.null()
        ])).default(''),
        transient_environment: z.optional(z.boolean()).default(false),
        production_environment: z.optional(z.boolean())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

export const zReposCreateDeploymentResponse = z.union([
    zDeployment,
    z.object({
        message: z.optional(z.string())
    })
]);

export const zReposDeleteDeploymentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        deployment_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteDeploymentResponse = z.void();

export const zReposGetDeploymentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        deployment_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetDeploymentResponse = zDeployment;

export const zReposListDeploymentStatusesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        deployment_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListDeploymentStatusesResponse = z.array(zDeploymentStatus);

export const zReposCreateDeploymentStatusData = z.object({
    body: z.object({
        state: z.enum([
            'error',
            'failure',
            'inactive',
            'in_progress',
            'queued',
            'pending',
            'success'
        ]),
        target_url: z.optional(z.string()).default(''),
        log_url: z.optional(z.string()).default(''),
        description: z.optional(z.string()).default(''),
        environment: z.optional(z.string()),
        environment_url: z.optional(z.string()).default(''),
        auto_inactive: z.optional(z.boolean())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        deployment_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateDeploymentStatusResponse = zDeploymentStatus;

export const zReposGetDeploymentStatusData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        deployment_id: z.int(),
        status_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetDeploymentStatusResponse = zDeploymentStatus;

export const zReposCreateDispatchEventData = z.object({
    body: z.object({
        event_type: z.string().min(1).max(100),
        client_payload: z.optional(z.record(z.string(), z.unknown()))
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateDispatchEventResponse = z.void();

export const zReposGetAllEnvironmentsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposGetAllEnvironmentsResponse = z.object({
    total_count: z.optional(z.int()),
    environments: z.optional(z.array(zEnvironment))
});

export const zReposDeleteAnEnvironmentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Default response
 */
export const zReposDeleteAnEnvironmentResponse = z.void();

export const zReposGetEnvironmentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetEnvironmentResponse = zEnvironment;

export const zReposCreateOrUpdateEnvironmentData = z.object({
    body: z.optional(z.union([
        z.object({
            wait_timer: z.optional(zWaitTimer),
            prevent_self_review: z.optional(zPreventSelfReview),
            reviewers: z.optional(z.union([
                z.array(z.object({
                    type: z.optional(zDeploymentReviewerType),
                    id: z.optional(z.int())
                })),
                z.null()
            ])),
            deployment_branch_policy: z.optional(zDeploymentBranchPolicySettings)
        }),
        z.null()
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateOrUpdateEnvironmentResponse = zEnvironment;

export const zReposListDeploymentBranchPoliciesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListDeploymentBranchPoliciesResponse = z.object({
    total_count: z.int(),
    branch_policies: z.array(zDeploymentBranchPolicy)
});

export const zReposCreateDeploymentBranchPolicyData = z.object({
    body: zDeploymentBranchPolicyNamePatternWithType,
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateDeploymentBranchPolicyResponse = zDeploymentBranchPolicy;

export const zReposDeleteDeploymentBranchPolicyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string(),
        branch_policy_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteDeploymentBranchPolicyResponse = z.void();

export const zReposGetDeploymentBranchPolicyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string(),
        branch_policy_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetDeploymentBranchPolicyResponse = zDeploymentBranchPolicy;

export const zReposUpdateDeploymentBranchPolicyData = z.object({
    body: zDeploymentBranchPolicyNamePattern,
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string(),
        branch_policy_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposUpdateDeploymentBranchPolicyResponse = zDeploymentBranchPolicy;

export const zReposGetAllDeploymentProtectionRulesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        environment_name: z.string(),
        repo: z.string(),
        owner: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * List of deployment protection rules
 */
export const zReposGetAllDeploymentProtectionRulesResponse = z.object({
    total_count: z.optional(z.int()),
    custom_deployment_protection_rules: z.optional(z.array(zDeploymentProtectionRule))
});

export const zReposCreateDeploymentProtectionRuleData = z.object({
    body: z.object({
        integration_id: z.optional(z.int())
    }),
    path: z.object({
        environment_name: z.string(),
        repo: z.string(),
        owner: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The enabled custom deployment protection rule
 */
export const zReposCreateDeploymentProtectionRuleResponse = zDeploymentProtectionRule;

export const zReposListCustomDeploymentRuleIntegrationsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        environment_name: z.string(),
        repo: z.string(),
        owner: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * A list of custom deployment rule integrations available for this environment.
 */
export const zReposListCustomDeploymentRuleIntegrationsResponse = z.object({
    total_count: z.optional(z.int()),
    available_custom_deployment_protection_rule_integrations: z.optional(z.array(zCustomDeploymentRuleApp))
});

export const zReposDisableDeploymentProtectionRuleData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        environment_name: z.string(),
        repo: z.string(),
        owner: z.string(),
        protection_rule_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDisableDeploymentProtectionRuleResponse = z.void();

export const zReposGetCustomDeploymentProtectionRuleData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string(),
        protection_rule_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetCustomDeploymentProtectionRuleResponse = zDeploymentProtectionRule;

export const zActionsListEnvironmentSecretsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListEnvironmentSecretsResponse = z.object({
    total_count: z.int(),
    secrets: z.array(zActionsSecret)
});

export const zActionsGetEnvironmentPublicKeyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetEnvironmentPublicKeyResponse = zActionsPublicKey;

export const zActionsDeleteEnvironmentSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Default response
 */
export const zActionsDeleteEnvironmentSecretResponse = z.void();

export const zActionsGetEnvironmentSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetEnvironmentSecretResponse = zActionsSecret;

export const zActionsCreateOrUpdateEnvironmentSecretData = z.object({
    body: z.object({
        encrypted_value: z.string().regex(/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})$/),
        key_id: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string(),
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

export const zActionsCreateOrUpdateEnvironmentSecretResponse = z.union([
    zEmptyObject,
    z.void()
]);

export const zActionsListEnvironmentVariablesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(10),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActionsListEnvironmentVariablesResponse = z.object({
    total_count: z.int(),
    variables: z.array(zActionsVariable)
});

export const zActionsCreateEnvironmentVariableData = z.object({
    body: z.object({
        name: z.string(),
        value: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsCreateEnvironmentVariableResponse = zEmptyObject;

export const zActionsDeleteEnvironmentVariableData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        name: z.string(),
        environment_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsDeleteEnvironmentVariableResponse = z.void();

export const zActionsGetEnvironmentVariableData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        environment_name: z.string(),
        name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsGetEnvironmentVariableResponse = zActionsVariable;

export const zActionsUpdateEnvironmentVariableData = z.object({
    body: z.object({
        name: z.optional(z.string()),
        value: z.optional(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        name: z.string(),
        environment_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActionsUpdateEnvironmentVariableResponse = z.void();

export const zActivityListRepoEventsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActivityListRepoEventsResponse = z.array(zEvent);

export const zReposListForksData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        sort: z.optional(z.enum([
            'newest',
            'oldest',
            'stargazers',
            'watchers'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListForksResponse = z.array(zMinimalRepository);

export const zReposCreateForkData = z.object({
    body: z.optional(z.union([
        z.object({
            organization: z.optional(z.string()),
            name: z.optional(z.string()),
            default_branch_only: z.optional(z.boolean())
        }),
        z.null()
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateForkResponse = zFullRepository;

export const zGitCreateBlobData = z.object({
    body: z.object({
        content: z.string(),
        encoding: z.optional(z.string()).default('utf-8')
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGitCreateBlobResponse = zShortBlob;

export const zGitGetBlobData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        file_sha: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGitGetBlobResponse = zBlob;

export const zGitCreateCommitData = z.object({
    body: z.object({
        message: z.string(),
        tree: z.string(),
        parents: z.optional(z.array(z.string())),
        author: z.optional(z.object({
            name: z.string(),
            email: z.string(),
            date: z.optional(z.iso.datetime())
        })),
        committer: z.optional(z.object({
            name: z.optional(z.string()),
            email: z.optional(z.string()),
            date: z.optional(z.iso.datetime())
        })),
        signature: z.optional(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGitCreateCommitResponse = zGitCommit;

export const zGitGetCommitData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        commit_sha: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGitGetCommitResponse = zGitCommit;

export const zGitListMatchingRefsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ref: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGitListMatchingRefsResponse = z.array(zGitRef);

export const zGitGetRefData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ref: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGitGetRefResponse = zGitRef;

export const zGitCreateRefData = z.object({
    body: z.object({
        ref: z.string(),
        sha: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGitCreateRefResponse = zGitRef;

export const zGitDeleteRefData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ref: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGitDeleteRefResponse = z.void();

export const zGitUpdateRefData = z.object({
    body: z.object({
        sha: z.string(),
        force: z.optional(z.boolean()).default(false)
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ref: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGitUpdateRefResponse = zGitRef;

export const zGitCreateTagData = z.object({
    body: z.object({
        tag: z.string(),
        message: z.string(),
        object: z.string(),
        type: z.enum([
            'commit',
            'tree',
            'blob'
        ]),
        tagger: z.optional(z.object({
            name: z.string(),
            email: z.string(),
            date: z.optional(z.iso.datetime())
        }))
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGitCreateTagResponse = zGitTag;

export const zGitGetTagData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        tag_sha: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGitGetTagResponse = zGitTag;

export const zGitCreateTreeData = z.object({
    body: z.object({
        tree: z.array(z.object({
            path: z.optional(z.string()),
            mode: z.optional(z.enum([
                '100644',
                '100755',
                '040000',
                '160000',
                '120000'
            ])),
            type: z.optional(z.enum([
                'blob',
                'tree',
                'commit'
            ])),
            sha: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            content: z.optional(z.string())
        })),
        base_tree: z.optional(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zGitCreateTreeResponse = zGitTree;

export const zGitGetTreeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        tree_sha: z.string()
    }),
    query: z.optional(z.object({
        recursive: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zGitGetTreeResponse = zGitTree;

export const zReposListWebhooksData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListWebhooksResponse = z.array(zHook);

export const zReposCreateWebhookData = z.object({
    body: z.optional(z.union([
        z.object({
            name: z.optional(z.string()),
            config: z.optional(z.object({
                url: z.optional(zWebhookConfigUrl),
                content_type: z.optional(zWebhookConfigContentType),
                secret: z.optional(zWebhookConfigSecret),
                insecure_ssl: z.optional(zWebhookConfigInsecureSsl)
            })),
            events: z.optional(z.array(z.string())).default(['push']),
            active: z.optional(z.boolean()).default(true)
        }),
        z.null()
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateWebhookResponse = zHook;

export const zReposDeleteWebhookData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        hook_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteWebhookResponse = z.void();

export const zReposGetWebhookData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        hook_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetWebhookResponse = zHook;

export const zReposUpdateWebhookData = z.object({
    body: z.object({
        config: z.optional(zWebhookConfig),
        events: z.optional(z.array(z.string())).default(['push']),
        add_events: z.optional(z.array(z.string())),
        remove_events: z.optional(z.array(z.string())),
        active: z.optional(z.boolean()).default(true)
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        hook_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposUpdateWebhookResponse = zHook;

export const zReposGetWebhookConfigForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        hook_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetWebhookConfigForRepoResponse = zWebhookConfig;

export const zReposUpdateWebhookConfigForRepoData = z.object({
    body: z.optional(z.object({
        url: z.optional(zWebhookConfigUrl),
        content_type: z.optional(zWebhookConfigContentType),
        secret: z.optional(zWebhookConfigSecret),
        insecure_ssl: z.optional(zWebhookConfigInsecureSsl)
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        hook_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposUpdateWebhookConfigForRepoResponse = zWebhookConfig;

export const zReposListWebhookDeliveriesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        hook_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        cursor: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zReposListWebhookDeliveriesResponse = z.array(zHookDeliveryItem);

export const zReposGetWebhookDeliveryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        hook_id: z.int(),
        delivery_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetWebhookDeliveryResponse = zHookDelivery;

export const zReposRedeliverWebhookDeliveryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        hook_id: z.int(),
        delivery_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Accepted
 */
export const zReposRedeliverWebhookDeliveryResponse = z.record(z.string(), z.unknown());

export const zReposPingWebhookData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        hook_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposPingWebhookResponse = z.void();

export const zReposTestPushWebhookData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        hook_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposTestPushWebhookResponse = z.void();

export const zReposDisableImmutableReleasesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * A header with no content is returned.
 */
export const zReposDisableImmutableReleasesResponse = z.void();

export const zReposCheckImmutableReleasesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response if immutable releases are enabled
 */
export const zReposCheckImmutableReleasesResponse = zCheckImmutableReleases;

export const zReposEnableImmutableReleasesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * A header with no content is returned.
 */
export const zReposEnableImmutableReleasesResponse = z.void();

export const zMigrationsCancelImportData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMigrationsCancelImportResponse = z.void();

export const zMigrationsGetImportStatusData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMigrationsGetImportStatusResponse = zImport;

export const zMigrationsUpdateImportData = z.object({
    body: z.optional(z.union([
        z.object({
            vcs_username: z.optional(z.string()),
            vcs_password: z.optional(z.string()),
            vcs: z.optional(z.enum([
                'subversion',
                'tfvc',
                'git',
                'mercurial'
            ])),
            tfvc_project: z.optional(z.string())
        }),
        z.null()
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMigrationsUpdateImportResponse = zImport;

export const zMigrationsStartImportData = z.object({
    body: z.object({
        vcs_url: z.string(),
        vcs: z.optional(z.enum([
            'subversion',
            'git',
            'mercurial',
            'tfvc'
        ])),
        vcs_username: z.optional(z.string()),
        vcs_password: z.optional(z.string()),
        tfvc_project: z.optional(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMigrationsStartImportResponse = zImport;

export const zMigrationsGetCommitAuthorsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        since: z.optional(z.int())
    }))
});

/**
 * Response
 */
export const zMigrationsGetCommitAuthorsResponse = z.array(zPorterAuthor);

export const zMigrationsMapCommitAuthorData = z.object({
    body: z.optional(z.object({
        email: z.optional(z.string()),
        name: z.optional(z.string())
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        author_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMigrationsMapCommitAuthorResponse = zPorterAuthor;

export const zMigrationsGetLargeFilesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMigrationsGetLargeFilesResponse = z.array(zPorterLargeFile);

export const zMigrationsSetLfsPreferenceData = z.object({
    body: z.object({
        use_lfs: z.enum([
            'opt_in',
            'opt_out'
        ])
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMigrationsSetLfsPreferenceResponse = zImport;

export const zAppsGetRepoInstallationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsGetRepoInstallationResponse = zInstallation;

export const zInteractionsRemoveRestrictionsForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zInteractionsRemoveRestrictionsForRepoResponse = z.void();

export const zInteractionsGetRestrictionsForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zInteractionsGetRestrictionsForRepoResponse = z.union([
    zInteractionLimitResponse,
    z.record(z.string(), z.never())
]);

export const zInteractionsSetRestrictionsForRepoData = z.object({
    body: zInteractionLimit,
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zInteractionsSetRestrictionsForRepoResponse = zInteractionLimitResponse;

export const zReposListInvitationsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListInvitationsResponse = z.array(zRepositoryInvitation);

export const zReposDeleteInvitationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        invitation_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteInvitationResponse = z.void();

export const zReposUpdateInvitationData = z.object({
    body: z.optional(z.object({
        permissions: z.optional(z.enum([
            'read',
            'write',
            'maintain',
            'triage',
            'admin'
        ]))
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        invitation_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposUpdateInvitationResponse = zRepositoryInvitation;

export const zIssuesListForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        milestone: z.optional(z.string()),
        state: z.optional(z.enum([
            'open',
            'closed',
            'all'
        ])),
        assignee: z.optional(z.string()),
        type: z.optional(z.string()),
        creator: z.optional(z.string()),
        mentioned: z.optional(z.string()),
        labels: z.optional(z.string()),
        sort: z.optional(z.enum([
            'created',
            'updated',
            'comments'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        since: z.optional(z.iso.datetime()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListForRepoResponse = z.array(zIssue);

export const zIssuesCreateData = z.object({
    body: z.object({
        title: z.union([
            z.string(),
            z.int()
        ]),
        body: z.optional(z.string()),
        assignee: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        milestone: z.optional(z.union([
            z.string(),
            z.int(),
            z.null()
        ])),
        labels: z.optional(z.array(z.union([
            z.string(),
            z.object({
                id: z.optional(z.int()),
                name: z.optional(z.string()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                color: z.optional(z.union([
                    z.string(),
                    z.null()
                ]))
            })
        ]))),
        assignees: z.optional(z.array(z.string())),
        type: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesCreateResponse = zIssue;

export const zIssuesListCommentsForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        sort: z.optional(z.enum([
            'created',
            'updated'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        since: z.optional(z.iso.datetime()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListCommentsForRepoResponse = z.array(zIssueComment);

export const zIssuesDeleteCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesDeleteCommentResponse = z.void();

export const zIssuesGetCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesGetCommentResponse = zIssueComment;

export const zIssuesUpdateCommentData = z.object({
    body: z.object({
        body: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesUpdateCommentResponse = zIssueComment;

export const zReactionsListForIssueCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.object({
        content: z.optional(z.enum([
            '+1',
            '-1',
            'laugh',
            'confused',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReactionsListForIssueCommentResponse = z.array(zReaction);

export const zReactionsCreateForIssueCommentData = z.object({
    body: z.object({
        content: z.enum([
            '+1',
            '-1',
            'laugh',
            'confused',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.never())
});

/**
 * Reaction exists
 */
export const zReactionsCreateForIssueCommentResponse = zReaction;

export const zReactionsDeleteForIssueCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint(),
        reaction_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReactionsDeleteForIssueCommentResponse = z.void();

export const zIssuesListEventsForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListEventsForRepoResponse = z.array(zIssueEvent);

export const zIssuesGetEventData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        event_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesGetEventResponse = zIssueEvent;

export const zIssuesGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesGetResponse = zIssue;

export const zIssuesUpdateData = z.object({
    body: z.optional(z.object({
        title: z.optional(z.union([
            z.string(),
            z.int(),
            z.null()
        ])),
        body: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        assignee: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        state: z.optional(z.enum([
            'open',
            'closed'
        ])),
        state_reason: z.optional(z.enum([
            'completed',
            'not_planned',
            'duplicate',
            'reopened'
        ])),
        milestone: z.optional(z.union([
            z.string(),
            z.int(),
            z.null()
        ])),
        labels: z.optional(z.array(z.union([
            z.string(),
            z.object({
                id: z.optional(z.int()),
                name: z.optional(z.string()),
                description: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                color: z.optional(z.union([
                    z.string(),
                    z.null()
                ]))
            })
        ]))),
        assignees: z.optional(z.array(z.string())),
        type: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesUpdateResponse = zIssue;

export const zIssuesRemoveAssigneesData = z.object({
    body: z.optional(z.object({
        assignees: z.optional(z.array(z.string()))
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesRemoveAssigneesResponse = zIssue;

export const zIssuesAddAssigneesData = z.object({
    body: z.optional(z.object({
        assignees: z.optional(z.array(z.string()))
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesAddAssigneesResponse = zIssue;

export const zIssuesCheckUserCanBeAssignedToIssueData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int(),
        assignee: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response if `assignee` can be assigned to `issue_number`
 */
export const zIssuesCheckUserCanBeAssignedToIssueResponse = z.void();

export const zIssuesListCommentsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.object({
        since: z.optional(z.iso.datetime()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListCommentsResponse = z.array(zIssueComment);

export const zIssuesCreateCommentData = z.object({
    body: z.object({
        body: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesCreateCommentResponse = zIssueComment;

export const zIssuesListDependenciesBlockedByData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListDependenciesBlockedByResponse = z.array(zIssue);

export const zIssuesAddBlockedByDependencyData = z.object({
    body: z.object({
        issue_id: z.int()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesAddBlockedByDependencyResponse = zIssue;

export const zIssuesRemoveDependencyBlockedByData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int(),
        issue_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesRemoveDependencyBlockedByResponse = zIssue;

export const zIssuesListDependenciesBlockingData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListDependenciesBlockingResponse = z.array(zIssue);

export const zIssuesListEventsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListEventsResponse = z.array(zIssueEventForIssue);

export const zIssuesRemoveAllLabelsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesRemoveAllLabelsResponse = z.void();

export const zIssuesListLabelsOnIssueData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListLabelsOnIssueResponse = z.array(zLabel);

export const zIssuesAddLabelsData = z.object({
    body: z.optional(z.union([
        z.object({
            labels: z.optional(z.array(z.string()).min(1))
        }),
        z.array(z.string()).min(1),
        z.object({
            labels: z.optional(z.array(z.object({
                name: z.string()
            })).min(1))
        }),
        z.array(z.object({
            name: z.string()
        })).min(1),
        z.string()
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesAddLabelsResponse = z.array(zLabel);

export const zIssuesSetLabelsData = z.object({
    body: z.optional(z.union([
        z.object({
            labels: z.optional(z.array(z.string()).min(1))
        }),
        z.array(z.string()).min(1),
        z.object({
            labels: z.optional(z.array(z.object({
                name: z.string()
            })).min(1))
        }),
        z.array(z.object({
            name: z.string()
        })).min(1),
        z.string()
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesSetLabelsResponse = z.array(zLabel);

export const zIssuesRemoveLabelData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int(),
        name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesRemoveLabelResponse = z.array(zLabel);

export const zIssuesUnlockData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesUnlockResponse = z.void();

export const zIssuesLockData = z.object({
    body: z.optional(z.union([
        z.object({
            lock_reason: z.optional(z.enum([
                'off-topic',
                'too heated',
                'resolved',
                'spam'
            ]))
        }),
        z.null()
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesLockResponse = z.void();

export const zIssuesGetParentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesGetParentResponse = zIssue;

export const zReactionsListForIssueData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.object({
        content: z.optional(z.enum([
            '+1',
            '-1',
            'laugh',
            'confused',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReactionsListForIssueResponse = z.array(zReaction);

export const zReactionsCreateForIssueData = z.object({
    body: z.object({
        content: z.enum([
            '+1',
            '-1',
            'laugh',
            'confused',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReactionsCreateForIssueResponse = zReaction;

export const zReactionsDeleteForIssueData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int(),
        reaction_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReactionsDeleteForIssueResponse = z.void();

export const zIssuesRemoveSubIssueData = z.object({
    body: z.object({
        sub_issue_id: z.int()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesRemoveSubIssueResponse = zIssue;

export const zIssuesListSubIssuesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListSubIssuesResponse = z.array(zIssue);

export const zIssuesAddSubIssueData = z.object({
    body: z.object({
        sub_issue_id: z.int(),
        replace_parent: z.optional(z.boolean())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesAddSubIssueResponse = zIssue;

export const zIssuesReprioritizeSubIssueData = z.object({
    body: z.object({
        sub_issue_id: z.int(),
        after_id: z.optional(z.int()),
        before_id: z.optional(z.int())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesReprioritizeSubIssueResponse = zIssue;

export const zIssuesListEventsForTimelineData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        issue_number: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListEventsForTimelineResponse = z.array(zTimelineIssueEvents);

export const zReposListDeployKeysData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListDeployKeysResponse = z.array(zDeployKey);

export const zReposCreateDeployKeyData = z.object({
    body: z.object({
        title: z.optional(z.string()),
        key: z.string(),
        read_only: z.optional(z.boolean())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateDeployKeyResponse = zDeployKey;

export const zReposDeleteDeployKeyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        key_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteDeployKeyResponse = z.void();

export const zReposGetDeployKeyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        key_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetDeployKeyResponse = zDeployKey;

export const zIssuesListLabelsForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListLabelsForRepoResponse = z.array(zLabel);

export const zIssuesCreateLabelData = z.object({
    body: z.object({
        name: z.string(),
        color: z.optional(z.string()),
        description: z.optional(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesCreateLabelResponse = zLabel;

export const zIssuesDeleteLabelData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesDeleteLabelResponse = z.void();

export const zIssuesGetLabelData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesGetLabelResponse = zLabel;

export const zIssuesUpdateLabelData = z.object({
    body: z.optional(z.object({
        new_name: z.optional(z.string()),
        color: z.optional(z.string()),
        description: z.optional(z.string())
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesUpdateLabelResponse = zLabel;

export const zReposListLanguagesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposListLanguagesResponse = zLanguage;

export const zLicensesGetForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        ref: z.optional(zCodeScanningRef)
    }))
});

/**
 * Response
 */
export const zLicensesGetForRepoResponse = zLicenseContent;

export const zReposMergeUpstreamData = z.object({
    body: z.object({
        branch: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The branch has been successfully synced with the upstream repository
 */
export const zReposMergeUpstreamResponse = zMergedUpstream;

export const zReposMergeData = z.object({
    body: z.object({
        base: z.string(),
        head: z.string(),
        commit_message: z.optional(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

export const zReposMergeResponse = z.union([
    zCommit,
    z.void()
]);

export const zIssuesListMilestonesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        state: z.optional(z.enum([
            'open',
            'closed',
            'all'
        ])),
        sort: z.optional(z.enum([
            'due_on',
            'completeness'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListMilestonesResponse = z.array(zMilestone);

export const zIssuesCreateMilestoneData = z.object({
    body: z.object({
        title: z.string(),
        state: z.optional(z.enum([
            'open',
            'closed'
        ])),
        description: z.optional(z.string()),
        due_on: z.optional(z.iso.datetime())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesCreateMilestoneResponse = zMilestone;

export const zIssuesDeleteMilestoneData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        milestone_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesDeleteMilestoneResponse = z.void();

export const zIssuesGetMilestoneData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        milestone_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesGetMilestoneResponse = zMilestone;

export const zIssuesUpdateMilestoneData = z.object({
    body: z.optional(z.object({
        title: z.optional(z.string()),
        state: z.optional(z.enum([
            'open',
            'closed'
        ])),
        description: z.optional(z.string()),
        due_on: z.optional(z.iso.datetime())
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        milestone_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zIssuesUpdateMilestoneResponse = zMilestone;

export const zIssuesListLabelsForMilestoneData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        milestone_number: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListLabelsForMilestoneResponse = z.array(zLabel);

export const zActivityListRepoNotificationsForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        all: z.optional(z.boolean()).default(false),
        participating: z.optional(z.boolean()).default(false),
        since: z.optional(z.iso.datetime()),
        before: z.optional(z.iso.datetime()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActivityListRepoNotificationsForAuthenticatedUserResponse = z.array(zThread);

export const zActivityMarkRepoNotificationsAsReadData = z.object({
    body: z.optional(z.object({
        last_read_at: z.optional(z.iso.datetime())
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

export const zActivityMarkRepoNotificationsAsReadResponse = z.union([
    z.object({
        message: z.optional(z.string()),
        url: z.optional(z.string())
    }),
    z.unknown()
]);

export const zReposDeletePagesSiteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeletePagesSiteResponse = z.void();

export const zReposGetPagesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetPagesResponse = zPage;

export const zReposCreatePagesSiteData = z.object({
    body: z.intersection(z.union([
        z.unknown(),
        z.null()
    ]), z.object({
        build_type: z.optional(z.enum([
            'legacy',
            'workflow'
        ])),
        source: z.optional(z.object({
            branch: z.string(),
            path: z.optional(z.enum([
                '/',
                '/docs'
            ]))
        }))
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreatePagesSiteResponse = zPage;

export const zReposUpdateInformationAboutPagesSiteData = z.object({
    body: z.intersection(z.unknown(), z.object({
        cname: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        https_enforced: z.optional(z.boolean()),
        build_type: z.optional(z.enum([
            'legacy',
            'workflow'
        ])),
        source: z.optional(z.union([
            z.enum([
                'gh-pages',
                'master',
                'master /docs'
            ]),
            z.object({
                branch: z.string(),
                path: z.enum([
                    '/',
                    '/docs'
                ])
            })
        ]))
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposUpdateInformationAboutPagesSiteResponse = z.void();

export const zReposListPagesBuildsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListPagesBuildsResponse = z.array(zPageBuild);

export const zReposRequestPagesBuildData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposRequestPagesBuildResponse = zPageBuildStatus;

export const zReposGetLatestPagesBuildData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetLatestPagesBuildResponse = zPageBuild;

export const zReposGetPagesBuildData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        build_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetPagesBuildResponse = zPageBuild;

export const zReposCreatePagesDeploymentData = z.object({
    body: z.object({
        artifact_id: z.optional(z.number()),
        artifact_url: z.optional(z.string()),
        environment: z.optional(z.string()).default('github-pages'),
        pages_build_version: z.string().default('GITHUB_SHA'),
        oidc_token: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreatePagesDeploymentResponse = zPageDeployment;

export const zReposGetPagesDeploymentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pages_deployment_id: z.union([
            z.int(),
            z.string()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetPagesDeploymentResponse = zPagesDeploymentStatus;

export const zReposCancelPagesDeploymentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pages_deployment_id: z.union([
            z.int(),
            z.string()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * A header with no content is returned.
 */
export const zReposCancelPagesDeploymentResponse = z.void();

export const zReposGetPagesHealthCheckData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

export const zReposGetPagesHealthCheckResponse = z.union([
    zPagesHealthCheck,
    zEmptyObject
]);

export const zReposDisablePrivateVulnerabilityReportingData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * A header with no content is returned.
 */
export const zReposDisablePrivateVulnerabilityReportingResponse = z.void();

export const zReposCheckPrivateVulnerabilityReportingData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Private vulnerability reporting status
 */
export const zReposCheckPrivateVulnerabilityReportingResponse = z.object({
    enabled: z.boolean()
});

export const zReposEnablePrivateVulnerabilityReportingData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * A header with no content is returned.
 */
export const zReposEnablePrivateVulnerabilityReportingResponse = z.void();

export const zProjectsClassicListForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        state: z.optional(z.enum([
            'open',
            'closed',
            'all'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zProjectsClassicListForRepoResponse = z.array(zProject);

export const zProjectsClassicCreateForRepoData = z.object({
    body: z.object({
        name: z.string(),
        body: z.optional(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsClassicCreateForRepoResponse = zProject;

export const zReposCustomPropertiesForReposGetRepositoryValuesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCustomPropertiesForReposGetRepositoryValuesResponse = z.array(zCustomPropertyValue);

export const zReposCustomPropertiesForReposCreateOrUpdateRepositoryValuesData = z.object({
    body: z.object({
        properties: z.array(zCustomPropertyValue)
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * No Content when custom property values are successfully created or updated
 */
export const zReposCustomPropertiesForReposCreateOrUpdateRepositoryValuesResponse = z.void();

export const zPullsListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        state: z.optional(z.enum([
            'open',
            'closed',
            'all'
        ])),
        head: z.optional(z.string()),
        base: z.optional(z.string()),
        sort: z.optional(z.enum([
            'created',
            'updated',
            'popularity',
            'long-running'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zPullsListResponse = z.array(zPullRequestSimple);

export const zPullsCreateData = z.object({
    body: z.object({
        title: z.optional(z.string()),
        head: z.string(),
        head_repo: z.optional(z.string()),
        base: z.string(),
        body: z.optional(z.string()),
        maintainer_can_modify: z.optional(z.boolean()),
        draft: z.optional(z.boolean()),
        issue: z.optional(z.coerce.bigint())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsCreateResponse = zPullRequest;

export const zPullsListReviewCommentsForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        sort: z.optional(z.enum([
            'created',
            'updated',
            'created_at'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        since: z.optional(z.iso.datetime()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zPullsListReviewCommentsForRepoResponse = z.array(zPullRequestReviewComment);

export const zPullsDeleteReviewCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsDeleteReviewCommentResponse = z.void();

export const zPullsGetReviewCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsGetReviewCommentResponse = zPullRequestReviewComment;

export const zPullsUpdateReviewCommentData = z.object({
    body: z.object({
        body: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsUpdateReviewCommentResponse = zPullRequestReviewComment;

export const zReactionsListForPullRequestReviewCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.object({
        content: z.optional(z.enum([
            '+1',
            '-1',
            'laugh',
            'confused',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReactionsListForPullRequestReviewCommentResponse = z.array(zReaction);

export const zReactionsCreateForPullRequestReviewCommentData = z.object({
    body: z.object({
        content: z.enum([
            '+1',
            '-1',
            'laugh',
            'confused',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.never())
});

/**
 * Reaction exists
 */
export const zReactionsCreateForPullRequestReviewCommentResponse = zReaction;

export const zReactionsDeleteForPullRequestCommentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        comment_id: z.coerce.bigint(),
        reaction_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReactionsDeleteForPullRequestCommentResponse = z.void();

export const zPullsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Pass the appropriate [media type](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types) to fetch diff and patch formats.
 */
export const zPullsGetResponse = zPullRequest;

export const zPullsUpdateData = z.object({
    body: z.optional(z.object({
        title: z.optional(z.string()),
        body: z.optional(z.string()),
        state: z.optional(z.enum([
            'open',
            'closed'
        ])),
        base: z.optional(z.string()),
        maintainer_can_modify: z.optional(z.boolean())
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsUpdateResponse = zPullRequest;

export const zCodespacesCreateWithPrForAuthenticatedUserData = z.object({
    body: z.union([
        z.object({
            location: z.optional(z.string()),
            geo: z.optional(z.enum([
                'EuropeWest',
                'SoutheastAsia',
                'UsEast',
                'UsWest'
            ])),
            client_ip: z.optional(z.string()),
            machine: z.optional(z.string()),
            devcontainer_path: z.optional(z.string()),
            multi_repo_permissions_opt_out: z.optional(z.boolean()),
            working_directory: z.optional(z.string()),
            idle_timeout_minutes: z.optional(z.int()),
            display_name: z.optional(z.string()),
            retention_period_minutes: z.optional(z.int())
        }),
        z.null()
    ]),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response when the codespace was successfully created
 */
export const zCodespacesCreateWithPrForAuthenticatedUserResponse = zCodespace;

export const zPullsListReviewCommentsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int()
    }),
    query: z.optional(z.object({
        sort: z.optional(z.enum([
            'created',
            'updated'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        since: z.optional(z.iso.datetime()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zPullsListReviewCommentsResponse = z.array(zPullRequestReviewComment);

export const zPullsCreateReviewCommentData = z.object({
    body: z.object({
        body: z.string(),
        commit_id: z.string(),
        path: z.string(),
        position: z.optional(z.int()),
        side: z.optional(z.enum([
            'LEFT',
            'RIGHT'
        ])),
        line: z.optional(z.int()),
        start_line: z.optional(z.int()),
        start_side: z.optional(z.enum([
            'LEFT',
            'RIGHT',
            'side'
        ])),
        in_reply_to: z.optional(z.int()),
        subject_type: z.optional(z.enum([
            'line',
            'file'
        ]))
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsCreateReviewCommentResponse = zPullRequestReviewComment;

export const zPullsCreateReplyForReviewCommentData = z.object({
    body: z.object({
        body: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int(),
        comment_id: z.coerce.bigint()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsCreateReplyForReviewCommentResponse = zPullRequestReviewComment;

export const zPullsListCommitsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zPullsListCommitsResponse = z.array(zCommit);

export const zPullsListFilesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zPullsListFilesResponse = z.array(zDiffEntry);

export const zPullsCheckIfMergedData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response if pull request has been merged
 */
export const zPullsCheckIfMergedResponse = z.void();

export const zPullsMergeData = z.object({
    body: z.optional(z.union([
        z.object({
            commit_title: z.optional(z.string()),
            commit_message: z.optional(z.string()),
            sha: z.optional(z.string()),
            merge_method: z.optional(z.enum([
                'merge',
                'squash',
                'rebase'
            ]))
        }),
        z.null()
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * if merge was successful
 */
export const zPullsMergeResponse = zPullRequestMergeResult;

export const zPullsRemoveRequestedReviewersData = z.object({
    body: z.object({
        reviewers: z.array(z.string()),
        team_reviewers: z.optional(z.array(z.string()))
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsRemoveRequestedReviewersResponse = zPullRequestSimple;

export const zPullsListRequestedReviewersData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsListRequestedReviewersResponse = zPullRequestReviewRequest;

export const zPullsRequestReviewersData = z.object({
    body: z.optional(z.intersection(z.unknown(), z.object({
        reviewers: z.optional(z.array(z.string())),
        team_reviewers: z.optional(z.array(z.string()))
    }))),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsRequestReviewersResponse = zPullRequestSimple;

export const zPullsListReviewsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * The list of reviews returns in chronological order.
 */
export const zPullsListReviewsResponse = z.array(zPullRequestReview);

export const zPullsCreateReviewData = z.object({
    body: z.optional(z.object({
        commit_id: z.optional(z.string()),
        body: z.optional(z.string()),
        event: z.optional(z.enum([
            'APPROVE',
            'REQUEST_CHANGES',
            'COMMENT'
        ])),
        comments: z.optional(z.array(z.object({
            path: z.string(),
            position: z.optional(z.int()),
            body: z.string(),
            line: z.optional(z.int()),
            side: z.optional(z.string()),
            start_line: z.optional(z.int()),
            start_side: z.optional(z.string())
        })))
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsCreateReviewResponse = zPullRequestReview;

export const zPullsDeletePendingReviewData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int(),
        review_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsDeletePendingReviewResponse = zPullRequestReview;

export const zPullsGetReviewData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int(),
        review_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsGetReviewResponse = zPullRequestReview;

export const zPullsUpdateReviewData = z.object({
    body: z.object({
        body: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int(),
        review_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsUpdateReviewResponse = zPullRequestReview;

export const zPullsListCommentsForReviewData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int(),
        review_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zPullsListCommentsForReviewResponse = z.array(zReviewComment);

export const zPullsDismissReviewData = z.object({
    body: z.object({
        message: z.string(),
        event: z.optional(z.enum([
            'DISMISS'
        ]))
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int(),
        review_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsDismissReviewResponse = zPullRequestReview;

export const zPullsSubmitReviewData = z.object({
    body: z.object({
        body: z.optional(z.string()),
        event: z.enum([
            'APPROVE',
            'REQUEST_CHANGES',
            'COMMENT'
        ])
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int(),
        review_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsSubmitReviewResponse = zPullRequestReview;

export const zPullsUpdateBranchData = z.object({
    body: z.optional(z.union([
        z.object({
            expected_head_sha: z.optional(z.string())
        }),
        z.null()
    ])),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        pull_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPullsUpdateBranchResponse = z.object({
    message: z.optional(z.string()),
    url: z.optional(z.string())
});

export const zReposGetReadmeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        ref: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zReposGetReadmeResponse = zContentFile;

export const zReposGetReadmeInDirectoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        dir: z.string()
    }),
    query: z.optional(z.object({
        ref: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zReposGetReadmeInDirectoryResponse = zContentFile;

export const zReposListReleasesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListReleasesResponse = z.array(zRelease);

export const zReposCreateReleaseData = z.object({
    body: z.object({
        tag_name: z.string(),
        target_commitish: z.optional(z.string()),
        name: z.optional(z.string()),
        body: z.optional(z.string()),
        draft: z.optional(z.boolean()).default(false),
        prerelease: z.optional(z.boolean()).default(false),
        discussion_category_name: z.optional(z.string()),
        generate_release_notes: z.optional(z.boolean()).default(false),
        make_latest: z.optional(z.enum([
            'true',
            'false',
            'legacy'
        ]))
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateReleaseResponse = zRelease;

export const zReposDeleteReleaseAssetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        asset_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteReleaseAssetResponse = z.void();

export const zReposGetReleaseAssetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        asset_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetReleaseAssetResponse = zReleaseAsset;

export const zReposUpdateReleaseAssetData = z.object({
    body: z.optional(z.object({
        name: z.optional(z.string()),
        label: z.optional(z.string()),
        state: z.optional(z.string())
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        asset_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposUpdateReleaseAssetResponse = zReleaseAsset;

export const zReposGenerateReleaseNotesData = z.object({
    body: z.object({
        tag_name: z.string(),
        target_commitish: z.optional(z.string()),
        previous_tag_name: z.optional(z.string()),
        configuration_file_path: z.optional(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Name and body of generated release notes
 */
export const zReposGenerateReleaseNotesResponse = zReleaseNotesContent;

export const zReposGetLatestReleaseData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetLatestReleaseResponse = zRelease;

export const zReposGetReleaseByTagData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        tag: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetReleaseByTagResponse = zRelease;

export const zReposDeleteReleaseData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        release_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteReleaseResponse = z.void();

export const zReposGetReleaseData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        release_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a hypermedia resource. For more information, see "[Getting started with the REST API](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia)."
 */
export const zReposGetReleaseResponse = zRelease;

export const zReposUpdateReleaseData = z.object({
    body: z.optional(z.object({
        tag_name: z.optional(z.string()),
        target_commitish: z.optional(z.string()),
        name: z.optional(z.string()),
        body: z.optional(z.string()),
        draft: z.optional(z.boolean()),
        prerelease: z.optional(z.boolean()),
        make_latest: z.optional(z.enum([
            'true',
            'false',
            'legacy'
        ])),
        discussion_category_name: z.optional(z.string())
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        release_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposUpdateReleaseResponse = zRelease;

export const zReposListReleaseAssetsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        release_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListReleaseAssetsResponse = z.array(zReleaseAsset);

export const zReposUploadReleaseAssetData = z.object({
    body: z.optional(z.string()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        release_id: z.int()
    }),
    query: z.object({
        name: z.string(),
        label: z.optional(z.string())
    })
});

/**
 * Response for successful upload
 */
export const zReposUploadReleaseAssetResponse = zReleaseAsset;

export const zReactionsListForReleaseData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        release_id: z.int()
    }),
    query: z.optional(z.object({
        content: z.optional(z.enum([
            '+1',
            'laugh',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReactionsListForReleaseResponse = z.array(zReaction);

export const zReactionsCreateForReleaseData = z.object({
    body: z.object({
        content: z.enum([
            '+1',
            'laugh',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        release_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Reaction exists
 */
export const zReactionsCreateForReleaseResponse = zReaction;

export const zReactionsDeleteForReleaseData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        release_id: z.int(),
        reaction_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReactionsDeleteForReleaseResponse = z.void();

export const zReposGetBranchRulesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        branch: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposGetBranchRulesResponse = z.array(zRepositoryRuleDetailed);

export const zReposGetRepoRulesetsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        includes_parents: z.optional(z.boolean()).default(true),
        targets: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zReposGetRepoRulesetsResponse = z.array(zRepositoryRuleset);

export const zReposCreateRepoRulesetData = z.object({
    body: z.object({
        name: z.string(),
        target: z.optional(z.enum([
            'branch',
            'tag',
            'push'
        ])),
        enforcement: zRepositoryRuleEnforcement,
        bypass_actors: z.optional(z.array(zRepositoryRulesetBypassActor)),
        conditions: z.optional(zRepositoryRulesetConditions),
        rules: z.optional(z.array(zRepositoryRule))
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateRepoRulesetResponse = zRepositoryRuleset;

export const zReposGetRepoRuleSuitesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        ref: z.optional(z.string()),
        time_period: z.optional(z.enum([
            'hour',
            'day',
            'week',
            'month'
        ])),
        actor_name: z.optional(z.string()),
        rule_suite_result: z.optional(z.enum([
            'pass',
            'fail',
            'bypass',
            'all'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposGetRepoRuleSuitesResponse = zRuleSuites;

export const zReposGetRepoRuleSuiteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        rule_suite_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetRepoRuleSuiteResponse = zRuleSuite;

export const zReposDeleteRepoRulesetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ruleset_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteRepoRulesetResponse = z.void();

export const zReposGetRepoRulesetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ruleset_id: z.int()
    }),
    query: z.optional(z.object({
        includes_parents: z.optional(z.boolean()).default(true)
    }))
});

/**
 * Response
 */
export const zReposGetRepoRulesetResponse = zRepositoryRuleset;

export const zReposUpdateRepoRulesetData = z.object({
    body: z.optional(z.object({
        name: z.optional(z.string()),
        target: z.optional(z.enum([
            'branch',
            'tag',
            'push'
        ])),
        enforcement: z.optional(zRepositoryRuleEnforcement),
        bypass_actors: z.optional(z.array(zRepositoryRulesetBypassActor)),
        conditions: z.optional(zRepositoryRulesetConditions),
        rules: z.optional(z.array(zRepositoryRule))
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ruleset_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposUpdateRepoRulesetResponse = zRepositoryRuleset;

export const zReposGetRepoRulesetHistoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ruleset_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposGetRepoRulesetHistoryResponse = z.array(zRulesetVersion);

export const zReposGetRepoRulesetVersionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ruleset_id: z.int(),
        version_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetRepoRulesetVersionResponse = zRulesetVersionWithState;

export const zSecretScanningListAlertsForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        state: z.optional(z.enum([
            'open',
            'resolved'
        ])),
        secret_type: z.optional(z.string()),
        resolution: z.optional(z.string()),
        sort: z.optional(z.enum([
            'created',
            'updated'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        validity: z.optional(z.string()),
        is_publicly_leaked: z.optional(z.boolean()).default(false),
        is_multi_repo: z.optional(z.boolean()).default(false),
        hide_secret: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Response
 */
export const zSecretScanningListAlertsForRepoResponse = z.array(zSecretScanningAlert);

export const zSecretScanningGetAlertData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        alert_number: zAlertNumber
    }),
    query: z.optional(z.object({
        hide_secret: z.optional(z.boolean()).default(false)
    }))
});

/**
 * Response
 */
export const zSecretScanningGetAlertResponse = zSecretScanningAlert;

export const zSecretScanningUpdateAlertData = z.object({
    body: z.object({
        state: zSecretScanningAlertState,
        resolution: z.optional(zSecretScanningAlertResolution),
        resolution_comment: z.optional(zSecretScanningAlertResolutionComment)
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        alert_number: zAlertNumber
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zSecretScanningUpdateAlertResponse = zSecretScanningAlert;

export const zSecretScanningListLocationsForAlertData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        alert_number: zAlertNumber
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * List of locations where the secret was detected
 */
export const zSecretScanningListLocationsForAlertResponse = z.array(zSecretScanningLocation);

export const zSecretScanningCreatePushProtectionBypassData = z.object({
    body: z.object({
        reason: zSecretScanningPushProtectionBypassReason,
        placeholder_id: zSecretScanningPushProtectionBypassPlaceholderId
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zSecretScanningCreatePushProtectionBypassResponse = zSecretScanningPushProtectionBypass;

export const zSecretScanningGetScanHistoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zSecretScanningGetScanHistoryResponse = zSecretScanningScanHistory;

export const zSecurityAdvisoriesListRepositoryAdvisoriesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        sort: z.optional(z.enum([
            'created',
            'updated',
            'published'
        ])),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        per_page: z.optional(z.int().gte(1).lte(100)).default(30),
        state: z.optional(z.enum([
            'triage',
            'draft',
            'published',
            'closed'
        ]))
    }))
});

/**
 * Response
 */
export const zSecurityAdvisoriesListRepositoryAdvisoriesResponse = z.array(zRepositoryAdvisory);

export const zSecurityAdvisoriesCreateRepositoryAdvisoryData = z.object({
    body: zRepositoryAdvisoryCreate,
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zSecurityAdvisoriesCreateRepositoryAdvisoryResponse = zRepositoryAdvisory;

export const zSecurityAdvisoriesCreatePrivateVulnerabilityReportData = z.object({
    body: zPrivateVulnerabilityReportCreate,
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zSecurityAdvisoriesCreatePrivateVulnerabilityReportResponse = zRepositoryAdvisory;

export const zSecurityAdvisoriesGetRepositoryAdvisoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ghsa_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zSecurityAdvisoriesGetRepositoryAdvisoryResponse = zRepositoryAdvisory;

export const zSecurityAdvisoriesUpdateRepositoryAdvisoryData = z.object({
    body: zRepositoryAdvisoryUpdate,
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ghsa_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zSecurityAdvisoriesUpdateRepositoryAdvisoryResponse = zRepositoryAdvisory;

export const zSecurityAdvisoriesCreateRepositoryAdvisoryCveRequestData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ghsa_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Accepted
 */
export const zSecurityAdvisoriesCreateRepositoryAdvisoryCveRequestResponse = z.record(z.string(), z.unknown());

export const zSecurityAdvisoriesCreateForkData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ghsa_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zSecurityAdvisoriesCreateForkResponse = zFullRepository;

export const zActivityListStargazersForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActivityListStargazersForRepoResponse = z.union([
    z.array(zSimpleUser),
    z.array(zStargazer)
]);

export const zReposGetCodeFrequencyStatsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

export const zReposGetCodeFrequencyStatsResponse = z.union([
    z.array(zCodeFrequencyStat),
    z.record(z.string(), z.unknown()),
    z.void()
]);

export const zReposGetCommitActivityStatsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

export const zReposGetCommitActivityStatsResponse = z.union([
    z.array(zCommitActivity),
    z.record(z.string(), z.unknown()),
    z.void()
]);

export const zReposGetContributorsStatsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

export const zReposGetContributorsStatsResponse = z.union([
    z.array(zContributorActivity),
    z.record(z.string(), z.unknown()),
    z.void()
]);

export const zReposGetParticipationStatsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The array order is oldest week (index 0) to most recent week.
 */
export const zReposGetParticipationStatsResponse = zParticipationStats;

export const zReposGetPunchCardStatsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

export const zReposGetPunchCardStatsResponse = z.union([
    z.array(zCodeFrequencyStat),
    z.void()
]);

export const zReposCreateCommitStatusData = z.object({
    body: z.object({
        state: z.enum([
            'error',
            'failure',
            'pending',
            'success'
        ]),
        target_url: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        description: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        context: z.optional(z.string()).default('default')
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        sha: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateCommitStatusResponse = zStatus;

export const zActivityListWatchersForRepoData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActivityListWatchersForRepoResponse = z.array(zSimpleUser);

export const zActivityDeleteRepoSubscriptionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActivityDeleteRepoSubscriptionResponse = z.void();

export const zActivityGetRepoSubscriptionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * if you subscribe to the repository
 */
export const zActivityGetRepoSubscriptionResponse = zRepositorySubscription;

export const zActivitySetRepoSubscriptionData = z.object({
    body: z.optional(z.object({
        subscribed: z.optional(z.boolean()),
        ignored: z.optional(z.boolean())
    })),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActivitySetRepoSubscriptionResponse = zRepositorySubscription;

export const zReposListTagsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListTagsResponse = z.array(zTag);

export const zReposListTagProtectionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposListTagProtectionResponse = z.array(zTagProtection);

export const zReposCreateTagProtectionData = z.object({
    body: z.object({
        pattern: z.string()
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateTagProtectionResponse = zTagProtection;

export const zReposDeleteTagProtectionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        tag_protection_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeleteTagProtectionResponse = z.void();

export const zReposDownloadTarballArchiveData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ref: z.string()
    }),
    query: z.optional(z.never())
});

export const zReposListTeamsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListTeamsResponse = z.array(zTeam);

export const zReposGetAllTopicsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zReposGetAllTopicsResponse = zTopic;

export const zReposReplaceAllTopicsData = z.object({
    body: z.object({
        names: z.array(z.string())
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposReplaceAllTopicsResponse = zTopic;

export const zReposGetClonesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per: z.optional(z.enum([
            'day',
            'week'
        ]))
    }))
});

/**
 * Response
 */
export const zReposGetClonesResponse = zCloneTraffic;

export const zReposGetTopPathsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetTopPathsResponse = z.array(zContentTraffic);

export const zReposGetTopReferrersData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposGetTopReferrersResponse = z.array(zReferrerTraffic);

export const zReposGetViewsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.object({
        per: z.optional(z.enum([
            'day',
            'week'
        ]))
    }))
});

/**
 * Response
 */
export const zReposGetViewsResponse = zViewTraffic;

export const zReposTransferData = z.object({
    body: z.object({
        new_owner: z.string(),
        new_name: z.optional(z.string()),
        team_ids: z.optional(z.array(z.int()))
    }),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposTransferResponse = zMinimalRepository;

export const zReposDisableVulnerabilityAlertsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDisableVulnerabilityAlertsResponse = z.void();

export const zReposCheckVulnerabilityAlertsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response if repository is enabled with vulnerability alerts
 */
export const zReposCheckVulnerabilityAlertsResponse = z.void();

export const zReposEnableVulnerabilityAlertsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposEnableVulnerabilityAlertsResponse = z.void();

export const zReposDownloadZipballArchiveData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string(),
        ref: z.string()
    }),
    query: z.optional(z.never())
});

export const zReposCreateUsingTemplateData = z.object({
    body: z.object({
        owner: z.optional(z.string()),
        name: z.string(),
        description: z.optional(z.string()),
        include_all_branches: z.optional(z.boolean()).default(false),
        private: z.optional(z.boolean()).default(false)
    }),
    path: z.object({
        template_owner: z.string(),
        template_repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateUsingTemplateResponse = zFullRepository;

export const zReposListPublicData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        since: z.optional(z.int())
    }))
});

/**
 * Response
 */
export const zReposListPublicResponse = z.array(zMinimalRepository);

export const zSearchCodeData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        q: z.string(),
        sort: z.optional(z.enum([
            'indexed'
        ])),
        order: z.optional(z.enum([
            'desc',
            'asc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    })
});

/**
 * Response
 */
export const zSearchCodeResponse = z.object({
    total_count: z.int(),
    incomplete_results: z.boolean(),
    items: z.array(zCodeSearchResultItem)
});

export const zSearchCommitsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        q: z.string(),
        sort: z.optional(z.enum([
            'author-date',
            'committer-date'
        ])),
        order: z.optional(z.enum([
            'desc',
            'asc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    })
});

/**
 * Response
 */
export const zSearchCommitsResponse = z.object({
    total_count: z.int(),
    incomplete_results: z.boolean(),
    items: z.array(zCommitSearchResultItem)
});

export const zSearchIssuesAndPullRequestsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        q: z.string(),
        sort: z.optional(z.enum([
            'comments',
            'reactions',
            'reactions-+1',
            'reactions--1',
            'reactions-smile',
            'reactions-thinking_face',
            'reactions-heart',
            'reactions-tada',
            'interactions',
            'created',
            'updated'
        ])),
        order: z.optional(z.enum([
            'desc',
            'asc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        advanced_search: z.optional(z.string())
    })
});

/**
 * Response
 */
export const zSearchIssuesAndPullRequestsResponse = z.object({
    total_count: z.int(),
    incomplete_results: z.boolean(),
    items: z.array(zIssueSearchResultItem)
});

export const zSearchLabelsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        repository_id: z.int(),
        q: z.string(),
        sort: z.optional(z.enum([
            'created',
            'updated'
        ])),
        order: z.optional(z.enum([
            'desc',
            'asc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    })
});

/**
 * Response
 */
export const zSearchLabelsResponse = z.object({
    total_count: z.int(),
    incomplete_results: z.boolean(),
    items: z.array(zLabelSearchResultItem)
});

export const zSearchReposData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        q: z.string(),
        sort: z.optional(z.enum([
            'stars',
            'forks',
            'help-wanted-issues',
            'updated'
        ])),
        order: z.optional(z.enum([
            'desc',
            'asc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    })
});

/**
 * Response
 */
export const zSearchReposResponse = z.object({
    total_count: z.int(),
    incomplete_results: z.boolean(),
    items: z.array(zRepoSearchResultItem)
});

export const zSearchTopicsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        q: z.string(),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    })
});

/**
 * Response
 */
export const zSearchTopicsResponse = z.object({
    total_count: z.int(),
    incomplete_results: z.boolean(),
    items: z.array(zTopicSearchResultItem)
});

export const zSearchUsersData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        q: z.string(),
        sort: z.optional(z.enum([
            'followers',
            'repositories',
            'joined'
        ])),
        order: z.optional(z.enum([
            'desc',
            'asc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    })
});

/**
 * Response
 */
export const zSearchUsersResponse = z.object({
    total_count: z.int(),
    incomplete_results: z.boolean(),
    items: z.array(zUserSearchResultItem)
});

export const zTeamsDeleteLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsDeleteLegacyResponse = z.void();

export const zTeamsGetLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsGetLegacyResponse = zTeamFull;

export const zTeamsUpdateLegacyData = z.object({
    body: z.object({
        name: z.string(),
        description: z.optional(z.string()),
        privacy: z.optional(z.enum([
            'secret',
            'closed'
        ])),
        notification_setting: z.optional(z.enum([
            'notifications_enabled',
            'notifications_disabled'
        ])),
        permission: z.optional(z.enum([
            'pull',
            'push',
            'admin'
        ])),
        parent_team_id: z.optional(z.union([
            z.int(),
            z.null()
        ]))
    }),
    path: z.object({
        team_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response when the updated information already exists
 */
export const zTeamsUpdateLegacyResponse = zTeamFull;

export const zTeamsListDiscussionsLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int()
    }),
    query: z.optional(z.object({
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zTeamsListDiscussionsLegacyResponse = z.array(zTeamDiscussion);

export const zTeamsCreateDiscussionLegacyData = z.object({
    body: z.object({
        title: z.string(),
        body: z.string(),
        private: z.optional(z.boolean()).default(false)
    }),
    path: z.object({
        team_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsCreateDiscussionLegacyResponse = zTeamDiscussion;

export const zTeamsDeleteDiscussionLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int(),
        discussion_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsDeleteDiscussionLegacyResponse = z.void();

export const zTeamsGetDiscussionLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int(),
        discussion_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsGetDiscussionLegacyResponse = zTeamDiscussion;

export const zTeamsUpdateDiscussionLegacyData = z.object({
    body: z.optional(z.object({
        title: z.optional(z.string()),
        body: z.optional(z.string())
    })),
    path: z.object({
        team_id: z.int(),
        discussion_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsUpdateDiscussionLegacyResponse = zTeamDiscussion;

export const zTeamsListDiscussionCommentsLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int(),
        discussion_number: z.int()
    }),
    query: z.optional(z.object({
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zTeamsListDiscussionCommentsLegacyResponse = z.array(zTeamDiscussionComment);

export const zTeamsCreateDiscussionCommentLegacyData = z.object({
    body: z.object({
        body: z.string()
    }),
    path: z.object({
        team_id: z.int(),
        discussion_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsCreateDiscussionCommentLegacyResponse = zTeamDiscussionComment;

export const zTeamsDeleteDiscussionCommentLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int(),
        discussion_number: z.int(),
        comment_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsDeleteDiscussionCommentLegacyResponse = z.void();

export const zTeamsGetDiscussionCommentLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int(),
        discussion_number: z.int(),
        comment_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsGetDiscussionCommentLegacyResponse = zTeamDiscussionComment;

export const zTeamsUpdateDiscussionCommentLegacyData = z.object({
    body: z.object({
        body: z.string()
    }),
    path: z.object({
        team_id: z.int(),
        discussion_number: z.int(),
        comment_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsUpdateDiscussionCommentLegacyResponse = zTeamDiscussionComment;

export const zReactionsListForTeamDiscussionCommentLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int(),
        discussion_number: z.int(),
        comment_number: z.int()
    }),
    query: z.optional(z.object({
        content: z.optional(z.enum([
            '+1',
            '-1',
            'laugh',
            'confused',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReactionsListForTeamDiscussionCommentLegacyResponse = z.array(zReaction);

export const zReactionsCreateForTeamDiscussionCommentLegacyData = z.object({
    body: z.object({
        content: z.enum([
            '+1',
            '-1',
            'laugh',
            'confused',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])
    }),
    path: z.object({
        team_id: z.int(),
        discussion_number: z.int(),
        comment_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReactionsCreateForTeamDiscussionCommentLegacyResponse = zReaction;

export const zReactionsListForTeamDiscussionLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int(),
        discussion_number: z.int()
    }),
    query: z.optional(z.object({
        content: z.optional(z.enum([
            '+1',
            '-1',
            'laugh',
            'confused',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReactionsListForTeamDiscussionLegacyResponse = z.array(zReaction);

export const zReactionsCreateForTeamDiscussionLegacyData = z.object({
    body: z.object({
        content: z.enum([
            '+1',
            '-1',
            'laugh',
            'confused',
            'heart',
            'hooray',
            'rocket',
            'eyes'
        ])
    }),
    path: z.object({
        team_id: z.int(),
        discussion_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReactionsCreateForTeamDiscussionLegacyResponse = zReaction;

export const zTeamsListPendingInvitationsLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zTeamsListPendingInvitationsLegacyResponse = z.array(zOrganizationInvitation);

export const zTeamsListMembersLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int()
    }),
    query: z.optional(z.object({
        role: z.optional(z.enum([
            'member',
            'maintainer',
            'all'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zTeamsListMembersLegacyResponse = z.array(zSimpleUser);

export const zTeamsRemoveMemberLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsRemoveMemberLegacyResponse = z.void();

export const zTeamsGetMemberLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * if user is a member
 */
export const zTeamsGetMemberLegacyResponse = z.void();

export const zTeamsAddMemberLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsAddMemberLegacyResponse = z.void();

export const zTeamsRemoveMembershipForUserLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsRemoveMembershipForUserLegacyResponse = z.void();

export const zTeamsGetMembershipForUserLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsGetMembershipForUserLegacyResponse = zTeamMembership;

export const zTeamsAddOrUpdateMembershipForUserLegacyData = z.object({
    body: z.optional(z.object({
        role: z.optional(z.enum([
            'member',
            'maintainer'
        ]))
    })),
    path: z.object({
        team_id: z.int(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsAddOrUpdateMembershipForUserLegacyResponse = zTeamMembership;

export const zTeamsListProjectsLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zTeamsListProjectsLegacyResponse = z.array(zTeamProject);

export const zTeamsRemoveProjectLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int(),
        project_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsRemoveProjectLegacyResponse = z.void();

export const zTeamsCheckPermissionsForProjectLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int(),
        project_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsCheckPermissionsForProjectLegacyResponse = zTeamProject;

export const zTeamsAddOrUpdateProjectPermissionsLegacyData = z.object({
    body: z.optional(z.object({
        permission: z.optional(z.enum([
            'read',
            'write',
            'admin'
        ]))
    })),
    path: z.object({
        team_id: z.int(),
        project_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsAddOrUpdateProjectPermissionsLegacyResponse = z.void();

export const zTeamsListReposLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zTeamsListReposLegacyResponse = z.array(zMinimalRepository);

export const zTeamsRemoveRepoLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int(),
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsRemoveRepoLegacyResponse = z.void();

export const zTeamsCheckPermissionsForRepoLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int(),
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

export const zTeamsCheckPermissionsForRepoLegacyResponse = z.union([
    zTeamRepository,
    z.void()
]);

export const zTeamsAddOrUpdateRepoPermissionsLegacyData = z.object({
    body: z.optional(z.object({
        permission: z.optional(z.enum([
            'pull',
            'push',
            'admin'
        ]))
    })),
    path: z.object({
        team_id: z.int(),
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zTeamsAddOrUpdateRepoPermissionsLegacyResponse = z.void();

export const zTeamsListChildLegacyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        team_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * if child teams exist
 */
export const zTeamsListChildLegacyResponse = z.array(zTeam);

export const zUsersGetAuthenticatedData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersGetAuthenticatedResponse = z.union([
    z.object({
        user_view_type: z.literal('private')
    }).and(zPrivateUser),
    z.object({
        user_view_type: z.literal('public')
    }).and(zPublicUser)
]);

export const zUsersUpdateAuthenticatedData = z.object({
    body: z.optional(z.object({
        name: z.optional(z.string()),
        email: z.optional(z.string()),
        blog: z.optional(z.string()),
        twitter_username: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        company: z.optional(z.string()),
        location: z.optional(z.string()),
        hireable: z.optional(z.boolean()),
        bio: z.optional(z.string())
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersUpdateAuthenticatedResponse = zPrivateUser;

export const zUsersListBlockedByAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zUsersListBlockedByAuthenticatedUserResponse = z.array(zSimpleUser);

export const zUsersUnblockData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersUnblockResponse = z.void();

export const zUsersCheckBlockedData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * If the user is blocked
 */
export const zUsersCheckBlockedResponse = z.void();

export const zUsersBlockData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersBlockResponse = z.void();

export const zCodespacesListForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        repository_id: z.optional(z.int())
    }))
});

/**
 * Response
 */
export const zCodespacesListForAuthenticatedUserResponse = z.object({
    total_count: z.int(),
    codespaces: z.array(zCodespace)
});

export const zCodespacesCreateForAuthenticatedUserData = z.object({
    body: z.union([
        z.object({
            repository_id: z.int(),
            ref: z.optional(z.string()),
            location: z.optional(z.string()),
            geo: z.optional(z.enum([
                'EuropeWest',
                'SoutheastAsia',
                'UsEast',
                'UsWest'
            ])),
            client_ip: z.optional(z.string()),
            machine: z.optional(z.string()),
            devcontainer_path: z.optional(z.string()),
            multi_repo_permissions_opt_out: z.optional(z.boolean()),
            working_directory: z.optional(z.string()),
            idle_timeout_minutes: z.optional(z.int()),
            display_name: z.optional(z.string()),
            retention_period_minutes: z.optional(z.int())
        }),
        z.object({
            pull_request: z.object({
                pull_request_number: z.int(),
                repository_id: z.int()
            }),
            location: z.optional(z.string()),
            geo: z.optional(z.enum([
                'EuropeWest',
                'SoutheastAsia',
                'UsEast',
                'UsWest'
            ])),
            machine: z.optional(z.string()),
            devcontainer_path: z.optional(z.string()),
            working_directory: z.optional(z.string()),
            idle_timeout_minutes: z.optional(z.int())
        })
    ]),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response when the codespace was successfully created
 */
export const zCodespacesCreateForAuthenticatedUserResponse = zCodespace;

export const zCodespacesListSecretsForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zCodespacesListSecretsForAuthenticatedUserResponse = z.object({
    total_count: z.int(),
    secrets: z.array(zCodespacesSecret)
});

export const zCodespacesGetPublicKeyForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesGetPublicKeyForAuthenticatedUserResponse = zCodespacesUserPublicKey;

export const zCodespacesDeleteSecretForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesDeleteSecretForAuthenticatedUserResponse = z.void();

export const zCodespacesGetSecretForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesGetSecretForAuthenticatedUserResponse = zCodespacesSecret;

export const zCodespacesCreateOrUpdateSecretForAuthenticatedUserData = z.object({
    body: z.object({
        encrypted_value: z.optional(z.string().regex(/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})$/)),
        key_id: z.string(),
        selected_repository_ids: z.optional(z.array(z.union([
            z.int(),
            z.string()
        ])))
    }),
    path: z.object({
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

export const zCodespacesCreateOrUpdateSecretForAuthenticatedUserResponse = z.union([
    zEmptyObject,
    z.void()
]);

export const zCodespacesListRepositoriesForSecretForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesListRepositoriesForSecretForAuthenticatedUserResponse = z.object({
    total_count: z.int(),
    repositories: z.array(zMinimalRepository)
});

export const zCodespacesSetRepositoriesForSecretForAuthenticatedUserData = z.object({
    body: z.object({
        selected_repository_ids: z.array(z.int())
    }),
    path: z.object({
        secret_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * No Content when repositories were added to the selected list
 */
export const zCodespacesSetRepositoriesForSecretForAuthenticatedUserResponse = z.void();

export const zCodespacesRemoveRepositoryForSecretForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        secret_name: z.string(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * No Content when repository was removed from the selected list
 */
export const zCodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse = z.void();

export const zCodespacesAddRepositoryForSecretForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        secret_name: z.string(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * No Content when repository was added to the selected list
 */
export const zCodespacesAddRepositoryForSecretForAuthenticatedUserResponse = z.void();

export const zCodespacesDeleteForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        codespace_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Accepted
 */
export const zCodespacesDeleteForAuthenticatedUserResponse = z.record(z.string(), z.unknown());

export const zCodespacesGetForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        codespace_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesGetForAuthenticatedUserResponse = zCodespace;

export const zCodespacesUpdateForAuthenticatedUserData = z.object({
    body: z.optional(z.object({
        machine: z.optional(z.string()),
        display_name: z.optional(z.string()),
        recent_folders: z.optional(z.array(z.string()))
    })),
    path: z.object({
        codespace_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesUpdateForAuthenticatedUserResponse = zCodespace;

export const zCodespacesExportForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        codespace_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesExportForAuthenticatedUserResponse = zCodespaceExportDetails;

export const zCodespacesGetExportDetailsForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        codespace_name: z.string(),
        export_id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesGetExportDetailsForAuthenticatedUserResponse = zCodespaceExportDetails;

export const zCodespacesCodespaceMachinesForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        codespace_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesCodespaceMachinesForAuthenticatedUserResponse = z.object({
    total_count: z.int(),
    machines: z.array(zCodespaceMachine)
});

export const zCodespacesPublishForAuthenticatedUserData = z.object({
    body: z.object({
        name: z.optional(z.string()),
        private: z.optional(z.boolean()).default(false)
    }),
    path: z.object({
        codespace_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesPublishForAuthenticatedUserResponse = zCodespaceWithFullRepository;

export const zCodespacesStartForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        codespace_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesStartForAuthenticatedUserResponse = zCodespace;

export const zCodespacesStopForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        codespace_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zCodespacesStopForAuthenticatedUserResponse = zCodespace;

export const zPackagesListDockerMigrationConflictingPackagesForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesListDockerMigrationConflictingPackagesForAuthenticatedUserResponse = z.array(zPackage);

export const zUsersSetPrimaryEmailVisibilityForAuthenticatedUserData = z.object({
    body: z.object({
        visibility: z.enum([
            'public',
            'private'
        ])
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse = z.array(zEmail);

export const zUsersDeleteEmailForAuthenticatedUserData = z.object({
    body: z.optional(z.union([
        z.object({
            emails: z.array(z.string()).min(1)
        }),
        z.array(z.string()).min(1),
        z.string()
    ])),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersDeleteEmailForAuthenticatedUserResponse = z.void();

export const zUsersListEmailsForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zUsersListEmailsForAuthenticatedUserResponse = z.array(zEmail);

export const zUsersAddEmailForAuthenticatedUserData = z.object({
    body: z.optional(z.union([
        z.object({
            emails: z.array(z.string()).min(1)
        }),
        z.array(z.string()).min(1),
        z.string()
    ])),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersAddEmailForAuthenticatedUserResponse = z.array(zEmail);

export const zUsersListFollowersForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zUsersListFollowersForAuthenticatedUserResponse = z.array(zSimpleUser);

export const zUsersListFollowedByAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zUsersListFollowedByAuthenticatedUserResponse = z.array(zSimpleUser);

export const zUsersUnfollowData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersUnfollowResponse = z.void();

export const zUsersCheckPersonIsFollowedByAuthenticatedData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * if the person is followed by the authenticated user
 */
export const zUsersCheckPersonIsFollowedByAuthenticatedResponse = z.void();

export const zUsersFollowData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersFollowResponse = z.void();

export const zUsersListGpgKeysForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zUsersListGpgKeysForAuthenticatedUserResponse = z.array(zGpgKey);

export const zUsersCreateGpgKeyForAuthenticatedUserData = z.object({
    body: z.object({
        name: z.optional(z.string()),
        armored_public_key: z.string()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersCreateGpgKeyForAuthenticatedUserResponse = zGpgKey;

export const zUsersDeleteGpgKeyForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        gpg_key_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersDeleteGpgKeyForAuthenticatedUserResponse = z.void();

export const zUsersGetGpgKeyForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        gpg_key_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersGetGpgKeyForAuthenticatedUserResponse = zGpgKey;

export const zAppsListInstallationsForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * You can find the permissions for the installation under the `permissions` key.
 */
export const zAppsListInstallationsForAuthenticatedUserResponse = z.object({
    total_count: z.int(),
    installations: z.array(zInstallation)
});

export const zAppsListInstallationReposForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        installation_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * The access the user has to each repository is included in the hash under the `permissions` key.
 */
export const zAppsListInstallationReposForAuthenticatedUserResponse = z.object({
    total_count: z.int(),
    repository_selection: z.optional(z.string()),
    repositories: z.array(zRepository)
});

export const zAppsRemoveRepoFromInstallationForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        installation_id: z.int(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsRemoveRepoFromInstallationForAuthenticatedUserResponse = z.void();

export const zAppsAddRepoToInstallationForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        installation_id: z.int(),
        repository_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsAddRepoToInstallationForAuthenticatedUserResponse = z.void();

export const zInteractionsRemoveRestrictionsForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zInteractionsRemoveRestrictionsForAuthenticatedUserResponse = z.void();

export const zInteractionsGetRestrictionsForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zInteractionsGetRestrictionsForAuthenticatedUserResponse = z.union([
    z.union([
        zInteractionLimitResponse,
        z.record(z.string(), z.never())
    ]),
    z.void()
]);

export const zInteractionsSetRestrictionsForAuthenticatedUserData = z.object({
    body: zInteractionLimit,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zInteractionsSetRestrictionsForAuthenticatedUserResponse = zInteractionLimitResponse;

export const zIssuesListForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        filter: z.optional(z.enum([
            'assigned',
            'created',
            'mentioned',
            'subscribed',
            'repos',
            'all'
        ])),
        state: z.optional(z.enum([
            'open',
            'closed',
            'all'
        ])),
        labels: z.optional(z.string()),
        sort: z.optional(z.enum([
            'created',
            'updated',
            'comments'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        since: z.optional(z.iso.datetime()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zIssuesListForAuthenticatedUserResponse = z.array(zIssue);

export const zUsersListPublicSshKeysForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zUsersListPublicSshKeysForAuthenticatedUserResponse = z.array(zKey);

export const zUsersCreatePublicSshKeyForAuthenticatedUserData = z.object({
    body: z.object({
        title: z.optional(z.string()),
        key: z.string().regex(/^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) /)
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersCreatePublicSshKeyForAuthenticatedUserResponse = zKey;

export const zUsersDeletePublicSshKeyForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        key_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersDeletePublicSshKeyForAuthenticatedUserResponse = z.void();

export const zUsersGetPublicSshKeyForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        key_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersGetPublicSshKeyForAuthenticatedUserResponse = zKey;

export const zAppsListSubscriptionsForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zAppsListSubscriptionsForAuthenticatedUserResponse = z.array(zUserMarketplacePurchase);

export const zAppsListSubscriptionsForAuthenticatedUserStubbedData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zAppsListSubscriptionsForAuthenticatedUserStubbedResponse = z.array(zUserMarketplacePurchase);

export const zOrgsListMembershipsForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        state: z.optional(z.enum([
            'active',
            'pending'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zOrgsListMembershipsForAuthenticatedUserResponse = z.array(zOrgMembership);

export const zOrgsGetMembershipForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsGetMembershipForAuthenticatedUserResponse = zOrgMembership;

export const zOrgsUpdateMembershipForAuthenticatedUserData = z.object({
    body: z.object({
        state: z.enum([
            'active'
        ])
    }),
    path: z.object({
        org: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zOrgsUpdateMembershipForAuthenticatedUserResponse = zOrgMembership;

export const zMigrationsListForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zMigrationsListForAuthenticatedUserResponse = z.array(zMigration);

export const zMigrationsStartForAuthenticatedUserData = z.object({
    body: z.object({
        lock_repositories: z.optional(z.boolean()),
        exclude_metadata: z.optional(z.boolean()),
        exclude_git_data: z.optional(z.boolean()),
        exclude_attachments: z.optional(z.boolean()),
        exclude_releases: z.optional(z.boolean()),
        exclude_owner_projects: z.optional(z.boolean()),
        org_metadata_only: z.optional(z.boolean()).default(false),
        exclude: z.optional(z.array(z.enum([
            'repositories'
        ]))),
        repositories: z.array(z.string())
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMigrationsStartForAuthenticatedUserResponse = zMigration;

export const zMigrationsGetStatusForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        migration_id: z.int()
    }),
    query: z.optional(z.object({
        exclude: z.optional(z.array(z.string()))
    }))
});

/**
 * Response
 */
export const zMigrationsGetStatusForAuthenticatedUserResponse = zMigration;

export const zMigrationsDeleteArchiveForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        migration_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMigrationsDeleteArchiveForAuthenticatedUserResponse = z.void();

export const zMigrationsGetArchiveForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        migration_id: z.int()
    }),
    query: z.optional(z.never())
});

export const zMigrationsUnlockRepoForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        migration_id: z.int(),
        repo_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMigrationsUnlockRepoForAuthenticatedUserResponse = z.void();

export const zMigrationsListReposForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        migration_id: z.int()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zMigrationsListReposForAuthenticatedUserResponse = z.array(zMinimalRepository);

export const zOrgsListForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zOrgsListForAuthenticatedUserResponse = z.array(zOrganizationSimple);

export const zPackagesListPackagesForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        visibility: z.optional(z.enum([
            'public',
            'private',
            'internal'
        ])),
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    })
});

/**
 * Response
 */
export const zPackagesListPackagesForAuthenticatedUserResponse = z.array(zPackage);

export const zPackagesDeletePackageForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesDeletePackageForAuthenticatedUserResponse = z.void();

export const zPackagesGetPackageForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesGetPackageForAuthenticatedUserResponse = zPackage;

export const zPackagesRestorePackageForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string()
    }),
    query: z.optional(z.object({
        token: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zPackagesRestorePackageForAuthenticatedUserResponse = z.void();

export const zPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30),
        state: z.optional(z.enum([
            'active',
            'deleted'
        ]))
    }))
});

/**
 * Response
 */
export const zPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse = z.array(zPackageVersion);

export const zPackagesDeletePackageVersionForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        package_version_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesDeletePackageVersionForAuthenticatedUserResponse = z.void();

export const zPackagesGetPackageVersionForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        package_version_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesGetPackageVersionForAuthenticatedUserResponse = zPackageVersion;

export const zPackagesRestorePackageVersionForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        package_version_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesRestorePackageVersionForAuthenticatedUserResponse = z.void();

export const zProjectsClassicCreateForAuthenticatedUserData = z.object({
    body: z.object({
        name: z.string(),
        body: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsClassicCreateForAuthenticatedUserResponse = zProject;

export const zUsersListPublicEmailsForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zUsersListPublicEmailsForAuthenticatedUserResponse = z.array(zEmail);

export const zReposListForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        visibility: z.optional(z.enum([
            'all',
            'public',
            'private'
        ])),
        affiliation: z.optional(z.string()).default('owner,collaborator,organization_member'),
        type: z.optional(z.enum([
            'all',
            'owner',
            'public',
            'private',
            'member'
        ])),
        sort: z.optional(z.enum([
            'created',
            'updated',
            'pushed',
            'full_name'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1),
        since: z.optional(z.iso.datetime()),
        before: z.optional(z.iso.datetime())
    }))
});

/**
 * Response
 */
export const zReposListForAuthenticatedUserResponse = z.array(zRepository);

export const zReposCreateForAuthenticatedUserData = z.object({
    body: z.object({
        name: z.string(),
        description: z.optional(z.string()),
        homepage: z.optional(z.string()),
        private: z.optional(z.boolean()).default(false),
        has_issues: z.optional(z.boolean()).default(true),
        has_projects: z.optional(z.boolean()).default(true),
        has_wiki: z.optional(z.boolean()).default(true),
        has_discussions: z.optional(z.boolean()).default(false),
        team_id: z.optional(z.int()),
        auto_init: z.optional(z.boolean()).default(false),
        gitignore_template: z.optional(z.string()),
        license_template: z.optional(z.string()),
        allow_squash_merge: z.optional(z.boolean()).default(true),
        allow_merge_commit: z.optional(z.boolean()).default(true),
        allow_rebase_merge: z.optional(z.boolean()).default(true),
        allow_auto_merge: z.optional(z.boolean()).default(false),
        delete_branch_on_merge: z.optional(z.boolean()).default(false),
        squash_merge_commit_title: z.optional(z.enum([
            'PR_TITLE',
            'COMMIT_OR_PR_TITLE'
        ])),
        squash_merge_commit_message: z.optional(z.enum([
            'PR_BODY',
            'COMMIT_MESSAGES',
            'BLANK'
        ])),
        merge_commit_title: z.optional(z.enum([
            'PR_TITLE',
            'MERGE_MESSAGE'
        ])),
        merge_commit_message: z.optional(z.enum([
            'PR_BODY',
            'PR_TITLE',
            'BLANK'
        ])),
        has_downloads: z.optional(z.boolean()).default(true),
        is_template: z.optional(z.boolean()).default(false)
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposCreateForAuthenticatedUserResponse = zFullRepository;

export const zReposListInvitationsForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListInvitationsForAuthenticatedUserResponse = z.array(zRepositoryInvitation);

export const zReposDeclineInvitationForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        invitation_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposDeclineInvitationForAuthenticatedUserResponse = z.void();

export const zReposAcceptInvitationForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        invitation_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zReposAcceptInvitationForAuthenticatedUserResponse = z.void();

export const zUsersDeleteSocialAccountForAuthenticatedUserData = z.object({
    body: z.object({
        account_urls: z.array(z.string())
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersDeleteSocialAccountForAuthenticatedUserResponse = z.void();

export const zUsersListSocialAccountsForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zUsersListSocialAccountsForAuthenticatedUserResponse = z.array(zSocialAccount);

export const zUsersAddSocialAccountForAuthenticatedUserData = z.object({
    body: z.object({
        account_urls: z.array(z.string())
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersAddSocialAccountForAuthenticatedUserResponse = z.array(zSocialAccount);

export const zUsersListSshSigningKeysForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zUsersListSshSigningKeysForAuthenticatedUserResponse = z.array(zSshSigningKey);

export const zUsersCreateSshSigningKeyForAuthenticatedUserData = z.object({
    body: z.object({
        title: z.optional(z.string()),
        key: z.string().regex(/^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) |^(sk-ssh-ed25519|sk-ecdsa-sha2-nistp256)@openssh.com /)
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersCreateSshSigningKeyForAuthenticatedUserResponse = zSshSigningKey;

export const zUsersDeleteSshSigningKeyForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        ssh_signing_key_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersDeleteSshSigningKeyForAuthenticatedUserResponse = z.void();

export const zUsersGetSshSigningKeyForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        ssh_signing_key_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersGetSshSigningKeyForAuthenticatedUserResponse = zSshSigningKey;

export const zActivityListReposStarredByAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        sort: z.optional(z.enum([
            'created',
            'updated'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActivityListReposStarredByAuthenticatedUserResponse = z.array(zRepository);

export const zActivityUnstarRepoForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActivityUnstarRepoForAuthenticatedUserResponse = z.void();

export const zActivityCheckRepoIsStarredByAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response if this repository is starred by you
 */
export const zActivityCheckRepoIsStarredByAuthenticatedUserResponse = z.void();

export const zActivityStarRepoForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        owner: z.string(),
        repo: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zActivityStarRepoForAuthenticatedUserResponse = z.void();

export const zActivityListWatchedReposForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActivityListWatchedReposForAuthenticatedUserResponse = z.array(zMinimalRepository);

export const zTeamsListForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zTeamsListForAuthenticatedUserResponse = z.array(zTeamFull);

export const zUsersGetByIdData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        account_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersGetByIdResponse = z.union([
    z.object({
        user_view_type: z.literal('private')
    }).and(zPrivateUser),
    z.object({
        user_view_type: z.literal('public')
    }).and(zPublicUser)
]);

export const zUsersListData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        since: z.optional(z.int()),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zUsersListResponse = z.array(zSimpleUser);

export const zUsersGetByUsernameData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zUsersGetByUsernameResponse = z.union([
    z.object({
        user_view_type: z.literal('private')
    }).and(zPrivateUser),
    z.object({
        user_view_type: z.literal('public')
    }).and(zPublicUser)
]);

export const zUsersListAttestationsBulkData = z.object({
    body: z.object({
        subject_digests: z.array(z.string()).min(1).max(1024),
        predicate_type: z.optional(z.string())
    }),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        before: z.optional(z.string()),
        after: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zUsersListAttestationsBulkResponse = z.object({
    attestations_subject_digests: z.optional(z.record(z.string(), z.union([
        z.array(z.object({
            bundle: z.optional(z.object({
                mediaType: z.optional(z.string()),
                verificationMaterial: z.optional(z.record(z.string(), z.unknown())),
                dsseEnvelope: z.optional(z.record(z.string(), z.unknown()))
            })),
            repository_id: z.optional(z.int()),
            bundle_url: z.optional(z.string())
        })),
        z.null()
    ]))),
    page_info: z.optional(z.object({
        has_next: z.optional(z.boolean()),
        has_previous: z.optional(z.boolean()),
        next: z.optional(z.string()),
        previous: z.optional(z.string())
    }))
});

export const zUsersDeleteAttestationsBulkData = z.object({
    body: z.union([
        z.object({
            subject_digests: z.array(z.string()).min(1).max(1024)
        }),
        z.object({
            attestation_ids: z.array(z.int()).min(1).max(1024)
        })
    ]),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

export const zUsersDeleteAttestationsBySubjectDigestData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string(),
        subject_digest: z.string()
    }),
    query: z.optional(z.never())
});

export const zUsersDeleteAttestationsBySubjectDigestResponse = z.union([
    z.unknown(),
    z.void()
]);

export const zUsersDeleteAttestationsByIdData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string(),
        attestation_id: z.int()
    }),
    query: z.optional(z.never())
});

export const zUsersDeleteAttestationsByIdResponse = z.union([
    z.unknown(),
    z.void()
]);

export const zUsersListAttestationsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string(),
        subject_digest: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        predicate_type: z.optional(z.string())
    }))
});

export const zUsersListAttestationsResponse = z.union([
    z.object({
        attestations: z.optional(z.array(z.object({
            bundle: z.optional(z.object({
                mediaType: z.optional(z.string()),
                verificationMaterial: z.optional(z.record(z.string(), z.unknown())),
                dsseEnvelope: z.optional(z.record(z.string(), z.unknown()))
            })),
            repository_id: z.optional(z.int()),
            bundle_url: z.optional(z.string()),
            initiator: z.optional(z.string())
        })))
    }),
    zEmptyObject,
    z.void()
]);

export const zPackagesListDockerMigrationConflictingPackagesForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesListDockerMigrationConflictingPackagesForUserResponse = z.array(zPackage);

export const zActivityListEventsForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActivityListEventsForAuthenticatedUserResponse = z.array(zEvent);

export const zActivityListOrgEventsForAuthenticatedUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string(),
        org: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActivityListOrgEventsForAuthenticatedUserResponse = z.array(zEvent);

export const zActivityListPublicEventsForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActivityListPublicEventsForUserResponse = z.array(zEvent);

export const zUsersListFollowersForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zUsersListFollowersForUserResponse = z.array(zSimpleUser);

export const zUsersListFollowingForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zUsersListFollowingForUserResponse = z.array(zSimpleUser);

export const zUsersCheckFollowingForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string(),
        target_user: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * if the user follows the target user
 */
export const zUsersCheckFollowingForUserResponse = z.void();

export const zGistsListForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        since: z.optional(z.iso.datetime()),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zGistsListForUserResponse = z.array(zBaseGist);

export const zUsersListGpgKeysForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zUsersListGpgKeysForUserResponse = z.array(zGpgKey);

export const zUsersGetContextForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        subject_type: z.optional(z.enum([
            'organization',
            'repository',
            'issue',
            'pull_request'
        ])),
        subject_id: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zUsersGetContextForUserResponse = zHovercard;

export const zAppsGetUserInstallationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zAppsGetUserInstallationResponse = zInstallation;

export const zUsersListPublicKeysForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zUsersListPublicKeysForUserResponse = z.array(zKeySimple);

export const zOrgsListForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zOrgsListForUserResponse = z.array(zOrganizationSimple);

export const zPackagesListPackagesForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        visibility: z.optional(z.enum([
            'public',
            'private',
            'internal'
        ])),
        page: z.optional(z.int()).default(1),
        per_page: z.optional(z.int()).default(30)
    })
});

/**
 * Response
 */
export const zPackagesListPackagesForUserResponse = z.array(zPackage);

export const zPackagesDeletePackageForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesDeletePackageForUserResponse = z.void();

export const zPackagesGetPackageForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesGetPackageForUserResponse = zPackage;

export const zPackagesRestorePackageForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        username: z.string()
    }),
    query: z.optional(z.object({
        token: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zPackagesRestorePackageForUserResponse = z.void();

export const zPackagesGetAllPackageVersionsForPackageOwnedByUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesGetAllPackageVersionsForPackageOwnedByUserResponse = z.array(zPackageVersion);

export const zPackagesDeletePackageVersionForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        username: z.string(),
        package_version_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesDeletePackageVersionForUserResponse = z.void();

export const zPackagesGetPackageVersionForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        package_version_id: z.int(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesGetPackageVersionForUserResponse = zPackageVersion;

export const zPackagesRestorePackageVersionForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        package_type: z.enum([
            'npm',
            'maven',
            'rubygems',
            'docker',
            'nuget',
            'container'
        ]),
        package_name: z.string(),
        username: z.string(),
        package_version_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zPackagesRestorePackageVersionForUserResponse = z.void();

export const zProjectsClassicListForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        state: z.optional(z.enum([
            'open',
            'closed',
            'all'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zProjectsClassicListForUserResponse = z.array(zProject);

export const zProjectsListForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        q: z.optional(z.string()),
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        per_page: z.optional(z.int()).default(30)
    }))
});

/**
 * Response
 */
export const zProjectsListForUserResponse = z.array(zProjectsV2);

export const zProjectsGetForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_number: z.int(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsGetForUserResponse = zProjectsV2;

export const zProjectsListFieldsForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_number: z.int(),
        username: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        before: z.optional(z.string()),
        after: z.optional(z.string())
    }))
});

/**
 * Response
 */
export const zProjectsListFieldsForUserResponse = z.array(zProjectsV2Field);

export const zProjectsGetFieldForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_number: z.int(),
        field_id: z.int(),
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsGetFieldForUserResponse = zProjectsV2Field;

export const zProjectsListItemsForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_number: z.int(),
        username: z.string()
    }),
    query: z.optional(z.object({
        before: z.optional(z.string()),
        after: z.optional(z.string()),
        per_page: z.optional(z.int()).default(30),
        q: z.optional(z.string()),
        fields: z.optional(z.union([
            z.string(),
            z.array(z.string()).max(50)
        ]))
    }))
});

/**
 * Response
 */
export const zProjectsListItemsForUserResponse = z.array(zProjectsV2ItemWithContent);

export const zProjectsAddItemForUserData = z.object({
    body: z.object({
        type: z.enum([
            'Issue',
            'PullRequest'
        ]),
        id: z.int()
    }),
    path: z.object({
        username: z.string(),
        project_number: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsAddItemForUserResponse = zProjectsV2ItemSimple;

export const zProjectsDeleteItemForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_number: z.int(),
        username: z.string(),
        item_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsDeleteItemForUserResponse = z.void();

export const zProjectsGetUserItemData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        project_number: z.int(),
        username: z.string(),
        item_id: z.int()
    }),
    query: z.optional(z.object({
        fields: z.optional(z.union([
            z.string(),
            z.array(z.string()).max(50)
        ]))
    }))
});

/**
 * Response
 */
export const zProjectsGetUserItemResponse = zProjectsV2ItemWithContent;

export const zProjectsUpdateItemForUserData = z.object({
    body: z.object({
        fields: z.array(z.object({
            id: z.int(),
            value: z.union([
                z.string(),
                z.number(),
                z.null()
            ])
        }))
    }),
    path: z.object({
        project_number: z.int(),
        username: z.string(),
        item_id: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zProjectsUpdateItemForUserResponse = zProjectsV2ItemWithContent;

export const zActivityListReceivedEventsForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActivityListReceivedEventsForUserResponse = z.array(zEvent);

export const zActivityListReceivedPublicEventsForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActivityListReceivedPublicEventsForUserResponse = z.array(zEvent);

export const zReposListForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        type: z.optional(z.enum([
            'all',
            'owner',
            'member'
        ])),
        sort: z.optional(z.enum([
            'created',
            'updated',
            'pushed',
            'full_name'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zReposListForUserResponse = z.array(zMinimalRepository);

export const zBillingGetGithubActionsBillingUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zBillingGetGithubActionsBillingUserResponse = zActionsBillingUsage;

export const zBillingGetGithubPackagesBillingUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zBillingGetGithubPackagesBillingUserResponse = zPackagesBillingUsage;

export const zBillingGetGithubBillingPremiumRequestUsageReportUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        year: z.optional(z.int()),
        month: z.optional(z.int()),
        day: z.optional(z.int()),
        model: z.optional(z.string()),
        product: z.optional(z.string())
    }))
});

/**
 * Response when getting a billing premium request usage report
 */
export const zBillingGetGithubBillingPremiumRequestUsageReportUserResponse = zBillingPremiumRequestUsageReportUser;

export const zBillingGetSharedStorageBillingUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zBillingGetSharedStorageBillingUserResponse = zCombinedBillingUsage;

export const zBillingGetGithubBillingUsageReportUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        year: z.optional(z.int()),
        month: z.optional(z.int()),
        day: z.optional(z.int()),
        hour: z.optional(z.int())
    }))
});

/**
 * Response when getting a billing usage report
 */
export const zBillingGetGithubBillingUsageReportUserResponse = zBillingUsageReportUser;

export const zUsersListSocialAccountsForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zUsersListSocialAccountsForUserResponse = z.array(zSocialAccount);

export const zUsersListSshSigningKeysForUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zUsersListSshSigningKeysForUserResponse = z.array(zSshSigningKey);

export const zActivityListReposStarredByUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        sort: z.optional(z.enum([
            'created',
            'updated'
        ])),
        direction: z.optional(z.enum([
            'asc',
            'desc'
        ])),
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActivityListReposStarredByUserResponse = z.union([
    z.array(zStarredRepository),
    z.array(zRepository)
]);

export const zActivityListReposWatchedByUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.object({
        per_page: z.optional(z.int()).default(30),
        page: z.optional(z.int()).default(1)
    }))
});

/**
 * Response
 */
export const zActivityListReposWatchedByUserResponse = z.array(zMinimalRepository);

export const zMetaGetAllVersionsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMetaGetAllVersionsResponse = z.array(z.iso.date());

export const zMetaGetZenData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Response
 */
export const zMetaGetZenResponse = z.string();
