/**
* Generated by Kubb (https://kubb.dev/).
* Do not edit manually.
*/

import { z } from "zod/v4";

export const rootSchema = z.object({
    "current_user_url": z.string(),
"current_user_authorizations_html_url": z.string(),
"authorizations_url": z.string(),
"code_search_url": z.string(),
"commit_search_url": z.string(),
"emails_url": z.string(),
"emojis_url": z.string(),
"events_url": z.string(),
"feeds_url": z.string(),
"followers_url": z.string(),
"following_url": z.string(),
"gists_url": z.string(),
"hub_url": z.optional(z.string()),
"issue_search_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"label_search_url": z.string(),
"notifications_url": z.string(),
"organization_url": z.string(),
"organization_repositories_url": z.string(),
"organization_teams_url": z.string(),
"public_gists_url": z.string(),
"rate_limit_url": z.string(),
"repository_url": z.string(),
"repository_search_url": z.string(),
"current_user_repositories_url": z.string(),
"starred_url": z.string(),
"starred_gists_url": z.string(),
"topic_search_url": z.optional(z.string()),
"user_url": z.string(),
"user_organizations_url": z.string(),
"user_repositories_url": z.string(),
"user_search_url": z.string()
    })

/**
 * @description The package\'s language or package management ecosystem.
 */
export const securityAdvisoryEcosystemsSchema = z.enum(["rubygems", "npm", "pip", "maven", "nuget", "composer", "go", "rust", "erlang", "actions", "pub", "other", "swift"]).describe("The package's language or package management ecosystem.")

/**
 * @description A vulnerability describing the product and its affected versions within a GitHub Security Advisory.
 */
export const vulnerabilitySchema = z.object({
    "package": z.nullable(z.object({
    get "ecosystem"(){
                return securityAdvisoryEcosystemsSchema.describe("The package's language or package management ecosystem.")
              },
"name": z.nullable(z.string().describe("The unique package name within its ecosystem."))
    }).describe("The name of the package affected by the vulnerability.")),
"vulnerable_version_range": z.nullable(z.string().describe("The range of the package versions affected by the vulnerability.")),
"first_patched_version": z.nullable(z.string().describe("The package version that resolves the vulnerability.")),
"vulnerable_functions": z.nullable(z.array(z.string()).describe("The functions in the package that are affected by the vulnerability."))
    }).describe("A vulnerability describing the product and its affected versions within a GitHub Security Advisory.")

export const cvssSeveritiesSchema = z.object({
    "cvss_v3": z.object({
    "vector_string": z.nullable(z.string().describe("The CVSS 3 vector string.")),
"score": z.nullable(z.number().min(0).max(10).describe("The CVSS 3 score."))
    }).nullish(),
"cvss_v4": z.object({
    "vector_string": z.nullable(z.string().describe("The CVSS 4 vector string.")),
"score": z.nullable(z.number().min(0).max(10).describe("The CVSS 4 score."))
    }).nullish()
    }).nullable()

/**
 * @description The EPSS scores as calculated by the [Exploit Prediction Scoring System](https://www.first.org/epss).
 */
export const securityAdvisoryEpssSchema = z.object({
    "percentage": z.optional(z.number().min(0).max(100)),
"percentile": z.optional(z.number().min(0).max(100))
    }).describe("The EPSS scores as calculated by the [Exploit Prediction Scoring System](https://www.first.org/epss).").nullable()

/**
 * @description A GitHub user.
 */
export const simpleUserSchema = z.object({
    "name": z.string().nullish(),
"email": z.string().nullish(),
"login": z.string(),
"id": z.int(),
"node_id": z.string(),
"avatar_url": z.url(),
"gravatar_id": z.nullable(z.string()),
"url": z.url(),
"html_url": z.url(),
"followers_url": z.url(),
"following_url": z.string(),
"gists_url": z.string(),
"starred_url": z.string(),
"subscriptions_url": z.url(),
"organizations_url": z.url(),
"repos_url": z.url(),
"events_url": z.string(),
"received_events_url": z.url(),
"type": z.string(),
"site_admin": z.boolean(),
"starred_at": z.optional(z.string()),
"user_view_type": z.optional(z.string())
    }).describe("A GitHub user.")

/**
 * @description The type of credit the user is receiving.
 */
export const securityAdvisoryCreditTypesSchema = z.enum(["analyst", "finder", "reporter", "coordinator", "remediation_developer", "remediation_reviewer", "remediation_verifier", "tool", "sponsor", "other"]).describe("The type of credit the user is receiving.")

/**
 * @description A GitHub Security Advisory.
 */
export const globalAdvisorySchema = z.object({
    "ghsa_id": z.string().describe("The GitHub Security Advisory ID."),
"cve_id": z.nullable(z.string().describe("The Common Vulnerabilities and Exposures (CVE) ID.")),
"url": z.string().describe("The API URL for the advisory."),
"html_url": z.url().describe("The URL for the advisory."),
"repository_advisory_url": z.nullable(z.url().describe("The API URL for the repository advisory.")),
"summary": z.string().max(1024).describe("A short summary of the advisory."),
"description": z.nullable(z.string().max(65535).describe("A detailed description of what the advisory entails.")),
"type": z.enum(["reviewed", "unreviewed", "malware"]).describe("The type of advisory."),
"severity": z.enum(["critical", "high", "medium", "low", "unknown"]).describe("The severity of the advisory."),
"source_code_location": z.nullable(z.url().describe("The URL of the advisory's source code.")),
"identifiers": z.nullable(z.array(z.object({
    "type": z.enum(["CVE", "GHSA"]).describe("The type of identifier."),
"value": z.string().describe("The identifier value.")
    }))),
"references": z.nullable(z.array(z.string().describe("URLs with more information regarding the advisory."))),
"published_at": z.iso.datetime({ offset: true }).describe("The date and time of when the advisory was published, in ISO 8601 format."),
"updated_at": z.iso.datetime({ offset: true }).describe("The date and time of when the advisory was last updated, in ISO 8601 format."),
"github_reviewed_at": z.nullable(z.iso.datetime({ offset: true }).describe("The date and time of when the advisory was reviewed by GitHub, in ISO 8601 format.")),
"nvd_published_at": z.nullable(z.iso.datetime({ offset: true }).describe("The date and time when the advisory was published in the National Vulnerability Database, in ISO 8601 format.\nThis field is only populated when the advisory is imported from the National Vulnerability Database.")),
"withdrawn_at": z.nullable(z.iso.datetime({ offset: true }).describe("The date and time of when the advisory was withdrawn, in ISO 8601 format.")),
get "vulnerabilities"(){
               return z.array(vulnerabilitySchema.describe("A vulnerability describing the product and its affected versions within a GitHub Security Advisory.")).describe("The products and respective version ranges affected by the advisory.").nullable()
              },
"cvss": z.nullable(z.object({
    "vector_string": z.nullable(z.string().describe("The CVSS vector.")),
"score": z.nullable(z.number().min(0).max(10).describe("The CVSS score."))
    })),
get "cvss_severities"(){
                return cvssSeveritiesSchema.optional()
              },
get "epss"(){
                return securityAdvisoryEpssSchema.describe("The EPSS scores as calculated by the [Exploit Prediction Scoring System](https://www.first.org/epss).").optional()
              },
"cwes": z.nullable(z.array(z.object({
    "cwe_id": z.string().describe("The Common Weakness Enumeration (CWE) identifier."),
"name": z.string().describe("The name of the CWE.")
    }))),
"credits": z.nullable(z.array(z.object({
    get "user"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "type"(){
                return securityAdvisoryCreditTypesSchema.describe("The type of credit the user is receiving.")
              }
    })).describe("The users who contributed to the advisory."))
    }).describe("A GitHub Security Advisory.")

/**
 * @description Basic Error
 */
export const basicErrorSchema = z.object({
    "message": z.optional(z.string()),
"documentation_url": z.optional(z.string()),
"url": z.optional(z.string()),
"status": z.optional(z.string())
    }).describe("Basic Error")

/**
 * @description Validation Error Simple
 */
export const validationErrorSimpleSchema = z.object({
    "message": z.string(),
"documentation_url": z.string(),
"errors": z.optional(z.array(z.string()))
    }).describe("Validation Error Simple")

/**
 * @description An enterprise on GitHub.
 */
export const enterpriseSchema = z.object({
    "description": z.string().describe("A short description of the enterprise.").nullish(),
"html_url": z.url(),
"website_url": z.url().describe("The enterprise's website URL.").nullish(),
"id": z.int().describe("Unique identifier of the enterprise"),
"node_id": z.string(),
"name": z.string().describe("The name of the enterprise."),
"slug": z.string().describe("The slug url identifier for the enterprise."),
"created_at": z.nullable(z.iso.datetime({ offset: true })),
"updated_at": z.nullable(z.iso.datetime({ offset: true })),
"avatar_url": z.url()
    }).describe("An enterprise on GitHub.")

/**
 * @description GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
 */
export const integrationSchema = z.object({
    "id": z.int().describe("Unique identifier of the GitHub app"),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"node_id": z.string(),
"client_id": z.optional(z.string()),
get "owner"(){
                return z.union([simpleUserSchema, enterpriseSchema])
              },
"name": z.string().describe("The name of the GitHub app"),
"description": z.nullable(z.string()),
"external_url": z.url(),
"html_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"permissions": z.object({
    "issues": z.optional(z.string()),
"checks": z.optional(z.string()),
"metadata": z.optional(z.string()),
"contents": z.optional(z.string()),
"deployments": z.optional(z.string())
    }).catchall(z.string()).describe("The set of permissions for the GitHub app"),
"events": z.array(z.string()).describe("The list of events for the GitHub app. Note that the `installation_target`, `security_advisory`, and `meta` events are not included because they are global events and not specific to an installation."),
"installations_count": z.optional(z.int().describe("The number of installations associated with the GitHub app. Only returned when the integration is requesting details about itself."))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()

/**
 * @description The URL to which the payloads will be delivered.
 */
export const webhookConfigUrlSchema = z.url().describe("The URL to which the payloads will be delivered.")

/**
 * @description The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
 */
export const webhookConfigContentTypeSchema = z.string().describe("The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.")

/**
 * @description If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).
 */
export const webhookConfigSecretSchema = z.string().describe("If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).")

export const webhookConfigInsecureSslSchema = z.union([z.string(), z.number()])

/**
 * @description Configuration object of the webhook
 */
export const webhookConfigSchema = z.object({
    get "url"(){
                return webhookConfigUrlSchema.describe("The URL to which the payloads will be delivered.").optional()
              },
get "content_type"(){
                return webhookConfigContentTypeSchema.describe("The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.").optional()
              },
get "secret"(){
                return webhookConfigSecretSchema.describe("If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).").optional()
              },
get "insecure_ssl"(){
                return webhookConfigInsecureSslSchema.optional()
              }
    }).describe("Configuration object of the webhook")

/**
 * @description Delivery made by a webhook, without request and response information.
 */
export const hookDeliveryItemSchema = z.object({
    "id": z.int().describe("Unique identifier of the webhook delivery."),
"guid": z.string().describe("Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event)."),
"delivered_at": z.iso.datetime({ offset: true }).describe("Time when the webhook delivery occurred."),
"redelivery": z.boolean().describe("Whether the webhook delivery is a redelivery."),
"duration": z.number().describe("Time spent delivering."),
"status": z.string().describe("Describes the response returned after attempting the delivery."),
"status_code": z.int().describe("Status code received when delivery was made."),
"event": z.string().describe("The event that triggered the delivery."),
"action": z.nullable(z.string().describe("The type of activity for the event that triggered the delivery.")),
"installation_id": z.nullable(z.int().describe("The id of the GitHub App installation associated with this event.")),
"repository_id": z.nullable(z.int().describe("The id of the repository associated with this event.")),
"throttled_at": z.iso.datetime({ offset: true }).describe("Time when the webhook delivery was throttled.").nullish()
    }).describe("Delivery made by a webhook, without request and response information.")

/**
 * @description Scim Error
 */
export const scimErrorSchema = z.object({
    "message": z.string().nullish(),
"documentation_url": z.string().nullish(),
"detail": z.string().nullish(),
"status": z.optional(z.int()),
"scimType": z.string().nullish(),
"schemas": z.optional(z.array(z.string()))
    }).describe("Scim Error")

/**
 * @description Validation Error
 */
export const validationErrorSchema = z.object({
    "message": z.string(),
"documentation_url": z.string(),
"errors": z.optional(z.array(z.object({
    "resource": z.optional(z.string()),
"field": z.optional(z.string()),
"message": z.optional(z.string()),
"code": z.string(),
"index": z.optional(z.int()),
"value": z.optional(z.union([z.int(), z.array(z.string()), z.string()]))
    })))
    }).describe("Validation Error")

/**
 * @description Delivery made by a webhook.
 */
export const hookDeliverySchema = z.object({
    "id": z.int().describe("Unique identifier of the delivery."),
"guid": z.string().describe("Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event)."),
"delivered_at": z.iso.datetime({ offset: true }).describe("Time when the delivery was delivered."),
"redelivery": z.boolean().describe("Whether the delivery is a redelivery."),
"duration": z.number().describe("Time spent delivering."),
"status": z.string().describe("Description of the status of the attempted delivery"),
"status_code": z.int().describe("Status code received when delivery was made."),
"event": z.string().describe("The event that triggered the delivery."),
"action": z.nullable(z.string().describe("The type of activity for the event that triggered the delivery.")),
"installation_id": z.nullable(z.int().describe("The id of the GitHub App installation associated with this event.")),
"repository_id": z.nullable(z.int().describe("The id of the repository associated with this event.")),
"throttled_at": z.iso.datetime({ offset: true }).describe("Time when the webhook delivery was throttled.").nullish(),
"url": z.optional(z.string().describe("The URL target of the delivery.")),
"request": z.object({
    "headers": z.nullable(z.object({
    
    }).catchall(z.unknown()).describe("The request headers sent with the webhook delivery.")),
"payload": z.nullable(z.object({
    
    }).catchall(z.unknown()).describe("The webhook payload."))
    }),
"response": z.object({
    "headers": z.nullable(z.object({
    
    }).catchall(z.unknown()).describe("The response headers received when the delivery was made.")),
"payload": z.nullable(z.object({
    
    }).catchall(z.unknown()).describe("The response payload received."))
    })
    }).describe("Delivery made by a webhook.")

/**
 * @description Request to install an integration on a target
 */
export const integrationInstallationRequestSchema = z.object({
    "id": z.int().describe("Unique identifier of the request installation."),
"node_id": z.optional(z.string()),
get "account"(){
                return z.union([simpleUserSchema, enterpriseSchema])
              },
get "requester"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"created_at": z.iso.datetime({ offset: true })
    }).describe("Request to install an integration on a target")

/**
 * @description The permissions granted to the user access token.
 */
export const appPermissionsSchema = z.object({
    "actions": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token for GitHub Actions workflows, workflow runs, and artifacts.")),
"administration": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token for repository creation, deletion, settings, teams, and collaborators creation.")),
"checks": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token for checks on code.")),
"codespaces": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to create, edit, delete, and list Codespaces.")),
"contents": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token for repository contents, commits, branches, downloads, releases, and merges.")),
"dependabot_secrets": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to manage Dependabot secrets.")),
"deployments": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token for deployments and deployment statuses.")),
"environments": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token for managing repository environments.")),
"issues": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token for issues and related comments, assignees, labels, and milestones.")),
"metadata": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to search repositories, list collaborators, and access repository metadata.")),
"packages": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token for packages published to GitHub Packages.")),
"pages": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to retrieve Pages statuses, configuration, and builds, as well as create new builds.")),
"pull_requests": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token for pull requests and related comments, assignees, labels, milestones, and merges.")),
"repository_custom_properties": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to view and edit custom properties for a repository, when allowed by the property.")),
"repository_hooks": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to manage the post-receive hooks for a repository.")),
"repository_projects": z.optional(z.enum(["read", "write", "admin"]).describe("The level of permission to grant the access token to manage repository projects, columns, and cards.")),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to view and manage secret scanning alerts.")),
"secrets": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to manage repository secrets.")),
"security_events": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to view and manage security events like code scanning alerts.")),
"single_file": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to manage just a single file.")),
"statuses": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token for commit statuses.")),
"vulnerability_alerts": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to manage Dependabot alerts.")),
"workflows": z.optional(z.enum(["write"]).describe("The level of permission to grant the access token to update GitHub Actions workflow files.")),
"custom_properties_for_organizations": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to view and edit custom properties for an organization, when allowed by the property.")),
"members": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token for organization teams and members.")),
"organization_administration": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to manage access to an organization.")),
"organization_custom_roles": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token for custom repository roles management.")),
"organization_custom_org_roles": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token for custom organization roles management.")),
"organization_custom_properties": z.optional(z.enum(["read", "write", "admin"]).describe("The level of permission to grant the access token for repository custom properties management at the organization level.")),
"organization_copilot_seat_management": z.optional(z.enum(["write"]).describe("The level of permission to grant the access token for managing access to GitHub Copilot for members of an organization with a Copilot Business subscription. This property is in public preview and is subject to change.")),
"organization_announcement_banners": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to view and manage announcement banners for an organization.")),
"organization_events": z.optional(z.enum(["read"]).describe("The level of permission to grant the access token to view events triggered by an activity in an organization.")),
"organization_hooks": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to manage the post-receive hooks for an organization.")),
"organization_personal_access_tokens": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token for viewing and managing fine-grained personal access token requests to an organization.")),
"organization_personal_access_token_requests": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token for viewing and managing fine-grained personal access tokens that have been approved by an organization.")),
"organization_plan": z.optional(z.enum(["read"]).describe("The level of permission to grant the access token for viewing an organization's plan.")),
"organization_projects": z.optional(z.enum(["read", "write", "admin"]).describe("The level of permission to grant the access token to manage organization projects and projects public preview (where available).")),
"organization_packages": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token for organization packages published to GitHub Packages.")),
"organization_secrets": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to manage organization secrets.")),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to view and manage GitHub Actions self-hosted runners available to an organization.")),
"organization_user_blocking": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to view and manage users blocked by the organization.")),
"team_discussions": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to manage team discussions and related comments.")),
"email_addresses": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to manage the email addresses belonging to a user.")),
"followers": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to manage the followers belonging to a user.")),
"git_ssh_keys": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to manage git SSH keys.")),
"gpg_keys": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to view and manage GPG keys belonging to a user.")),
"interaction_limits": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to view and manage interaction limits on a repository.")),
"profile": z.optional(z.enum(["write"]).describe("The level of permission to grant the access token to manage the profile settings belonging to a user.")),
"starring": z.optional(z.enum(["read", "write"]).describe("The level of permission to grant the access token to list and manage repositories a user is starring.")),
"enterprise_custom_properties_for_organizations": z.optional(z.enum(["read", "write", "admin"]).describe("The level of permission to grant the access token for organization custom properties management at the enterprise level."))
    }).describe("The permissions granted to the user access token.")

/**
 * @description A GitHub user.
 */
export const nullableSimpleUserSchema = z.object({
    "name": z.string().nullish(),
"email": z.string().nullish(),
"login": z.string(),
"id": z.int(),
"node_id": z.string(),
"avatar_url": z.url(),
"gravatar_id": z.nullable(z.string()),
"url": z.url(),
"html_url": z.url(),
"followers_url": z.url(),
"following_url": z.string(),
"gists_url": z.string(),
"starred_url": z.string(),
"subscriptions_url": z.url(),
"organizations_url": z.url(),
"repos_url": z.url(),
"events_url": z.string(),
"received_events_url": z.url(),
"type": z.string(),
"site_admin": z.boolean(),
"starred_at": z.optional(z.string()),
"user_view_type": z.optional(z.string())
    }).describe("A GitHub user.").nullable()

/**
 * @description Installation
 */
export const installationSchema = z.object({
    "id": z.int().describe("The ID of the installation."),
get "account"(){
               return z.union([simpleUserSchema, enterpriseSchema]).nullable()
              },
"repository_selection": z.enum(["all", "selected"]).describe("Describe whether all repositories have been selected or there's a selection involved"),
"access_tokens_url": z.url(),
"repositories_url": z.url(),
"html_url": z.url(),
"app_id": z.int(),
"client_id": z.optional(z.string()),
"target_id": z.int().describe("The ID of the user or organization this token is being scoped to."),
"target_type": z.string(),
get "permissions"(){
                return appPermissionsSchema.describe("The permissions granted to the user access token.")
              },
"events": z.array(z.string()),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"single_file_name": z.nullable(z.string()),
"has_multiple_single_files": z.optional(z.boolean()),
"single_file_paths": z.optional(z.array(z.string())),
"app_slug": z.string(),
get "suspended_by"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"suspended_at": z.nullable(z.iso.datetime({ offset: true })),
"contact_email": z.string().nullish()
    }).describe("Installation")

/**
 * @description License Simple
 */
export const nullableLicenseSimpleSchema = z.object({
    "key": z.string(),
"name": z.string(),
"url": z.nullable(z.url()),
"spdx_id": z.nullable(z.string()),
"node_id": z.string(),
"html_url": z.optional(z.url())
    }).describe("License Simple").nullable()

/**
 * @description A repository on GitHub.
 */
export const repositorySchema = z.object({
    "id": z.int().describe("Unique identifier of the repository"),
"node_id": z.string(),
"name": z.string().describe("The name of the repository."),
"full_name": z.string(),
get "license"(){
               return nullableLicenseSimpleSchema.describe("License Simple").nullable()
              },
"forks": z.int(),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"pull": z.boolean(),
"triage": z.optional(z.boolean()),
"push": z.boolean(),
"maintain": z.optional(z.boolean())
    })),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"private": z.boolean().default(false).describe("Whether the repository is private or public."),
"html_url": z.url(),
"description": z.nullable(z.string()),
"fork": z.boolean(),
"url": z.url(),
"archive_url": z.string(),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"deployments_url": z.url(),
"downloads_url": z.url(),
"events_url": z.url(),
"forks_url": z.url(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.string(),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"languages_url": z.url(),
"merges_url": z.url(),
"milestones_url": z.string(),
"notifications_url": z.string(),
"pulls_url": z.string(),
"releases_url": z.string(),
"ssh_url": z.string(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"trees_url": z.string(),
"clone_url": z.string(),
"mirror_url": z.nullable(z.url()),
"hooks_url": z.url(),
"svn_url": z.url(),
"homepage": z.nullable(z.url()),
"language": z.nullable(z.string()),
"forks_count": z.int(),
"stargazers_count": z.int(),
"watchers_count": z.int(),
"size": z.int().describe("The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0."),
"default_branch": z.string().describe("The default branch of the repository."),
"open_issues_count": z.int(),
"is_template": z.optional(z.boolean().default(false).describe("Whether this repository acts as a template that can be used to generate new repositories.")),
"topics": z.optional(z.array(z.string())),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_pages": z.boolean(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_discussions": z.optional(z.boolean().default(false).describe("Whether discussions are enabled.")),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"disabled": z.boolean().describe("Returns whether or not this repository disabled."),
"visibility": z.optional(z.string().default("public").describe("The repository visibility: public, private, or internal.")),
"pushed_at": z.nullable(z.iso.datetime({ offset: true })),
"created_at": z.nullable(z.iso.datetime({ offset: true })),
"updated_at": z.nullable(z.iso.datetime({ offset: true })),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"temp_clone_token": z.optional(z.string()),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow Auto-merge to be used on pull requests.")),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"allow_update_branch": z.optional(z.boolean().default(false).describe("Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.")),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow forking this repo")),
"web_commit_signoff_required": z.optional(z.boolean().default(false).describe("Whether to require contributors to sign off on web-based commits")),
"open_issues": z.int(),
"watchers": z.int(),
"master_branch": z.optional(z.string()),
"starred_at": z.optional(z.string()),
"anonymous_access_enabled": z.optional(z.boolean().describe("Whether anonymous git access is enabled for this repository")),
"code_search_index_status": z.optional(z.object({
    "lexical_search_ok": z.optional(z.boolean()),
"lexical_commit_sha": z.optional(z.string())
    }).describe("The status of the code search index for this repository"))
    }).describe("A repository on GitHub.")

/**
 * @description Authentication token for a GitHub App installed on a user or org.
 */
export const installationTokenSchema = z.object({
    "token": z.string(),
"expires_at": z.string(),
get "permissions"(){
                return appPermissionsSchema.describe("The permissions granted to the user access token.").optional()
              },
"repository_selection": z.optional(z.enum(["all", "selected"])),
get "repositories"(){
                return z.array(repositorySchema.describe("A repository on GitHub.")).optional()
              },
"single_file": z.optional(z.string()),
"has_multiple_single_files": z.optional(z.boolean()),
"single_file_paths": z.optional(z.array(z.string()))
    }).describe("Authentication token for a GitHub App installed on a user or org.")

export const nullableScopedInstallationSchema = z.object({
    get "permissions"(){
                return appPermissionsSchema.describe("The permissions granted to the user access token.")
              },
"repository_selection": z.enum(["all", "selected"]).describe("Describe whether all repositories have been selected or there's a selection involved"),
"single_file_name": z.nullable(z.string()),
"has_multiple_single_files": z.optional(z.boolean()),
"single_file_paths": z.optional(z.array(z.string())),
"repositories_url": z.url(),
get "account"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    }).nullable()

/**
 * @description The authorization for an OAuth app, GitHub App, or a Personal Access Token.
 */
export const authorizationSchema = z.object({
    "id": z.int(),
"url": z.url(),
"scopes": z.nullable(z.array(z.string()).describe("A list of scopes that this authorization is in.")),
"token": z.string(),
"token_last_eight": z.nullable(z.string()),
"hashed_token": z.nullable(z.string()),
"app": z.object({
    "client_id": z.string(),
"name": z.string(),
"url": z.url()
    }),
"note": z.nullable(z.string()),
"note_url": z.nullable(z.url()),
"updated_at": z.iso.datetime({ offset: true }),
"created_at": z.iso.datetime({ offset: true }),
"fingerprint": z.nullable(z.string()),
get "user"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
get "installation"(){
                return nullableScopedInstallationSchema.optional()
              },
"expires_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("The authorization for an OAuth app, GitHub App, or a Personal Access Token.")

/**
 * @description A GitHub repository view for Classroom
 */
export const simpleClassroomRepositorySchema = z.object({
    "id": z.int().describe("A unique identifier of the repository."),
"full_name": z.string().describe("The full, globally unique name of the repository."),
"html_url": z.url().describe("The URL to view the repository on GitHub.com."),
"node_id": z.string().describe("The GraphQL identifier of the repository."),
"private": z.boolean().describe("Whether the repository is private."),
"default_branch": z.string().describe("The default branch for the repository.")
    }).describe("A GitHub repository view for Classroom")

/**
 * @description A GitHub organization.
 */
export const simpleClassroomOrganizationSchema = z.object({
    "id": z.int(),
"login": z.string(),
"node_id": z.string(),
"html_url": z.url(),
"name": z.nullable(z.string()),
"avatar_url": z.string()
    }).describe("A GitHub organization.")

/**
 * @description A GitHub Classroom classroom
 */
export const classroomSchema = z.object({
    "id": z.int().describe("Unique identifier of the classroom."),
"name": z.string().describe("The name of the classroom."),
"archived": z.boolean().describe("Whether classroom is archived."),
get "organization"(){
                return simpleClassroomOrganizationSchema.describe("A GitHub organization.")
              },
"url": z.string().describe("The URL of the classroom on GitHub Classroom.")
    }).describe("A GitHub Classroom classroom")

/**
 * @description A GitHub Classroom assignment
 */
export const classroomAssignmentSchema = z.object({
    "id": z.int().describe("Unique identifier of the repository."),
"public_repo": z.boolean().describe("Whether an accepted assignment creates a public repository."),
"title": z.string().describe("Assignment title."),
"type": z.enum(["individual", "group"]).describe("Whether it's a group assignment or individual assignment."),
"invite_link": z.string().describe("The link that a student can use to accept the assignment."),
"invitations_enabled": z.boolean().describe("Whether the invitation link is enabled. Visiting an enabled invitation link will accept the assignment."),
"slug": z.string().describe("Sluggified name of the assignment."),
"students_are_repo_admins": z.boolean().describe("Whether students are admins on created repository when a student accepts the assignment."),
"feedback_pull_requests_enabled": z.boolean().describe("Whether feedback pull request will be created when a student accepts the assignment."),
"max_teams": z.nullable(z.int().describe("The maximum allowable teams for the assignment.")),
"max_members": z.nullable(z.int().describe("The maximum allowable members per team.")),
"editor": z.string().describe("The selected editor for the assignment."),
"accepted": z.int().describe("The number of students that have accepted the assignment."),
"submitted": z.int().describe("The number of students that have submitted the assignment."),
"passing": z.int().describe("The number of students that have passed the assignment."),
"language": z.string().describe("The programming language used in the assignment."),
"deadline": z.nullable(z.iso.datetime({ offset: true }).describe("The time at which the assignment is due.")),
get "starter_code_repository"(){
                return simpleClassroomRepositorySchema.describe("A GitHub repository view for Classroom")
              },
get "classroom"(){
                return classroomSchema.describe("A GitHub Classroom classroom")
              }
    }).describe("A GitHub Classroom assignment")

/**
 * @description A GitHub user simplified for Classroom.
 */
export const simpleClassroomUserSchema = z.object({
    "id": z.int(),
"login": z.string(),
"avatar_url": z.url(),
"html_url": z.url()
    }).describe("A GitHub user simplified for Classroom.")

/**
 * @description A GitHub Classroom classroom
 */
export const simpleClassroomSchema = z.object({
    "id": z.int().describe("Unique identifier of the classroom."),
"name": z.string().describe("The name of the classroom."),
"archived": z.boolean().describe("Returns whether classroom is archived or not."),
"url": z.string().describe("The url of the classroom on GitHub Classroom.")
    }).describe("A GitHub Classroom classroom")

/**
 * @description A GitHub Classroom assignment
 */
export const simpleClassroomAssignmentSchema = z.object({
    "id": z.int().describe("Unique identifier of the repository."),
"public_repo": z.boolean().describe("Whether an accepted assignment creates a public repository."),
"title": z.string().describe("Assignment title."),
"type": z.enum(["individual", "group"]).describe("Whether it's a Group Assignment or Individual Assignment."),
"invite_link": z.string().describe("The link that a student can use to accept the assignment."),
"invitations_enabled": z.boolean().describe("Whether the invitation link is enabled. Visiting an enabled invitation link will accept the assignment."),
"slug": z.string().describe("Sluggified name of the assignment."),
"students_are_repo_admins": z.boolean().describe("Whether students are admins on created repository on accepted assignment."),
"feedback_pull_requests_enabled": z.boolean().describe("Whether feedback pull request will be created on assignment acceptance."),
"max_teams": z.int().describe("The maximum allowable teams for the assignment.").nullish(),
"max_members": z.int().describe("The maximum allowable members per team.").nullish(),
"editor": z.string().describe("The selected editor for the assignment."),
"accepted": z.int().describe("The number of students that have accepted the assignment."),
"submitted": z.int().describe("The number of students that have submitted the assignment."),
"passing": z.int().describe("The number of students that have passed the assignment."),
"language": z.string().describe("The programming language used in the assignment."),
"deadline": z.nullable(z.iso.datetime({ offset: true }).describe("The time at which the assignment is due.")),
get "classroom"(){
                return simpleClassroomSchema.describe("A GitHub Classroom classroom")
              }
    }).describe("A GitHub Classroom assignment")

/**
 * @description A GitHub Classroom accepted assignment
 */
export const classroomAcceptedAssignmentSchema = z.object({
    "id": z.int().describe("Unique identifier of the repository."),
"submitted": z.boolean().describe("Whether an accepted assignment has been submitted."),
"passing": z.boolean().describe("Whether a submission passed."),
"commit_count": z.int().describe("Count of student commits."),
"grade": z.string().describe("Most recent grade."),
get "students"(){
                return z.array(simpleClassroomUserSchema.describe("A GitHub user simplified for Classroom."))
              },
get "repository"(){
                return simpleClassroomRepositorySchema.describe("A GitHub repository view for Classroom")
              },
get "assignment"(){
                return simpleClassroomAssignmentSchema.describe("A GitHub Classroom assignment")
              }
    }).describe("A GitHub Classroom accepted assignment")

/**
 * @description Grade for a student or groups GitHub Classroom assignment
 */
export const classroomAssignmentGradeSchema = z.object({
    "assignment_name": z.string().describe("Name of the assignment"),
"assignment_url": z.string().describe("URL of the assignment"),
"starter_code_url": z.string().describe("URL of the starter code for the assignment"),
"github_username": z.string().describe("GitHub username of the student"),
"roster_identifier": z.string().describe("Roster identifier of the student"),
"student_repository_name": z.string().describe("Name of the student's assignment repository"),
"student_repository_url": z.string().describe("URL of the student's assignment repository"),
"submission_timestamp": z.string().describe("Timestamp of the student's assignment submission"),
"points_awarded": z.int().describe("Number of points awarded to the student"),
"points_available": z.int().describe("Number of points available for the assignment"),
"group_name": z.optional(z.string().describe("If a group assignment, name of the group the student is in"))
    }).describe("Grade for a student or groups GitHub Classroom assignment")

/**
 * @description Code Of Conduct
 */
export const codeOfConductSchema = z.object({
    "key": z.string(),
"name": z.string(),
"url": z.url(),
"body": z.optional(z.string()),
"html_url": z.nullable(z.url())
    }).describe("Code Of Conduct")

/**
 * @description A code security configuration
 */
export const codeSecurityConfigurationSchema = z.object({
    "id": z.optional(z.int().describe("The ID of the code security configuration")),
"name": z.optional(z.string().describe("The name of the code security configuration. Must be unique within the organization.")),
"target_type": z.optional(z.enum(["global", "organization", "enterprise"]).describe("The type of the code security configuration.")),
"description": z.optional(z.string().describe("A description of the code security configuration")),
"advanced_security": z.optional(z.enum(["enabled", "disabled", "code_security", "secret_protection"]).describe("The enablement status of GitHub Advanced Security")),
"dependency_graph": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of Dependency Graph")),
"dependency_graph_autosubmit_action": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of Automatic dependency submission")),
"dependency_graph_autosubmit_action_options": z.optional(z.object({
    "labeled_runners": z.optional(z.boolean().describe("Whether to use runners labeled with 'dependency-submission' or standard GitHub runners."))
    }).describe("Feature options for Automatic dependency submission")),
"dependabot_alerts": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of Dependabot alerts")),
"dependabot_security_updates": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of Dependabot security updates")),
"code_scanning_options": z.object({
    "allow_advanced": z.boolean().describe("Whether to allow repos which use advanced setup").nullish()
    }).describe("Feature options for code scanning").nullish(),
"code_scanning_default_setup": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of code scanning default setup")),
"code_scanning_default_setup_options": z.object({
    "runner_type": z.enum(["standard", "labeled", "not_set"]).describe("Whether to use labeled runners or standard GitHub runners.").nullish(),
"runner_label": z.string().describe("The label of the runner to use for code scanning when runner_type is 'labeled'.").nullish()
    }).describe("Feature options for code scanning default setup").nullish(),
"code_scanning_delegated_alert_dismissal": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of code scanning delegated alert dismissal")),
"secret_scanning": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning")),
"secret_scanning_push_protection": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning push protection")),
"secret_scanning_delegated_bypass": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning delegated bypass")),
"secret_scanning_delegated_bypass_options": z.optional(z.object({
    "reviewers": z.optional(z.array(z.object({
    "reviewer_id": z.int().describe("The ID of the team or role selected as a bypass reviewer"),
"reviewer_type": z.enum(["TEAM", "ROLE"]).describe("The type of the bypass reviewer")
    })).describe("The bypass reviewers for secret scanning delegated bypass"))
    }).describe("Feature options for secret scanning delegated bypass")),
"secret_scanning_validity_checks": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning validity checks")),
"secret_scanning_non_provider_patterns": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning non-provider patterns")),
"secret_scanning_generic_secrets": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of Copilot secret scanning")),
"secret_scanning_delegated_alert_dismissal": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning delegated alert dismissal")),
"private_vulnerability_reporting": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of private vulnerability reporting")),
"enforcement": z.optional(z.enum(["enforced", "unenforced"]).describe("The enforcement status for a security configuration")),
"url": z.optional(z.url().describe("The URL of the configuration")),
"html_url": z.optional(z.url().describe("The URL of the configuration")),
"created_at": z.optional(z.iso.datetime({ offset: true })),
"updated_at": z.optional(z.iso.datetime({ offset: true }))
    }).describe("A code security configuration")

/**
 * @description Security Configuration feature options for code scanning
 */
export const codeScanningOptionsSchema = z.object({
    "allow_advanced": z.boolean().describe("Whether to allow repos which use advanced setup").nullish()
    }).describe("Security Configuration feature options for code scanning").nullable()

/**
 * @description Feature options for code scanning default setup
 */
export const codeScanningDefaultSetupOptionsSchema = z.object({
    "runner_type": z.optional(z.enum(["standard", "labeled", "not_set"]).describe("Whether to use labeled runners or standard GitHub runners.")),
"runner_label": z.string().describe("The label of the runner to use for code scanning default setup when runner_type is 'labeled'.").nullish()
    }).describe("Feature options for code scanning default setup").nullable()

/**
 * @description A list of default code security configurations
 */
export const codeSecurityDefaultConfigurationsSchema = z.array(z.object({
    "default_for_new_repos": z.optional(z.enum(["public", "private_and_internal", "all"]).describe("The visibility of newly created repositories for which the code security configuration will be applied to by default")),
get "configuration"(){
                return codeSecurityConfigurationSchema.describe("A code security configuration").optional()
              }
    })).describe("A list of default code security configurations")

/**
 * @description A GitHub repository.
 */
export const simpleRepositorySchema = z.object({
    "id": z.int().describe("A unique identifier of the repository."),
"node_id": z.string().describe("The GraphQL identifier of the repository."),
"name": z.string().describe("The name of the repository."),
"full_name": z.string().describe("The full, globally unique, name of the repository."),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"private": z.boolean().describe("Whether the repository is private."),
"html_url": z.url().describe("The URL to view the repository on GitHub.com."),
"description": z.nullable(z.string().describe("The repository description.")),
"fork": z.boolean().describe("Whether the repository is a fork."),
"url": z.url().describe("The URL to get more information about the repository from the GitHub API."),
"archive_url": z.string().describe("A template for the API URL to download the repository as an archive."),
"assignees_url": z.string().describe("A template for the API URL to list the available assignees for issues in the repository."),
"blobs_url": z.string().describe("A template for the API URL to create or retrieve a raw Git blob in the repository."),
"branches_url": z.string().describe("A template for the API URL to get information about branches in the repository."),
"collaborators_url": z.string().describe("A template for the API URL to get information about collaborators of the repository."),
"comments_url": z.string().describe("A template for the API URL to get information about comments on the repository."),
"commits_url": z.string().describe("A template for the API URL to get information about commits on the repository."),
"compare_url": z.string().describe("A template for the API URL to compare two commits or refs."),
"contents_url": z.string().describe("A template for the API URL to get the contents of the repository."),
"contributors_url": z.url().describe("A template for the API URL to list the contributors to the repository."),
"deployments_url": z.url().describe("The API URL to list the deployments of the repository."),
"downloads_url": z.url().describe("The API URL to list the downloads on the repository."),
"events_url": z.url().describe("The API URL to list the events of the repository."),
"forks_url": z.url().describe("The API URL to list the forks of the repository."),
"git_commits_url": z.string().describe("A template for the API URL to get information about Git commits of the repository."),
"git_refs_url": z.string().describe("A template for the API URL to get information about Git refs of the repository."),
"git_tags_url": z.string().describe("A template for the API URL to get information about Git tags of the repository."),
"issue_comment_url": z.string().describe("A template for the API URL to get information about issue comments on the repository."),
"issue_events_url": z.string().describe("A template for the API URL to get information about issue events on the repository."),
"issues_url": z.string().describe("A template for the API URL to get information about issues on the repository."),
"keys_url": z.string().describe("A template for the API URL to get information about deploy keys on the repository."),
"labels_url": z.string().describe("A template for the API URL to get information about labels of the repository."),
"languages_url": z.url().describe("The API URL to get information about the languages of the repository."),
"merges_url": z.url().describe("The API URL to merge branches in the repository."),
"milestones_url": z.string().describe("A template for the API URL to get information about milestones of the repository."),
"notifications_url": z.string().describe("A template for the API URL to get information about notifications on the repository."),
"pulls_url": z.string().describe("A template for the API URL to get information about pull requests on the repository."),
"releases_url": z.string().describe("A template for the API URL to get information about releases on the repository."),
"stargazers_url": z.url().describe("The API URL to list the stargazers on the repository."),
"statuses_url": z.string().describe("A template for the API URL to get information about statuses of a commit."),
"subscribers_url": z.url().describe("The API URL to list the subscribers on the repository."),
"subscription_url": z.url().describe("The API URL to subscribe to notifications for this repository."),
"tags_url": z.url().describe("The API URL to get information about tags on the repository."),
"teams_url": z.url().describe("The API URL to list the teams on the repository."),
"trees_url": z.string().describe("A template for the API URL to create or retrieve a raw Git tree of the repository."),
"hooks_url": z.url().describe("The API URL to list the hooks on the repository.")
    }).describe("A GitHub repository.")

/**
 * @description Repositories associated with a code security configuration and attachment status
 */
export const codeSecurityConfigurationRepositoriesSchema = z.object({
    "status": z.optional(z.enum(["attached", "attaching", "detached", "removed", "enforced", "failed", "updating", "removed_by_enterprise"]).describe("The attachment status of the code security configuration on the repository.")),
get "repository"(){
                return simpleRepositorySchema.describe("A GitHub repository.").optional()
              }
    }).describe("Repositories associated with a code security configuration and attachment status")

/**
 * @description The security alert number.
 */
export const alertNumberSchema = z.int().describe("The security alert number.")

/**
 * @description Details for the vulnerable package.
 */
export const dependabotAlertPackageSchema = z.object({
    "ecosystem": z.string().describe("The package's language or package management ecosystem."),
"name": z.string().describe("The unique package name within its ecosystem.")
    }).describe("Details for the vulnerable package.")

/**
 * @description Details pertaining to one vulnerable version range for the advisory.
 */
export const dependabotAlertSecurityVulnerabilitySchema = z.object({
    get "package"(){
                return dependabotAlertPackageSchema.describe("Details for the vulnerable package.")
              },
"severity": z.enum(["low", "medium", "high", "critical"]).describe("The severity of the vulnerability."),
"vulnerable_version_range": z.string().describe("Conditions that identify vulnerable versions of this vulnerability's package."),
"first_patched_version": z.nullable(z.object({
    "identifier": z.string().describe("The package version that patches this vulnerability.")
    }).describe("Details pertaining to the package version that patches this vulnerability."))
    }).describe("Details pertaining to one vulnerable version range for the advisory.")

/**
 * @description Details for the GitHub Security Advisory.
 */
export const dependabotAlertSecurityAdvisorySchema = z.object({
    "ghsa_id": z.string().describe("The unique GitHub Security Advisory ID assigned to the advisory."),
"cve_id": z.nullable(z.string().describe("The unique CVE ID assigned to the advisory.")),
"summary": z.string().max(1024).describe("A short, plain text summary of the advisory."),
"description": z.string().describe("A long-form Markdown-supported description of the advisory."),
get "vulnerabilities"(){
                return z.array(dependabotAlertSecurityVulnerabilitySchema.describe("Details pertaining to one vulnerable version range for the advisory.")).describe("Vulnerable version range information for the advisory.")
              },
"severity": z.enum(["low", "medium", "high", "critical"]).describe("The severity of the advisory."),
"cvss": z.object({
    "score": z.number().min(0).max(10).describe("The overall CVSS score of the advisory."),
"vector_string": z.nullable(z.string().describe("The full CVSS vector string for the advisory."))
    }).describe("Details for the advisory pertaining to the Common Vulnerability Scoring System."),
get "cvss_severities"(){
                return cvssSeveritiesSchema.optional()
              },
get "epss"(){
                return securityAdvisoryEpssSchema.describe("The EPSS scores as calculated by the [Exploit Prediction Scoring System](https://www.first.org/epss).").optional()
              },
"cwes": z.array(z.object({
    "cwe_id": z.string().describe("The unique CWE ID."),
"name": z.string().describe("The short, plain text name of the CWE.")
    }).describe("A CWE weakness assigned to the advisory.")).describe("Details for the advisory pertaining to Common Weakness Enumeration."),
"identifiers": z.array(z.object({
    "type": z.enum(["CVE", "GHSA"]).describe("The type of advisory identifier."),
"value": z.string().describe("The value of the advisory identifer.")
    }).describe("An advisory identifier.")).describe("Values that identify this advisory among security information sources."),
"references": z.array(z.object({
    "url": z.url().describe("The URL of the reference.")
    }).describe("A link to additional advisory information.")).describe("Links to additional advisory information."),
"published_at": z.iso.datetime({ offset: true }).describe("The time that the advisory was published in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."),
"updated_at": z.iso.datetime({ offset: true }).describe("The time that the advisory was last modified in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."),
"withdrawn_at": z.nullable(z.iso.datetime({ offset: true }).describe("The time that the advisory was withdrawn in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."))
    }).describe("Details for the GitHub Security Advisory.")

/**
 * @description The REST API URL of the alert resource.
 */
export const alertUrlSchema = z.url().describe("The REST API URL of the alert resource.")

/**
 * @description The GitHub URL of the alert resource.
 */
export const alertHtmlUrlSchema = z.url().describe("The GitHub URL of the alert resource.")

/**
 * @description The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const alertCreatedAtSchema = z.iso.datetime({ offset: true }).describe("The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.")

/**
 * @description The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const alertUpdatedAtSchema = z.iso.datetime({ offset: true }).describe("The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.")

/**
 * @description The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const alertDismissedAtSchema = z.iso.datetime({ offset: true }).describe("The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullable()

/**
 * @description The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const alertFixedAtSchema = z.iso.datetime({ offset: true }).describe("The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullable()

/**
 * @description The time that the alert was auto-dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const alertAutoDismissedAtSchema = z.iso.datetime({ offset: true }).describe("The time that the alert was auto-dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullable()

/**
 * @description A Dependabot alert.
 */
export const dependabotAlertWithRepositorySchema = z.object({
    get "number"(){
                return alertNumberSchema.describe("The security alert number.")
              },
"state": z.enum(["auto_dismissed", "dismissed", "fixed", "open"]).describe("The state of the Dependabot alert."),
"dependency": z.object({
    get "package"(){
                return dependabotAlertPackageSchema.describe("Details for the vulnerable package.").optional()
              },
"manifest_path": z.optional(z.string().describe("The full path to the dependency manifest file, relative to the root of the repository.")),
"scope": z.enum(["development", "runtime"]).describe("The execution scope of the vulnerable dependency.").nullish(),
"relationship": z.enum(["unknown", "direct", "transitive"]).describe("The vulnerable dependency's relationship to your project.\n\n> [!NOTE]\n> We are rolling out support for dependency relationship across ecosystems. This value will be \"unknown\" for all dependencies in unsupported ecosystems.\n").nullish()
    }).describe("Details for the vulnerable dependency."),
get "security_advisory"(){
                return dependabotAlertSecurityAdvisorySchema.describe("Details for the GitHub Security Advisory.")
              },
get "security_vulnerability"(){
                return dependabotAlertSecurityVulnerabilitySchema.describe("Details pertaining to one vulnerable version range for the advisory.")
              },
get "url"(){
                return alertUrlSchema.describe("The REST API URL of the alert resource.")
              },
get "html_url"(){
                return alertHtmlUrlSchema.describe("The GitHub URL of the alert resource.")
              },
get "created_at"(){
                return alertCreatedAtSchema.describe("The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.")
              },
get "updated_at"(){
                return alertUpdatedAtSchema.describe("The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.")
              },
get "dismissed_at"(){
               return alertDismissedAtSchema.describe("The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullable()
              },
get "dismissed_by"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"dismissed_reason": z.nullable(z.enum(["fix_started", "inaccurate", "no_bandwidth", "not_used", "tolerable_risk"]).describe("The reason that the alert was dismissed.")),
"dismissed_comment": z.nullable(z.string().max(280).describe("An optional comment associated with the alert's dismissal.")),
get "fixed_at"(){
               return alertFixedAtSchema.describe("The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullable()
              },
get "auto_dismissed_at"(){
                return alertAutoDismissedAtSchema.describe("The time that the alert was auto-dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").optional()
              },
get "repository"(){
                return simpleRepositorySchema.describe("A GitHub repository.")
              }
    }).describe("A Dependabot alert.")

/**
 * @description Group of enterprise owners and/or members
 */
export const enterpriseTeamSchema = z.object({
    "id": z.int(),
"name": z.string(),
"description": z.optional(z.string()),
"slug": z.string(),
"url": z.url(),
"sync_to_organizations": z.optional(z.string().describe("Retired: this field will not be returned with GHEC enterprise teams.")),
"organization_selection_type": z.optional(z.string()),
"group_id": z.nullable(z.string()),
"group_name": z.string().describe("Retired: this field will not be returned with GHEC enterprise teams.").nullish(),
"html_url": z.url(),
"members_url": z.string(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true })
    }).describe("Group of enterprise owners and/or members")

/**
 * @description A GitHub organization.
 */
export const organizationSimpleSchema = z.object({
    "login": z.string(),
"id": z.int(),
"node_id": z.string(),
"url": z.url(),
"repos_url": z.url(),
"events_url": z.url(),
"hooks_url": z.string(),
"issues_url": z.string(),
"members_url": z.string(),
"public_members_url": z.string(),
"avatar_url": z.string(),
"description": z.nullable(z.string())
    }).describe("A GitHub organization.")

/**
 * @description Actor
 */
export const actorSchema = z.object({
    "id": z.int(),
"login": z.string(),
"display_login": z.optional(z.string()),
"gravatar_id": z.nullable(z.string()),
"url": z.url(),
"avatar_url": z.url()
    }).describe("Actor")

/**
 * @description A collection of related issues and pull requests.
 */
export const nullableMilestoneSchema = z.object({
    "url": z.url(),
"html_url": z.url(),
"labels_url": z.url(),
"id": z.int(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"state": z.enum(["open", "closed"]).default("open").describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"description": z.nullable(z.string()),
get "creator"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"open_issues": z.int(),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"due_on": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("A collection of related issues and pull requests.").nullable()

/**
 * @description The type of issue.
 */
export const issueTypeSchema = z.object({
    "id": z.int().describe("The unique identifier of the issue type."),
"node_id": z.string().describe("The node identifier of the issue type."),
"name": z.string().describe("The name of the issue type."),
"description": z.nullable(z.string().describe("The description of the issue type.")),
"color": z.enum(["gray", "blue", "green", "yellow", "orange", "red", "pink", "purple"]).describe("The color of the issue type.").nullish(),
"created_at": z.optional(z.iso.datetime({ offset: true }).describe("The time the issue type created.")),
"updated_at": z.optional(z.iso.datetime({ offset: true }).describe("The time the issue type last updated.")),
"is_enabled": z.optional(z.boolean().describe("The enabled state of the issue type."))
    }).describe("The type of issue.").nullable()

/**
 * @description GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
 */
export const nullableIntegrationSchema = z.object({
    "id": z.int().describe("Unique identifier of the GitHub app"),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"node_id": z.string(),
"client_id": z.optional(z.string()),
get "owner"(){
                return z.union([simpleUserSchema, enterpriseSchema])
              },
"name": z.string().describe("The name of the GitHub app"),
"description": z.nullable(z.string()),
"external_url": z.url(),
"html_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"permissions": z.object({
    "issues": z.optional(z.string()),
"checks": z.optional(z.string()),
"metadata": z.optional(z.string()),
"contents": z.optional(z.string()),
"deployments": z.optional(z.string())
    }).catchall(z.string()).describe("The set of permissions for the GitHub app"),
"events": z.array(z.string()).describe("The list of events for the GitHub app. Note that the `installation_target`, `security_advisory`, and `meta` events are not included because they are global events and not specific to an installation."),
"installations_count": z.optional(z.int().describe("The number of installations associated with the GitHub app. Only returned when the integration is requesting details about itself."))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()

/**
 * @description How the author is associated with the repository.
 */
export const authorAssociationSchema = z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository.")

export const reactionRollupSchema = z.object({
    "url": z.url(),
"total_count": z.int(),
"+1": z.int(),
"-1": z.int(),
"laugh": z.int(),
"confused": z.int(),
"heart": z.int(),
"hooray": z.int(),
"eyes": z.int(),
"rocket": z.int()
    })

export const subIssuesSummarySchema = z.object({
    "total": z.int(),
"completed": z.int(),
"percent_completed": z.int()
    })

export const issueDependenciesSummarySchema = z.object({
    "blocked_by": z.int(),
"blocking": z.int(),
"total_blocked_by": z.int(),
"total_blocking": z.int()
    })

/**
 * @description A value assigned to an issue field
 */
export const issueFieldValueSchema = z.object({
    "issue_field_id": z.int().describe("Unique identifier for the issue field."),
"node_id": z.string(),
"data_type": z.enum(["text", "single_select", "number", "date"]).describe("The data type of the issue field"),
"value": z.nullable(z.union([z.int(), z.string(), z.number()]).describe("The value of the issue field")),
"single_select_option": z.object({
    "id": z.int().describe("Unique identifier for the option."),
"name": z.string().describe("The name of the option"),
"color": z.string().describe("The color of the option")
    }).describe("Details about the selected option (only present for single_select fields)").nullish()
    }).describe("A value assigned to an issue field")

/**
 * @description Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
 */
export const issueSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.url().describe("URL for the issue"),
"repository_url": z.url(),
"labels_url": z.string(),
"comments_url": z.url(),
"events_url": z.url(),
"html_url": z.url(),
"number": z.int().describe("Number uniquely identifying the issue within its repository"),
"state": z.string().describe("State of the issue; either 'open' or 'closed'"),
"state_reason": z.enum(["completed", "reopened", "not_planned", "duplicate"]).describe("The reason for the current state").nullish(),
"title": z.string().describe("Title of the issue"),
"body": z.string().describe("Contents of the issue").nullish(),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"labels": z.array(z.union([z.string(), z.object({
    "id": z.optional(z.int()),
"node_id": z.optional(z.string()),
"url": z.optional(z.url()),
"name": z.optional(z.string()),
"description": z.string().nullish(),
"color": z.string().nullish(),
"default": z.optional(z.boolean())
    })])).describe("Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository"),
get "assignee"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
get "assignees"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).nullish()
              },
get "milestone"(){
               return nullableMilestoneSchema.describe("A collection of related issues and pull requests.").nullable()
              },
"locked": z.boolean(),
"active_lock_reason": z.string().nullish(),
"comments": z.int(),
"pull_request": z.optional(z.object({
    "merged_at": z.iso.datetime({ offset: true }).nullish(),
"diff_url": z.nullable(z.url()),
"html_url": z.nullable(z.url()),
"patch_url": z.nullable(z.url()),
"url": z.nullable(z.url())
    })),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"draft": z.optional(z.boolean()),
get "closed_by"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
"body_html": z.optional(z.string()),
"body_text": z.optional(z.string()),
"timeline_url": z.optional(z.url()),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
get "repository"(){
                return repositorySchema.describe("A repository on GitHub.").optional()
              },
get "performed_via_github_app"(){
                return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").optional()
              },
get "author_association"(){
                return authorAssociationSchema.describe("How the author is associated with the repository.").optional()
              },
get "reactions"(){
                return reactionRollupSchema.optional()
              },
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
"parent_issue_url": z.url().describe("URL to get the parent issue of this issue, if it is a sub-issue").nullish(),
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              }
    }).describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")

/**
 * @description Comments provide a way for people to collaborate on an issue.
 */
export const issueCommentSchema = z.object({
    "id": z.int().describe("Unique identifier of the issue comment"),
"node_id": z.string(),
"url": z.url().describe("URL for the issue comment"),
"body": z.optional(z.string().describe("Contents of the issue comment")),
"body_text": z.optional(z.string()),
"body_html": z.optional(z.string()),
"html_url": z.url(),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"issue_url": z.url(),
get "author_association"(){
                return authorAssociationSchema.describe("How the author is associated with the repository.")
              },
get "performed_via_github_app"(){
                return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").optional()
              },
get "reactions"(){
                return reactionRollupSchema.optional()
              }
    }).describe("Comments provide a way for people to collaborate on an issue.")

/**
 * @description Event
 */
export const eventSchema = z.object({
    "id": z.string(),
"type": z.nullable(z.string()),
get "actor"(){
                return actorSchema.describe("Actor")
              },
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
get "org"(){
                return actorSchema.describe("Actor").optional()
              },
"payload": z.object({
    "action": z.optional(z.string()),
get "issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.").optional()
              },
get "comment"(){
                return issueCommentSchema.describe("Comments provide a way for people to collaborate on an issue.").optional()
              },
"pages": z.optional(z.array(z.object({
    "page_name": z.optional(z.string()),
"title": z.optional(z.string()),
"summary": z.string().nullish(),
"action": z.optional(z.string()),
"sha": z.optional(z.string()),
"html_url": z.optional(z.string())
    })))
    }),
"public": z.boolean(),
"created_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("Event")

/**
 * @description Hypermedia Link with Type
 */
export const linkWithTypeSchema = z.object({
    "href": z.string(),
"type": z.string()
    }).describe("Hypermedia Link with Type")

/**
 * @description Feed
 */
export const feedSchema = z.object({
    "timeline_url": z.string(),
"user_url": z.string(),
"current_user_public_url": z.optional(z.string()),
"current_user_url": z.optional(z.string()),
"current_user_actor_url": z.optional(z.string()),
"current_user_organization_url": z.optional(z.string()),
"current_user_organization_urls": z.optional(z.array(z.url())),
"security_advisories_url": z.optional(z.string()),
"repository_discussions_url": z.optional(z.string().describe("A feed of discussions for a given repository.")),
"repository_discussions_category_url": z.optional(z.string().describe("A feed of discussions for a given repository and category.")),
"_links": z.object({
    get "timeline"(){
                return linkWithTypeSchema.describe("Hypermedia Link with Type")
              },
get "user"(){
                return linkWithTypeSchema.describe("Hypermedia Link with Type")
              },
get "security_advisories"(){
                return linkWithTypeSchema.describe("Hypermedia Link with Type").optional()
              },
get "current_user"(){
                return linkWithTypeSchema.describe("Hypermedia Link with Type").optional()
              },
get "current_user_public"(){
                return linkWithTypeSchema.describe("Hypermedia Link with Type").optional()
              },
get "current_user_actor"(){
                return linkWithTypeSchema.describe("Hypermedia Link with Type").optional()
              },
get "current_user_organization"(){
                return linkWithTypeSchema.describe("Hypermedia Link with Type").optional()
              },
get "current_user_organizations"(){
                return z.array(linkWithTypeSchema.describe("Hypermedia Link with Type")).optional()
              },
get "repository_discussions"(){
                return linkWithTypeSchema.describe("Hypermedia Link with Type").optional()
              },
get "repository_discussions_category"(){
                return linkWithTypeSchema.describe("Hypermedia Link with Type").optional()
              }
    })
    }).describe("Feed")

/**
 * @description Base Gist
 */
export const baseGistSchema = z.object({
    "url": z.url(),
"forks_url": z.url(),
"commits_url": z.url(),
"id": z.string(),
"node_id": z.string(),
"git_pull_url": z.url(),
"git_push_url": z.url(),
"html_url": z.url(),
"files": z.object({
    
    }).catchall(z.object({
    "filename": z.optional(z.string()),
"type": z.optional(z.string()),
"language": z.optional(z.string()),
"raw_url": z.optional(z.string()),
"size": z.optional(z.int()),
"encoding": z.optional(z.string().default("utf-8").describe("The encoding used for `content`. Currently, `\"utf-8\"` and `\"base64\"` are supported."))
    })),
"public": z.boolean(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"description": z.nullable(z.string()),
"comments": z.int(),
"comments_enabled": z.optional(z.boolean()),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"comments_url": z.url(),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
"truncated": z.optional(z.boolean()),
"forks": z.optional(z.array(z.unknown())),
"history": z.optional(z.array(z.unknown()))
    }).describe("Base Gist")

/**
 * @description Public User
 */
export const publicUserSchema = z.object({
    "login": z.string(),
"id": z.int(),
"user_view_type": z.optional(z.string()),
"node_id": z.string(),
"avatar_url": z.url(),
"gravatar_id": z.nullable(z.string()),
"url": z.url(),
"html_url": z.url(),
"followers_url": z.url(),
"following_url": z.string(),
"gists_url": z.string(),
"starred_url": z.string(),
"subscriptions_url": z.url(),
"organizations_url": z.url(),
"repos_url": z.url(),
"events_url": z.string(),
"received_events_url": z.url(),
"type": z.string(),
"site_admin": z.boolean(),
"name": z.nullable(z.string()),
"company": z.nullable(z.string()),
"blog": z.nullable(z.string()),
"location": z.nullable(z.string()),
"email": z.nullable(z.email()),
"notification_email": z.email().nullish(),
"hireable": z.nullable(z.boolean()),
"bio": z.nullable(z.string()),
"twitter_username": z.string().nullish(),
"public_repos": z.int(),
"public_gists": z.int(),
"followers": z.int(),
"following": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"plan": z.optional(z.object({
    "collaborators": z.int(),
"name": z.string(),
"space": z.int(),
"private_repos": z.int()
    })),
"private_gists": z.optional(z.int()),
"total_private_repos": z.optional(z.int()),
"owned_private_repos": z.optional(z.int()),
"disk_usage": z.optional(z.int()),
"collaborators": z.optional(z.int())
    }).describe("Public User")

/**
 * @description Gist History
 */
export const gistHistorySchema = z.object({
    get "user"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
"version": z.optional(z.string()),
"committed_at": z.optional(z.iso.datetime({ offset: true })),
"change_status": z.optional(z.object({
    "total": z.optional(z.int()),
"additions": z.optional(z.int()),
"deletions": z.optional(z.int())
    })),
"url": z.optional(z.url())
    }).describe("Gist History")

/**
 * @description Gist Simple
 */
export const gistSimpleSchema = z.object({
    "forks": z.array(z.object({
    "id": z.optional(z.string()),
"url": z.optional(z.url()),
get "user"(){
                return publicUserSchema.describe("Public User").optional()
              },
"created_at": z.optional(z.iso.datetime({ offset: true })),
"updated_at": z.optional(z.iso.datetime({ offset: true }))
    })).nullish(),
get "history"(){
                return z.array(gistHistorySchema.describe("Gist History")).nullish()
              },
"fork_of": z.object({
    "url": z.url(),
"forks_url": z.url(),
"commits_url": z.url(),
"id": z.string(),
"node_id": z.string(),
"git_pull_url": z.url(),
"git_push_url": z.url(),
"html_url": z.url(),
"files": z.object({
    
    }).catchall(z.object({
    "filename": z.optional(z.string()),
"type": z.optional(z.string()),
"language": z.optional(z.string()),
"raw_url": z.optional(z.string()),
"size": z.optional(z.int())
    })),
"public": z.boolean(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"description": z.nullable(z.string()),
"comments": z.int(),
"comments_enabled": z.optional(z.boolean()),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"comments_url": z.url(),
get "owner"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
"truncated": z.optional(z.boolean()),
"forks": z.optional(z.array(z.unknown())),
"history": z.optional(z.array(z.unknown()))
    }).describe("Gist").nullish(),
"url": z.optional(z.string()),
"forks_url": z.optional(z.string()),
"commits_url": z.optional(z.string()),
"id": z.optional(z.string()),
"node_id": z.optional(z.string()),
"git_pull_url": z.optional(z.string()),
"git_push_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"files": z.optional(z.object({
    
    }).catchall(z.object({
    "filename": z.optional(z.string()),
"type": z.optional(z.string()),
"language": z.optional(z.string()),
"raw_url": z.optional(z.string()),
"size": z.optional(z.int()),
"truncated": z.optional(z.boolean()),
"content": z.optional(z.string()),
"encoding": z.optional(z.string().default("utf-8").describe("The encoding used for `content`. Currently, `\"utf-8\"` and `\"base64\"` are supported."))
    }).nullable())),
"public": z.optional(z.boolean()),
"created_at": z.optional(z.string()),
"updated_at": z.optional(z.string()),
"description": z.string().nullish(),
"comments": z.optional(z.int()),
"comments_enabled": z.optional(z.boolean()),
"user": z.string().nullish(),
"comments_url": z.optional(z.string()),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
"truncated": z.optional(z.boolean())
    }).describe("Gist Simple")

/**
 * @description A comment made to a gist.
 */
export const gistCommentSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.url(),
"body": z.string().max(65535).describe("The comment text."),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
get "author_association"(){
                return authorAssociationSchema.describe("How the author is associated with the repository.")
              }
    }).describe("A comment made to a gist.")

/**
 * @description Gist Commit
 */
export const gistCommitSchema = z.object({
    "url": z.url(),
"version": z.string(),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"change_status": z.object({
    "total": z.optional(z.int()),
"additions": z.optional(z.int()),
"deletions": z.optional(z.int())
    }),
"committed_at": z.iso.datetime({ offset: true })
    }).describe("Gist Commit")

/**
 * @description Gitignore Template
 */
export const gitignoreTemplateSchema = z.object({
    "name": z.string(),
"source": z.string()
    }).describe("Gitignore Template")

/**
 * @description License Simple
 */
export const licenseSimpleSchema = z.object({
    "key": z.string(),
"name": z.string(),
"url": z.nullable(z.url()),
"spdx_id": z.nullable(z.string()),
"node_id": z.string(),
"html_url": z.optional(z.url())
    }).describe("License Simple")

/**
 * @description License
 */
export const licenseSchema = z.object({
    "key": z.string(),
"name": z.string(),
"spdx_id": z.nullable(z.string()),
"url": z.nullable(z.url()),
"node_id": z.string(),
"html_url": z.url(),
"description": z.string(),
"implementation": z.string(),
"permissions": z.array(z.string()),
"conditions": z.array(z.string()),
"limitations": z.array(z.string()),
"body": z.string(),
"featured": z.boolean()
    }).describe("License")

/**
 * @description Marketplace Listing Plan
 */
export const marketplaceListingPlanSchema = z.object({
    "url": z.url(),
"accounts_url": z.url(),
"id": z.int(),
"number": z.int(),
"name": z.string(),
"description": z.string(),
"monthly_price_in_cents": z.int(),
"yearly_price_in_cents": z.int(),
"price_model": z.enum(["FREE", "FLAT_RATE", "PER_UNIT"]),
"has_free_trial": z.boolean(),
"unit_name": z.nullable(z.string()),
"state": z.string(),
"bullets": z.array(z.string())
    }).describe("Marketplace Listing Plan")

/**
 * @description Marketplace Purchase
 */
export const marketplacePurchaseSchema = z.object({
    "url": z.string(),
"type": z.string(),
"id": z.int(),
"login": z.string(),
"organization_billing_email": z.optional(z.string()),
"email": z.string().nullish(),
"marketplace_pending_change": z.object({
    "is_installed": z.optional(z.boolean()),
"effective_date": z.optional(z.string()),
"unit_count": z.int().nullish(),
"id": z.optional(z.int()),
get "plan"(){
                return marketplaceListingPlanSchema.describe("Marketplace Listing Plan").optional()
              }
    }).nullish(),
"marketplace_purchase": z.object({
    "billing_cycle": z.optional(z.string()),
"next_billing_date": z.string().nullish(),
"is_installed": z.optional(z.boolean()),
"unit_count": z.int().nullish(),
"on_free_trial": z.optional(z.boolean()),
"free_trial_ends_on": z.string().nullish(),
"updated_at": z.optional(z.string()),
get "plan"(){
                return marketplaceListingPlanSchema.describe("Marketplace Listing Plan").optional()
              }
    })
    }).describe("Marketplace Purchase")

/**
 * @description Api Overview
 */
export const apiOverviewSchema = z.object({
    "verifiable_password_authentication": z.boolean(),
"ssh_key_fingerprints": z.optional(z.object({
    "SHA256_RSA": z.optional(z.string()),
"SHA256_DSA": z.optional(z.string()),
"SHA256_ECDSA": z.optional(z.string()),
"SHA256_ED25519": z.optional(z.string())
    })),
"ssh_keys": z.optional(z.array(z.string())),
"hooks": z.optional(z.array(z.string())),
"github_enterprise_importer": z.optional(z.array(z.string())),
"web": z.optional(z.array(z.string())),
"api": z.optional(z.array(z.string())),
"git": z.optional(z.array(z.string())),
"packages": z.optional(z.array(z.string())),
"pages": z.optional(z.array(z.string())),
"importer": z.optional(z.array(z.string())),
"actions": z.optional(z.array(z.string())),
"actions_macos": z.optional(z.array(z.string())),
"codespaces": z.optional(z.array(z.string())),
"dependabot": z.optional(z.array(z.string())),
"copilot": z.optional(z.array(z.string())),
"domains": z.optional(z.object({
    "website": z.optional(z.array(z.string())),
"codespaces": z.optional(z.array(z.string())),
"copilot": z.optional(z.array(z.string())),
"packages": z.optional(z.array(z.string())),
"actions": z.optional(z.array(z.string())),
"actions_inbound": z.optional(z.object({
    "full_domains": z.optional(z.array(z.string())),
"wildcard_domains": z.optional(z.array(z.string()))
    })),
"artifact_attestations": z.optional(z.object({
    "trust_domain": z.optional(z.string()),
"services": z.optional(z.array(z.string()))
    }))
    }))
    }).describe("Api Overview")

export const securityAndAnalysisSchema = z.object({
    "advanced_security": z.optional(z.object({
    "status": z.optional(z.enum(["enabled", "disabled"]))
    }).describe("Enable or disable GitHub Advanced Security for the repository.\n\nFor standalone Code Scanning or Secret Protection products, this parameter cannot be used.\n")),
"code_security": z.optional(z.object({
    "status": z.optional(z.enum(["enabled", "disabled"]))
    })),
"dependabot_security_updates": z.optional(z.object({
    "status": z.optional(z.enum(["enabled", "disabled"]).describe("The enablement status of Dependabot security updates for the repository."))
    }).describe("Enable or disable Dependabot security updates for the repository.")),
"secret_scanning": z.optional(z.object({
    "status": z.optional(z.enum(["enabled", "disabled"]))
    })),
"secret_scanning_push_protection": z.optional(z.object({
    "status": z.optional(z.enum(["enabled", "disabled"]))
    })),
"secret_scanning_non_provider_patterns": z.optional(z.object({
    "status": z.optional(z.enum(["enabled", "disabled"]))
    })),
"secret_scanning_ai_detection": z.optional(z.object({
    "status": z.optional(z.enum(["enabled", "disabled"]))
    }))
    }).nullable()

/**
 * @description Minimal Repository
 */
export const minimalRepositorySchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"name": z.string(),
"full_name": z.string(),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"private": z.boolean(),
"html_url": z.url(),
"description": z.nullable(z.string()),
"fork": z.boolean(),
"url": z.url(),
"archive_url": z.string(),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"deployments_url": z.url(),
"downloads_url": z.url(),
"events_url": z.url(),
"forks_url": z.url(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.optional(z.string()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"languages_url": z.url(),
"merges_url": z.url(),
"milestones_url": z.string(),
"notifications_url": z.string(),
"pulls_url": z.string(),
"releases_url": z.string(),
"ssh_url": z.optional(z.string()),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"trees_url": z.string(),
"clone_url": z.optional(z.string()),
"mirror_url": z.string().nullish(),
"hooks_url": z.url(),
"svn_url": z.optional(z.string()),
"homepage": z.string().nullish(),
"language": z.string().nullish(),
"forks_count": z.optional(z.int()),
"stargazers_count": z.optional(z.int()),
"watchers_count": z.optional(z.int()),
"size": z.optional(z.int().describe("The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.")),
"default_branch": z.optional(z.string()),
"open_issues_count": z.optional(z.int()),
"is_template": z.optional(z.boolean()),
"topics": z.optional(z.array(z.string())),
"has_issues": z.optional(z.boolean()),
"has_projects": z.optional(z.boolean()),
"has_wiki": z.optional(z.boolean()),
"has_pages": z.optional(z.boolean()),
"has_downloads": z.optional(z.boolean()),
"has_discussions": z.optional(z.boolean()),
"archived": z.optional(z.boolean()),
"disabled": z.optional(z.boolean()),
"visibility": z.optional(z.string()),
"pushed_at": z.iso.datetime({ offset: true }).nullish(),
"created_at": z.iso.datetime({ offset: true }).nullish(),
"updated_at": z.iso.datetime({ offset: true }).nullish(),
"permissions": z.optional(z.object({
    "admin": z.optional(z.boolean()),
"maintain": z.optional(z.boolean()),
"push": z.optional(z.boolean()),
"triage": z.optional(z.boolean()),
"pull": z.optional(z.boolean())
    })),
"role_name": z.optional(z.string()),
"temp_clone_token": z.optional(z.string()),
"delete_branch_on_merge": z.optional(z.boolean()),
"subscribers_count": z.optional(z.int()),
"network_count": z.optional(z.int()),
get "code_of_conduct"(){
                return codeOfConductSchema.describe("Code Of Conduct").optional()
              },
"license": z.object({
    "key": z.optional(z.string()),
"name": z.optional(z.string()),
"spdx_id": z.optional(z.string()),
"url": z.optional(z.string()),
"node_id": z.optional(z.string())
    }).nullish(),
"forks": z.optional(z.int()),
"open_issues": z.optional(z.int()),
"watchers": z.optional(z.int()),
"allow_forking": z.optional(z.boolean()),
"web_commit_signoff_required": z.optional(z.boolean()),
get "security_and_analysis"(){
                return securityAndAnalysisSchema.optional()
              },
"custom_properties": z.optional(z.object({
    
    }).catchall(z.unknown()).describe("The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values."))
    }).describe("Minimal Repository")

/**
 * @description Thread
 */
export const threadSchema = z.object({
    "id": z.string(),
get "repository"(){
                return minimalRepositorySchema.describe("Minimal Repository")
              },
"subject": z.object({
    "title": z.string(),
"url": z.string(),
"latest_comment_url": z.string(),
"type": z.string()
    }),
"reason": z.string(),
"unread": z.boolean(),
"updated_at": z.string(),
"last_read_at": z.nullable(z.string()),
"url": z.string(),
"subscription_url": z.string()
    }).describe("Thread")

/**
 * @description Thread Subscription
 */
export const threadSubscriptionSchema = z.object({
    "subscribed": z.boolean(),
"ignored": z.boolean(),
"reason": z.nullable(z.string()),
"created_at": z.nullable(z.iso.datetime({ offset: true })),
"url": z.url(),
"thread_url": z.optional(z.url()),
"repository_url": z.optional(z.url())
    }).describe("Thread Subscription")

/**
 * @description A GitHub repository.
 */
export const nullableSimpleRepositorySchema = z.object({
    "id": z.int().describe("A unique identifier of the repository."),
"node_id": z.string().describe("The GraphQL identifier of the repository."),
"name": z.string().describe("The name of the repository."),
"full_name": z.string().describe("The full, globally unique, name of the repository."),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"private": z.boolean().describe("Whether the repository is private."),
"html_url": z.url().describe("The URL to view the repository on GitHub.com."),
"description": z.nullable(z.string().describe("The repository description.")),
"fork": z.boolean().describe("Whether the repository is a fork."),
"url": z.url().describe("The URL to get more information about the repository from the GitHub API."),
"archive_url": z.string().describe("A template for the API URL to download the repository as an archive."),
"assignees_url": z.string().describe("A template for the API URL to list the available assignees for issues in the repository."),
"blobs_url": z.string().describe("A template for the API URL to create or retrieve a raw Git blob in the repository."),
"branches_url": z.string().describe("A template for the API URL to get information about branches in the repository."),
"collaborators_url": z.string().describe("A template for the API URL to get information about collaborators of the repository."),
"comments_url": z.string().describe("A template for the API URL to get information about comments on the repository."),
"commits_url": z.string().describe("A template for the API URL to get information about commits on the repository."),
"compare_url": z.string().describe("A template for the API URL to compare two commits or refs."),
"contents_url": z.string().describe("A template for the API URL to get the contents of the repository."),
"contributors_url": z.url().describe("A template for the API URL to list the contributors to the repository."),
"deployments_url": z.url().describe("The API URL to list the deployments of the repository."),
"downloads_url": z.url().describe("The API URL to list the downloads on the repository."),
"events_url": z.url().describe("The API URL to list the events of the repository."),
"forks_url": z.url().describe("The API URL to list the forks of the repository."),
"git_commits_url": z.string().describe("A template for the API URL to get information about Git commits of the repository."),
"git_refs_url": z.string().describe("A template for the API URL to get information about Git refs of the repository."),
"git_tags_url": z.string().describe("A template for the API URL to get information about Git tags of the repository."),
"issue_comment_url": z.string().describe("A template for the API URL to get information about issue comments on the repository."),
"issue_events_url": z.string().describe("A template for the API URL to get information about issue events on the repository."),
"issues_url": z.string().describe("A template for the API URL to get information about issues on the repository."),
"keys_url": z.string().describe("A template for the API URL to get information about deploy keys on the repository."),
"labels_url": z.string().describe("A template for the API URL to get information about labels of the repository."),
"languages_url": z.url().describe("The API URL to get information about the languages of the repository."),
"merges_url": z.url().describe("The API URL to merge branches in the repository."),
"milestones_url": z.string().describe("A template for the API URL to get information about milestones of the repository."),
"notifications_url": z.string().describe("A template for the API URL to get information about notifications on the repository."),
"pulls_url": z.string().describe("A template for the API URL to get information about pull requests on the repository."),
"releases_url": z.string().describe("A template for the API URL to get information about releases on the repository."),
"stargazers_url": z.url().describe("The API URL to list the stargazers on the repository."),
"statuses_url": z.string().describe("A template for the API URL to get information about statuses of a commit."),
"subscribers_url": z.url().describe("The API URL to list the subscribers on the repository."),
"subscription_url": z.url().describe("The API URL to subscribe to notifications for this repository."),
"tags_url": z.url().describe("The API URL to get information about tags on the repository."),
"teams_url": z.url().describe("The API URL to list the teams on the repository."),
"trees_url": z.string().describe("A template for the API URL to create or retrieve a raw Git tree of the repository."),
"hooks_url": z.url().describe("The API URL to list the hooks on the repository.")
    }).describe("A GitHub repository.").nullable()

/**
 * @description Information about repositories that Dependabot is able to access in an organization
 */
export const dependabotRepositoryAccessDetailsSchema = z.object({
    "default_level": z.enum(["public", "internal"]).describe("The default repository access level for Dependabot updates.").nullish(),
get "accessible_repositories"(){
                return z.array(nullableSimpleRepositorySchema.describe("A GitHub repository.").nullable()).optional()
              }
    }).describe("Information about repositories that Dependabot is able to access in an organization")

/**
 * @description Custom property name and associated value
 */
export const customPropertyValueSchema = z.object({
    "property_name": z.string().describe("The name of the property"),
"value": z.nullable(z.union([z.array(z.string()), z.string()]).describe("The value assigned to the property"))
    }).describe("Custom property name and associated value")

export const billingPremiumRequestUsageReportOrgSchema = z.object({
    "timePeriod": z.object({
    "year": z.int().describe("The year for the usage report."),
"month": z.optional(z.int().describe("The month for the usage report.")),
"day": z.optional(z.int().describe("The day for the usage report."))
    }),
"organization": z.string().describe("The unique identifier of the organization."),
"user": z.optional(z.string().describe("The name of the user for the usage report.")),
"product": z.optional(z.string().describe("The product for the usage report.")),
"model": z.optional(z.string().describe("The model for the usage report.")),
"usageItems": z.array(z.object({
    "product": z.string().describe("Product name."),
"sku": z.string().describe("SKU name."),
"model": z.string().describe("Model name."),
"unitType": z.string().describe("Unit type of the usage line item."),
"pricePerUnit": z.number().describe("Price per unit of the usage line item."),
"grossQuantity": z.number().describe("Gross quantity of the usage line item."),
"grossAmount": z.number().describe("Gross amount of the usage line item."),
"discountQuantity": z.number().describe("Discount quantity of the usage line item."),
"discountAmount": z.number().describe("Discount amount of the usage line item."),
"netQuantity": z.number().describe("Net quantity of the usage line item."),
"netAmount": z.number().describe("Net amount of the usage line item.")
    }))
    })

export const billingUsageReportSchema = z.object({
    "usageItems": z.optional(z.array(z.object({
    "date": z.string().describe("Date of the usage line item."),
"product": z.string().describe("Product name."),
"sku": z.string().describe("SKU name."),
"quantity": z.int().describe("Quantity of the usage line item."),
"unitType": z.string().describe("Unit type of the usage line item."),
"pricePerUnit": z.number().describe("Price per unit of the usage line item."),
"grossAmount": z.number().describe("Gross amount of the usage line item."),
"discountAmount": z.number().describe("Discount amount of the usage line item."),
"netAmount": z.number().describe("Net amount of the usage line item."),
"organizationName": z.string().describe("Name of the organization."),
"repositoryName": z.optional(z.string().describe("Name of the repository."))
    })))
    })

/**
 * @description Organization Full
 */
export const organizationFullSchema = z.object({
    "login": z.string(),
"id": z.int(),
"node_id": z.string(),
"url": z.url(),
"repos_url": z.url(),
"events_url": z.url(),
"hooks_url": z.string(),
"issues_url": z.string(),
"members_url": z.string(),
"public_members_url": z.string(),
"avatar_url": z.string(),
"description": z.nullable(z.string()),
"name": z.optional(z.string()),
"company": z.optional(z.string()),
"blog": z.optional(z.url()),
"location": z.optional(z.string()),
"email": z.optional(z.email()),
"twitter_username": z.string().nullish(),
"is_verified": z.optional(z.boolean()),
"has_organization_projects": z.boolean(),
"has_repository_projects": z.boolean(),
"public_repos": z.int(),
"public_gists": z.int(),
"followers": z.int(),
"following": z.int(),
"html_url": z.url(),
"type": z.string(),
"total_private_repos": z.optional(z.int()),
"owned_private_repos": z.optional(z.int()),
"private_gists": z.int().nullish(),
"disk_usage": z.int().nullish(),
"collaborators": z.int().describe("The number of collaborators on private repositories.\n\nThis field may be null if the number of private repositories is over 50,000.").nullish(),
"billing_email": z.email().nullish(),
"plan": z.optional(z.object({
    "name": z.string(),
"space": z.int(),
"private_repos": z.int(),
"filled_seats": z.optional(z.int()),
"seats": z.optional(z.int())
    })),
"default_repository_permission": z.string().nullish(),
"default_repository_branch": z.string().describe("The default branch for repositories created in this organization.").nullish(),
"members_can_create_repositories": z.boolean().nullish(),
"two_factor_requirement_enabled": z.boolean().nullish(),
"members_allowed_repository_creation_type": z.optional(z.string()),
"members_can_create_public_repositories": z.optional(z.boolean()),
"members_can_create_private_repositories": z.optional(z.boolean()),
"members_can_create_internal_repositories": z.optional(z.boolean()),
"members_can_create_pages": z.optional(z.boolean()),
"members_can_create_public_pages": z.optional(z.boolean()),
"members_can_create_private_pages": z.optional(z.boolean()),
"members_can_delete_repositories": z.optional(z.boolean()),
"members_can_change_repo_visibility": z.optional(z.boolean()),
"members_can_invite_outside_collaborators": z.optional(z.boolean()),
"members_can_delete_issues": z.optional(z.boolean()),
"display_commenter_full_name_setting_enabled": z.optional(z.boolean()),
"readers_can_create_discussions": z.optional(z.boolean()),
"members_can_create_teams": z.optional(z.boolean()),
"members_can_view_dependency_insights": z.optional(z.boolean()),
"members_can_fork_private_repositories": z.boolean().nullish(),
"web_commit_signoff_required": z.optional(z.boolean()),
"advanced_security_enabled_for_new_repositories": z.optional(z.boolean().describe("**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether GitHub Advanced Security is enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.")),
"dependabot_alerts_enabled_for_new_repositories": z.optional(z.boolean().describe("**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether Dependabot alerts are automatically enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.")),
"dependabot_security_updates_enabled_for_new_repositories": z.optional(z.boolean().describe("**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether Dependabot security updates are automatically enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.")),
"dependency_graph_enabled_for_new_repositories": z.optional(z.boolean().describe("**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether dependency graph is automatically enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.")),
"secret_scanning_enabled_for_new_repositories": z.optional(z.boolean().describe("**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether secret scanning is automatically enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.")),
"secret_scanning_push_protection_enabled_for_new_repositories": z.optional(z.boolean().describe("**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether secret scanning push protection is automatically enabled for new repositories and repositories transferred to this organization.\n\nThis field is only visible to organization owners or members of a team with the security manager role.")),
"secret_scanning_push_protection_custom_link_enabled": z.optional(z.boolean().describe("Whether a custom link is shown to contributors who are blocked from pushing a secret by push protection.")),
"secret_scanning_push_protection_custom_link": z.string().describe("An optional URL string to display to contributors who are blocked from pushing a secret.").nullish(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"archived_at": z.nullable(z.iso.datetime({ offset: true })),
"deploy_keys_enabled_for_repositories": z.optional(z.boolean().describe("Controls whether or not deploy keys may be added and used for repositories in the organization."))
    }).describe("Organization Full")

export const actionsCacheUsageOrgEnterpriseSchema = z.object({
    "total_active_caches_count": z.int().describe("The count of active caches across all repositories of an enterprise or an organization."),
"total_active_caches_size_in_bytes": z.int().describe("The total size in bytes of all active cache items across all repositories of an enterprise or an organization.")
    })

/**
 * @description GitHub Actions Cache Usage by repository.
 */
export const actionsCacheUsageByRepositorySchema = z.object({
    "full_name": z.string().describe("The repository owner and name for the cache usage being shown."),
"active_caches_size_in_bytes": z.int().describe("The sum of the size in bytes of all the active cache items in the repository."),
"active_caches_count": z.int().describe("The number of active caches in the repository.")
    }).describe("GitHub Actions Cache Usage by repository.")

/**
 * @description Provides details of a hosted runner image
 */
export const nullableActionsHostedRunnerPoolImageSchema = z.object({
    "id": z.string().describe("The ID of the image. Use this ID for the `image` parameter when creating a new larger runner."),
"size_gb": z.int().describe("Image size in GB."),
"display_name": z.string().describe("Display name for this image."),
"source": z.enum(["github", "partner", "custom"]).describe("The image provider."),
"version": z.optional(z.string().describe("The image version of the hosted runner pool."))
    }).describe("Provides details of a hosted runner image").nullable()

/**
 * @description Provides details of a particular machine spec.
 */
export const actionsHostedRunnerMachineSpecSchema = z.object({
    "id": z.string().describe("The ID used for the `size` parameter when creating a new runner."),
"cpu_cores": z.int().describe("The number of cores."),
"memory_gb": z.int().describe("The available RAM for the machine spec."),
"storage_gb": z.int().describe("The available SSD storage for the machine spec.")
    }).describe("Provides details of a particular machine spec.")

/**
 * @description Provides details of Public IP for a GitHub-hosted larger runners
 */
export const publicIpSchema = z.object({
    "enabled": z.optional(z.boolean().describe("Whether public IP is enabled.")),
"prefix": z.optional(z.string().describe("The prefix for the public IP.")),
"length": z.optional(z.int().describe("The length of the IP prefix."))
    }).describe("Provides details of Public IP for a GitHub-hosted larger runners")

/**
 * @description A Github-hosted hosted runner.
 */
export const actionsHostedRunnerSchema = z.object({
    "id": z.int().describe("The unique identifier of the hosted runner."),
"name": z.string().describe("The name of the hosted runner."),
"runner_group_id": z.optional(z.int().describe("The unique identifier of the group that the hosted runner belongs to.")),
get "image_details"(){
               return nullableActionsHostedRunnerPoolImageSchema.describe("Provides details of a hosted runner image").nullable()
              },
get "machine_size_details"(){
                return actionsHostedRunnerMachineSpecSchema.describe("Provides details of a particular machine spec.")
              },
"status": z.enum(["Ready", "Provisioning", "Shutdown", "Deleting", "Stuck"]).describe("The status of the runner."),
"platform": z.string().describe("The operating system of the image."),
"maximum_runners": z.optional(z.int().default(10).describe("The maximum amount of hosted runners. Runners will not scale automatically above this number. Use this setting to limit your cost.")),
"public_ip_enabled": z.boolean().describe("Whether public IP is enabled for the hosted runners."),
get "public_ips"(){
                return z.array(publicIpSchema.describe("Provides details of Public IP for a GitHub-hosted larger runners")).describe("The public IP ranges when public IP is enabled for the hosted runners.").optional()
              },
"last_active_on": z.iso.datetime({ offset: true }).describe("The time at which the runner was last used, in ISO 8601 format.").nullish(),
"image_gen": z.optional(z.boolean().describe("Whether custom image generation is enabled for the hosted runners."))
    }).describe("A Github-hosted hosted runner.")

/**
 * @description Provides details of a custom runner image
 */
export const actionsHostedRunnerCustomImageSchema = z.object({
    "id": z.int().describe("The ID of the image. Use this ID for the `image` parameter when creating a new larger runner."),
"platform": z.string().describe("The operating system of the image."),
"total_versions_size": z.int().describe("Total size of all the image versions in GB."),
"name": z.string().describe("Display name for this image."),
"source": z.string().describe("The image provider."),
"versions_count": z.int().describe("The number of image versions associated with the image."),
"latest_version": z.string().describe("The latest image version associated with the image."),
"state": z.string().describe("The number of image versions associated with the image.")
    }).describe("Provides details of a custom runner image")

/**
 * @description Provides details of a hosted runner custom image version
 */
export const actionsHostedRunnerCustomImageVersionSchema = z.object({
    "version": z.string().describe("The version of image."),
"state": z.string().describe("The state of image version."),
"size_gb": z.int().describe("Image version size in GB."),
"created_on": z.string().describe("The creation date time of the image version."),
"state_details": z.string().describe("The image version status details.")
    }).describe("Provides details of a hosted runner custom image version")

/**
 * @description Provides details of a hosted runner image
 */
export const actionsHostedRunnerCuratedImageSchema = z.object({
    "id": z.string().describe("The ID of the image. Use this ID for the `image` parameter when creating a new larger runner."),
"platform": z.string().describe("The operating system of the image."),
"size_gb": z.int().describe("Image size in GB."),
"display_name": z.string().describe("Display name for this image."),
"source": z.enum(["github", "partner", "custom"]).describe("The image provider.")
    }).describe("Provides details of a hosted runner image")

export const actionsHostedRunnerLimitsSchema = z.object({
    "public_ips": z.object({
    "maximum": z.int().describe("The maximum number of static public IP addresses that can be used for Hosted Runners."),
"current_usage": z.int().describe("The current number of static public IP addresses in use by Hosted Runners.")
    }).describe("Provides details of static public IP limits for GitHub-hosted Hosted Runners")
    })

/**
 * @description Actions OIDC Subject customization
 */
export const oidcCustomSubSchema = z.object({
    "include_claim_keys": z.array(z.string()).describe("Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.")
    }).describe("Actions OIDC Subject customization")

/**
 * @description An object without any properties.
 */
export const emptyObjectSchema = z.object({
    
    }).describe("An object without any properties.")

/**
 * @description The policy that controls the repositories in the organization that are allowed to run GitHub Actions.
 */
export const enabledRepositoriesSchema = z.enum(["all", "none", "selected"]).describe("The policy that controls the repositories in the organization that are allowed to run GitHub Actions.")

/**
 * @description The permissions policy that controls the actions and reusable workflows that are allowed to run.
 */
export const allowedActionsSchema = z.enum(["all", "local_only", "selected"]).describe("The permissions policy that controls the actions and reusable workflows that are allowed to run.")

/**
 * @description The API URL to use to get or set the actions and reusable workflows that are allowed to run, when `allowed_actions` is set to `selected`.
 */
export const selectedActionsUrlSchema = z.string().describe("The API URL to use to get or set the actions and reusable workflows that are allowed to run, when `allowed_actions` is set to `selected`.")

/**
 * @description Whether actions must be pinned to a full-length commit SHA.
 */
export const shaPinningRequiredSchema = z.boolean().describe("Whether actions must be pinned to a full-length commit SHA.")

export const actionsOrganizationPermissionsSchema = z.object({
    get "enabled_repositories"(){
                return enabledRepositoriesSchema.describe("The policy that controls the repositories in the organization that are allowed to run GitHub Actions.")
              },
"selected_repositories_url": z.optional(z.string().describe("The API URL to use to get or set the selected repositories that are allowed to run GitHub Actions, when `enabled_repositories` is set to `selected`.")),
get "allowed_actions"(){
                return allowedActionsSchema.describe("The permissions policy that controls the actions and reusable workflows that are allowed to run.").optional()
              },
get "selected_actions_url"(){
                return selectedActionsUrlSchema.describe("The API URL to use to get or set the actions and reusable workflows that are allowed to run, when `allowed_actions` is set to `selected`.").optional()
              },
get "sha_pinning_required"(){
                return shaPinningRequiredSchema.describe("Whether actions must be pinned to a full-length commit SHA.").optional()
              }
    })

export const actionsArtifactAndLogRetentionResponseSchema = z.object({
    "days": z.int().describe("The number of days artifacts and logs are retained"),
"maximum_allowed_days": z.int().describe("The maximum number of days that can be configured")
    })

export const actionsArtifactAndLogRetentionSchema = z.object({
    "days": z.int().describe("The number of days to retain artifacts and logs")
    })

export const actionsForkPrContributorApprovalSchema = z.object({
    "approval_policy": z.enum(["first_time_contributors_new_to_github", "first_time_contributors", "all_external_contributors"]).describe("The policy that controls when fork PR workflows require approval from a maintainer.")
    })

export const actionsForkPrWorkflowsPrivateReposSchema = z.object({
    "run_workflows_from_fork_pull_requests": z.boolean().describe("Whether workflows triggered by pull requests from forks are allowed to run on private repositories."),
"send_write_tokens_to_workflows": z.boolean().describe("Whether GitHub Actions can create pull requests or submit approving pull request reviews from a workflow triggered by a fork pull request."),
"send_secrets_and_variables": z.boolean().describe("Whether to make secrets and variables available to workflows triggered by pull requests from forks."),
"require_approval_for_fork_pr_workflows": z.boolean().describe("Whether workflows triggered by pull requests from forks require approval from a repository administrator to run.")
    })

export const actionsForkPrWorkflowsPrivateReposRequestSchema = z.object({
    "run_workflows_from_fork_pull_requests": z.boolean().describe("Whether workflows triggered by pull requests from forks are allowed to run on private repositories."),
"send_write_tokens_to_workflows": z.optional(z.boolean().describe("Whether GitHub Actions can create pull requests or submit approving pull request reviews from a workflow triggered by a fork pull request.")),
"send_secrets_and_variables": z.optional(z.boolean().describe("Whether to make secrets and variables available to workflows triggered by pull requests from forks.")),
"require_approval_for_fork_pr_workflows": z.optional(z.boolean().describe("Whether workflows triggered by pull requests from forks require approval from a repository administrator to run."))
    })

export const selectedActionsSchema = z.object({
    "github_owned_allowed": z.optional(z.boolean().describe("Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization.")),
"verified_allowed": z.optional(z.boolean().describe("Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators.")),
"patterns_allowed": z.optional(z.array(z.string()).describe("Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`.\n\n> [!NOTE]\n> The `patterns_allowed` setting only applies to public repositories."))
    })

export const selfHostedRunnersSettingsSchema = z.object({
    "enabled_repositories": z.enum(["all", "selected", "none"]).describe("The policy that controls whether self-hosted runners can be used by repositories in the organization"),
"selected_repositories_url": z.optional(z.string().describe("The URL to the endpoint for managing selected repositories for self-hosted runners in the organization"))
    })

/**
 * @description The default workflow permissions granted to the GITHUB_TOKEN when running workflows.
 */
export const actionsDefaultWorkflowPermissionsSchema = z.enum(["read", "write"]).describe("The default workflow permissions granted to the GITHUB_TOKEN when running workflows.")

/**
 * @description Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.
 */
export const actionsCanApprovePullRequestReviewsSchema = z.boolean().describe("Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.")

export const actionsGetDefaultWorkflowPermissionsSchema = z.object({
    get "default_workflow_permissions"(){
                return actionsDefaultWorkflowPermissionsSchema.describe("The default workflow permissions granted to the GITHUB_TOKEN when running workflows.")
              },
get "can_approve_pull_request_reviews"(){
                return actionsCanApprovePullRequestReviewsSchema.describe("Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.")
              }
    })

export const actionsSetDefaultWorkflowPermissionsSchema = z.object({
    get "default_workflow_permissions"(){
                return actionsDefaultWorkflowPermissionsSchema.describe("The default workflow permissions granted to the GITHUB_TOKEN when running workflows.").optional()
              },
get "can_approve_pull_request_reviews"(){
                return actionsCanApprovePullRequestReviewsSchema.describe("Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.").optional()
              }
    })

export const runnerGroupsOrgSchema = z.object({
    "id": z.number(),
"name": z.string(),
"visibility": z.string(),
"default": z.boolean(),
"selected_repositories_url": z.optional(z.string().describe("Link to the selected repositories resource for this runner group. Not present unless visibility was set to `selected`")),
"runners_url": z.string(),
"hosted_runners_url": z.optional(z.string()),
"network_configuration_id": z.optional(z.string().describe("The identifier of a hosted compute network configuration.")),
"inherited": z.boolean(),
"inherited_allows_public_repositories": z.optional(z.boolean()),
"allows_public_repositories": z.boolean(),
"workflow_restrictions_read_only": z.optional(z.boolean().default(false).describe("If `true`, the `restricted_to_workflows` and `selected_workflows` fields cannot be modified.")),
"restricted_to_workflows": z.optional(z.boolean().default(false).describe("If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.")),
"selected_workflows": z.optional(z.array(z.string().describe("Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.")).describe("List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`."))
    })

/**
 * @description A label for a self hosted runner
 */
export const runnerLabelSchema = z.object({
    "id": z.optional(z.int().describe("Unique identifier of the label.")),
"name": z.string().describe("Name of the label."),
"type": z.optional(z.enum(["read-only", "custom"]).describe("The type of label. Read-only labels are applied automatically when the runner is configured."))
    }).describe("A label for a self hosted runner")

/**
 * @description A self hosted runner
 */
export const runnerSchema = z.object({
    "id": z.int().describe("The ID of the runner."),
"runner_group_id": z.optional(z.int().describe("The ID of the runner group.")),
"name": z.string().describe("The name of the runner."),
"os": z.string().describe("The Operating System of the runner."),
"status": z.string().describe("The status of the runner."),
"busy": z.boolean(),
get "labels"(){
                return z.array(runnerLabelSchema.describe("A label for a self hosted runner"))
              },
"ephemeral": z.optional(z.boolean())
    }).describe("A self hosted runner")

/**
 * @description Runner Application
 */
export const runnerApplicationSchema = z.object({
    "os": z.string(),
"architecture": z.string(),
"download_url": z.string(),
"filename": z.string(),
"temp_download_token": z.optional(z.string().describe("A short lived bearer token used to download the runner, if needed.")),
"sha256_checksum": z.optional(z.string())
    }).describe("Runner Application")

/**
 * @description Authentication Token
 */
export const authenticationTokenSchema = z.object({
    "token": z.string().describe("The token used for authentication"),
"expires_at": z.iso.datetime({ offset: true }).describe("The time this token expires"),
"permissions": z.optional(z.object({
    
    })),
get "repositories"(){
                return z.array(repositorySchema.describe("A repository on GitHub.")).describe("The repositories this token has access to").optional()
              },
"single_file": z.string().nullish(),
"repository_selection": z.optional(z.enum(["all", "selected"]).describe("Describe whether all repositories have been selected or there's a selection involved"))
    }).describe("Authentication Token")

/**
 * @description Secrets for GitHub Actions for an organization.
 */
export const organizationActionsSecretSchema = z.object({
    "name": z.string().describe("The name of the secret."),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"visibility": z.enum(["all", "private", "selected"]).describe("Visibility of a secret"),
"selected_repositories_url": z.optional(z.url())
    }).describe("Secrets for GitHub Actions for an organization.")

/**
 * @description The public key used for setting Actions Secrets.
 */
export const actionsPublicKeySchema = z.object({
    "key_id": z.string().describe("The identifier for the key."),
"key": z.string().describe("The Base64 encoded public key."),
"id": z.optional(z.int()),
"url": z.optional(z.string()),
"title": z.optional(z.string()),
"created_at": z.optional(z.string())
    }).describe("The public key used for setting Actions Secrets.")

/**
 * @description Organization variable for GitHub Actions.
 */
export const organizationActionsVariableSchema = z.object({
    "name": z.string().describe("The name of the variable."),
"value": z.string().describe("The value of the variable."),
"created_at": z.iso.datetime({ offset: true }).describe("The date and time at which the variable was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."),
"updated_at": z.iso.datetime({ offset: true }).describe("The date and time at which the variable was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."),
"visibility": z.enum(["all", "private", "selected"]).describe("Visibility of a variable"),
"selected_repositories_url": z.optional(z.url())
    }).describe("Organization variable for GitHub Actions.")

/**
 * @description Indicates whether a campaign is open or closed
 */
export const campaignStateSchema = z.enum(["open", "closed"]).describe("Indicates whether a campaign is open or closed")

/**
 * @description Indicates the alert type of a campaign
 */
export const campaignAlertTypeSchema = z.enum(["code_scanning", "secret_scanning"]).describe("Indicates the alert type of a campaign")

/**
 * @description Groups of organization members that gives permissions on specified repositories.
 */
export const nullableTeamSimpleSchema = z.object({
    "id": z.int().describe("Unique identifier of the team"),
"node_id": z.string(),
"url": z.url().describe("URL for the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"description": z.nullable(z.string().describe("Description of the team")),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.optional(z.string().describe("The level of privacy this team should have")),
"notification_setting": z.optional(z.string().describe("The notification setting the team has set")),
"html_url": z.url(),
"repositories_url": z.url(),
"slug": z.string(),
"ldap_dn": z.optional(z.string().describe("Distinguished Name (DN) that team maps to within LDAP environment")),
"type": z.enum(["enterprise", "organization"]).describe("The ownership type of the team"),
"organization_id": z.optional(z.int().describe("Unique identifier of the organization to which this team belongs")),
"enterprise_id": z.optional(z.int().describe("Unique identifier of the enterprise to which this team belongs"))
    }).describe("Groups of organization members that gives permissions on specified repositories.").nullable()

/**
 * @description Groups of organization members that gives permissions on specified repositories.
 */
export const teamSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"name": z.string(),
"slug": z.string(),
"description": z.nullable(z.string()),
"privacy": z.optional(z.string()),
"notification_setting": z.optional(z.string()),
"permission": z.string(),
"permissions": z.optional(z.object({
    "pull": z.boolean(),
"triage": z.boolean(),
"push": z.boolean(),
"maintain": z.boolean(),
"admin": z.boolean()
    })),
"url": z.url(),
"html_url": z.url(),
"members_url": z.string(),
"repositories_url": z.url(),
"type": z.enum(["enterprise", "organization"]).describe("The ownership type of the team"),
"organization_id": z.optional(z.int().describe("Unique identifier of the organization to which this team belongs")),
"enterprise_id": z.optional(z.int().describe("Unique identifier of the enterprise to which this team belongs")),
get "parent"(){
               return nullableTeamSimpleSchema.describe("Groups of organization members that gives permissions on specified repositories.").nullable()
              }
    }).describe("Groups of organization members that gives permissions on specified repositories.")

/**
 * @description The campaign metadata and alert stats.
 */
export const campaignSummarySchema = z.object({
    "number": z.int().describe("The number of the newly created campaign"),
"created_at": z.iso.datetime({ offset: true }).describe("The date and time the campaign was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."),
"updated_at": z.iso.datetime({ offset: true }).describe("The date and time the campaign was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."),
"name": z.optional(z.string().describe("The campaign name")),
"description": z.string().describe("The campaign description"),
get "managers"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).describe("The campaign managers")
              },
get "team_managers"(){
                return z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories.")).describe("The campaign team managers").optional()
              },
"published_at": z.optional(z.iso.datetime({ offset: true }).describe("The date and time the campaign was published, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.")),
"ends_at": z.iso.datetime({ offset: true }).describe("The date and time the campaign has ended, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."),
"closed_at": z.iso.datetime({ offset: true }).describe("The date and time the campaign was closed, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ. Will be null if the campaign is still open.").nullish(),
get "state"(){
                return campaignStateSchema.describe("Indicates whether a campaign is open or closed")
              },
"contact_link": z.nullable(z.url().describe("The contact link of the campaign.")),
"alert_stats": z.optional(z.object({
    "open_count": z.int().describe("The number of open alerts"),
"closed_count": z.int().describe("The number of closed alerts"),
"in_progress_count": z.int().describe("The number of in-progress alerts")
    }))
    }).describe("The campaign metadata and alert stats.")

/**
 * @description The name of the tool used to generate the code scanning analysis.
 */
export const codeScanningAnalysisToolNameSchema = z.string().describe("The name of the tool used to generate the code scanning analysis.")

/**
 * @description The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.
 */
export const codeScanningAnalysisToolGuidSchema = z.string().describe("The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.").nullable()

/**
 * @description State of a code scanning alert.
 */
export const codeScanningAlertStateQuerySchema = z.enum(["open", "closed", "dismissed", "fixed"]).describe("State of a code scanning alert.")

/**
 * @description Severity of a code scanning alert.
 */
export const codeScanningAlertSeveritySchema = z.enum(["critical", "high", "medium", "low", "warning", "note", "error"]).describe("Severity of a code scanning alert.")

/**
 * @description The REST API URL for fetching the list of instances for an alert.
 */
export const alertInstancesUrlSchema = z.url().describe("The REST API URL for fetching the list of instances for an alert.")

/**
 * @description State of a code scanning alert.
 */
export const codeScanningAlertStateSchema = z.enum(["open", "dismissed", "fixed"]).describe("State of a code scanning alert.").nullable()

/**
 * @description **Required when the state is dismissed.** The reason for dismissing or closing the alert.
 */
export const codeScanningAlertDismissedReasonSchema = z.enum(["false positive", "won't fix", "used in tests"]).describe("**Required when the state is dismissed.** The reason for dismissing or closing the alert.").nullable()

/**
 * @description The dismissal comment associated with the dismissal of the alert.
 */
export const codeScanningAlertDismissedCommentSchema = z.string().max(280).describe("The dismissal comment associated with the dismissal of the alert.").nullable()

export const codeScanningAlertRuleSummarySchema = z.object({
    "id": z.string().describe("A unique identifier for the rule used to detect the alert.").nullish(),
"name": z.optional(z.string().describe("The name of the rule used to detect the alert.")),
"severity": z.enum(["none", "note", "warning", "error"]).describe("The severity of the alert.").nullish(),
"security_severity_level": z.enum(["low", "medium", "high", "critical"]).describe("The security severity of the alert.").nullish(),
"description": z.optional(z.string().describe("A short description of the rule used to detect the alert.")),
"full_description": z.optional(z.string().describe("A description of the rule used to detect the alert.")),
"tags": z.array(z.string()).describe("A set of tags applicable for the rule.").nullish(),
"help": z.string().describe("Detailed documentation for the rule as GitHub Flavored Markdown.").nullish(),
"help_uri": z.string().describe("A link to the documentation for the rule used to detect the alert.").nullish()
    })

/**
 * @description The version of the tool used to generate the code scanning analysis.
 */
export const codeScanningAnalysisToolVersionSchema = z.string().describe("The version of the tool used to generate the code scanning analysis.").nullable()

export const codeScanningAnalysisToolSchema = z.object({
    get "name"(){
                return codeScanningAnalysisToolNameSchema.describe("The name of the tool used to generate the code scanning analysis.").optional()
              },
get "version"(){
                return codeScanningAnalysisToolVersionSchema.describe("The version of the tool used to generate the code scanning analysis.").optional()
              },
get "guid"(){
                return codeScanningAnalysisToolGuidSchema.describe("The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.").optional()
              }
    })

/**
 * @description The Git reference, formatted as `refs/pull/<number>/merge`, `refs/pull/<number>/head`,\n`refs/heads/<branch name>` or simply `<branch name>`.
 */
export const codeScanningRefSchema = z.string().describe("The Git reference, formatted as `refs/pull/<number>/merge`, `refs/pull/<number>/head`,\n`refs/heads/<branch name>` or simply `<branch name>`.")

/**
 * @description Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.
 */
export const codeScanningAnalysisAnalysisKeySchema = z.string().describe("Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.")

/**
 * @description Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.
 */
export const codeScanningAlertEnvironmentSchema = z.string().describe("Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.")

/**
 * @description Identifies the configuration under which the analysis was executed. Used to distinguish between multiple analyses for the same tool and commit, but performed on different languages or different parts of the code.
 */
export const codeScanningAnalysisCategorySchema = z.string().describe("Identifies the configuration under which the analysis was executed. Used to distinguish between multiple analyses for the same tool and commit, but performed on different languages or different parts of the code.")

/**
 * @description Describe a region within a file for the alert.
 */
export const codeScanningAlertLocationSchema = z.object({
    "path": z.optional(z.string()),
"start_line": z.optional(z.int()),
"end_line": z.optional(z.int()),
"start_column": z.optional(z.int()),
"end_column": z.optional(z.int())
    }).describe("Describe a region within a file for the alert.")

/**
 * @description A classification of the file. For example to identify it as generated.
 */
export const codeScanningAlertClassificationSchema = z.enum(["source", "generated", "test", "library"]).describe("A classification of the file. For example to identify it as generated.").nullable()

export const codeScanningAlertInstanceSchema = z.object({
    get "ref"(){
                return codeScanningRefSchema.describe("The Git reference, formatted as `refs/pull/<number>/merge`, `refs/pull/<number>/head`,\n`refs/heads/<branch name>` or simply `<branch name>`.").optional()
              },
get "analysis_key"(){
                return codeScanningAnalysisAnalysisKeySchema.describe("Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.").optional()
              },
get "environment"(){
                return codeScanningAlertEnvironmentSchema.describe("Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.").optional()
              },
get "category"(){
                return codeScanningAnalysisCategorySchema.describe("Identifies the configuration under which the analysis was executed. Used to distinguish between multiple analyses for the same tool and commit, but performed on different languages or different parts of the code.").optional()
              },
get "state"(){
                return codeScanningAlertStateSchema.describe("State of a code scanning alert.").optional()
              },
"commit_sha": z.optional(z.string()),
"message": z.optional(z.object({
    "text": z.optional(z.string())
    })),
get "location"(){
                return codeScanningAlertLocationSchema.describe("Describe a region within a file for the alert.").optional()
              },
"html_url": z.optional(z.string()),
get "classifications"(){
                return z.array(codeScanningAlertClassificationSchema.describe("A classification of the file. For example to identify it as generated.").nullable()).describe("Classifications that have been applied to the file that triggered the alert.\nFor example identifying it as documentation, or a generated file.").optional()
              }
    })

export const codeScanningOrganizationAlertItemsSchema = z.object({
    get "number"(){
                return alertNumberSchema.describe("The security alert number.")
              },
get "created_at"(){
                return alertCreatedAtSchema.describe("The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.")
              },
get "updated_at"(){
                return alertUpdatedAtSchema.describe("The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").optional()
              },
get "url"(){
                return alertUrlSchema.describe("The REST API URL of the alert resource.")
              },
get "html_url"(){
                return alertHtmlUrlSchema.describe("The GitHub URL of the alert resource.")
              },
get "instances_url"(){
                return alertInstancesUrlSchema.describe("The REST API URL for fetching the list of instances for an alert.")
              },
get "state"(){
               return codeScanningAlertStateSchema.describe("State of a code scanning alert.").nullable()
              },
get "fixed_at"(){
                return alertFixedAtSchema.describe("The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").optional()
              },
get "dismissed_by"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
get "dismissed_at"(){
               return alertDismissedAtSchema.describe("The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullable()
              },
get "dismissed_reason"(){
               return codeScanningAlertDismissedReasonSchema.describe("**Required when the state is dismissed.** The reason for dismissing or closing the alert.").nullable()
              },
get "dismissed_comment"(){
                return codeScanningAlertDismissedCommentSchema.describe("The dismissal comment associated with the dismissal of the alert.").optional()
              },
get "rule"(){
                return codeScanningAlertRuleSummarySchema
              },
get "tool"(){
                return codeScanningAnalysisToolSchema
              },
get "most_recent_instance"(){
                return codeScanningAlertInstanceSchema
              },
get "repository"(){
                return simpleRepositorySchema.describe("A GitHub repository.")
              },
get "dismissal_approved_by"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
get "assignees"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).optional()
              }
    })

/**
 * @description A description of the machine powering a codespace.
 */
export const nullableCodespaceMachineSchema = z.object({
    "name": z.string().describe("The name of the machine."),
"display_name": z.string().describe("The display name of the machine includes cores, memory, and storage."),
"operating_system": z.string().describe("The operating system of the machine."),
"storage_in_bytes": z.int().describe("How much storage is available to the codespace."),
"memory_in_bytes": z.int().describe("How much memory is available to the codespace."),
"cpus": z.int().describe("How many cores are available to the codespace."),
"prebuild_availability": z.nullable(z.enum(["none", "ready", "in_progress"]).describe("Whether a prebuild is currently available when creating a codespace for this machine and repository. If a branch was not specified as a ref, the default branch will be assumed. Value will be \"null\" if prebuilds are not supported or prebuild availability could not be determined. Value will be \"none\" if no prebuild is available. Latest values \"ready\" and \"in_progress\" indicate the prebuild availability status."))
    }).describe("A description of the machine powering a codespace.").nullable()

/**
 * @description A codespace.
 */
export const codespaceSchema = z.object({
    "id": z.int(),
"name": z.string().describe("Automatically generated name of this codespace."),
"display_name": z.string().describe("Display name for this codespace.").nullish(),
"environment_id": z.nullable(z.string().describe("UUID identifying this codespace's environment.")),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "billable_owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "repository"(){
                return minimalRepositorySchema.describe("Minimal Repository")
              },
get "machine"(){
               return nullableCodespaceMachineSchema.describe("A description of the machine powering a codespace.").nullable()
              },
"devcontainer_path": z.string().describe("Path to devcontainer.json from repo root used to create Codespace.").nullish(),
"prebuild": z.nullable(z.boolean().describe("Whether the codespace was created from a prebuild.")),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"last_used_at": z.iso.datetime({ offset: true }).describe("Last known time this codespace was started."),
"state": z.enum(["Unknown", "Created", "Queued", "Provisioning", "Available", "Awaiting", "Unavailable", "Deleted", "Moved", "Shutdown", "Archived", "Starting", "ShuttingDown", "Failed", "Exporting", "Updating", "Rebuilding"]).describe("State of this codespace."),
"url": z.url().describe("API URL for this codespace."),
"git_status": z.object({
    "ahead": z.optional(z.int().describe("The number of commits the local repository is ahead of the remote.")),
"behind": z.optional(z.int().describe("The number of commits the local repository is behind the remote.")),
"has_unpushed_changes": z.optional(z.boolean().describe("Whether the local repository has unpushed changes.")),
"has_uncommitted_changes": z.optional(z.boolean().describe("Whether the local repository has uncommitted changes.")),
"ref": z.optional(z.string().describe("The current branch (or SHA if in detached HEAD state) of the local repository."))
    }).describe("Details about the codespace's git repository."),
"location": z.enum(["EastUs", "SouthEastAsia", "WestEurope", "WestUs2"]).describe("The initally assigned location of a new codespace."),
"idle_timeout_minutes": z.nullable(z.int().describe("The number of minutes of inactivity after which this codespace will be automatically stopped.")),
"web_url": z.url().describe("URL to access this codespace on the web."),
"machines_url": z.url().describe("API URL to access available alternate machine types for this codespace."),
"start_url": z.url().describe("API URL to start this codespace."),
"stop_url": z.url().describe("API URL to stop this codespace."),
"publish_url": z.url().describe("API URL to publish this codespace to a new repository.").nullish(),
"pulls_url": z.nullable(z.url().describe("API URL for the Pull Request associated with this codespace, if any.")),
"recent_folders": z.array(z.string()),
"runtime_constraints": z.optional(z.object({
    "allowed_port_privacy_settings": z.array(z.string()).describe("The privacy settings a user can select from when forwarding a port.").nullish()
    })),
"pending_operation": z.boolean().describe("Whether or not a codespace has a pending async operation. This would mean that the codespace is temporarily unavailable. The only thing that you can do with a codespace in this state is delete it.").nullish(),
"pending_operation_disabled_reason": z.string().describe("Text to show user when codespace is disabled by a pending operation").nullish(),
"idle_timeout_notice": z.string().describe("Text to show user when codespace idle timeout minutes has been overriden by an organization policy").nullish(),
"retention_period_minutes": z.int().describe("Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).").nullish(),
"retention_expires_at": z.iso.datetime({ offset: true }).describe("When a codespace will be auto-deleted based on the \"retention_period_minutes\" and \"last_used_at\"").nullish(),
"last_known_stop_notice": z.string().describe("The text to display to a user when a codespace has been stopped for a potentially actionable reason.").nullish()
    }).describe("A codespace.")

/**
 * @description Secrets for a GitHub Codespace.
 */
export const codespacesOrgSecretSchema = z.object({
    "name": z.string().describe("The name of the secret"),
"created_at": z.iso.datetime({ offset: true }).describe("The date and time at which the secret was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."),
"updated_at": z.iso.datetime({ offset: true }).describe("The date and time at which the secret was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."),
"visibility": z.enum(["all", "private", "selected"]).describe("The type of repositories in the organization that the secret is visible to"),
"selected_repositories_url": z.optional(z.url().describe("The API URL at which the list of repositories this secret is visible to can be retrieved"))
    }).describe("Secrets for a GitHub Codespace.")

/**
 * @description The public key used for setting Codespaces secrets.
 */
export const codespacesPublicKeySchema = z.object({
    "key_id": z.string().describe("The identifier for the key."),
"key": z.string().describe("The Base64 encoded public key."),
"id": z.optional(z.int()),
"url": z.optional(z.string()),
"title": z.optional(z.string()),
"created_at": z.optional(z.string())
    }).describe("The public key used for setting Codespaces secrets.")

/**
 * @description The breakdown of Copilot Business seats for the organization.
 */
export const copilotOrganizationSeatBreakdownSchema = z.object({
    "total": z.optional(z.int().describe("The total number of seats being billed for the organization as of the current billing cycle.")),
"added_this_cycle": z.optional(z.int().describe("Seats added during the current billing cycle.")),
"pending_cancellation": z.optional(z.int().describe("The number of seats that are pending cancellation at the end of the current billing cycle.")),
"pending_invitation": z.optional(z.int().describe("The number of users who have been invited to receive a Copilot seat through this organization.")),
"active_this_cycle": z.optional(z.int().describe("The number of seats that have used Copilot during the current billing cycle.")),
"inactive_this_cycle": z.optional(z.int().describe("The number of seats that have not used Copilot during the current billing cycle."))
    }).describe("The breakdown of Copilot Business seats for the organization.")

/**
 * @description Information about the seat breakdown and policies set for an organization with a Copilot Business or Copilot Enterprise subscription.
 */
export const copilotOrganizationDetailsSchema = z.object({
    get "seat_breakdown"(){
                return copilotOrganizationSeatBreakdownSchema.describe("The breakdown of Copilot Business seats for the organization.")
              },
"public_code_suggestions": z.enum(["allow", "block", "unconfigured"]).describe("The organization policy for allowing or blocking suggestions matching public code (duplication detection filter)."),
"ide_chat": z.optional(z.enum(["enabled", "disabled", "unconfigured"]).describe("The organization policy for allowing or disallowing Copilot Chat in the IDE.")),
"platform_chat": z.optional(z.enum(["enabled", "disabled", "unconfigured"]).describe("The organization policy for allowing or disallowing Copilot features on GitHub.com.")),
"cli": z.optional(z.enum(["enabled", "disabled", "unconfigured"]).describe("The organization policy for allowing or disallowing Copilot in the CLI.")),
"seat_management_setting": z.enum(["assign_all", "assign_selected", "disabled", "unconfigured"]).describe("The mode of assigning new seats."),
"plan_type": z.optional(z.enum(["business", "enterprise"]).describe("The Copilot plan of the organization, or the parent enterprise, when applicable."))
    }).catchall(z.unknown()).describe("Information about the seat breakdown and policies set for an organization with a Copilot Business or Copilot Enterprise subscription.")

/**
 * @description A GitHub organization.
 */
export const nullableOrganizationSimpleSchema = z.object({
    "login": z.string(),
"id": z.int(),
"node_id": z.string(),
"url": z.url(),
"repos_url": z.url(),
"events_url": z.url(),
"hooks_url": z.string(),
"issues_url": z.string(),
"members_url": z.string(),
"public_members_url": z.string(),
"avatar_url": z.string(),
"description": z.nullable(z.string())
    }).describe("A GitHub organization.").nullable()

/**
 * @description Information about a Copilot Business seat assignment for a user, team, or organization.
 */
export const copilotSeatDetailsSchema = z.object({
    get "assignee"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
get "organization"(){
                return nullableOrganizationSimpleSchema.describe("A GitHub organization.").optional()
              },
get "assigning_team"(){
                return z.union([teamSchema, enterpriseTeamSchema]).describe("The team through which the assignee is granted access to GitHub Copilot, if applicable.").nullish()
              },
"pending_cancellation_date": z.iso.date().describe("The pending cancellation date for the seat, in `YYYY-MM-DD` format. This will be null unless the assignee's Copilot access has been canceled during the current billing cycle. If the seat has been cancelled, this corresponds to the start of the organization's next billing cycle.").nullish(),
"last_activity_at": z.iso.datetime({ offset: true }).describe("Timestamp of user's last GitHub Copilot activity, in ISO 8601 format.").nullish(),
"last_activity_editor": z.string().describe("Last editor that was used by the user for a GitHub Copilot completion.").nullish(),
"last_authenticated_at": z.iso.datetime({ offset: true }).describe("Timestamp of the last time the user authenticated with GitHub Copilot, in ISO 8601 format.").nullish(),
"created_at": z.iso.datetime({ offset: true }).describe("Timestamp of when the assignee was last granted access to GitHub Copilot, in ISO 8601 format."),
"updated_at": z.optional(z.iso.datetime({ offset: true }).describe("**Closing down notice:** This field is no longer relevant and is closing down. Use the `created_at` field to determine when the assignee was last granted access to GitHub Copilot. Timestamp of when the assignee's GitHub Copilot access was last updated, in ISO 8601 format.")),
"plan_type": z.optional(z.enum(["business", "enterprise", "unknown"]).describe("The Copilot plan of the organization, or the parent enterprise, when applicable."))
    }).describe("Information about a Copilot Business seat assignment for a user, team, or organization.")

/**
 * @description Usage metrics for Copilot editor code completions in the IDE.
 */
export const copilotIdeCodeCompletionsSchema = z.object({
    "total_engaged_users": z.optional(z.int().describe("Number of users who accepted at least one Copilot code suggestion, across all active editors. Includes both full and partial acceptances.")),
"languages": z.optional(z.array(z.object({
    "name": z.optional(z.string().describe("Name of the language used for Copilot code completion suggestions.")),
"total_engaged_users": z.optional(z.int().describe("Number of users who accepted at least one Copilot code completion suggestion for the given language. Includes both full and partial acceptances."))
    }).describe("Usage metrics for a given language for the given editor for Copilot code completions.")).describe("Code completion metrics for active languages.")),
"editors": z.optional(z.array(z.object({
    "name": z.optional(z.string().describe("Name of the given editor.")),
"total_engaged_users": z.optional(z.int().describe("Number of users who accepted at least one Copilot code completion suggestion for the given editor. Includes both full and partial acceptances.")),
"models": z.optional(z.array(z.object({
    "name": z.optional(z.string().describe("Name of the model used for Copilot code completion suggestions. If the default model is used will appear as 'default'.")),
"is_custom_model": z.optional(z.boolean().describe("Indicates whether a model is custom or default.")),
"custom_model_training_date": z.string().describe("The training date for the custom model.").nullish(),
"total_engaged_users": z.optional(z.int().describe("Number of users who accepted at least one Copilot code completion suggestion for the given editor, for the given language and model. Includes both full and partial acceptances.")),
"languages": z.optional(z.array(z.object({
    "name": z.optional(z.string().describe("Name of the language used for Copilot code completion suggestions, for the given editor.")),
"total_engaged_users": z.optional(z.int().describe("Number of users who accepted at least one Copilot code completion suggestion for the given editor, for the given language. Includes both full and partial acceptances.")),
"total_code_suggestions": z.optional(z.int().describe("The number of Copilot code suggestions generated for the given editor, for the given language.")),
"total_code_acceptances": z.optional(z.int().describe("The number of Copilot code suggestions accepted for the given editor, for the given language. Includes both full and partial acceptances.")),
"total_code_lines_suggested": z.optional(z.int().describe("The number of lines of code suggested by Copilot code completions for the given editor, for the given language.")),
"total_code_lines_accepted": z.optional(z.int().describe("The number of lines of code accepted from Copilot code suggestions for the given editor, for the given language."))
    }).describe("Usage metrics for a given language for the given editor for Copilot code completions.")).describe("Code completion metrics for active languages, for the given editor."))
    })).describe("List of model metrics for custom models and the default model."))
    }).catchall(z.unknown()).describe("Copilot code completion metrics for active editors.")))
    }).catchall(z.unknown()).describe("Usage metrics for Copilot editor code completions in the IDE.").nullable()

/**
 * @description Usage metrics for Copilot Chat in the IDE.
 */
export const copilotIdeChatSchema = z.object({
    "total_engaged_users": z.optional(z.int().describe("Total number of users who prompted Copilot Chat in the IDE.")),
"editors": z.optional(z.array(z.object({
    "name": z.optional(z.string().describe("Name of the given editor.")),
"total_engaged_users": z.optional(z.int().describe("The number of users who prompted Copilot Chat in the specified editor.")),
"models": z.optional(z.array(z.object({
    "name": z.optional(z.string().describe("Name of the model used for Copilot Chat. If the default model is used will appear as 'default'.")),
"is_custom_model": z.optional(z.boolean().describe("Indicates whether a model is custom or default.")),
"custom_model_training_date": z.string().describe("The training date for the custom model.").nullish(),
"total_engaged_users": z.optional(z.int().describe("The number of users who prompted Copilot Chat in the given editor and model.")),
"total_chats": z.optional(z.int().describe("The total number of chats initiated by users in the given editor and model.")),
"total_chat_insertion_events": z.optional(z.int().describe("The number of times users accepted a code suggestion from Copilot Chat using the 'Insert Code' UI element, for the given editor.")),
"total_chat_copy_events": z.optional(z.int().describe("The number of times users copied a code suggestion from Copilot Chat using the keyboard, or the 'Copy' UI element, for the given editor."))
    })).describe("List of model metrics for custom models and the default model."))
    }).describe("Copilot Chat metrics, for active editors.")))
    }).catchall(z.unknown()).describe("Usage metrics for Copilot Chat in the IDE.").nullable()

/**
 * @description Usage metrics for Copilot Chat in GitHub.com
 */
export const copilotDotcomChatSchema = z.object({
    "total_engaged_users": z.optional(z.int().describe("Total number of users who prompted Copilot Chat on github.com at least once.")),
"models": z.optional(z.array(z.object({
    "name": z.optional(z.string().describe("Name of the model used for Copilot Chat. If the default model is used will appear as 'default'.")),
"is_custom_model": z.optional(z.boolean().describe("Indicates whether a model is custom or default.")),
"custom_model_training_date": z.string().describe("The training date for the custom model (if applicable).").nullish(),
"total_engaged_users": z.optional(z.int().describe("Total number of users who prompted Copilot Chat on github.com at least once for each model.")),
"total_chats": z.optional(z.int().describe("Total number of chats initiated by users on github.com."))
    })).describe("List of model metrics for a custom models and the default model."))
    }).catchall(z.unknown()).describe("Usage metrics for Copilot Chat in GitHub.com").nullable()

/**
 * @description Usage metrics for Copilot for pull requests.
 */
export const copilotDotcomPullRequestsSchema = z.object({
    "total_engaged_users": z.optional(z.int().describe("The number of users who used Copilot for Pull Requests on github.com to generate a pull request summary at least once.")),
"repositories": z.optional(z.array(z.object({
    "name": z.optional(z.string().describe("Repository name")),
"total_engaged_users": z.optional(z.int().describe("The number of users who generated pull request summaries using Copilot for Pull Requests in the given repository.")),
"models": z.optional(z.array(z.object({
    "name": z.optional(z.string().describe("Name of the model used for Copilot pull request summaries. If the default model is used will appear as 'default'.")),
"is_custom_model": z.optional(z.boolean().describe("Indicates whether a model is custom or default.")),
"custom_model_training_date": z.string().describe("The training date for the custom model.").nullish(),
"total_pr_summaries_created": z.optional(z.int().describe("The number of pull request summaries generated using Copilot for Pull Requests in the given repository.")),
"total_engaged_users": z.optional(z.int().describe("The number of users who generated pull request summaries using Copilot for Pull Requests in the given repository and model."))
    })).describe("List of model metrics for custom models and the default model."))
    })).describe("Repositories in which users used Copilot for Pull Requests to generate pull request summaries"))
    }).catchall(z.unknown()).describe("Usage metrics for Copilot for pull requests.").nullable()

/**
 * @description Copilot usage metrics for a given day.
 */
export const copilotUsageMetricsDaySchema = z.object({
    "date": z.iso.date().describe("The date for which the usage metrics are aggregated, in `YYYY-MM-DD` format."),
"total_active_users": z.optional(z.int().describe("The total number of Copilot users with activity belonging to any Copilot feature, globally, for the given day. Includes passive activity such as receiving a code suggestion, as well as engagement activity such as accepting a code suggestion or prompting chat. Does not include authentication events. Is not limited to the individual features detailed on the endpoint.")),
"total_engaged_users": z.optional(z.int().describe("The total number of Copilot users who engaged with any Copilot feature, for the given day. Examples include but are not limited to accepting a code suggestion, prompting Copilot chat, or triggering a PR Summary. Does not include authentication events. Is not limited to the individual features detailed on the endpoint.")),
get "copilot_ide_code_completions"(){
                return copilotIdeCodeCompletionsSchema.describe("Usage metrics for Copilot editor code completions in the IDE.").optional()
              },
get "copilot_ide_chat"(){
                return copilotIdeChatSchema.describe("Usage metrics for Copilot Chat in the IDE.").optional()
              },
get "copilot_dotcom_chat"(){
                return copilotDotcomChatSchema.describe("Usage metrics for Copilot Chat in GitHub.com").optional()
              },
get "copilot_dotcom_pull_requests"(){
                return copilotDotcomPullRequestsSchema.describe("Usage metrics for Copilot for pull requests.").optional()
              }
    }).catchall(z.unknown()).describe("Copilot usage metrics for a given day.")

/**
 * @description Secrets for GitHub Dependabot for an organization.
 */
export const organizationDependabotSecretSchema = z.object({
    "name": z.string().describe("The name of the secret."),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"visibility": z.enum(["all", "private", "selected"]).describe("Visibility of a secret"),
"selected_repositories_url": z.optional(z.url())
    }).describe("Secrets for GitHub Dependabot for an organization.")

/**
 * @description The public key used for setting Dependabot Secrets.
 */
export const dependabotPublicKeySchema = z.object({
    "key_id": z.string().describe("The identifier for the key."),
"key": z.string().describe("The Base64 encoded public key.")
    }).describe("The public key used for setting Dependabot Secrets.")

/**
 * @description Minimal Repository
 */
export const nullableMinimalRepositorySchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"name": z.string(),
"full_name": z.string(),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"private": z.boolean(),
"html_url": z.url(),
"description": z.nullable(z.string()),
"fork": z.boolean(),
"url": z.url(),
"archive_url": z.string(),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"deployments_url": z.url(),
"downloads_url": z.url(),
"events_url": z.url(),
"forks_url": z.url(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.optional(z.string()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"languages_url": z.url(),
"merges_url": z.url(),
"milestones_url": z.string(),
"notifications_url": z.string(),
"pulls_url": z.string(),
"releases_url": z.string(),
"ssh_url": z.optional(z.string()),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"trees_url": z.string(),
"clone_url": z.optional(z.string()),
"mirror_url": z.string().nullish(),
"hooks_url": z.url(),
"svn_url": z.optional(z.string()),
"homepage": z.string().nullish(),
"language": z.string().nullish(),
"forks_count": z.optional(z.int()),
"stargazers_count": z.optional(z.int()),
"watchers_count": z.optional(z.int()),
"size": z.optional(z.int().describe("The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.")),
"default_branch": z.optional(z.string()),
"open_issues_count": z.optional(z.int()),
"is_template": z.optional(z.boolean()),
"topics": z.optional(z.array(z.string())),
"has_issues": z.optional(z.boolean()),
"has_projects": z.optional(z.boolean()),
"has_wiki": z.optional(z.boolean()),
"has_pages": z.optional(z.boolean()),
"has_downloads": z.optional(z.boolean()),
"has_discussions": z.optional(z.boolean()),
"archived": z.optional(z.boolean()),
"disabled": z.optional(z.boolean()),
"visibility": z.optional(z.string()),
"pushed_at": z.iso.datetime({ offset: true }).nullish(),
"created_at": z.iso.datetime({ offset: true }).nullish(),
"updated_at": z.iso.datetime({ offset: true }).nullish(),
"permissions": z.optional(z.object({
    "admin": z.optional(z.boolean()),
"maintain": z.optional(z.boolean()),
"push": z.optional(z.boolean()),
"triage": z.optional(z.boolean()),
"pull": z.optional(z.boolean())
    })),
"role_name": z.optional(z.string()),
"temp_clone_token": z.optional(z.string()),
"delete_branch_on_merge": z.optional(z.boolean()),
"subscribers_count": z.optional(z.int()),
"network_count": z.optional(z.int()),
get "code_of_conduct"(){
                return codeOfConductSchema.describe("Code Of Conduct").optional()
              },
"license": z.object({
    "key": z.optional(z.string()),
"name": z.optional(z.string()),
"spdx_id": z.optional(z.string()),
"url": z.optional(z.string()),
"node_id": z.optional(z.string())
    }).nullish(),
"forks": z.optional(z.int()),
"open_issues": z.optional(z.int()),
"watchers": z.optional(z.int()),
"allow_forking": z.optional(z.boolean()),
"web_commit_signoff_required": z.optional(z.boolean()),
get "security_and_analysis"(){
                return securityAndAnalysisSchema.optional()
              },
"custom_properties": z.optional(z.object({
    
    }).catchall(z.unknown()).describe("The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values."))
    }).describe("Minimal Repository").nullable()

/**
 * @description A software package
 */
export const packageSchema = z.object({
    "id": z.int().describe("Unique identifier of the package."),
"name": z.string().describe("The name of the package."),
"package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]),
"url": z.string(),
"html_url": z.string(),
"version_count": z.int().describe("The number of versions of the package."),
"visibility": z.enum(["private", "public"]),
get "owner"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
get "repository"(){
                return nullableMinimalRepositorySchema.describe("Minimal Repository").optional()
              },
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true })
    }).describe("A software package")

/**
 * @description Organization Invitation
 */
export const organizationInvitationSchema = z.object({
    "id": z.int(),
"login": z.nullable(z.string()),
"email": z.nullable(z.string()),
"role": z.string(),
"created_at": z.string(),
"failed_at": z.string().nullish(),
"failed_reason": z.string().nullish(),
get "inviter"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"team_count": z.int(),
"node_id": z.string(),
"invitation_teams_url": z.string(),
"invitation_source": z.optional(z.string())
    }).describe("Organization Invitation")

/**
 * @description Org Hook
 */
export const orgHookSchema = z.object({
    "id": z.int(),
"url": z.url(),
"ping_url": z.url(),
"deliveries_url": z.optional(z.url()),
"name": z.string(),
"events": z.array(z.string()),
"active": z.boolean(),
"config": z.object({
    "url": z.optional(z.string()),
"insecure_ssl": z.optional(z.string()),
"content_type": z.optional(z.string()),
"secret": z.optional(z.string())
    }),
"updated_at": z.iso.datetime({ offset: true }),
"created_at": z.iso.datetime({ offset: true }),
"type": z.string()
    }).describe("Org Hook")

/**
 * @description API Insights usage route stats for an actor
 */
export const apiInsightsRouteStatsSchema = z.array(z.object({
    "http_method": z.optional(z.string().describe("The HTTP method")),
"api_route": z.optional(z.string().describe("The API path's route template")),
"total_request_count": z.optional(z.int().describe("The total number of requests within the queried time period")),
"rate_limited_request_count": z.optional(z.int().describe("The total number of requests that were rate limited within the queried time period")),
"last_rate_limited_timestamp": z.string().nullish(),
"last_request_timestamp": z.optional(z.string())
    })).describe("API Insights usage route stats for an actor")

/**
 * @description API Insights usage subject stats for an organization
 */
export const apiInsightsSubjectStatsSchema = z.array(z.object({
    "subject_type": z.optional(z.string()),
"subject_name": z.optional(z.string()),
"subject_id": z.optional(z.int()),
"total_request_count": z.optional(z.int()),
"rate_limited_request_count": z.optional(z.int()),
"last_rate_limited_timestamp": z.string().nullish(),
"last_request_timestamp": z.optional(z.string())
    })).describe("API Insights usage subject stats for an organization")

/**
 * @description API Insights usage summary stats for an organization
 */
export const apiInsightsSummaryStatsSchema = z.object({
    "total_request_count": z.optional(z.int().describe("The total number of requests within the queried time period")),
"rate_limited_request_count": z.optional(z.int().describe("The total number of requests that were rate limited within the queried time period"))
    }).describe("API Insights usage summary stats for an organization")

/**
 * @description API Insights usage time stats for an organization
 */
export const apiInsightsTimeStatsSchema = z.array(z.object({
    "timestamp": z.optional(z.string()),
"total_request_count": z.optional(z.int()),
"rate_limited_request_count": z.optional(z.int())
    })).describe("API Insights usage time stats for an organization")

/**
 * @description API Insights usage stats for a user
 */
export const apiInsightsUserStatsSchema = z.array(z.object({
    "actor_type": z.optional(z.string()),
"actor_name": z.optional(z.string()),
"actor_id": z.optional(z.int()),
"integration_id": z.int().nullish(),
"oauth_application_id": z.int().nullish(),
"total_request_count": z.optional(z.int()),
"rate_limited_request_count": z.optional(z.int()),
"last_rate_limited_timestamp": z.string().nullish(),
"last_request_timestamp": z.optional(z.string())
    })).describe("API Insights usage stats for a user")

/**
 * @description The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.
 */
export const interactionGroupSchema = z.enum(["existing_users", "contributors_only", "collaborators_only"]).describe("The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.")

/**
 * @description Interaction limit settings.
 */
export const interactionLimitResponseSchema = z.object({
    get "limit"(){
                return interactionGroupSchema.describe("The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.")
              },
"origin": z.string(),
"expires_at": z.iso.datetime({ offset: true })
    }).describe("Interaction limit settings.")

/**
 * @description The duration of the interaction restriction. Default: `one_day`.
 */
export const interactionExpirySchema = z.enum(["one_day", "three_days", "one_week", "one_month", "six_months"]).describe("The duration of the interaction restriction. Default: `one_day`.")

/**
 * @description Limit interactions to a specific type of user for a specified duration
 */
export const interactionLimitSchema = z.object({
    get "limit"(){
                return interactionGroupSchema.describe("The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.")
              },
get "expiry"(){
                return interactionExpirySchema.describe("The duration of the interaction restriction. Default: `one_day`.").optional()
              }
    }).describe("Limit interactions to a specific type of user for a specified duration")

export const organizationCreateIssueTypeSchema = z.object({
    "name": z.string().describe("Name of the issue type."),
"is_enabled": z.boolean().describe("Whether or not the issue type is enabled at the organization level."),
"description": z.string().describe("Description of the issue type.").nullish(),
"color": z.enum(["gray", "blue", "green", "yellow", "orange", "red", "pink", "purple"]).describe("Color for the issue type.").nullish()
    })

export const organizationUpdateIssueTypeSchema = z.object({
    "name": z.string().describe("Name of the issue type."),
"is_enabled": z.boolean().describe("Whether or not the issue type is enabled at the organization level."),
"description": z.string().describe("Description of the issue type.").nullish(),
"color": z.enum(["gray", "blue", "green", "yellow", "orange", "red", "pink", "purple"]).describe("Color for the issue type.").nullish()
    })

/**
 * @description Org Membership
 */
export const orgMembershipSchema = z.object({
    "url": z.url(),
"state": z.enum(["active", "pending"]).describe("The state of the member in the organization. The `pending` state indicates the user has not yet accepted an invitation."),
"role": z.enum(["admin", "member", "billing_manager"]).describe("The user's membership type in the organization."),
"direct_membership": z.optional(z.boolean().describe("Whether the user has direct membership in the organization.")),
"enterprise_teams_providing_indirect_membership": z.optional(z.array(z.string()).max(100).describe("The slugs of the enterprise teams providing the user with indirect membership in the organization.\nA limit of 100 enterprise team slugs is returned.")),
"organization_url": z.url(),
get "organization"(){
                return organizationSimpleSchema.describe("A GitHub organization.")
              },
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"permissions": z.optional(z.object({
    "can_create_repository": z.boolean()
    }))
    }).describe("Org Membership")

/**
 * @description A migration.
 */
export const migrationSchema = z.object({
    "id": z.int(),
get "owner"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"guid": z.string(),
"state": z.string(),
"lock_repositories": z.boolean(),
"exclude_metadata": z.boolean(),
"exclude_git_data": z.boolean(),
"exclude_attachments": z.boolean(),
"exclude_releases": z.boolean(),
"exclude_owner_projects": z.boolean(),
"org_metadata_only": z.boolean(),
get "repositories"(){
                return z.array(repositorySchema.describe("A repository on GitHub.")).describe("The repositories included in the migration. Only returned for export migrations.")
              },
"url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"node_id": z.string(),
"archive_url": z.optional(z.url()),
"exclude": z.optional(z.array(z.string().describe("Allowed values that can be passed to the exclude parameter. The array can include any of: `\"repositories\"`.")).describe("Exclude related items from being returned in the response in order to improve performance of the request. The array can include any of: `\"repositories\"`."))
    }).describe("A migration.")

/**
 * @description Organization roles
 */
export const organizationRoleSchema = z.object({
    "id": z.int().describe("The unique identifier of the role."),
"name": z.string().describe("The name of the role."),
"description": z.string().describe("A short description about who this role is for or what permissions it grants.").nullish(),
"base_role": z.enum(["read", "triage", "write", "maintain", "admin"]).describe("The system role from which this role inherits permissions.").nullish(),
"source": z.enum(["Organization", "Enterprise", "Predefined"]).describe("Source answers the question, \"where did this role come from?\"").nullish(),
"permissions": z.array(z.string()).describe("A list of permissions included in this role."),
get "organization"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"created_at": z.iso.datetime({ offset: true }).describe("The date and time the role was created."),
"updated_at": z.iso.datetime({ offset: true }).describe("The date and time the role was last updated.")
    }).describe("Organization roles")

/**
 * @description The Relationship a Team has with a role.
 */
export const teamRoleAssignmentSchema = z.object({
    "assignment": z.optional(z.enum(["direct", "indirect", "mixed"]).describe("Determines if the team has a direct, indirect, or mixed relationship to a role")),
"id": z.int(),
"node_id": z.string(),
"name": z.string(),
"slug": z.string(),
"description": z.nullable(z.string()),
"privacy": z.optional(z.string()),
"notification_setting": z.optional(z.string()),
"permission": z.string(),
"permissions": z.optional(z.object({
    "pull": z.boolean(),
"triage": z.boolean(),
"push": z.boolean(),
"maintain": z.boolean(),
"admin": z.boolean()
    })),
"url": z.url(),
"html_url": z.url(),
"members_url": z.string(),
"repositories_url": z.url(),
get "parent"(){
               return nullableTeamSimpleSchema.describe("Groups of organization members that gives permissions on specified repositories.").nullable()
              },
"type": z.enum(["enterprise", "organization"]).describe("The ownership type of the team"),
"organization_id": z.optional(z.int().describe("Unique identifier of the organization to which this team belongs")),
"enterprise_id": z.optional(z.int().describe("Unique identifier of the enterprise to which this team belongs"))
    }).describe("The Relationship a Team has with a role.")

/**
 * @description Groups of organization members that gives permissions on specified repositories.
 */
export const teamSimpleSchema = z.object({
    "id": z.int().describe("Unique identifier of the team"),
"node_id": z.string(),
"url": z.url().describe("URL for the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"description": z.nullable(z.string().describe("Description of the team")),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.optional(z.string().describe("The level of privacy this team should have")),
"notification_setting": z.optional(z.string().describe("The notification setting the team has set")),
"html_url": z.url(),
"repositories_url": z.url(),
"slug": z.string(),
"ldap_dn": z.optional(z.string().describe("Distinguished Name (DN) that team maps to within LDAP environment")),
"type": z.enum(["enterprise", "organization"]).describe("The ownership type of the team"),
"organization_id": z.optional(z.int().describe("Unique identifier of the organization to which this team belongs")),
"enterprise_id": z.optional(z.int().describe("Unique identifier of the enterprise to which this team belongs"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")

/**
 * @description The Relationship a User has with a role.
 */
export const userRoleAssignmentSchema = z.object({
    "assignment": z.optional(z.enum(["direct", "indirect", "mixed"]).describe("Determines if the user has a direct, indirect, or mixed relationship to a role")),
get "inherited_from"(){
                return z.array(teamSimpleSchema.describe("Groups of organization members that gives permissions on specified repositories.")).describe("Team the user has gotten the role through").optional()
              },
"name": z.string().nullish(),
"email": z.string().nullish(),
"login": z.string(),
"id": z.int(),
"node_id": z.string(),
"avatar_url": z.url(),
"gravatar_id": z.nullable(z.string()),
"url": z.url(),
"html_url": z.url(),
"followers_url": z.url(),
"following_url": z.string(),
"gists_url": z.string(),
"starred_url": z.string(),
"subscriptions_url": z.url(),
"organizations_url": z.url(),
"repos_url": z.url(),
"events_url": z.string(),
"received_events_url": z.url(),
"type": z.string(),
"site_admin": z.boolean(),
"starred_at": z.optional(z.string()),
"user_view_type": z.optional(z.string())
    }).describe("The Relationship a User has with a role.")

/**
 * @description A version of a software package
 */
export const packageVersionSchema = z.object({
    "id": z.int().describe("Unique identifier of the package version."),
"name": z.string().describe("The name of the package version."),
"url": z.string(),
"package_html_url": z.string(),
"html_url": z.optional(z.string()),
"license": z.optional(z.string()),
"description": z.optional(z.string()),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"deleted_at": z.optional(z.iso.datetime({ offset: true })),
"metadata": z.optional(z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]),
"container": z.optional(z.object({
    "tags": z.array(z.string())
    })),
"docker": z.optional(z.object({
    "tag": z.optional(z.array(z.string()))
    }))
    }))
    }).describe("A version of a software package")

/**
 * @description Minimal representation of an organization programmatic access grant request for enumerations
 */
export const organizationProgrammaticAccessGrantRequestSchema = z.object({
    "id": z.int().describe("Unique identifier of the request for access via fine-grained personal access token. The `pat_request_id` used to review PAT requests."),
"reason": z.nullable(z.string().describe("Reason for requesting access.")),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"repository_selection": z.enum(["none", "all", "subset"]).describe("Type of repository selection requested."),
"repositories_url": z.string().describe("URL to the list of repositories requested to be accessed via fine-grained personal access token. Should only be followed when `repository_selection` is `subset`."),
"permissions": z.object({
    "organization": z.optional(z.object({
    
    }).catchall(z.string())),
"repository": z.optional(z.object({
    
    }).catchall(z.string())),
"other": z.optional(z.object({
    
    }).catchall(z.string()))
    }).describe("Permissions requested, categorized by type of permission."),
"created_at": z.string().describe("Date and time when the request for access was created."),
"token_id": z.int().describe("Unique identifier of the user's token. This field can also be found in audit log events and the organization's settings for their PAT grants."),
"token_name": z.string().describe("The name given to the user's token. This field can also be found in an organization's settings page for Active Tokens."),
"token_expired": z.boolean().describe("Whether the associated fine-grained personal access token has expired."),
"token_expires_at": z.nullable(z.string().describe("Date and time when the associated fine-grained personal access token expires.")),
"token_last_used_at": z.nullable(z.string().describe("Date and time when the associated fine-grained personal access token was last used for authentication."))
    }).describe("Minimal representation of an organization programmatic access grant request for enumerations")

/**
 * @description Minimal representation of an organization programmatic access grant for enumerations
 */
export const organizationProgrammaticAccessGrantSchema = z.object({
    "id": z.int().describe("Unique identifier of the fine-grained personal access token grant. The `pat_id` used to get details about an approved fine-grained personal access token."),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"repository_selection": z.enum(["none", "all", "subset"]).describe("Type of repository selection requested."),
"repositories_url": z.string().describe("URL to the list of repositories the fine-grained personal access token can access. Only follow when `repository_selection` is `subset`."),
"permissions": z.object({
    "organization": z.optional(z.object({
    
    }).catchall(z.string())),
"repository": z.optional(z.object({
    
    }).catchall(z.string())),
"other": z.optional(z.object({
    
    }).catchall(z.string()))
    }).describe("Permissions requested, categorized by type of permission."),
"access_granted_at": z.string().describe("Date and time when the fine-grained personal access token was approved to access the organization."),
"token_id": z.int().describe("Unique identifier of the user's token. This field can also be found in audit log events and the organization's settings for their PAT grants."),
"token_name": z.string().describe("The name given to the user's token. This field can also be found in an organization's settings page for Active Tokens."),
"token_expired": z.boolean().describe("Whether the associated fine-grained personal access token has expired."),
"token_expires_at": z.nullable(z.string().describe("Date and time when the associated fine-grained personal access token expires.")),
"token_last_used_at": z.nullable(z.string().describe("Date and time when the associated fine-grained personal access token was last used for authentication."))
    }).describe("Minimal representation of an organization programmatic access grant for enumerations")

/**
 * @description Private registry configuration for an organization
 */
export const orgPrivateRegistryConfigurationSchema = z.object({
    "name": z.string().describe("The name of the private registry configuration."),
"registry_type": z.enum(["maven_repository", "nuget_feed", "goproxy_server", "npm_registry", "rubygems_server", "cargo_registry", "composer_repository", "docker_registry", "git_source", "helm_registry", "hex_organization", "hex_repository", "pub_repository", "python_index", "terraform_registry"]).describe("The registry type."),
"username": z.string().describe("The username to use when authenticating with the private registry.").nullish(),
"visibility": z.enum(["all", "private", "selected"]).describe("Which type of organization repositories have access to the private registry."),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true })
    }).describe("Private registry configuration for an organization")

/**
 * @description Private registry configuration for an organization
 */
export const orgPrivateRegistryConfigurationWithSelectedRepositoriesSchema = z.object({
    "name": z.string().describe("The name of the private registry configuration."),
"registry_type": z.enum(["maven_repository", "nuget_feed", "goproxy_server", "npm_registry", "rubygems_server", "cargo_registry", "composer_repository", "docker_registry", "git_source", "helm_registry", "hex_organization", "hex_repository", "pub_repository", "python_index", "terraform_registry"]).describe("The registry type."),
"username": z.optional(z.string().describe("The username to use when authenticating with the private registry.")),
"visibility": z.enum(["all", "private", "selected"]).describe("Which type of organization repositories have access to the private registry. `selected` means only the repositories specified by `selected_repository_ids` can access the private registry."),
"selected_repository_ids": z.optional(z.array(z.int()).describe("An array of repository IDs that can access the organization private registry when `visibility` is set to `selected`.")),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true })
    }).describe("Private registry configuration for an organization")

/**
 * @description Projects are a way to organize columns and cards of work.
 */
export const projectSchema = z.object({
    "owner_url": z.url(),
"url": z.url(),
"html_url": z.url(),
"columns_url": z.url(),
"id": z.int(),
"node_id": z.string(),
"name": z.string().describe("Name of the project"),
"body": z.nullable(z.string().describe("Body of the project")),
"number": z.int(),
"state": z.string().describe("State of the project; either 'open' or 'closed'"),
get "creator"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"organization_permission": z.optional(z.enum(["read", "write", "admin", "none"]).describe("The baseline permission that all organization members have on this project. Only present if owner is an organization.")),
"private": z.optional(z.boolean().describe("Whether or not this project can be seen by everyone. Only present if owner is an organization."))
    }).describe("Projects are a way to organize columns and cards of work.")

/**
 * @description An status update belonging to a project
 */
export const nullableProjectsV2StatusUpdateSchema = z.object({
    "id": z.number().describe("The unique identifier of the status update."),
"node_id": z.string().describe("The node ID of the status update."),
"project_node_id": z.optional(z.string().describe("The node ID of the project that this status update belongs to.")),
get "creator"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
"created_at": z.iso.datetime({ offset: true }).describe("The time when the status update was created."),
"updated_at": z.iso.datetime({ offset: true }).describe("The time when the status update was last updated."),
"status": z.enum(["INACTIVE", "ON_TRACK", "AT_RISK", "OFF_TRACK", "COMPLETE"]).describe("The current status.").nullish(),
"start_date": z.optional(z.iso.date().describe("The start date of the period covered by the update.")),
"target_date": z.optional(z.iso.date().describe("The target date associated with the update.")),
"body": z.string().describe("Body of the status update").nullish()
    }).describe("An status update belonging to a project").nullable()

/**
 * @description A projects v2 project
 */
export const projectsV2Schema = z.object({
    "id": z.number().describe("The unique identifier of the project."),
"node_id": z.string().describe("The node ID of the project."),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "creator"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"title": z.string().describe("The project title."),
"description": z.nullable(z.string().describe("A short description of the project.")),
"public": z.boolean().describe("Whether the project is visible to anyone with access to the owner."),
"closed_at": z.nullable(z.iso.datetime({ offset: true }).describe("The time when the project was closed.")),
"created_at": z.iso.datetime({ offset: true }).describe("The time when the project was created."),
"updated_at": z.iso.datetime({ offset: true }).describe("The time when the project was last updated."),
"number": z.int().describe("The project number."),
"short_description": z.nullable(z.string().describe("A concise summary of the project.")),
"deleted_at": z.nullable(z.iso.datetime({ offset: true }).describe("The time when the project was deleted.")),
get "deleted_by"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"state": z.optional(z.enum(["open", "closed"]).describe("The current state of the project.")),
get "latest_status_update"(){
                return nullableProjectsV2StatusUpdateSchema.describe("An status update belonging to a project").optional()
              },
"is_template": z.optional(z.boolean().describe("Whether this project is a template"))
    }).describe("A projects v2 project")

/**
 * @description An option for a single select field
 */
export const projectsV2SingleSelectOptionsSchema = z.object({
    "id": z.string().describe("The unique identifier of the option."),
"name": z.object({
    "raw": z.string(),
"html": z.string()
    }).describe("The display name of the option, in raw text and HTML formats."),
"description": z.object({
    "raw": z.string(),
"html": z.string()
    }).describe("The description of the option, in raw text and HTML formats."),
"color": z.string().describe("The color associated with the option.")
    }).describe("An option for a single select field")

/**
 * @description An iteration setting for an iteration field
 */
export const projectsV2IterationSettingsSchema = z.object({
    "id": z.string().describe("The unique identifier of the iteration setting."),
"start_date": z.iso.date().describe("The start date of the iteration."),
"duration": z.int().describe("The duration of the iteration in days."),
"title": z.object({
    "raw": z.string(),
"html": z.string()
    }).describe("The iteration title, in raw text and HTML formats."),
"completed": z.boolean().describe("Whether the iteration has been completed.")
    }).describe("An iteration setting for an iteration field")

/**
 * @description A field inside a projects v2 project
 */
export const projectsV2FieldSchema = z.object({
    "id": z.int().describe("The unique identifier of the field."),
"node_id": z.optional(z.string().describe("The node ID of the field.")),
"project_url": z.string().describe("The API URL of the project that contains the field."),
"name": z.string().describe("The name of the field."),
"data_type": z.enum(["assignees", "linked_pull_requests", "reviewers", "labels", "milestone", "repository", "title", "text", "single_select", "number", "date", "iteration", "issue_type", "parent_issue", "sub_issues_progress"]).describe("The field's data type."),
get "options"(){
                return z.array(projectsV2SingleSelectOptionsSchema.describe("An option for a single select field")).describe("The options available for single select fields.").optional()
              },
"configuration": z.optional(z.object({
    "start_day": z.optional(z.int().describe("The day of the week when the iteration starts.")),
"duration": z.optional(z.int().describe("The duration of the iteration in days.")),
get "iterations"(){
                return z.array(projectsV2IterationSettingsSchema.describe("An iteration setting for an iteration field")).optional()
              }
    }).describe("Configuration for iteration fields.")),
"created_at": z.iso.datetime({ offset: true }).describe("The time when the field was created."),
"updated_at": z.iso.datetime({ offset: true }).describe("The time when the field was last updated.")
    }).describe("A field inside a projects v2 project")

/**
 * @description The type of content tracked in a project item
 */
export const projectsV2ItemContentTypeSchema = z.enum(["Issue", "PullRequest", "DraftIssue"]).describe("The type of content tracked in a project item")

/**
 * @description An item belonging to a project
 */
export const projectsV2ItemWithContentSchema = z.object({
    "id": z.number().describe("The unique identifier of the project item."),
"node_id": z.optional(z.string().describe("The node ID of the project item.")),
"project_url": z.optional(z.url().describe("The API URL of the project that contains this item.")),
get "content_type"(){
                return projectsV2ItemContentTypeSchema.describe("The type of content tracked in a project item")
              },
"content": z.object({
    
    }).catchall(z.unknown()).describe("The content of the item, which varies by content type.").nullish(),
get "creator"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
"created_at": z.iso.datetime({ offset: true }).describe("The time when the item was created."),
"updated_at": z.iso.datetime({ offset: true }).describe("The time when the item was last updated."),
"archived_at": z.nullable(z.iso.datetime({ offset: true }).describe("The time when the item was archived.")),
"item_url": z.url().describe("The API URL of this item.").nullish(),
"fields": z.optional(z.array(z.object({
    
    }).catchall(z.unknown())).describe("The fields and values associated with this item."))
    }).describe("An item belonging to a project")

/**
 * @description Hypermedia Link
 */
export const linkSchema = z.object({
    "href": z.string()
    }).describe("Hypermedia Link")

/**
 * @description The status of auto merging a pull request.
 */
export const autoMergeSchema = z.object({
    get "enabled_by"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use."),
"commit_title": z.string().describe("Title for the merge commit message."),
"commit_message": z.string().describe("Commit message for the merge commit.")
    }).describe("The status of auto merging a pull request.").nullable()

/**
 * @description Pull Request Simple
 */
export const pullRequestSimpleSchema = z.object({
    "url": z.url(),
"id": z.int(),
"node_id": z.string(),
"html_url": z.url(),
"diff_url": z.url(),
"patch_url": z.url(),
"issue_url": z.url(),
"commits_url": z.url(),
"review_comments_url": z.url(),
"review_comment_url": z.string(),
"comments_url": z.url(),
"statuses_url": z.url(),
"number": z.int(),
"state": z.string(),
"locked": z.boolean(),
"title": z.string(),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"body": z.nullable(z.string()),
"labels": z.array(z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
"name": z.string(),
"description": z.string(),
"color": z.string(),
"default": z.boolean()
    })),
get "milestone"(){
               return nullableMilestoneSchema.describe("A collection of related issues and pull requests.").nullable()
              },
"active_lock_reason": z.string().nullish(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merge_commit_sha": z.nullable(z.string()),
get "assignee"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
get "assignees"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).nullish()
              },
get "requested_reviewers"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).nullish()
              },
get "requested_teams"(){
                return z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories.")).nullish()
              },
"head": z.object({
    "label": z.string(),
"ref": z.string(),
get "repo"(){
                return repositorySchema.describe("A repository on GitHub.")
              },
"sha": z.string(),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              }
    }),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
get "repo"(){
                return repositorySchema.describe("A repository on GitHub.")
              },
"sha": z.string(),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              }
    }),
"_links": z.object({
    get "comments"(){
                return linkSchema.describe("Hypermedia Link")
              },
get "commits"(){
                return linkSchema.describe("Hypermedia Link")
              },
get "statuses"(){
                return linkSchema.describe("Hypermedia Link")
              },
get "html"(){
                return linkSchema.describe("Hypermedia Link")
              },
get "issue"(){
                return linkSchema.describe("Hypermedia Link")
              },
get "review_comments"(){
                return linkSchema.describe("Hypermedia Link")
              },
get "review_comment"(){
                return linkSchema.describe("Hypermedia Link")
              },
get "self"(){
                return linkSchema.describe("Hypermedia Link")
              }
    }),
get "author_association"(){
                return authorAssociationSchema.describe("How the author is associated with the repository.")
              },
get "auto_merge"(){
               return autoMergeSchema.describe("The status of auto merging a pull request.").nullable()
              },
"draft": z.optional(z.boolean().describe("Indicates whether or not the pull request is a draft."))
    }).describe("Pull Request Simple")

/**
 * @description A draft issue in a project
 */
export const projectsV2DraftIssueSchema = z.object({
    "id": z.number().describe("The ID of the draft issue"),
"node_id": z.string().describe("The node ID of the draft issue"),
"title": z.string().describe("The title of the draft issue"),
"body": z.string().describe("The body content of the draft issue").nullish(),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"created_at": z.iso.datetime({ offset: true }).describe("The time the draft issue was created"),
"updated_at": z.iso.datetime({ offset: true }).describe("The time the draft issue was last updated")
    }).describe("A draft issue in a project")

/**
 * @description An item belonging to a project
 */
export const projectsV2ItemSimpleSchema = z.object({
    "id": z.number().describe("The unique identifier of the project item."),
"node_id": z.optional(z.string().describe("The node ID of the project item.")),
get "content"(){
                return z.union([issueSchema, pullRequestSimpleSchema, projectsV2DraftIssueSchema]).describe("The content represented by the item.").optional()
              },
get "content_type"(){
                return projectsV2ItemContentTypeSchema.describe("The type of content tracked in a project item")
              },
get "creator"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
"created_at": z.iso.datetime({ offset: true }).describe("The time when the item was created."),
"updated_at": z.iso.datetime({ offset: true }).describe("The time when the item was last updated."),
"archived_at": z.nullable(z.iso.datetime({ offset: true }).describe("The time when the item was archived.")),
"project_url": z.optional(z.url().describe("The URL of the project this item belongs to.")),
"item_url": z.optional(z.url().describe("The URL of the item in the project."))
    }).describe("An item belonging to a project")

/**
 * @description Custom property defined on an organization
 */
export const customPropertySchema = z.object({
    "property_name": z.string().describe("The name of the property"),
"url": z.optional(z.url().describe("The URL that can be used to fetch, update, or delete info about this property via the API.")),
"source_type": z.optional(z.enum(["organization", "enterprise"]).describe("The source type of the property")),
"value_type": z.enum(["string", "single_select", "multi_select", "true_false"]).describe("The type of the value for the property"),
"required": z.optional(z.boolean().describe("Whether the property is required.")),
"default_value": z.union([z.array(z.string()), z.string()]).describe("Default value of the property").nullish(),
"description": z.string().describe("Short description of the property").nullish(),
"allowed_values": z.array(z.string().max(75)).max(200).describe("An ordered list of the allowed values of the property.\nThe property can have up to 200 allowed values.").nullish(),
"values_editable_by": z.enum(["org_actors", "org_and_repo_actors"]).describe("Who can edit the values of the property").nullish()
    }).describe("Custom property defined on an organization")

/**
 * @description Custom property set payload
 */
export const customPropertySetPayloadSchema = z.object({
    "value_type": z.enum(["string", "single_select", "multi_select", "true_false"]).describe("The type of the value for the property"),
"required": z.optional(z.boolean().describe("Whether the property is required.")),
"default_value": z.union([z.array(z.string()), z.string()]).describe("Default value of the property").nullish(),
"description": z.string().describe("Short description of the property").nullish(),
"allowed_values": z.array(z.string().max(75)).max(200).describe("An ordered list of the allowed values of the property.\nThe property can have up to 200 allowed values.").nullish(),
"values_editable_by": z.enum(["org_actors", "org_and_repo_actors"]).describe("Who can edit the values of the property").nullish()
    }).describe("Custom property set payload")

/**
 * @description List of custom property values for a repository
 */
export const orgRepoCustomPropertyValuesSchema = z.object({
    "repository_id": z.int(),
"repository_name": z.string(),
"repository_full_name": z.string(),
get "properties"(){
                return z.array(customPropertyValueSchema.describe("Custom property name and associated value")).describe("List of custom property names and associated values")
              }
    }).describe("List of custom property values for a repository")

/**
 * @description A repository on GitHub.
 */
export const nullableRepositorySchema = z.object({
    "id": z.int().describe("Unique identifier of the repository"),
"node_id": z.string(),
"name": z.string().describe("The name of the repository."),
"full_name": z.string(),
get "license"(){
               return nullableLicenseSimpleSchema.describe("License Simple").nullable()
              },
"forks": z.int(),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"pull": z.boolean(),
"triage": z.optional(z.boolean()),
"push": z.boolean(),
"maintain": z.optional(z.boolean())
    })),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"private": z.boolean().default(false).describe("Whether the repository is private or public."),
"html_url": z.url(),
"description": z.nullable(z.string()),
"fork": z.boolean(),
"url": z.url(),
"archive_url": z.string(),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"deployments_url": z.url(),
"downloads_url": z.url(),
"events_url": z.url(),
"forks_url": z.url(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.string(),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"languages_url": z.url(),
"merges_url": z.url(),
"milestones_url": z.string(),
"notifications_url": z.string(),
"pulls_url": z.string(),
"releases_url": z.string(),
"ssh_url": z.string(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"trees_url": z.string(),
"clone_url": z.string(),
"mirror_url": z.nullable(z.url()),
"hooks_url": z.url(),
"svn_url": z.url(),
"homepage": z.nullable(z.url()),
"language": z.nullable(z.string()),
"forks_count": z.int(),
"stargazers_count": z.int(),
"watchers_count": z.int(),
"size": z.int().describe("The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0."),
"default_branch": z.string().describe("The default branch of the repository."),
"open_issues_count": z.int(),
"is_template": z.optional(z.boolean().default(false).describe("Whether this repository acts as a template that can be used to generate new repositories.")),
"topics": z.optional(z.array(z.string())),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_pages": z.boolean(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_discussions": z.optional(z.boolean().default(false).describe("Whether discussions are enabled.")),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"disabled": z.boolean().describe("Returns whether or not this repository disabled."),
"visibility": z.optional(z.string().default("public").describe("The repository visibility: public, private, or internal.")),
"pushed_at": z.nullable(z.iso.datetime({ offset: true })),
"created_at": z.nullable(z.iso.datetime({ offset: true })),
"updated_at": z.nullable(z.iso.datetime({ offset: true })),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"temp_clone_token": z.optional(z.string()),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow Auto-merge to be used on pull requests.")),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"allow_update_branch": z.optional(z.boolean().default(false).describe("Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.")),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow forking this repo")),
"web_commit_signoff_required": z.optional(z.boolean().default(false).describe("Whether to require contributors to sign off on web-based commits")),
"open_issues": z.int(),
"watchers": z.int(),
"master_branch": z.optional(z.string()),
"starred_at": z.optional(z.string()),
"anonymous_access_enabled": z.optional(z.boolean().describe("Whether anonymous git access is enabled for this repository")),
"code_search_index_status": z.optional(z.object({
    "lexical_search_ok": z.optional(z.boolean()),
"lexical_commit_sha": z.optional(z.string())
    }).describe("The status of the code search index for this repository"))
    }).describe("A repository on GitHub.").nullable()

/**
 * @description Code of Conduct Simple
 */
export const codeOfConductSimpleSchema = z.object({
    "url": z.url(),
"key": z.string(),
"name": z.string(),
"html_url": z.nullable(z.url())
    }).describe("Code of Conduct Simple")

/**
 * @description Full Repository
 */
export const fullRepositorySchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"name": z.string(),
"full_name": z.string(),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"private": z.boolean(),
"html_url": z.url(),
"description": z.nullable(z.string()),
"fork": z.boolean(),
"url": z.url(),
"archive_url": z.string(),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"deployments_url": z.url(),
"downloads_url": z.url(),
"events_url": z.url(),
"forks_url": z.url(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.string(),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"languages_url": z.url(),
"merges_url": z.url(),
"milestones_url": z.string(),
"notifications_url": z.string(),
"pulls_url": z.string(),
"releases_url": z.string(),
"ssh_url": z.string(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"trees_url": z.string(),
"clone_url": z.string(),
"mirror_url": z.nullable(z.url()),
"hooks_url": z.url(),
"svn_url": z.url(),
"homepage": z.nullable(z.url()),
"language": z.nullable(z.string()),
"forks_count": z.int(),
"stargazers_count": z.int(),
"watchers_count": z.int(),
"size": z.int().describe("The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0."),
"default_branch": z.string(),
"open_issues_count": z.int(),
"is_template": z.optional(z.boolean()),
"topics": z.optional(z.array(z.string())),
"has_issues": z.boolean(),
"has_projects": z.boolean(),
"has_wiki": z.boolean(),
"has_pages": z.boolean(),
"has_downloads": z.optional(z.boolean()),
"has_discussions": z.boolean(),
"archived": z.boolean(),
"disabled": z.boolean().describe("Returns whether or not this repository disabled."),
"visibility": z.optional(z.string().describe("The repository visibility: public, private, or internal.")),
"pushed_at": z.iso.datetime({ offset: true }),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"push": z.boolean(),
"triage": z.optional(z.boolean()),
"pull": z.boolean()
    })),
"allow_rebase_merge": z.optional(z.boolean()),
get "template_repository"(){
                return nullableRepositorySchema.describe("A repository on GitHub.").optional()
              },
"temp_clone_token": z.string().nullish(),
"allow_squash_merge": z.optional(z.boolean()),
"allow_auto_merge": z.optional(z.boolean()),
"delete_branch_on_merge": z.optional(z.boolean()),
"allow_merge_commit": z.optional(z.boolean()),
"allow_update_branch": z.optional(z.boolean()),
"use_squash_pr_title_as_default": z.optional(z.boolean()),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n  - `PR_TITLE` - default to the pull request's title.\n  - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"allow_forking": z.optional(z.boolean()),
"web_commit_signoff_required": z.optional(z.boolean()),
"subscribers_count": z.int(),
"network_count": z.int(),
get "license"(){
               return nullableLicenseSimpleSchema.describe("License Simple").nullable()
              },
get "organization"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
get "parent"(){
                return repositorySchema.describe("A repository on GitHub.").optional()
              },
get "source"(){
                return repositorySchema.describe("A repository on GitHub.").optional()
              },
"forks": z.int(),
"master_branch": z.optional(z.string()),
"open_issues": z.int(),
"watchers": z.int(),
"anonymous_access_enabled": z.optional(z.boolean().default(true).describe("Whether anonymous git access is allowed.")),
get "code_of_conduct"(){
                return codeOfConductSimpleSchema.describe("Code of Conduct Simple").optional()
              },
get "security_and_analysis"(){
                return securityAndAnalysisSchema.optional()
              },
"custom_properties": z.optional(z.object({
    
    }).catchall(z.unknown()).describe("The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values."))
    }).describe("Full Repository")

/**
 * @description The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).
 */
export const repositoryRuleEnforcementSchema = z.enum(["disabled", "active", "evaluate"]).describe("The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).")

/**
 * @description An actor that can bypass rules in a ruleset
 */
export const repositoryRulesetBypassActorSchema = z.object({
    "actor_id": z.int().describe("The ID of the actor that can bypass a ruleset. Required for `Integration`, `RepositoryRole`, and `Team` actor types. If `actor_type` is `OrganizationAdmin`, this should be `1`. If `actor_type` is `DeployKey`, this should be null. `OrganizationAdmin` is not applicable for personal repositories.").nullish(),
"actor_type": z.enum(["Integration", "OrganizationAdmin", "RepositoryRole", "Team", "DeployKey"]).describe("The type of actor that can bypass a ruleset."),
"bypass_mode": z.optional(z.enum(["always", "pull_request", "exempt"]).default("always").describe("When the specified actor can bypass the ruleset. `pull_request` means that an actor can only bypass rules on pull requests. `pull_request` is not applicable for the `DeployKey` actor type. Also, `pull_request` is only applicable to branch rulesets. When `bypass_mode` is `exempt`, rules will not be run for that actor and a bypass audit entry will not be created."))
    }).describe("An actor that can bypass rules in a ruleset")

/**
 * @description Parameters for a repository ruleset ref name condition
 */
export const repositoryRulesetConditionsSchema = z.object({
    "ref_name": z.optional(z.object({
    "include": z.optional(z.array(z.string()).describe("Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.")),
"exclude": z.optional(z.array(z.string()).describe("Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match."))
    }))
    }).describe("Parameters for a repository ruleset ref name condition")

/**
 * @description Parameters for a repository name condition
 */
export const repositoryRulesetConditionsRepositoryNameTargetSchema = z.object({
    "repository_name": z.object({
    "include": z.optional(z.array(z.string()).describe("Array of repository names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~ALL` to include all repositories.")),
"exclude": z.optional(z.array(z.string()).describe("Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match.")),
"protected": z.optional(z.boolean().describe("Whether renaming of target repositories is prevented."))
    })
    }).describe("Parameters for a repository name condition")

/**
 * @description Parameters for a repository ID condition
 */
export const repositoryRulesetConditionsRepositoryIdTargetSchema = z.object({
    "repository_id": z.object({
    "repository_ids": z.optional(z.array(z.int()).describe("The repository IDs that the ruleset applies to. One of these IDs must match for the condition to pass."))
    })
    }).describe("Parameters for a repository ID condition")

/**
 * @description Parameters for a targeting a repository property
 */
export const repositoryRulesetConditionsRepositoryPropertySpecSchema = z.object({
    "name": z.string().describe("The name of the repository property to target"),
"property_values": z.array(z.string()).describe("The values to match for the repository property"),
"source": z.optional(z.enum(["custom", "system"]).describe("The source of the repository property. Defaults to 'custom' if not specified."))
    }).describe("Parameters for a targeting a repository property")

/**
 * @description Parameters for a repository property condition
 */
export const repositoryRulesetConditionsRepositoryPropertyTargetSchema = z.object({
    "repository_property": z.object({
    get "include"(){
                return z.array(repositoryRulesetConditionsRepositoryPropertySpecSchema.describe("Parameters for a targeting a repository property")).describe("The repository properties and values to include. All of these properties must match for the condition to pass.").optional()
              },
get "exclude"(){
                return z.array(repositoryRulesetConditionsRepositoryPropertySpecSchema.describe("Parameters for a targeting a repository property")).describe("The repository properties and values to exclude. The condition will not pass if any of these properties match.").optional()
              }
    })
    }).describe("Parameters for a repository property condition")

/**
 * @description Conditions for an organization ruleset.\nThe branch and tag rulesets conditions object should contain both `repository_name` and `ref_name` properties, or both `repository_id` and `ref_name` properties, or both `repository_property` and `ref_name` properties.\nThe push rulesets conditions object does not require the `ref_name` property.\nFor repository policy rulesets, the conditions object should only contain the `repository_name`, the `repository_id`, or the `repository_property`.
 */
export const orgRulesetConditionsSchema = z.union([repositoryRulesetConditionsSchema.and(repositoryRulesetConditionsRepositoryNameTargetSchema), repositoryRulesetConditionsSchema.and(repositoryRulesetConditionsRepositoryIdTargetSchema), repositoryRulesetConditionsSchema.and(repositoryRulesetConditionsRepositoryPropertyTargetSchema)]).describe("Conditions for an organization ruleset.\nThe branch and tag rulesets conditions object should contain both `repository_name` and `ref_name` properties, or both `repository_id` and `ref_name` properties, or both `repository_property` and `ref_name` properties.\nThe push rulesets conditions object does not require the `ref_name` property.\nFor repository policy rulesets, the conditions object should only contain the `repository_name`, the `repository_id`, or the `repository_property`.")

/**
 * @description Only allow users with bypass permission to create matching refs.
 */
export const repositoryRuleCreationSchema = z.object({
    "type": z.enum(["creation"])
    }).describe("Only allow users with bypass permission to create matching refs.")

/**
 * @description Only allow users with bypass permission to update matching refs.
 */
export const repositoryRuleUpdateSchema = z.object({
    "type": z.enum(["update"]),
"parameters": z.optional(z.object({
    "update_allows_fetch_and_merge": z.boolean().describe("Branch can pull changes from its upstream repository")
    }))
    }).describe("Only allow users with bypass permission to update matching refs.")

/**
 * @description Only allow users with bypass permissions to delete matching refs.
 */
export const repositoryRuleDeletionSchema = z.object({
    "type": z.enum(["deletion"])
    }).describe("Only allow users with bypass permissions to delete matching refs.")

/**
 * @description Prevent merge commits from being pushed to matching refs.
 */
export const repositoryRuleRequiredLinearHistorySchema = z.object({
    "type": z.enum(["required_linear_history"])
    }).describe("Prevent merge commits from being pushed to matching refs.")

/**
 * @description Merges must be performed via a merge queue.
 */
export const repositoryRuleMergeQueueSchema = z.object({
    "type": z.enum(["merge_queue"]),
"parameters": z.optional(z.object({
    "check_response_timeout_minutes": z.int().min(1).max(360).describe("Maximum time for a required status check to report a conclusion. After this much time has elapsed, checks that have not reported a conclusion will be assumed to have failed"),
"grouping_strategy": z.enum(["ALLGREEN", "HEADGREEN"]).describe("When set to ALLGREEN, the merge commit created by merge queue for each PR in the group must pass all required checks to merge. When set to HEADGREEN, only the commit at the head of the merge group, i.e. the commit containing changes from all of the PRs in the group, must pass its required checks to merge."),
"max_entries_to_build": z.int().min(0).max(100).describe("Limit the number of queued pull requests requesting checks and workflow runs at the same time."),
"max_entries_to_merge": z.int().min(0).max(100).describe("The maximum number of PRs that will be merged together in a group."),
"merge_method": z.enum(["MERGE", "SQUASH", "REBASE"]).describe("Method to use when merging changes from queued pull requests."),
"min_entries_to_merge": z.int().min(0).max(100).describe("The minimum number of PRs that will be merged together in a group."),
"min_entries_to_merge_wait_minutes": z.int().min(0).max(360).describe("The time merge queue should wait after the first PR is added to the queue for the minimum group size to be met. After this time has elapsed, the minimum group size will be ignored and a smaller group will be merged.")
    }))
    }).describe("Merges must be performed via a merge queue.")

/**
 * @description Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule.
 */
export const repositoryRuleRequiredDeploymentsSchema = z.object({
    "type": z.enum(["required_deployments"]),
"parameters": z.optional(z.object({
    "required_deployment_environments": z.array(z.string()).describe("The environments that must be successfully deployed to before branches can be merged.")
    }))
    }).describe("Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule.")

/**
 * @description Commits pushed to matching refs must have verified signatures.
 */
export const repositoryRuleRequiredSignaturesSchema = z.object({
    "type": z.enum(["required_signatures"])
    }).describe("Commits pushed to matching refs must have verified signatures.")

/**
 * @description A required reviewing team
 */
export const repositoryRuleParamsReviewerSchema = z.object({
    "id": z.int().describe("ID of the reviewer which must review changes to matching files."),
"type": z.enum(["Team"]).describe("The type of the reviewer")
    }).describe("A required reviewing team")

/**
 * @description A reviewing team, and file patterns describing which files they must approve changes to.
 */
export const repositoryRuleParamsRequiredReviewerConfigurationSchema = z.object({
    "file_patterns": z.array(z.string()).describe("Array of file patterns. Pull requests which change matching files must be approved by the specified team. File patterns use the same syntax as `.gitignore` files."),
"minimum_approvals": z.int().describe("Minimum number of approvals required from the specified team. If set to zero, the team will be added to the pull request but approval is optional."),
get "reviewer"(){
                return repositoryRuleParamsReviewerSchema.describe("A required reviewing team")
              }
    }).describe("A reviewing team, and file patterns describing which files they must approve changes to.")

/**
 * @description Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
 */
export const repositoryRulePullRequestSchema = z.object({
    "type": z.enum(["pull_request"]),
"parameters": z.optional(z.object({
    "allowed_merge_methods": z.optional(z.array(z.enum(["merge", "squash", "rebase"])).describe("Array of allowed merge methods. Allowed values include `merge`, `squash`, and `rebase`. At least one option must be enabled.")),
"automatic_copilot_code_review_enabled": z.optional(z.boolean().describe("Request Copilot code review for new pull requests automatically if the author has access to Copilot code review.")),
"dismiss_stale_reviews_on_push": z.boolean().describe("New, reviewable commits pushed will dismiss previous pull request review approvals."),
"require_code_owner_review": z.boolean().describe("Require an approving review in pull requests that modify files that have a designated code owner."),
"require_last_push_approval": z.boolean().describe("Whether the most recent reviewable push must be approved by someone other than the person who pushed it."),
"required_approving_review_count": z.int().min(0).max(10).describe("The number of approving reviews that are required before a pull request can be merged."),
"required_review_thread_resolution": z.boolean().describe("All conversations on code must be resolved before a pull request can be merged.")
    }))
    }).describe("Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.")

/**
 * @description Required status check
 */
export const repositoryRuleParamsStatusCheckConfigurationSchema = z.object({
    "context": z.string().describe("The status check context name that must be present on the commit."),
"integration_id": z.optional(z.int().describe("The optional integration ID that this status check must originate from."))
    }).describe("Required status check")

/**
 * @description Choose which status checks must pass before the ref is updated. When enabled, commits must first be pushed to another ref where the checks pass.
 */
export const repositoryRuleRequiredStatusChecksSchema = z.object({
    "type": z.enum(["required_status_checks"]),
"parameters": z.optional(z.object({
    "do_not_enforce_on_create": z.optional(z.boolean().describe("Allow repositories and branches to be created if a check would otherwise prohibit it.")),
get "required_status_checks"(){
                return z.array(repositoryRuleParamsStatusCheckConfigurationSchema.describe("Required status check")).describe("Status checks that are required.")
              },
"strict_required_status_checks_policy": z.boolean().describe("Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled.")
    }))
    }).describe("Choose which status checks must pass before the ref is updated. When enabled, commits must first be pushed to another ref where the checks pass.")

/**
 * @description Prevent users with push access from force pushing to refs.
 */
export const repositoryRuleNonFastForwardSchema = z.object({
    "type": z.enum(["non_fast_forward"])
    }).describe("Prevent users with push access from force pushing to refs.")

/**
 * @description Parameters to be used for the commit_message_pattern rule
 */
export const repositoryRuleCommitMessagePatternSchema = z.object({
    "type": z.enum(["commit_message_pattern"]),
"parameters": z.optional(z.object({
    "name": z.optional(z.string().describe("How this rule will appear to users.")),
"negate": z.optional(z.boolean().describe("If true, the rule will fail if the pattern matches.")),
"operator": z.enum(["starts_with", "ends_with", "contains", "regex"]).describe("The operator to use for matching."),
"pattern": z.string().describe("The pattern to match with.")
    }))
    }).describe("Parameters to be used for the commit_message_pattern rule")

/**
 * @description Parameters to be used for the commit_author_email_pattern rule
 */
export const repositoryRuleCommitAuthorEmailPatternSchema = z.object({
    "type": z.enum(["commit_author_email_pattern"]),
"parameters": z.optional(z.object({
    "name": z.optional(z.string().describe("How this rule will appear to users.")),
"negate": z.optional(z.boolean().describe("If true, the rule will fail if the pattern matches.")),
"operator": z.enum(["starts_with", "ends_with", "contains", "regex"]).describe("The operator to use for matching."),
"pattern": z.string().describe("The pattern to match with.")
    }))
    }).describe("Parameters to be used for the commit_author_email_pattern rule")

/**
 * @description Parameters to be used for the committer_email_pattern rule
 */
export const repositoryRuleCommitterEmailPatternSchema = z.object({
    "type": z.enum(["committer_email_pattern"]),
"parameters": z.optional(z.object({
    "name": z.optional(z.string().describe("How this rule will appear to users.")),
"negate": z.optional(z.boolean().describe("If true, the rule will fail if the pattern matches.")),
"operator": z.enum(["starts_with", "ends_with", "contains", "regex"]).describe("The operator to use for matching."),
"pattern": z.string().describe("The pattern to match with.")
    }))
    }).describe("Parameters to be used for the committer_email_pattern rule")

/**
 * @description Parameters to be used for the branch_name_pattern rule
 */
export const repositoryRuleBranchNamePatternSchema = z.object({
    "type": z.enum(["branch_name_pattern"]),
"parameters": z.optional(z.object({
    "name": z.optional(z.string().describe("How this rule will appear to users.")),
"negate": z.optional(z.boolean().describe("If true, the rule will fail if the pattern matches.")),
"operator": z.enum(["starts_with", "ends_with", "contains", "regex"]).describe("The operator to use for matching."),
"pattern": z.string().describe("The pattern to match with.")
    }))
    }).describe("Parameters to be used for the branch_name_pattern rule")

/**
 * @description Parameters to be used for the tag_name_pattern rule
 */
export const repositoryRuleTagNamePatternSchema = z.object({
    "type": z.enum(["tag_name_pattern"]),
"parameters": z.optional(z.object({
    "name": z.optional(z.string().describe("How this rule will appear to users.")),
"negate": z.optional(z.boolean().describe("If true, the rule will fail if the pattern matches.")),
"operator": z.enum(["starts_with", "ends_with", "contains", "regex"]).describe("The operator to use for matching."),
"pattern": z.string().describe("The pattern to match with.")
    }))
    }).describe("Parameters to be used for the tag_name_pattern rule")

/**
 * @description Prevent commits that include changes in specified file and folder paths from being pushed to the commit graph. This includes absolute paths that contain file names.
 */
export const repositoryRuleFilePathRestrictionSchema = z.object({
    "type": z.enum(["file_path_restriction"]),
"parameters": z.optional(z.object({
    "restricted_file_paths": z.array(z.string()).describe("The file paths that are restricted from being pushed to the commit graph.")
    }))
    }).describe("Prevent commits that include changes in specified file and folder paths from being pushed to the commit graph. This includes absolute paths that contain file names.")

/**
 * @description Prevent commits that include file paths that exceed the specified character limit from being pushed to the commit graph.
 */
export const repositoryRuleMaxFilePathLengthSchema = z.object({
    "type": z.enum(["max_file_path_length"]),
"parameters": z.optional(z.object({
    "max_file_path_length": z.int().min(1).max(32767).describe("The maximum amount of characters allowed in file paths.")
    }))
    }).describe("Prevent commits that include file paths that exceed the specified character limit from being pushed to the commit graph.")

/**
 * @description Prevent commits that include files with specified file extensions from being pushed to the commit graph.
 */
export const repositoryRuleFileExtensionRestrictionSchema = z.object({
    "type": z.enum(["file_extension_restriction"]),
"parameters": z.optional(z.object({
    "restricted_file_extensions": z.array(z.string()).describe("The file extensions that are restricted from being pushed to the commit graph.")
    }))
    }).describe("Prevent commits that include files with specified file extensions from being pushed to the commit graph.")

/**
 * @description Prevent commits with individual files that exceed the specified limit from being pushed to the commit graph.
 */
export const repositoryRuleMaxFileSizeSchema = z.object({
    "type": z.enum(["max_file_size"]),
"parameters": z.optional(z.object({
    "max_file_size": z.int().min(1).max(100).describe("The maximum file size allowed in megabytes. This limit does not apply to Git Large File Storage (Git LFS).")
    }))
    }).describe("Prevent commits with individual files that exceed the specified limit from being pushed to the commit graph.")

/**
 * @description Restricted commit
 */
export const repositoryRuleParamsRestrictedCommitsSchema = z.object({
    "oid": z.string().describe("Full or abbreviated commit hash to reject"),
"reason": z.optional(z.string().describe("Reason for restriction"))
    }).describe("Restricted commit")

/**
 * @description A workflow that must run for this rule to pass
 */
export const repositoryRuleParamsWorkflowFileReferenceSchema = z.object({
    "path": z.string().describe("The path to the workflow file"),
"ref": z.optional(z.string().describe("The ref (branch or tag) of the workflow file to use")),
"repository_id": z.int().describe("The ID of the repository where the workflow is defined"),
"sha": z.optional(z.string().describe("The commit SHA of the workflow file to use"))
    }).describe("A workflow that must run for this rule to pass")

/**
 * @description Require all changes made to a targeted branch to pass the specified workflows before they can be merged.
 */
export const repositoryRuleWorkflowsSchema = z.object({
    "type": z.enum(["workflows"]),
"parameters": z.optional(z.object({
    "do_not_enforce_on_create": z.optional(z.boolean().describe("Allow repositories and branches to be created if a check would otherwise prohibit it.")),
get "workflows"(){
                return z.array(repositoryRuleParamsWorkflowFileReferenceSchema.describe("A workflow that must run for this rule to pass")).describe("Workflows that must pass for this rule to pass.")
              }
    }))
    }).describe("Require all changes made to a targeted branch to pass the specified workflows before they can be merged.")

/**
 * @description A tool that must provide code scanning results for this rule to pass.
 */
export const repositoryRuleParamsCodeScanningToolSchema = z.object({
    "alerts_threshold": z.enum(["none", "errors", "errors_and_warnings", "all"]).describe("The severity level at which code scanning results that raise alerts block a reference update. For more information on alert severity levels, see \"[About code scanning alerts](https://docs.github.com/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels).\""),
"security_alerts_threshold": z.enum(["none", "critical", "high_or_higher", "medium_or_higher", "all"]).describe("The severity level at which code scanning results that raise security alerts block a reference update. For more information on security severity levels, see \"[About code scanning alerts](https://docs.github.com/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels).\""),
"tool": z.string().describe("The name of a code scanning tool")
    }).describe("A tool that must provide code scanning results for this rule to pass.")

/**
 * @description Choose which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated.
 */
export const repositoryRuleCodeScanningSchema = z.object({
    "type": z.enum(["code_scanning"]),
"parameters": z.optional(z.object({
    get "code_scanning_tools"(){
                return z.array(repositoryRuleParamsCodeScanningToolSchema.describe("A tool that must provide code scanning results for this rule to pass.")).describe("Tools that must provide code scanning results for this rule to pass.")
              }
    }))
    }).describe("Choose which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated.")

/**
 * @description Request Copilot code review for new pull requests automatically if the author has access to Copilot code review.
 */
export const repositoryRuleCopilotCodeReviewSchema = z.object({
    "type": z.enum(["copilot_code_review"]),
"parameters": z.optional(z.object({
    "review_draft_pull_requests": z.optional(z.boolean().describe("Copilot automatically reviews draft pull requests before they are marked as ready for review.")),
"review_on_push": z.optional(z.boolean().describe("Copilot automatically reviews each new push to the pull request."))
    }))
    }).describe("Request Copilot code review for new pull requests automatically if the author has access to Copilot code review.")

/**
 * @description A repository rule.
 */
export const repositoryRuleSchema = z.union([repositoryRuleCreationSchema, repositoryRuleUpdateSchema, repositoryRuleDeletionSchema, repositoryRuleRequiredLinearHistorySchema, repositoryRuleMergeQueueSchema, repositoryRuleRequiredDeploymentsSchema, repositoryRuleRequiredSignaturesSchema, repositoryRulePullRequestSchema, repositoryRuleRequiredStatusChecksSchema, repositoryRuleNonFastForwardSchema, repositoryRuleCommitMessagePatternSchema, repositoryRuleCommitAuthorEmailPatternSchema, repositoryRuleCommitterEmailPatternSchema, repositoryRuleBranchNamePatternSchema, repositoryRuleTagNamePatternSchema, repositoryRuleFilePathRestrictionSchema, repositoryRuleMaxFilePathLengthSchema, repositoryRuleFileExtensionRestrictionSchema, repositoryRuleMaxFileSizeSchema, repositoryRuleWorkflowsSchema, repositoryRuleCodeScanningSchema, repositoryRuleCopilotCodeReviewSchema]).describe("A repository rule.")

/**
 * @description A set of rules to apply when specified conditions are met.
 */
export const repositoryRulesetSchema = z.object({
    "id": z.int().describe("The ID of the ruleset"),
"name": z.string().describe("The name of the ruleset"),
"target": z.optional(z.enum(["branch", "tag", "push", "repository"]).describe("The target of the ruleset")),
"source_type": z.optional(z.enum(["Repository", "Organization", "Enterprise"]).describe("The type of the source of the ruleset")),
"source": z.string().describe("The name of the source"),
get "enforcement"(){
                return repositoryRuleEnforcementSchema.describe("The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).")
              },
get "bypass_actors"(){
                return z.array(repositoryRulesetBypassActorSchema.describe("An actor that can bypass rules in a ruleset")).describe("The actors that can bypass the rules in this ruleset").optional()
              },
"current_user_can_bypass": z.optional(z.enum(["always", "pull_requests_only", "never", "exempt"]).describe("The bypass type of the user making the API request for this ruleset. This field is only returned when\nquerying the repository-level endpoint.")),
"node_id": z.optional(z.string()),
"_links": z.optional(z.object({
    "self": z.optional(z.object({
    "href": z.optional(z.string().describe("The URL of the ruleset"))
    })),
"html": z.object({
    "href": z.optional(z.string().describe("The html URL of the ruleset"))
    }).nullish()
    })),
get "conditions"(){
                return z.union([repositoryRulesetConditionsSchema, orgRulesetConditionsSchema]).nullish()
              },
get "rules"(){
                return z.array(repositoryRuleSchema.describe("A repository rule.")).optional()
              },
"created_at": z.optional(z.iso.datetime({ offset: true })),
"updated_at": z.optional(z.iso.datetime({ offset: true }))
    }).describe("A set of rules to apply when specified conditions are met.")

/**
 * @description A repository rule.
 */
export const orgRulesSchema = z.union([repositoryRuleCreationSchema, repositoryRuleUpdateSchema, repositoryRuleDeletionSchema, repositoryRuleRequiredLinearHistorySchema, repositoryRuleRequiredDeploymentsSchema, repositoryRuleRequiredSignaturesSchema, repositoryRulePullRequestSchema, repositoryRuleRequiredStatusChecksSchema, repositoryRuleNonFastForwardSchema, repositoryRuleCommitMessagePatternSchema, repositoryRuleCommitAuthorEmailPatternSchema, repositoryRuleCommitterEmailPatternSchema, repositoryRuleBranchNamePatternSchema, repositoryRuleTagNamePatternSchema, repositoryRuleFilePathRestrictionSchema, repositoryRuleMaxFilePathLengthSchema, repositoryRuleFileExtensionRestrictionSchema, repositoryRuleMaxFileSizeSchema, repositoryRuleWorkflowsSchema, repositoryRuleCodeScanningSchema]).describe("A repository rule.")

/**
 * @description Response
 */
export const ruleSuitesSchema = z.array(z.object({
    "id": z.optional(z.int().describe("The unique identifier of the rule insight.")),
"actor_id": z.optional(z.int().describe("The number that identifies the user.")),
"actor_name": z.optional(z.string().describe("The handle for the GitHub user account.")),
"before_sha": z.optional(z.string().describe("The first commit sha before the push evaluation.")),
"after_sha": z.optional(z.string().describe("The last commit sha in the push evaluation.")),
"ref": z.optional(z.string().describe("The ref name that the evaluation ran on.")),
"repository_id": z.optional(z.int().describe("The ID of the repository associated with the rule evaluation.")),
"repository_name": z.optional(z.string().describe("The name of the repository without the `.git` extension.")),
"pushed_at": z.optional(z.iso.datetime({ offset: true })),
"result": z.optional(z.enum(["pass", "fail", "bypass"]).describe("The result of the rule evaluations for rules with the `active` enforcement status.")),
"evaluation_result": z.optional(z.enum(["pass", "fail", "bypass"]).describe("The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`."))
    })).describe("Response")

/**
 * @description Response
 */
export const ruleSuiteSchema = z.object({
    "id": z.optional(z.int().describe("The unique identifier of the rule insight.")),
"actor_id": z.int().describe("The number that identifies the user.").nullish(),
"actor_name": z.string().describe("The handle for the GitHub user account.").nullish(),
"before_sha": z.optional(z.string().describe("The previous commit SHA of the ref.")),
"after_sha": z.optional(z.string().describe("The new commit SHA of the ref.")),
"ref": z.optional(z.string().describe("The ref name that the evaluation ran on.")),
"repository_id": z.optional(z.int().describe("The ID of the repository associated with the rule evaluation.")),
"repository_name": z.optional(z.string().describe("The name of the repository without the `.git` extension.")),
"pushed_at": z.optional(z.iso.datetime({ offset: true })),
"result": z.optional(z.enum(["pass", "fail", "bypass"]).describe("The result of the rule evaluations for rules with the `active` enforcement status.")),
"evaluation_result": z.enum(["pass", "fail", "bypass"]).describe("The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`. Null if no rules with `evaluate` enforcement status were run.").nullish(),
"rule_evaluations": z.optional(z.array(z.object({
    "rule_source": z.optional(z.object({
    "type": z.optional(z.string().describe("The type of rule source.")),
"id": z.int().describe("The ID of the rule source.").nullish(),
"name": z.string().describe("The name of the rule source.").nullish()
    })),
"enforcement": z.optional(z.enum(["active", "evaluate", "deleted ruleset"]).describe("The enforcement level of this rule source.")),
"result": z.optional(z.enum(["pass", "fail"]).describe("The result of the evaluation of the individual rule.")),
"rule_type": z.optional(z.string().describe("The type of rule.")),
"details": z.string().describe("The detailed failure message for the rule. Null if the rule passed.").nullish()
    })).describe("Details on the evaluated rules."))
    }).describe("Response")

/**
 * @description The historical version of a ruleset
 */
export const rulesetVersionSchema = z.object({
    "version_id": z.int().describe("The ID of the previous version of the ruleset"),
"actor": z.object({
    "id": z.optional(z.int()),
"type": z.optional(z.string())
    }).describe("The actor who updated the ruleset"),
"updated_at": z.iso.datetime({ offset: true })
    }).describe("The historical version of a ruleset")

export const rulesetVersionWithStateSchema = rulesetVersionSchema.and(z.object({
    "state": z.object({
    
    }).describe("The state of the ruleset version")
    }))

/**
 * @description The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const nullableAlertUpdatedAtSchema = z.iso.datetime({ offset: true }).describe("The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullable()

/**
 * @description Sets the state of the secret scanning alert. You must provide `resolution` when you set the state to `resolved`.
 */
export const secretScanningAlertStateSchema = z.enum(["open", "resolved"]).describe("Sets the state of the secret scanning alert. You must provide `resolution` when you set the state to `resolved`.")

/**
 * @description **Required when the `state` is `resolved`.** The reason for resolving the alert.
 */
export const secretScanningAlertResolutionSchema = z.enum(["false_positive", "wont_fix", "revoked", "used_in_tests"]).describe("**Required when the `state` is `resolved`.** The reason for resolving the alert.").nullable()

/**
 * @description Represents a \'commit\' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository.
 */
export const secretScanningLocationCommitSchema = z.object({
    "path": z.string().describe("The file path in the repository"),
"start_line": z.number().describe("Line number at which the secret starts in the file"),
"end_line": z.number().describe("Line number at which the secret ends in the file"),
"start_column": z.number().describe("The column at which the secret starts within the start line when the file is interpreted as 8BIT ASCII"),
"end_column": z.number().describe("The column at which the secret ends within the end line when the file is interpreted as 8BIT ASCII"),
"blob_sha": z.string().describe("SHA-1 hash ID of the associated blob"),
"blob_url": z.string().describe("The API URL to get the associated blob resource"),
"commit_sha": z.string().describe("SHA-1 hash ID of the associated commit"),
"commit_url": z.string().describe("The API URL to get the associated commit resource")
    }).describe("Represents a 'commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository.")

/**
 * @description Represents a \'wiki_commit\' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository wiki.
 */
export const secretScanningLocationWikiCommitSchema = z.object({
    "path": z.string().describe("The file path of the wiki page"),
"start_line": z.number().describe("Line number at which the secret starts in the file"),
"end_line": z.number().describe("Line number at which the secret ends in the file"),
"start_column": z.number().describe("The column at which the secret starts within the start line when the file is interpreted as 8-bit ASCII."),
"end_column": z.number().describe("The column at which the secret ends within the end line when the file is interpreted as 8-bit ASCII."),
"blob_sha": z.string().describe("SHA-1 hash ID of the associated blob"),
"page_url": z.string().describe("The GitHub URL to get the associated wiki page"),
"commit_sha": z.string().describe("SHA-1 hash ID of the associated commit"),
"commit_url": z.string().describe("The GitHub URL to get the associated wiki commit")
    }).describe("Represents a 'wiki_commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository wiki.")

/**
 * @description Represents an \'issue_title\' secret scanning location type. This location type shows that a secret was detected in the title of an issue.
 */
export const secretScanningLocationIssueTitleSchema = z.object({
    "issue_title_url": z.url().describe("The API URL to get the issue where the secret was detected.")
    }).describe("Represents an 'issue_title' secret scanning location type. This location type shows that a secret was detected in the title of an issue.")

/**
 * @description Represents an \'issue_body\' secret scanning location type. This location type shows that a secret was detected in the body of an issue.
 */
export const secretScanningLocationIssueBodySchema = z.object({
    "issue_body_url": z.url().describe("The API URL to get the issue where the secret was detected.")
    }).describe("Represents an 'issue_body' secret scanning location type. This location type shows that a secret was detected in the body of an issue.")

/**
 * @description Represents an \'issue_comment\' secret scanning location type. This location type shows that a secret was detected in a comment on an issue.
 */
export const secretScanningLocationIssueCommentSchema = z.object({
    "issue_comment_url": z.url().describe("The API URL to get the issue comment where the secret was detected.")
    }).describe("Represents an 'issue_comment' secret scanning location type. This location type shows that a secret was detected in a comment on an issue.")

/**
 * @description Represents a \'discussion_title\' secret scanning location type. This location type shows that a secret was detected in the title of a discussion.
 */
export const secretScanningLocationDiscussionTitleSchema = z.object({
    "discussion_title_url": z.url().describe("The URL to the discussion where the secret was detected.")
    }).describe("Represents a 'discussion_title' secret scanning location type. This location type shows that a secret was detected in the title of a discussion.")

/**
 * @description Represents a \'discussion_body\' secret scanning location type. This location type shows that a secret was detected in the body of a discussion.
 */
export const secretScanningLocationDiscussionBodySchema = z.object({
    "discussion_body_url": z.url().describe("The URL to the discussion where the secret was detected.")
    }).describe("Represents a 'discussion_body' secret scanning location type. This location type shows that a secret was detected in the body of a discussion.")

/**
 * @description Represents a \'discussion_comment\' secret scanning location type. This location type shows that a secret was detected in a comment on a discussion.
 */
export const secretScanningLocationDiscussionCommentSchema = z.object({
    "discussion_comment_url": z.url().describe("The API URL to get the discussion comment where the secret was detected.")
    }).describe("Represents a 'discussion_comment' secret scanning location type. This location type shows that a secret was detected in a comment on a discussion.")

/**
 * @description Represents a \'pull_request_title\' secret scanning location type. This location type shows that a secret was detected in the title of a pull request.
 */
export const secretScanningLocationPullRequestTitleSchema = z.object({
    "pull_request_title_url": z.url().describe("The API URL to get the pull request where the secret was detected.")
    }).describe("Represents a 'pull_request_title' secret scanning location type. This location type shows that a secret was detected in the title of a pull request.")

/**
 * @description Represents a \'pull_request_body\' secret scanning location type. This location type shows that a secret was detected in the body of a pull request.
 */
export const secretScanningLocationPullRequestBodySchema = z.object({
    "pull_request_body_url": z.url().describe("The API URL to get the pull request where the secret was detected.")
    }).describe("Represents a 'pull_request_body' secret scanning location type. This location type shows that a secret was detected in the body of a pull request.")

/**
 * @description Represents a \'pull_request_comment\' secret scanning location type. This location type shows that a secret was detected in a comment on a pull request.
 */
export const secretScanningLocationPullRequestCommentSchema = z.object({
    "pull_request_comment_url": z.url().describe("The API URL to get the pull request comment where the secret was detected.")
    }).describe("Represents a 'pull_request_comment' secret scanning location type. This location type shows that a secret was detected in a comment on a pull request.")

/**
 * @description Represents a \'pull_request_review\' secret scanning location type. This location type shows that a secret was detected in a review on a pull request.
 */
export const secretScanningLocationPullRequestReviewSchema = z.object({
    "pull_request_review_url": z.url().describe("The API URL to get the pull request review where the secret was detected.")
    }).describe("Represents a 'pull_request_review' secret scanning location type. This location type shows that a secret was detected in a review on a pull request.")

/**
 * @description Represents a \'pull_request_review_comment\' secret scanning location type. This location type shows that a secret was detected in a review comment on a pull request.
 */
export const secretScanningLocationPullRequestReviewCommentSchema = z.object({
    "pull_request_review_comment_url": z.url().describe("The API URL to get the pull request review comment where the secret was detected.")
    }).describe("Represents a 'pull_request_review_comment' secret scanning location type. This location type shows that a secret was detected in a review comment on a pull request.")

/**
 * @description Details on the location where the token was initially detected. This can be a commit, wiki commit, issue, discussion, pull request.\n
 */
export const nullableSecretScanningFirstDetectedLocationSchema = z.union([secretScanningLocationCommitSchema, secretScanningLocationWikiCommitSchema, secretScanningLocationIssueTitleSchema, secretScanningLocationIssueBodySchema, secretScanningLocationIssueCommentSchema, secretScanningLocationDiscussionTitleSchema, secretScanningLocationDiscussionBodySchema, secretScanningLocationDiscussionCommentSchema, secretScanningLocationPullRequestTitleSchema, secretScanningLocationPullRequestBodySchema, secretScanningLocationPullRequestCommentSchema, secretScanningLocationPullRequestReviewSchema, secretScanningLocationPullRequestReviewCommentSchema]).describe("Details on the location where the token was initially detected. This can be a commit, wiki commit, issue, discussion, pull request.\n").nullable()

export const organizationSecretScanningAlertSchema = z.object({
    get "number"(){
                return alertNumberSchema.describe("The security alert number.").optional()
              },
get "created_at"(){
                return alertCreatedAtSchema.describe("The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").optional()
              },
get "updated_at"(){
                return nullableAlertUpdatedAtSchema.describe("The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").optional()
              },
get "url"(){
                return alertUrlSchema.describe("The REST API URL of the alert resource.").optional()
              },
get "html_url"(){
                return alertHtmlUrlSchema.describe("The GitHub URL of the alert resource.").optional()
              },
"locations_url": z.optional(z.url().describe("The REST API URL of the code locations for this alert.")),
get "state"(){
                return secretScanningAlertStateSchema.describe("Sets the state of the secret scanning alert. You must provide `resolution` when you set the state to `resolved`.").optional()
              },
get "resolution"(){
                return secretScanningAlertResolutionSchema.describe("**Required when the `state` is `resolved`.** The reason for resolving the alert.").optional()
              },
"resolved_at": z.iso.datetime({ offset: true }).describe("The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullish(),
get "resolved_by"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
"secret_type": z.optional(z.string().describe("The type of secret that secret scanning detected.")),
"secret_type_display_name": z.optional(z.string().describe("User-friendly name for the detected secret, matching the `secret_type`.\nFor a list of built-in patterns, see \"[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets).\"")),
"secret": z.optional(z.string().describe("The secret that was detected.")),
get "repository"(){
                return simpleRepositorySchema.describe("A GitHub repository.").optional()
              },
"push_protection_bypassed": z.boolean().describe("Whether push protection was bypassed for the detected secret.").nullish(),
get "push_protection_bypassed_by"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
"push_protection_bypassed_at": z.iso.datetime({ offset: true }).describe("The time that push protection was bypassed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullish(),
get "push_protection_bypass_request_reviewer"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
"push_protection_bypass_request_reviewer_comment": z.string().describe("An optional comment when reviewing a push protection bypass.").nullish(),
"push_protection_bypass_request_comment": z.string().describe("An optional comment when requesting a push protection bypass.").nullish(),
"push_protection_bypass_request_html_url": z.url().describe("The URL to a push protection bypass request.").nullish(),
"resolution_comment": z.string().describe("The comment that was optionally added when this alert was closed").nullish(),
"validity": z.optional(z.enum(["active", "inactive", "unknown"]).describe("The token status as of the latest validity check.")),
"publicly_leaked": z.boolean().describe("Whether the secret was publicly leaked.").nullish(),
"multi_repo": z.boolean().describe("Whether the detected secret was found in multiple repositories in the same organization or enterprise.").nullish(),
"is_base64_encoded": z.boolean().describe("A boolean value representing whether or not alert is base64 encoded").nullish(),
get "first_location_detected"(){
                return nullableSecretScanningFirstDetectedLocationSchema.describe("Details on the location where the token was initially detected. This can be a commit, wiki commit, issue, discussion, pull request.\n").optional()
              },
"has_more_locations": z.optional(z.boolean().describe("A boolean value representing whether or not the token in the alert was detected in more than one location.")),
get "assigned_to"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              }
    })

/**
 * @description The version of the entity. This is used to confirm you\'re updating the current version of the entity and mitigate unintentionally overriding someone else\'s update.
 */
export const secretScanningRowVersionSchema = z.string().describe("The version of the entity. This is used to confirm you're updating the current version of the entity and mitigate unintentionally overriding someone else's update.").nullable()

export const secretScanningPatternOverrideSchema = z.object({
    "token_type": z.optional(z.string().describe("The ID of the pattern.")),
"custom_pattern_version": z.string().describe("The version of this pattern if it's a custom pattern.").nullish(),
"slug": z.optional(z.string().describe("The slug of the pattern.")),
"display_name": z.optional(z.string().describe("The user-friendly name for the pattern.")),
"alert_total": z.optional(z.int().describe("The total number of alerts generated by this pattern.")),
"alert_total_percentage": z.optional(z.int().describe("The percentage of all alerts that this pattern represents, rounded to the nearest integer.")),
"false_positives": z.optional(z.int().describe("The number of false positive alerts generated by this pattern.")),
"false_positive_rate": z.optional(z.int().describe("The percentage of alerts from this pattern that are false positives, rounded to the nearest integer.")),
"bypass_rate": z.optional(z.int().describe("The percentage of blocks for this pattern that were bypassed, rounded to the nearest integer.")),
"default_setting": z.optional(z.enum(["disabled", "enabled"]).describe("The default push protection setting for this pattern.")),
"enterprise_setting": z.enum(["not-set", "disabled", "enabled"]).describe("The push protection setting for this pattern set at the enterprise level. Only present for partner patterns when the organization has a parent enterprise.").nullish(),
"setting": z.optional(z.enum(["not-set", "disabled", "enabled"]).describe("The current push protection setting for this pattern. If this is `not-set`, then it inherits either the enterprise setting if it exists or the default setting."))
    })

/**
 * @description A collection of secret scanning patterns and their settings related to push protection.
 */
export const secretScanningPatternConfigurationSchema = z.object({
    get "pattern_config_version"(){
                return secretScanningRowVersionSchema.describe("The version of the entity. This is used to confirm you're updating the current version of the entity and mitigate unintentionally overriding someone else's update.").optional()
              },
get "provider_pattern_overrides"(){
                return z.array(secretScanningPatternOverrideSchema).describe("Overrides for partner patterns.").optional()
              },
get "custom_pattern_overrides"(){
                return z.array(secretScanningPatternOverrideSchema).describe("Overrides for custom patterns defined by the organization.").optional()
              }
    }).describe("A collection of secret scanning patterns and their settings related to push protection.")

/**
 * @description A product affected by the vulnerability detailed in a repository security advisory.
 */
export const repositoryAdvisoryVulnerabilitySchema = z.object({
    "package": z.nullable(z.object({
    get "ecosystem"(){
                return securityAdvisoryEcosystemsSchema.describe("The package's language or package management ecosystem.")
              },
"name": z.nullable(z.string().describe("The unique package name within its ecosystem."))
    }).describe("The name of the package affected by the vulnerability.")),
"vulnerable_version_range": z.nullable(z.string().describe("The range of the package versions affected by the vulnerability.")),
"patched_versions": z.nullable(z.string().describe("The package version(s) that resolve the vulnerability.")),
"vulnerable_functions": z.nullable(z.array(z.string()).describe("The functions in the package that are affected."))
    }).describe("A product affected by the vulnerability detailed in a repository security advisory.")

/**
 * @description A credit given to a user for a repository security advisory.
 */
export const repositoryAdvisoryCreditSchema = z.object({
    get "user"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "type"(){
                return securityAdvisoryCreditTypesSchema.describe("The type of credit the user is receiving.")
              },
"state": z.enum(["accepted", "declined", "pending"]).describe("The state of the user's acceptance of the credit.")
    }).describe("A credit given to a user for a repository security advisory.")

/**
 * @description A repository security advisory.
 */
export const repositoryAdvisorySchema = z.object({
    "ghsa_id": z.string().describe("The GitHub Security Advisory ID."),
"cve_id": z.nullable(z.string().describe("The Common Vulnerabilities and Exposures (CVE) ID.")),
"url": z.url().describe("The API URL for the advisory."),
"html_url": z.url().describe("The URL for the advisory."),
"summary": z.string().max(1024).describe("A short summary of the advisory."),
"description": z.nullable(z.string().max(65535).describe("A detailed description of what the advisory entails.")),
"severity": z.nullable(z.enum(["critical", "high", "medium", "low"]).describe("The severity of the advisory.")),
get "author"(){
               return simpleUserSchema.describe("The author of the advisory.").nullable()
              },
get "publisher"(){
               return simpleUserSchema.describe("The publisher of the advisory.").nullable()
              },
"identifiers": z.array(z.object({
    "type": z.enum(["CVE", "GHSA"]).describe("The type of identifier."),
"value": z.string().describe("The identifier value.")
    })),
"state": z.enum(["published", "closed", "withdrawn", "draft", "triage"]).describe("The state of the advisory."),
"created_at": z.nullable(z.iso.datetime({ offset: true }).describe("The date and time of when the advisory was created, in ISO 8601 format.")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }).describe("The date and time of when the advisory was last updated, in ISO 8601 format.")),
"published_at": z.nullable(z.iso.datetime({ offset: true }).describe("The date and time of when the advisory was published, in ISO 8601 format.")),
"closed_at": z.nullable(z.iso.datetime({ offset: true }).describe("The date and time of when the advisory was closed, in ISO 8601 format.")),
"withdrawn_at": z.nullable(z.iso.datetime({ offset: true }).describe("The date and time of when the advisory was withdrawn, in ISO 8601 format.")),
"submission": z.nullable(z.object({
    "accepted": z.boolean().describe("Whether a private vulnerability report was accepted by the repository's administrators.")
    })),
get "vulnerabilities"(){
               return z.array(repositoryAdvisoryVulnerabilitySchema.describe("A product affected by the vulnerability detailed in a repository security advisory.")).nullable()
              },
"cvss": z.nullable(z.object({
    "vector_string": z.nullable(z.string().describe("The CVSS vector.")),
"score": z.nullable(z.number().min(0).max(10).describe("The CVSS score."))
    })),
get "cvss_severities"(){
                return cvssSeveritiesSchema.optional()
              },
"cwes": z.nullable(z.array(z.object({
    "cwe_id": z.string().describe("The Common Weakness Enumeration (CWE) identifier."),
"name": z.string().describe("The name of the CWE.")
    }))),
"cwe_ids": z.nullable(z.array(z.string()).describe("A list of only the CWE IDs.")),
"credits": z.nullable(z.array(z.object({
    "login": z.optional(z.string().describe("The username of the user credited.")),
get "type"(){
                return securityAdvisoryCreditTypesSchema.describe("The type of credit the user is receiving.").optional()
              }
    }))),
get "credits_detailed"(){
               return z.array(repositoryAdvisoryCreditSchema.describe("A credit given to a user for a repository security advisory.")).nullable()
              },
get "collaborating_users"(){
               return z.array(simpleUserSchema.describe("A GitHub user.")).describe("A list of users that collaborate on the advisory.").nullable()
              },
get "collaborating_teams"(){
               return z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories.")).describe("A list of teams that collaborate on the advisory.").nullable()
              },
get "private_fork"(){
               return simpleRepositorySchema.describe("A temporary private fork of the advisory's repository for collaborating on a fix.").nullable()
              }
    }).describe("A repository security advisory.")

export const actionsBillingUsageSchema = z.object({
    "total_minutes_used": z.int().describe("The sum of the free and paid GitHub Actions minutes used."),
"total_paid_minutes_used": z.int().describe("The total paid GitHub Actions minutes used."),
"included_minutes": z.int().describe("The amount of free GitHub Actions minutes available."),
"minutes_used_breakdown": z.object({
    "UBUNTU": z.optional(z.int().describe("Total minutes used on Ubuntu runner machines.")),
"MACOS": z.optional(z.int().describe("Total minutes used on macOS runner machines.")),
"WINDOWS": z.optional(z.int().describe("Total minutes used on Windows runner machines.")),
"ubuntu_4_core": z.optional(z.int().describe("Total minutes used on Ubuntu 4 core runner machines.")),
"ubuntu_8_core": z.optional(z.int().describe("Total minutes used on Ubuntu 8 core runner machines.")),
"ubuntu_16_core": z.optional(z.int().describe("Total minutes used on Ubuntu 16 core runner machines.")),
"ubuntu_32_core": z.optional(z.int().describe("Total minutes used on Ubuntu 32 core runner machines.")),
"ubuntu_64_core": z.optional(z.int().describe("Total minutes used on Ubuntu 64 core runner machines.")),
"windows_4_core": z.optional(z.int().describe("Total minutes used on Windows 4 core runner machines.")),
"windows_8_core": z.optional(z.int().describe("Total minutes used on Windows 8 core runner machines.")),
"windows_16_core": z.optional(z.int().describe("Total minutes used on Windows 16 core runner machines.")),
"windows_32_core": z.optional(z.int().describe("Total minutes used on Windows 32 core runner machines.")),
"windows_64_core": z.optional(z.int().describe("Total minutes used on Windows 64 core runner machines.")),
"macos_12_core": z.optional(z.int().describe("Total minutes used on macOS 12 core runner machines.")),
"total": z.optional(z.int().describe("Total minutes used on all runner machines."))
    })
    })

export const packagesBillingUsageSchema = z.object({
    "total_gigabytes_bandwidth_used": z.int().describe("Sum of the free and paid storage space (GB) for GitHuub Packages."),
"total_paid_gigabytes_bandwidth_used": z.int().describe("Total paid storage space (GB) for GitHuub Packages."),
"included_gigabytes_bandwidth": z.int().describe("Free storage space (GB) for GitHub Packages.")
    })

export const combinedBillingUsageSchema = z.object({
    "days_left_in_billing_cycle": z.int().describe("Numbers of days left in billing cycle."),
"estimated_paid_storage_for_month": z.int().describe("Estimated storage space (GB) used in billing cycle."),
"estimated_storage_for_month": z.int().describe("Estimated sum of free and paid storage space (GB) used in billing cycle.")
    })

/**
 * @description Check immutable releases settings for an organization.
 */
export const immutableReleasesOrganizationSettingsSchema = z.object({
    "enforced_repositories": z.enum(["all", "none", "selected"]).describe("The policy that controls how immutable releases are enforced in the organization."),
"selected_repositories_url": z.optional(z.string().describe("The API URL to use to get or set the selected repositories for immutable releases enforcement, when `enforced_repositories` is set to `selected`."))
    }).describe("Check immutable releases settings for an organization.")

/**
 * @description A hosted compute network configuration.
 */
export const networkConfigurationSchema = z.object({
    "id": z.string().describe("The unique identifier of the network configuration."),
"name": z.string().describe("The name of the network configuration."),
"compute_service": z.optional(z.enum(["none", "actions", "codespaces"]).describe("The hosted compute service the network configuration supports.")),
"network_settings_ids": z.optional(z.array(z.string()).describe("The unique identifier of each network settings in the configuration.")),
"created_on": z.nullable(z.iso.datetime({ offset: true }).describe("The time at which the network configuration was created, in ISO 8601 format."))
    }).describe("A hosted compute network configuration.")

/**
 * @description A hosted compute network settings resource.
 */
export const networkSettingsSchema = z.object({
    "id": z.string().describe("The unique identifier of the network settings resource."),
"network_configuration_id": z.optional(z.string().describe("The identifier of the network configuration that is using this settings resource.")),
"name": z.string().describe("The name of the network settings resource."),
"subnet_id": z.string().describe("The subnet this network settings resource is configured for."),
"region": z.string().describe("The location of the subnet this network settings resource is configured for.")
    }).describe("A hosted compute network settings resource.")

/**
 * @description Team Organization
 */
export const teamOrganizationSchema = z.object({
    "login": z.string(),
"id": z.int(),
"node_id": z.string(),
"url": z.url(),
"repos_url": z.url(),
"events_url": z.url(),
"hooks_url": z.string(),
"issues_url": z.string(),
"members_url": z.string(),
"public_members_url": z.string(),
"avatar_url": z.string(),
"description": z.nullable(z.string()),
"name": z.optional(z.string()),
"company": z.optional(z.string()),
"blog": z.optional(z.url()),
"location": z.optional(z.string()),
"email": z.optional(z.email()),
"twitter_username": z.string().nullish(),
"is_verified": z.optional(z.boolean()),
"has_organization_projects": z.boolean(),
"has_repository_projects": z.boolean(),
"public_repos": z.int(),
"public_gists": z.int(),
"followers": z.int(),
"following": z.int(),
"html_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"type": z.string(),
"total_private_repos": z.optional(z.int()),
"owned_private_repos": z.optional(z.int()),
"private_gists": z.int().nullish(),
"disk_usage": z.int().nullish(),
"collaborators": z.int().nullish(),
"billing_email": z.email().nullish(),
"plan": z.optional(z.object({
    "name": z.string(),
"space": z.int(),
"private_repos": z.int(),
"filled_seats": z.optional(z.int()),
"seats": z.optional(z.int())
    })),
"default_repository_permission": z.string().nullish(),
"members_can_create_repositories": z.boolean().nullish(),
"two_factor_requirement_enabled": z.boolean().nullish(),
"members_allowed_repository_creation_type": z.optional(z.string()),
"members_can_create_public_repositories": z.optional(z.boolean()),
"members_can_create_private_repositories": z.optional(z.boolean()),
"members_can_create_internal_repositories": z.optional(z.boolean()),
"members_can_create_pages": z.optional(z.boolean()),
"members_can_create_public_pages": z.optional(z.boolean()),
"members_can_create_private_pages": z.optional(z.boolean()),
"members_can_fork_private_repositories": z.boolean().nullish(),
"web_commit_signoff_required": z.optional(z.boolean()),
"updated_at": z.iso.datetime({ offset: true }),
"archived_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("Team Organization")

/**
 * @description The [distinguished name](https://www.ldap.com/ldap-dns-and-rdns) (DN) of the LDAP entry to map to a team.
 */
export const ldapDnSchema = z.string().describe("The [distinguished name](https://www.ldap.com/ldap-dns-and-rdns) (DN) of the LDAP entry to map to a team.")

/**
 * @description Groups of organization members that gives permissions on specified repositories.
 */
export const teamFullSchema = z.object({
    "id": z.int().describe("Unique identifier of the team"),
"node_id": z.string(),
"url": z.url().describe("URL for the team"),
"html_url": z.url(),
"name": z.string().describe("Name of the team"),
"slug": z.string(),
"description": z.nullable(z.string()),
"privacy": z.optional(z.enum(["closed", "secret"]).describe("The level of privacy this team should have")),
"notification_setting": z.optional(z.enum(["notifications_enabled", "notifications_disabled"]).describe("The notification setting the team has set")),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"members_url": z.string(),
"repositories_url": z.url(),
get "parent"(){
                return nullableTeamSimpleSchema.describe("Groups of organization members that gives permissions on specified repositories.").optional()
              },
"members_count": z.int(),
"repos_count": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
get "organization"(){
                return teamOrganizationSchema.describe("Team Organization")
              },
get "ldap_dn"(){
                return ldapDnSchema.describe("The [distinguished name](https://www.ldap.com/ldap-dns-and-rdns) (DN) of the LDAP entry to map to a team.").optional()
              },
"type": z.enum(["enterprise", "organization"]).describe("The ownership type of the team"),
"organization_id": z.optional(z.int().describe("Unique identifier of the organization to which this team belongs")),
"enterprise_id": z.optional(z.int().describe("Unique identifier of the enterprise to which this team belongs"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")

/**
 * @description A team discussion is a persistent record of a free-form conversation within a team.
 */
export const teamDiscussionSchema = z.object({
    get "author"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"body": z.string().describe("The main text of the discussion."),
"body_html": z.string(),
"body_version": z.string().describe("The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server."),
"comments_count": z.int(),
"comments_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"last_edited_at": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The unique sequence number of a team discussion."),
"pinned": z.boolean().describe("Whether or not this discussion should be pinned for easy retrieval."),
"private": z.boolean().describe("Whether or not this discussion should be restricted to team members and organization owners."),
"team_url": z.url(),
"title": z.string().describe("The title of the discussion."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
get "reactions"(){
                return reactionRollupSchema.optional()
              }
    }).describe("A team discussion is a persistent record of a free-form conversation within a team.")

/**
 * @description A reply to a discussion within a team.
 */
export const teamDiscussionCommentSchema = z.object({
    get "author"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"body": z.string().describe("The main text of the comment."),
"body_html": z.string(),
"body_version": z.string().describe("The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server."),
"created_at": z.iso.datetime({ offset: true }),
"last_edited_at": z.nullable(z.iso.datetime({ offset: true })),
"discussion_url": z.url(),
"html_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The unique sequence number of a team discussion comment."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
get "reactions"(){
                return reactionRollupSchema.optional()
              }
    }).describe("A reply to a discussion within a team.")

/**
 * @description Reactions to conversations provide a way to help people express their feelings more simply and effectively.
 */
export const reactionSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"content": z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("The reaction to use"),
"created_at": z.iso.datetime({ offset: true })
    }).describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

/**
 * @description Team Membership
 */
export const teamMembershipSchema = z.object({
    "url": z.url(),
"role": z.enum(["member", "maintainer"]).default("member").describe("The role of the user in the team."),
"state": z.enum(["active", "pending"]).describe("The state of the user's membership in the team.")
    }).describe("Team Membership")

/**
 * @description A team\'s access to a project.
 */
export const teamProjectSchema = z.object({
    "owner_url": z.string(),
"url": z.string(),
"html_url": z.string(),
"columns_url": z.string(),
"id": z.int(),
"node_id": z.string(),
"name": z.string(),
"body": z.nullable(z.string()),
"number": z.int(),
"state": z.string(),
get "creator"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"created_at": z.string(),
"updated_at": z.string(),
"organization_permission": z.optional(z.string().describe("The organization permission for this project. Only present when owner is an organization.")),
"private": z.optional(z.boolean().describe("Whether the project is private or not. Only present when owner is an organization.")),
"permissions": z.object({
    "read": z.boolean(),
"write": z.boolean(),
"admin": z.boolean()
    })
    }).describe("A team's access to a project.")

/**
 * @description A team\'s access to a repository.
 */
export const teamRepositorySchema = z.object({
    "id": z.int().describe("Unique identifier of the repository"),
"node_id": z.string(),
"name": z.string().describe("The name of the repository."),
"full_name": z.string(),
get "license"(){
               return nullableLicenseSimpleSchema.describe("License Simple").nullable()
              },
"forks": z.int(),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"pull": z.boolean(),
"triage": z.optional(z.boolean()),
"push": z.boolean(),
"maintain": z.optional(z.boolean())
    })),
"role_name": z.optional(z.string()),
get "owner"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"private": z.boolean().default(false).describe("Whether the repository is private or public."),
"html_url": z.url(),
"description": z.nullable(z.string()),
"fork": z.boolean(),
"url": z.url(),
"archive_url": z.string(),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"deployments_url": z.url(),
"downloads_url": z.url(),
"events_url": z.url(),
"forks_url": z.url(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.string(),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"languages_url": z.url(),
"merges_url": z.url(),
"milestones_url": z.string(),
"notifications_url": z.string(),
"pulls_url": z.string(),
"releases_url": z.string(),
"ssh_url": z.string(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"trees_url": z.string(),
"clone_url": z.string(),
"mirror_url": z.nullable(z.url()),
"hooks_url": z.url(),
"svn_url": z.url(),
"homepage": z.nullable(z.url()),
"language": z.nullable(z.string()),
"forks_count": z.int(),
"stargazers_count": z.int(),
"watchers_count": z.int(),
"size": z.int(),
"default_branch": z.string().describe("The default branch of the repository."),
"open_issues_count": z.int(),
"is_template": z.optional(z.boolean().default(false).describe("Whether this repository acts as a template that can be used to generate new repositories.")),
"topics": z.optional(z.array(z.string())),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_pages": z.boolean(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"disabled": z.boolean().describe("Returns whether or not this repository disabled."),
"visibility": z.optional(z.string().default("public").describe("The repository visibility: public, private, or internal.")),
"pushed_at": z.nullable(z.iso.datetime({ offset: true })),
"created_at": z.nullable(z.iso.datetime({ offset: true })),
"updated_at": z.nullable(z.iso.datetime({ offset: true })),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"temp_clone_token": z.optional(z.string()),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow Auto-merge to be used on pull requests.")),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_forking": z.optional(z.boolean().default(false).describe("Whether to allow forking this repo")),
"web_commit_signoff_required": z.optional(z.boolean().default(false).describe("Whether to require contributors to sign off on web-based commits")),
"subscribers_count": z.optional(z.int()),
"network_count": z.optional(z.int()),
"open_issues": z.int(),
"watchers": z.int(),
"master_branch": z.optional(z.string())
    }).describe("A team's access to a repository.")

/**
 * @description Project columns contain cards of work.
 */
export const projectColumnSchema = z.object({
    "url": z.url(),
"project_url": z.url(),
"cards_url": z.url(),
"id": z.int().describe("The unique identifier of the project column"),
"node_id": z.string(),
"name": z.string().describe("Name of the project column"),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true })
    }).describe("Project columns contain cards of work.")

/**
 * @description Project Collaborator Permission
 */
export const projectCollaboratorPermissionSchema = z.object({
    "permission": z.string(),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              }
    }).describe("Project Collaborator Permission")

export const rateLimitSchema = z.object({
    "limit": z.int(),
"remaining": z.int(),
"reset": z.int(),
"used": z.int()
    })

/**
 * @description Rate Limit Overview
 */
export const rateLimitOverviewSchema = z.object({
    "resources": z.object({
    get "core"(){
                return rateLimitSchema
              },
get "graphql"(){
                return rateLimitSchema.optional()
              },
get "search"(){
                return rateLimitSchema
              },
get "code_search"(){
                return rateLimitSchema.optional()
              },
get "source_import"(){
                return rateLimitSchema.optional()
              },
get "integration_manifest"(){
                return rateLimitSchema.optional()
              },
get "code_scanning_upload"(){
                return rateLimitSchema.optional()
              },
get "actions_runner_registration"(){
                return rateLimitSchema.optional()
              },
get "scim"(){
                return rateLimitSchema.optional()
              },
get "dependency_snapshots"(){
                return rateLimitSchema.optional()
              },
get "dependency_sbom"(){
                return rateLimitSchema.optional()
              },
get "code_scanning_autofix"(){
                return rateLimitSchema.optional()
              }
    }),
get "rate"(){
                return rateLimitSchema
              }
    }).describe("Rate Limit Overview")

/**
 * @description An artifact
 */
export const artifactSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"name": z.string().describe("The name of the artifact."),
"size_in_bytes": z.int().describe("The size in bytes of the artifact."),
"url": z.string(),
"archive_download_url": z.string(),
"expired": z.boolean().describe("Whether or not the artifact has expired."),
"created_at": z.nullable(z.iso.datetime({ offset: true })),
"expires_at": z.nullable(z.iso.datetime({ offset: true })),
"updated_at": z.nullable(z.iso.datetime({ offset: true })),
"digest": z.string().describe("The SHA256 digest of the artifact. This field will only be populated on artifacts uploaded with upload-artifact v4 or newer. For older versions, this field will be null.").nullish(),
"workflow_run": z.object({
    "id": z.optional(z.int()),
"repository_id": z.optional(z.int()),
"head_repository_id": z.optional(z.int()),
"head_branch": z.optional(z.string()),
"head_sha": z.optional(z.string())
    }).nullish()
    }).describe("An artifact")

/**
 * @description Repository actions caches
 */
export const actionsCacheListSchema = z.object({
    "total_count": z.int().describe("Total number of caches"),
"actions_caches": z.array(z.object({
    "id": z.optional(z.int()),
"ref": z.optional(z.string()),
"key": z.optional(z.string()),
"version": z.optional(z.string()),
"last_accessed_at": z.optional(z.iso.datetime({ offset: true })),
"created_at": z.optional(z.iso.datetime({ offset: true })),
"size_in_bytes": z.optional(z.int())
    })).describe("Array of caches")
    }).describe("Repository actions caches")

/**
 * @description Information of a job execution in a workflow run
 */
export const jobSchema = z.object({
    "id": z.int().describe("The id of the job."),
"run_id": z.int().describe("The id of the associated workflow run."),
"run_url": z.string(),
"run_attempt": z.optional(z.int().describe("Attempt number of the associated workflow run, 1 for first attempt and higher if the workflow was re-run.")),
"node_id": z.string(),
"head_sha": z.string().describe("The SHA of the commit that is being run."),
"url": z.string(),
"html_url": z.nullable(z.string()),
"status": z.enum(["queued", "in_progress", "completed", "waiting", "requested", "pending"]).describe("The phase of the lifecycle that the job is currently in."),
"conclusion": z.nullable(z.enum(["success", "failure", "neutral", "cancelled", "skipped", "timed_out", "action_required"]).describe("The outcome of the job.")),
"created_at": z.iso.datetime({ offset: true }).describe("The time that the job created, in ISO 8601 format."),
"started_at": z.iso.datetime({ offset: true }).describe("The time that the job started, in ISO 8601 format."),
"completed_at": z.nullable(z.iso.datetime({ offset: true }).describe("The time that the job finished, in ISO 8601 format.")),
"name": z.string().describe("The name of the job."),
"steps": z.optional(z.array(z.object({
    "status": z.enum(["queued", "in_progress", "completed"]).describe("The phase of the lifecycle that the job is currently in."),
"conclusion": z.nullable(z.string().describe("The outcome of the job.")),
"name": z.string().describe("The name of the job."),
"number": z.int(),
"started_at": z.iso.datetime({ offset: true }).describe("The time that the step started, in ISO 8601 format.").nullish(),
"completed_at": z.iso.datetime({ offset: true }).describe("The time that the job finished, in ISO 8601 format.").nullish()
    })).describe("Steps in this job.")),
"check_run_url": z.string(),
"labels": z.array(z.string()).describe("Labels for the workflow job. Specified by the \"runs_on\" attribute in the action's workflow file."),
"runner_id": z.nullable(z.int().describe("The ID of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)")),
"runner_name": z.nullable(z.string().describe("The name of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)")),
"runner_group_id": z.nullable(z.int().describe("The ID of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)")),
"runner_group_name": z.nullable(z.string().describe("The name of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)")),
"workflow_name": z.nullable(z.string().describe("The name of the workflow.")),
"head_branch": z.nullable(z.string().describe("The name of the current branch."))
    }).describe("Information of a job execution in a workflow run")

/**
 * @description Actions OIDC subject customization for a repository
 */
export const oidcCustomSubRepoSchema = z.object({
    "use_default": z.boolean().describe("Whether to use the default template or not. If `true`, the `include_claim_keys` field is ignored."),
"include_claim_keys": z.optional(z.array(z.string()).describe("Array of unique strings. Each claim key can only contain alphanumeric characters and underscores."))
    }).describe("Actions OIDC subject customization for a repository")

/**
 * @description Set secrets for GitHub Actions.
 */
export const actionsSecretSchema = z.object({
    "name": z.string().describe("The name of the secret."),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true })
    }).describe("Set secrets for GitHub Actions.")

export const actionsVariableSchema = z.object({
    "name": z.string().describe("The name of the variable."),
"value": z.string().describe("The value of the variable."),
"created_at": z.iso.datetime({ offset: true }).describe("The date and time at which the variable was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."),
"updated_at": z.iso.datetime({ offset: true }).describe("The date and time at which the variable was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.")
    })

/**
 * @description Whether GitHub Actions is enabled on the repository.
 */
export const actionsEnabledSchema = z.boolean().describe("Whether GitHub Actions is enabled on the repository.")

export const actionsRepositoryPermissionsSchema = z.object({
    get "enabled"(){
                return actionsEnabledSchema.describe("Whether GitHub Actions is enabled on the repository.")
              },
get "allowed_actions"(){
                return allowedActionsSchema.describe("The permissions policy that controls the actions and reusable workflows that are allowed to run.").optional()
              },
get "selected_actions_url"(){
                return selectedActionsUrlSchema.describe("The API URL to use to get or set the actions and reusable workflows that are allowed to run, when `allowed_actions` is set to `selected`.").optional()
              },
get "sha_pinning_required"(){
                return shaPinningRequiredSchema.describe("Whether actions must be pinned to a full-length commit SHA.").optional()
              }
    })

export const actionsWorkflowAccessToRepositorySchema = z.object({
    "access_level": z.enum(["none", "user", "organization"]).describe("Defines the level of access that workflows outside of the repository have to actions and reusable workflows within the\nrepository.\n\n`none` means the access is only possible from workflows in this repository. `user` level access allows sharing across user owned private repositories only. `organization` level access allows sharing across the organization.")
    })

/**
 * @description A workflow referenced/reused by the initial caller workflow
 */
export const referencedWorkflowSchema = z.object({
    "path": z.string(),
"sha": z.string(),
"ref": z.optional(z.string())
    }).describe("A workflow referenced/reused by the initial caller workflow")

export const pullRequestMinimalSchema = z.object({
    "id": z.int(),
"number": z.int(),
"url": z.string(),
"head": z.object({
    "ref": z.string(),
"sha": z.string(),
"repo": z.object({
    "id": z.int(),
"url": z.string(),
"name": z.string()
    })
    }),
"base": z.object({
    "ref": z.string(),
"sha": z.string(),
"repo": z.object({
    "id": z.int(),
"url": z.string(),
"name": z.string()
    })
    })
    })

/**
 * @description A commit.
 */
export const nullableSimpleCommitSchema = z.object({
    "id": z.string().describe("SHA for the commit"),
"tree_id": z.string().describe("SHA for the commit's tree"),
"message": z.string().describe("Message describing the purpose of the commit"),
"timestamp": z.iso.datetime({ offset: true }).describe("Timestamp of the commit"),
"author": z.nullable(z.object({
    "name": z.string().describe("Name of the commit's author"),
"email": z.email().describe("Git email address of the commit's author")
    }).describe("Information about the Git author")),
"committer": z.nullable(z.object({
    "name": z.string().describe("Name of the commit's committer"),
"email": z.email().describe("Git email address of the commit's committer")
    }).describe("Information about the Git committer"))
    }).describe("A commit.").nullable()

/**
 * @description An invocation of a workflow
 */
export const workflowRunSchema = z.object({
    "id": z.int().describe("The ID of the workflow run."),
"name": z.string().describe("The name of the workflow run.").nullish(),
"node_id": z.string(),
"check_suite_id": z.optional(z.int().describe("The ID of the associated check suite.")),
"check_suite_node_id": z.optional(z.string().describe("The node ID of the associated check suite.")),
"head_branch": z.nullable(z.string()),
"head_sha": z.string().describe("The SHA of the head commit that points to the version of the workflow being run."),
"path": z.string().describe("The full path of the workflow"),
"run_number": z.int().describe("The auto incrementing run number for the workflow run."),
"run_attempt": z.optional(z.int().describe("Attempt number of the run, 1 for first attempt and higher if the workflow was re-run.")),
get "referenced_workflows"(){
                return z.array(referencedWorkflowSchema.describe("A workflow referenced/reused by the initial caller workflow")).nullish()
              },
"event": z.string(),
"status": z.nullable(z.string()),
"conclusion": z.nullable(z.string()),
"workflow_id": z.int().describe("The ID of the parent workflow."),
"url": z.string().describe("The URL to the workflow run."),
"html_url": z.string(),
get "pull_requests"(){
               return z.array(pullRequestMinimalSchema).describe("Pull requests that are open with a `head_sha` or `head_branch` that matches the workflow run. The returned pull requests do not necessarily indicate pull requests that triggered the run.").nullable()
              },
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
get "triggering_actor"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
"run_started_at": z.optional(z.iso.datetime({ offset: true }).describe("The start time of the latest run. Resets on re-run.")),
"jobs_url": z.string().describe("The URL to the jobs for the workflow run."),
"logs_url": z.string().describe("The URL to download the logs for the workflow run."),
"check_suite_url": z.string().describe("The URL to the associated check suite."),
"artifacts_url": z.string().describe("The URL to the artifacts for the workflow run."),
"cancel_url": z.string().describe("The URL to cancel the workflow run."),
"rerun_url": z.string().describe("The URL to rerun the workflow run."),
"previous_attempt_url": z.string().describe("The URL to the previous attempted run of this workflow, if one exists.").nullish(),
"workflow_url": z.string().describe("The URL to the workflow."),
get "head_commit"(){
               return nullableSimpleCommitSchema.describe("A commit.").nullable()
              },
get "repository"(){
                return minimalRepositorySchema.describe("Minimal Repository")
              },
get "head_repository"(){
                return minimalRepositorySchema.describe("Minimal Repository")
              },
"head_repository_id": z.optional(z.int()),
"display_title": z.string().describe("The event-specific title associated with the run or the run-name if set, or the value of `run-name` if it is set in the workflow.")
    }).describe("An invocation of a workflow")

/**
 * @description An entry in the reviews log for environment deployments
 */
export const environmentApprovalsSchema = z.object({
    "environments": z.array(z.object({
    "id": z.optional(z.int().describe("The id of the environment.")),
"node_id": z.optional(z.string()),
"name": z.optional(z.string().describe("The name of the environment.")),
"url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"created_at": z.optional(z.iso.datetime({ offset: true }).describe("The time that the environment was created, in ISO 8601 format.")),
"updated_at": z.optional(z.iso.datetime({ offset: true }).describe("The time that the environment was last updated, in ISO 8601 format."))
    })).describe("The list of environments that were approved or rejected"),
"state": z.enum(["approved", "rejected", "pending"]).describe("Whether deployment to the environment(s) was approved or rejected or pending (with comments)"),
get "user"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"comment": z.string().describe("The comment submitted with the deployment review")
    }).describe("An entry in the reviews log for environment deployments")

export const reviewCustomGatesCommentRequiredSchema = z.object({
    "environment_name": z.string().describe("The name of the environment to approve or reject."),
"comment": z.string().describe("Comment associated with the pending deployment protection rule. **Required when state is not provided.**")
    })

export const reviewCustomGatesStateRequiredSchema = z.object({
    "environment_name": z.string().describe("The name of the environment to approve or reject."),
"state": z.enum(["approved", "rejected"]).describe("Whether to approve or reject deployment to the specified environments."),
"comment": z.optional(z.string().describe("Optional comment to include with the review."))
    })

/**
 * @description The type of reviewer.
 */
export const deploymentReviewerTypeSchema = z.enum(["User", "Team"]).describe("The type of reviewer.")

/**
 * @description Details of a deployment that is waiting for protection rules to pass
 */
export const pendingDeploymentSchema = z.object({
    "environment": z.object({
    "id": z.optional(z.int().describe("The id of the environment.")),
"node_id": z.optional(z.string()),
"name": z.optional(z.string().describe("The name of the environment.")),
"url": z.optional(z.string()),
"html_url": z.optional(z.string())
    }),
"wait_timer": z.int().describe("The set duration of the wait timer"),
"wait_timer_started_at": z.nullable(z.iso.datetime({ offset: true }).describe("The time that the wait timer began.")),
"current_user_can_approve": z.boolean().describe("Whether the currently authenticated user can approve the deployment"),
"reviewers": z.array(z.object({
    get "type"(){
                return deploymentReviewerTypeSchema.describe("The type of reviewer.").optional()
              },
get "reviewer"(){
                return z.union([simpleUserSchema, teamSchema]).optional()
              }
    })).describe("The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.")
    }).describe("Details of a deployment that is waiting for protection rules to pass")

/**
 * @description A request for a specific ref(branch,sha,tag) to be deployed
 */
export const deploymentSchema = z.object({
    "url": z.url(),
"id": z.int().describe("Unique identifier of the deployment"),
"node_id": z.string(),
"sha": z.string(),
"ref": z.string().describe("The ref to deploy. This can be a branch, tag, or sha."),
"task": z.string().describe("Parameter to specify a task to execute"),
"payload": z.union([z.string(), z.object({
    
    }).catchall(z.unknown())]),
"original_environment": z.optional(z.string()),
"environment": z.string().describe("Name for the target deployment environment."),
"description": z.nullable(z.string()),
get "creator"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"statuses_url": z.url(),
"repository_url": z.url(),
"transient_environment": z.optional(z.boolean().describe("Specifies if the given environment is will no longer exist at some point in the future. Default: false.")),
"production_environment": z.optional(z.boolean().describe("Specifies if the given environment is one that end-users directly interact with. Default: false.")),
get "performed_via_github_app"(){
                return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").optional()
              }
    }).describe("A request for a specific ref(branch,sha,tag) to be deployed")

/**
 * @description Workflow Run Usage
 */
export const workflowRunUsageSchema = z.object({
    "billable": z.object({
    "UBUNTU": z.optional(z.object({
    "total_ms": z.int(),
"jobs": z.int(),
"job_runs": z.optional(z.array(z.object({
    "job_id": z.int(),
"duration_ms": z.int()
    })))
    })),
"MACOS": z.optional(z.object({
    "total_ms": z.int(),
"jobs": z.int(),
"job_runs": z.optional(z.array(z.object({
    "job_id": z.int(),
"duration_ms": z.int()
    })))
    })),
"WINDOWS": z.optional(z.object({
    "total_ms": z.int(),
"jobs": z.int(),
"job_runs": z.optional(z.array(z.object({
    "job_id": z.int(),
"duration_ms": z.int()
    })))
    }))
    }),
"run_duration_ms": z.optional(z.int())
    }).describe("Workflow Run Usage")

/**
 * @description A GitHub Actions workflow
 */
export const workflowSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"name": z.string(),
"path": z.string(),
"state": z.enum(["active", "deleted", "disabled_fork", "disabled_inactivity", "disabled_manually"]),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.string(),
"html_url": z.string(),
"badge_url": z.string(),
"deleted_at": z.optional(z.iso.datetime({ offset: true }))
    }).describe("A GitHub Actions workflow")

/**
 * @description Workflow Usage
 */
export const workflowUsageSchema = z.object({
    "billable": z.object({
    "UBUNTU": z.optional(z.object({
    "total_ms": z.optional(z.int())
    })),
"MACOS": z.optional(z.object({
    "total_ms": z.optional(z.int())
    })),
"WINDOWS": z.optional(z.object({
    "total_ms": z.optional(z.int())
    }))
    })
    }).describe("Workflow Usage")

/**
 * @description Activity
 */
export const activitySchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"before": z.string().describe("The SHA of the commit before the activity."),
"after": z.string().describe("The SHA of the commit after the activity."),
"ref": z.string().describe("The full Git reference, formatted as `refs/heads/<branch name>`."),
"timestamp": z.iso.datetime({ offset: true }).describe("The time when the activity occurred."),
"activity_type": z.enum(["push", "force_push", "branch_deletion", "branch_creation", "pr_merge", "merge_queue_merge"]).describe("The type of the activity that was performed."),
get "actor"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              }
    }).describe("Activity")

/**
 * @description An autolink reference.
 */
export const autolinkSchema = z.object({
    "id": z.int(),
"key_prefix": z.string().describe("The prefix of a key that is linkified."),
"url_template": z.string().describe("A template for the target URL that is generated if a key was found."),
"is_alphanumeric": z.boolean().describe("Whether this autolink reference matches alphanumeric characters. If false, this autolink reference only matches numeric characters."),
"updated_at": z.iso.datetime({ offset: true }).nullish()
    }).describe("An autolink reference.")

/**
 * @description Check Dependabot security updates
 */
export const checkAutomatedSecurityFixesSchema = z.object({
    "enabled": z.boolean().describe("Whether Dependabot security updates are enabled for the repository."),
"paused": z.boolean().describe("Whether Dependabot security updates are paused for the repository.")
    }).describe("Check Dependabot security updates")

/**
 * @description Protected Branch Required Status Check
 */
export const protectedBranchRequiredStatusCheckSchema = z.object({
    "url": z.optional(z.string()),
"enforcement_level": z.optional(z.string()),
"contexts": z.array(z.string()),
"checks": z.array(z.object({
    "context": z.string(),
"app_id": z.nullable(z.int())
    })),
"contexts_url": z.optional(z.string()),
"strict": z.optional(z.boolean())
    }).describe("Protected Branch Required Status Check")

/**
 * @description Protected Branch Admin Enforced
 */
export const protectedBranchAdminEnforcedSchema = z.object({
    "url": z.url(),
"enabled": z.boolean()
    }).describe("Protected Branch Admin Enforced")

/**
 * @description Protected Branch Pull Request Review
 */
export const protectedBranchPullRequestReviewSchema = z.object({
    "url": z.optional(z.url()),
"dismissal_restrictions": z.optional(z.object({
    get "users"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).describe("The list of users with review dismissal access.").optional()
              },
get "teams"(){
                return z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories.")).describe("The list of teams with review dismissal access.").optional()
              },
get "apps"(){
                return z.array(integrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()).describe("The list of apps with review dismissal access.").optional()
              },
"url": z.optional(z.string()),
"users_url": z.optional(z.string()),
"teams_url": z.optional(z.string())
    })),
"bypass_pull_request_allowances": z.optional(z.object({
    get "users"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).describe("The list of users allowed to bypass pull request requirements.").optional()
              },
get "teams"(){
                return z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories.")).describe("The list of teams allowed to bypass pull request requirements.").optional()
              },
get "apps"(){
                return z.array(integrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()).describe("The list of apps allowed to bypass pull request requirements.").optional()
              }
    }).describe("Allow specific users, teams, or apps to bypass pull request requirements.")),
"dismiss_stale_reviews": z.boolean(),
"require_code_owner_reviews": z.boolean(),
"required_approving_review_count": z.optional(z.int().min(0).max(6)),
"require_last_push_approval": z.optional(z.boolean().default(false).describe("Whether the most recent push must be approved by someone other than the person who pushed it."))
    }).describe("Protected Branch Pull Request Review")

/**
 * @description Branch Restriction Policy
 */
export const branchRestrictionPolicySchema = z.object({
    "url": z.url(),
"users_url": z.url(),
"teams_url": z.url(),
"apps_url": z.url(),
"users": z.array(z.object({
    "login": z.optional(z.string()),
"id": z.optional(z.int()),
"node_id": z.optional(z.string()),
"avatar_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"type": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"user_view_type": z.optional(z.string())
    })),
get "teams"(){
                return z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories."))
              },
"apps": z.array(z.object({
    "id": z.optional(z.int()),
"slug": z.optional(z.string()),
"node_id": z.optional(z.string()),
"owner": z.optional(z.object({
    "login": z.optional(z.string()),
"id": z.optional(z.int()),
"node_id": z.optional(z.string()),
"url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"hooks_url": z.optional(z.string()),
"issues_url": z.optional(z.string()),
"members_url": z.optional(z.string()),
"public_members_url": z.optional(z.string()),
"avatar_url": z.optional(z.string()),
"description": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"type": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"user_view_type": z.optional(z.string())
    })),
"name": z.optional(z.string()),
"client_id": z.optional(z.string()),
"description": z.optional(z.string()),
"external_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"created_at": z.optional(z.string()),
"updated_at": z.optional(z.string()),
"permissions": z.optional(z.object({
    "metadata": z.optional(z.string()),
"contents": z.optional(z.string()),
"issues": z.optional(z.string()),
"single_file": z.optional(z.string())
    })),
"events": z.optional(z.array(z.string()))
    }))
    }).describe("Branch Restriction Policy")

/**
 * @description Branch Protection
 */
export const branchProtectionSchema = z.object({
    "url": z.optional(z.string()),
"enabled": z.optional(z.boolean()),
get "required_status_checks"(){
                return protectedBranchRequiredStatusCheckSchema.describe("Protected Branch Required Status Check").optional()
              },
get "enforce_admins"(){
                return protectedBranchAdminEnforcedSchema.describe("Protected Branch Admin Enforced").optional()
              },
get "required_pull_request_reviews"(){
                return protectedBranchPullRequestReviewSchema.describe("Protected Branch Pull Request Review").optional()
              },
get "restrictions"(){
                return branchRestrictionPolicySchema.describe("Branch Restriction Policy").optional()
              },
"required_linear_history": z.optional(z.object({
    "enabled": z.optional(z.boolean())
    })),
"allow_force_pushes": z.optional(z.object({
    "enabled": z.optional(z.boolean())
    })),
"allow_deletions": z.optional(z.object({
    "enabled": z.optional(z.boolean())
    })),
"block_creations": z.optional(z.object({
    "enabled": z.optional(z.boolean())
    })),
"required_conversation_resolution": z.optional(z.object({
    "enabled": z.optional(z.boolean())
    })),
"name": z.optional(z.string()),
"protection_url": z.optional(z.string()),
"required_signatures": z.optional(z.object({
    "url": z.url(),
"enabled": z.boolean()
    })),
"lock_branch": z.optional(z.object({
    "enabled": z.optional(z.boolean().default(false))
    }).describe("Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.")),
"allow_fork_syncing": z.optional(z.object({
    "enabled": z.optional(z.boolean().default(false))
    }).describe("Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing."))
    }).describe("Branch Protection")

/**
 * @description Short Branch
 */
export const shortBranchSchema = z.object({
    "name": z.string(),
"commit": z.object({
    "sha": z.string(),
"url": z.url()
    }),
"protected": z.boolean(),
get "protection"(){
                return branchProtectionSchema.describe("Branch Protection").optional()
              },
"protection_url": z.optional(z.url())
    }).describe("Short Branch")

/**
 * @description Metaproperties for Git author/committer information.
 */
export const nullableGitUserSchema = z.object({
    "name": z.optional(z.string()),
"email": z.optional(z.string()),
"date": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information.").nullable()

export const verificationSchema = z.object({
    "verified": z.boolean(),
"reason": z.string(),
"payload": z.nullable(z.string()),
"signature": z.nullable(z.string()),
"verified_at": z.nullable(z.string())
    })

/**
 * @description Diff Entry
 */
export const diffEntrySchema = z.object({
    "sha": z.nullable(z.string()),
"filename": z.string(),
"status": z.enum(["added", "removed", "modified", "renamed", "copied", "changed", "unchanged"]),
"additions": z.int(),
"deletions": z.int(),
"changes": z.int(),
"blob_url": z.url(),
"raw_url": z.url(),
"contents_url": z.url(),
"patch": z.optional(z.string()),
"previous_filename": z.optional(z.string())
    }).describe("Diff Entry")

/**
 * @description Commit
 */
export const commitSchema = z.object({
    "url": z.url(),
"sha": z.string(),
"node_id": z.string(),
"html_url": z.url(),
"comments_url": z.url(),
"commit": z.object({
    "url": z.url(),
get "author"(){
               return nullableGitUserSchema.describe("Metaproperties for Git author/committer information.").nullable()
              },
get "committer"(){
               return nullableGitUserSchema.describe("Metaproperties for Git author/committer information.").nullable()
              },
"message": z.string(),
"comment_count": z.int(),
"tree": z.object({
    "sha": z.string(),
"url": z.url()
    }),
get "verification"(){
                return verificationSchema.optional()
              }
    }),
get "author"(){
               return z.union([simpleUserSchema, emptyObjectSchema]).nullable()
              },
get "committer"(){
               return z.union([simpleUserSchema, emptyObjectSchema]).nullable()
              },
"parents": z.array(z.object({
    "sha": z.string(),
"url": z.url(),
"html_url": z.optional(z.url())
    })),
"stats": z.optional(z.object({
    "additions": z.optional(z.int()),
"deletions": z.optional(z.int()),
"total": z.optional(z.int())
    })),
get "files"(){
                return z.array(diffEntrySchema.describe("Diff Entry")).optional()
              }
    }).describe("Commit")

/**
 * @description Branch With Protection
 */
export const branchWithProtectionSchema = z.object({
    "name": z.string(),
get "commit"(){
                return commitSchema.describe("Commit")
              },
"_links": z.object({
    "html": z.string(),
"self": z.url()
    }),
"protected": z.boolean(),
get "protection"(){
                return branchProtectionSchema.describe("Branch Protection")
              },
"protection_url": z.url(),
"pattern": z.optional(z.string()),
"required_approving_review_count": z.optional(z.int())
    }).describe("Branch With Protection")

/**
 * @description Status Check Policy
 */
export const statusCheckPolicySchema = z.object({
    "url": z.url(),
"strict": z.boolean(),
"contexts": z.array(z.string()),
"checks": z.array(z.object({
    "context": z.string(),
"app_id": z.nullable(z.int())
    })),
"contexts_url": z.url()
    }).describe("Status Check Policy")

/**
 * @description Branch protections protect branches
 */
export const protectedBranchSchema = z.object({
    "url": z.url(),
get "required_status_checks"(){
                return statusCheckPolicySchema.describe("Status Check Policy").optional()
              },
"required_pull_request_reviews": z.optional(z.object({
    "url": z.url(),
"dismiss_stale_reviews": z.optional(z.boolean()),
"require_code_owner_reviews": z.optional(z.boolean()),
"required_approving_review_count": z.optional(z.int()),
"require_last_push_approval": z.optional(z.boolean().default(false).describe("Whether the most recent push must be approved by someone other than the person who pushed it.")),
"dismissal_restrictions": z.optional(z.object({
    "url": z.url(),
"users_url": z.url(),
"teams_url": z.url(),
get "users"(){
                return z.array(simpleUserSchema.describe("A GitHub user."))
              },
get "teams"(){
                return z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories."))
              },
get "apps"(){
                return z.array(integrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()).optional()
              }
    })),
"bypass_pull_request_allowances": z.optional(z.object({
    get "users"(){
                return z.array(simpleUserSchema.describe("A GitHub user."))
              },
get "teams"(){
                return z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories."))
              },
get "apps"(){
                return z.array(integrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()).optional()
              }
    }))
    })),
"required_signatures": z.optional(z.object({
    "url": z.url(),
"enabled": z.boolean()
    })),
"enforce_admins": z.optional(z.object({
    "url": z.url(),
"enabled": z.boolean()
    })),
"required_linear_history": z.optional(z.object({
    "enabled": z.boolean()
    })),
"allow_force_pushes": z.optional(z.object({
    "enabled": z.boolean()
    })),
"allow_deletions": z.optional(z.object({
    "enabled": z.boolean()
    })),
get "restrictions"(){
                return branchRestrictionPolicySchema.describe("Branch Restriction Policy").optional()
              },
"required_conversation_resolution": z.optional(z.object({
    "enabled": z.optional(z.boolean())
    })),
"block_creations": z.optional(z.object({
    "enabled": z.boolean()
    })),
"lock_branch": z.optional(z.object({
    "enabled": z.optional(z.boolean().default(false))
    }).describe("Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.")),
"allow_fork_syncing": z.optional(z.object({
    "enabled": z.optional(z.boolean().default(false))
    }).describe("Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing."))
    }).describe("Branch protections protect branches")

/**
 * @description A deployment created as the result of an Actions check run from a workflow that references an environment
 */
export const deploymentSimpleSchema = z.object({
    "url": z.url(),
"id": z.int().describe("Unique identifier of the deployment"),
"node_id": z.string(),
"task": z.string().describe("Parameter to specify a task to execute"),
"original_environment": z.optional(z.string()),
"environment": z.string().describe("Name for the target deployment environment."),
"description": z.nullable(z.string()),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"statuses_url": z.url(),
"repository_url": z.url(),
"transient_environment": z.optional(z.boolean().describe("Specifies if the given environment is will no longer exist at some point in the future. Default: false.")),
"production_environment": z.optional(z.boolean().describe("Specifies if the given environment is one that end-users directly interact with. Default: false.")),
get "performed_via_github_app"(){
                return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").optional()
              }
    }).describe("A deployment created as the result of an Actions check run from a workflow that references an environment")

/**
 * @description A check performed on the code of a given code change
 */
export const checkRunSchema = z.object({
    "id": z.int().describe("The id of the check."),
"head_sha": z.string().describe("The SHA of the commit that is being checked."),
"node_id": z.string(),
"external_id": z.nullable(z.string()),
"url": z.string(),
"html_url": z.nullable(z.string()),
"details_url": z.nullable(z.string()),
"status": z.enum(["queued", "in_progress", "completed", "waiting", "requested", "pending"]).describe("The phase of the lifecycle that the check is currently in. Statuses of waiting, requested, and pending are reserved for GitHub Actions check runs."),
"conclusion": z.nullable(z.enum(["success", "failure", "neutral", "cancelled", "skipped", "timed_out", "action_required"])),
"started_at": z.nullable(z.iso.datetime({ offset: true })),
"completed_at": z.nullable(z.iso.datetime({ offset: true })),
"output": z.object({
    "title": z.nullable(z.string()),
"summary": z.nullable(z.string()),
"text": z.nullable(z.string()),
"annotations_count": z.int(),
"annotations_url": z.url()
    }),
"name": z.string().describe("The name of the check."),
"check_suite": z.nullable(z.object({
    "id": z.int()
    })),
get "app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
get "pull_requests"(){
                return z.array(pullRequestMinimalSchema).describe("Pull requests that are open with a `head_sha` or `head_branch` that matches the check. The returned pull requests do not necessarily indicate pull requests that triggered the check.")
              },
get "deployment"(){
                return deploymentSimpleSchema.describe("A deployment created as the result of an Actions check run from a workflow that references an environment").optional()
              }
    }).describe("A check performed on the code of a given code change")

/**
 * @description Check Annotation
 */
export const checkAnnotationSchema = z.object({
    "path": z.string(),
"start_line": z.int(),
"end_line": z.int(),
"start_column": z.nullable(z.int()),
"end_column": z.nullable(z.int()),
"annotation_level": z.nullable(z.string()),
"title": z.nullable(z.string()),
"message": z.nullable(z.string()),
"raw_details": z.nullable(z.string()),
"blob_href": z.string()
    }).describe("Check Annotation")

/**
 * @description A commit.
 */
export const simpleCommitSchema = z.object({
    "id": z.string().describe("SHA for the commit"),
"tree_id": z.string().describe("SHA for the commit's tree"),
"message": z.string().describe("Message describing the purpose of the commit"),
"timestamp": z.iso.datetime({ offset: true }).describe("Timestamp of the commit"),
"author": z.nullable(z.object({
    "name": z.string().describe("Name of the commit's author"),
"email": z.email().describe("Git email address of the commit's author")
    }).describe("Information about the Git author")),
"committer": z.nullable(z.object({
    "name": z.string().describe("Name of the commit's committer"),
"email": z.email().describe("Git email address of the commit's committer")
    }).describe("Information about the Git committer"))
    }).describe("A commit.")

/**
 * @description A suite of checks performed on the code of a given code change
 */
export const checkSuiteSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"head_branch": z.nullable(z.string()),
"head_sha": z.string().describe("The SHA of the head commit that is being checked."),
"status": z.nullable(z.enum(["queued", "in_progress", "completed", "waiting", "requested", "pending"]).describe("The phase of the lifecycle that the check suite is currently in. Statuses of waiting, requested, and pending are reserved for GitHub Actions check suites.")),
"conclusion": z.nullable(z.enum(["success", "failure", "neutral", "cancelled", "skipped", "timed_out", "action_required", "startup_failure", "stale"])),
"url": z.nullable(z.string()),
"before": z.nullable(z.string()),
"after": z.nullable(z.string()),
get "pull_requests"(){
               return z.array(pullRequestMinimalSchema).nullable()
              },
get "app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
get "repository"(){
                return minimalRepositorySchema.describe("Minimal Repository")
              },
"created_at": z.nullable(z.iso.datetime({ offset: true })),
"updated_at": z.nullable(z.iso.datetime({ offset: true })),
get "head_commit"(){
                return simpleCommitSchema.describe("A commit.")
              },
"latest_check_runs_count": z.int(),
"check_runs_url": z.string(),
"rerequestable": z.optional(z.boolean()),
"runs_rerequestable": z.optional(z.boolean())
    }).describe("A suite of checks performed on the code of a given code change")

/**
 * @description Check suite configuration preferences for a repository.
 */
export const checkSuitePreferenceSchema = z.object({
    "preferences": z.object({
    "auto_trigger_checks": z.optional(z.array(z.object({
    "app_id": z.int(),
"setting": z.boolean()
    })))
    }),
get "repository"(){
                return minimalRepositorySchema.describe("Minimal Repository")
              }
    }).describe("Check suite configuration preferences for a repository.")

export const codeScanningAlertItemsSchema = z.object({
    get "number"(){
                return alertNumberSchema.describe("The security alert number.")
              },
get "created_at"(){
                return alertCreatedAtSchema.describe("The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.")
              },
get "updated_at"(){
                return alertUpdatedAtSchema.describe("The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").optional()
              },
get "url"(){
                return alertUrlSchema.describe("The REST API URL of the alert resource.")
              },
get "html_url"(){
                return alertHtmlUrlSchema.describe("The GitHub URL of the alert resource.")
              },
get "instances_url"(){
                return alertInstancesUrlSchema.describe("The REST API URL for fetching the list of instances for an alert.")
              },
get "state"(){
               return codeScanningAlertStateSchema.describe("State of a code scanning alert.").nullable()
              },
get "fixed_at"(){
                return alertFixedAtSchema.describe("The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").optional()
              },
get "dismissed_by"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
get "dismissed_at"(){
               return alertDismissedAtSchema.describe("The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullable()
              },
get "dismissed_reason"(){
               return codeScanningAlertDismissedReasonSchema.describe("**Required when the state is dismissed.** The reason for dismissing or closing the alert.").nullable()
              },
get "dismissed_comment"(){
                return codeScanningAlertDismissedCommentSchema.describe("The dismissal comment associated with the dismissal of the alert.").optional()
              },
get "rule"(){
                return codeScanningAlertRuleSummarySchema
              },
get "tool"(){
                return codeScanningAnalysisToolSchema
              },
get "most_recent_instance"(){
                return codeScanningAlertInstanceSchema
              },
get "dismissal_approved_by"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
get "assignees"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).optional()
              }
    })

export const codeScanningAlertRuleSchema = z.object({
    "id": z.string().describe("A unique identifier for the rule used to detect the alert.").nullish(),
"name": z.optional(z.string().describe("The name of the rule used to detect the alert.")),
"severity": z.enum(["none", "note", "warning", "error"]).describe("The severity of the alert.").nullish(),
"security_severity_level": z.enum(["low", "medium", "high", "critical"]).describe("The security severity of the alert.").nullish(),
"description": z.optional(z.string().describe("A short description of the rule used to detect the alert.")),
"full_description": z.optional(z.string().describe("A description of the rule used to detect the alert.")),
"tags": z.array(z.string()).describe("A set of tags applicable for the rule.").nullish(),
"help": z.string().describe("Detailed documentation for the rule as GitHub Flavored Markdown.").nullish(),
"help_uri": z.string().describe("A link to the documentation for the rule used to detect the alert.").nullish()
    })

export const codeScanningAlertSchema = z.object({
    get "number"(){
                return alertNumberSchema.describe("The security alert number.")
              },
get "created_at"(){
                return alertCreatedAtSchema.describe("The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.")
              },
get "updated_at"(){
                return alertUpdatedAtSchema.describe("The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").optional()
              },
get "url"(){
                return alertUrlSchema.describe("The REST API URL of the alert resource.")
              },
get "html_url"(){
                return alertHtmlUrlSchema.describe("The GitHub URL of the alert resource.")
              },
get "instances_url"(){
                return alertInstancesUrlSchema.describe("The REST API URL for fetching the list of instances for an alert.")
              },
get "state"(){
               return codeScanningAlertStateSchema.describe("State of a code scanning alert.").nullable()
              },
get "fixed_at"(){
                return alertFixedAtSchema.describe("The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").optional()
              },
get "dismissed_by"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
get "dismissed_at"(){
               return alertDismissedAtSchema.describe("The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullable()
              },
get "dismissed_reason"(){
               return codeScanningAlertDismissedReasonSchema.describe("**Required when the state is dismissed.** The reason for dismissing or closing the alert.").nullable()
              },
get "dismissed_comment"(){
                return codeScanningAlertDismissedCommentSchema.describe("The dismissal comment associated with the dismissal of the alert.").optional()
              },
get "rule"(){
                return codeScanningAlertRuleSchema
              },
get "tool"(){
                return codeScanningAnalysisToolSchema
              },
get "most_recent_instance"(){
                return codeScanningAlertInstanceSchema
              },
get "dismissal_approved_by"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
get "assignees"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).optional()
              }
    })

/**
 * @description Sets the state of the code scanning alert. You must provide `dismissed_reason` when you set the state to `dismissed`.
 */
export const codeScanningAlertSetStateSchema = z.enum(["open", "dismissed"]).describe("Sets the state of the code scanning alert. You must provide `dismissed_reason` when you set the state to `dismissed`.")

/**
 * @description If `true`, attempt to create an alert dismissal request.
 */
export const codeScanningAlertCreateRequestSchema = z.boolean().describe("If `true`, attempt to create an alert dismissal request.")

/**
 * @description The status of an autofix.
 */
export const codeScanningAutofixStatusSchema = z.enum(["pending", "error", "success", "outdated"]).describe("The status of an autofix.")

/**
 * @description The description of an autofix.
 */
export const codeScanningAutofixDescriptionSchema = z.string().describe("The description of an autofix.").nullable()

/**
 * @description The start time of an autofix in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const codeScanningAutofixStartedAtSchema = z.iso.datetime({ offset: true }).describe("The start time of an autofix in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.")

export const codeScanningAutofixSchema = z.object({
    get "status"(){
                return codeScanningAutofixStatusSchema.describe("The status of an autofix.")
              },
get "description"(){
               return codeScanningAutofixDescriptionSchema.describe("The description of an autofix.").nullable()
              },
get "started_at"(){
                return codeScanningAutofixStartedAtSchema.describe("The start time of an autofix in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.")
              }
    })

/**
 * @description Commit an autofix for a code scanning alert
 */
export const codeScanningAutofixCommitsSchema = z.object({
    "target_ref": z.optional(z.string().describe("The Git reference of target branch for the commit. Branch needs to already exist.  For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.")),
"message": z.optional(z.string().describe("Commit message to be used."))
    }).describe("Commit an autofix for a code scanning alert").nullable()

export const codeScanningAutofixCommitsResponseSchema = z.object({
    "target_ref": z.optional(z.string().describe("The Git reference of target branch for the commit. For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.")),
"sha": z.optional(z.string().describe("SHA of commit with autofix."))
    })

/**
 * @description An identifier for the upload.
 */
export const codeScanningAnalysisSarifIdSchema = z.string().describe("An identifier for the upload.")

/**
 * @description The SHA of the commit to which the analysis you are uploading relates.
 */
export const codeScanningAnalysisCommitShaSchema = z.string().regex(/^[0-9a-fA-F]+$/).describe("The SHA of the commit to which the analysis you are uploading relates.")

/**
 * @description Identifies the variable values associated with the environment in which this analysis was performed.
 */
export const codeScanningAnalysisEnvironmentSchema = z.string().describe("Identifies the variable values associated with the environment in which this analysis was performed.")

/**
 * @description The time that the analysis was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
 */
export const codeScanningAnalysisCreatedAtSchema = z.iso.datetime({ offset: true }).describe("The time that the analysis was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.")

/**
 * @description The REST API URL of the analysis resource.
 */
export const codeScanningAnalysisUrlSchema = z.url().describe("The REST API URL of the analysis resource.")

export const codeScanningAnalysisSchema = z.object({
    get "ref"(){
                return codeScanningRefSchema.describe("The Git reference, formatted as `refs/pull/<number>/merge`, `refs/pull/<number>/head`,\n`refs/heads/<branch name>` or simply `<branch name>`.")
              },
get "commit_sha"(){
                return codeScanningAnalysisCommitShaSchema.describe("The SHA of the commit to which the analysis you are uploading relates.")
              },
get "analysis_key"(){
                return codeScanningAnalysisAnalysisKeySchema.describe("Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.")
              },
get "environment"(){
                return codeScanningAnalysisEnvironmentSchema.describe("Identifies the variable values associated with the environment in which this analysis was performed.")
              },
get "category"(){
                return codeScanningAnalysisCategorySchema.describe("Identifies the configuration under which the analysis was executed. Used to distinguish between multiple analyses for the same tool and commit, but performed on different languages or different parts of the code.").optional()
              },
"error": z.string(),
get "created_at"(){
                return codeScanningAnalysisCreatedAtSchema.describe("The time that the analysis was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.")
              },
"results_count": z.int().describe("The total number of results in the analysis."),
"rules_count": z.int().describe("The total number of rules used in the analysis."),
"id": z.int().describe("Unique identifier for this analysis."),
get "url"(){
                return codeScanningAnalysisUrlSchema.describe("The REST API URL of the analysis resource.")
              },
get "sarif_id"(){
                return codeScanningAnalysisSarifIdSchema.describe("An identifier for the upload.")
              },
get "tool"(){
                return codeScanningAnalysisToolSchema
              },
"deletable": z.boolean(),
"warning": z.string().describe("Warning generated when processing the analysis")
    })

/**
 * @description Successful deletion of a code scanning analysis
 */
export const codeScanningAnalysisDeletionSchema = z.object({
    "next_analysis_url": z.nullable(z.url().describe("Next deletable analysis in chain, without last analysis deletion confirmation")),
"confirm_delete_url": z.nullable(z.url().describe("Next deletable analysis in chain, with last analysis deletion confirmation"))
    }).describe("Successful deletion of a code scanning analysis")

/**
 * @description A CodeQL database.
 */
export const codeScanningCodeqlDatabaseSchema = z.object({
    "id": z.int().describe("The ID of the CodeQL database."),
"name": z.string().describe("The name of the CodeQL database."),
"language": z.string().describe("The language of the CodeQL database."),
get "uploader"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"content_type": z.string().describe("The MIME type of the CodeQL database file."),
"size": z.int().describe("The size of the CodeQL database file in bytes."),
"created_at": z.iso.datetime({ offset: true }).describe("The date and time at which the CodeQL database was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."),
"updated_at": z.iso.datetime({ offset: true }).describe("The date and time at which the CodeQL database was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."),
"url": z.url().describe("The URL at which to download the CodeQL database. The `Accept` header must be set to the value of the `content_type` property."),
"commit_oid": z.string().describe("The commit SHA of the repository at the time the CodeQL database was created.").nullish()
    }).describe("A CodeQL database.")

/**
 * @description The language targeted by the CodeQL query
 */
export const codeScanningVariantAnalysisLanguageSchema = z.enum(["cpp", "csharp", "go", "java", "javascript", "python", "ruby", "rust", "swift"]).describe("The language targeted by the CodeQL query")

/**
 * @description Repository Identifier
 */
export const codeScanningVariantAnalysisRepositorySchema = z.object({
    "id": z.int().describe("A unique identifier of the repository."),
"name": z.string().describe("The name of the repository."),
"full_name": z.string().describe("The full, globally unique, name of the repository."),
"private": z.boolean().describe("Whether the repository is private."),
"stargazers_count": z.int(),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("Repository Identifier")

/**
 * @description The new status of the CodeQL variant analysis repository task.
 */
export const codeScanningVariantAnalysisStatusSchema = z.enum(["pending", "in_progress", "succeeded", "failed", "canceled", "timed_out"]).describe("The new status of the CodeQL variant analysis repository task.")

export const codeScanningVariantAnalysisSkippedRepoGroupSchema = z.object({
    "repository_count": z.int().describe("The total number of repositories that were skipped for this reason."),
get "repositories"(){
                return z.array(codeScanningVariantAnalysisRepositorySchema.describe("Repository Identifier")).describe("A list of repositories that were skipped. This list may not include all repositories that were skipped. This is only available when the repository was found and the user has access to it.")
              }
    })

/**
 * @description A run of a CodeQL query against one or more repositories.
 */
export const codeScanningVariantAnalysisSchema = z.object({
    "id": z.int().describe("The ID of the variant analysis."),
get "controller_repo"(){
                return simpleRepositorySchema.describe("A GitHub repository.")
              },
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "query_language"(){
                return codeScanningVariantAnalysisLanguageSchema.describe("The language targeted by the CodeQL query")
              },
"query_pack_url": z.string().describe("The download url for the query pack."),
"created_at": z.optional(z.iso.datetime({ offset: true }).describe("The date and time at which the variant analysis was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.")),
"updated_at": z.optional(z.iso.datetime({ offset: true }).describe("The date and time at which the variant analysis was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.")),
"completed_at": z.iso.datetime({ offset: true }).describe("The date and time at which the variant analysis was completed, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ. Will be null if the variant analysis has not yet completed or this information is not available.").nullish(),
"status": z.enum(["in_progress", "succeeded", "failed", "cancelled"]),
"actions_workflow_run_id": z.optional(z.int().describe("The GitHub Actions workflow run used to execute this variant analysis. This is only available if the workflow run has started.")),
"failure_reason": z.optional(z.enum(["no_repos_queried", "actions_workflow_run_failed", "internal_error"]).describe("The reason for a failure of the variant analysis. This is only available if the variant analysis has failed.")),
"scanned_repositories": z.optional(z.array(z.object({
    get "repository"(){
                return codeScanningVariantAnalysisRepositorySchema.describe("Repository Identifier")
              },
get "analysis_status"(){
                return codeScanningVariantAnalysisStatusSchema.describe("The new status of the CodeQL variant analysis repository task.")
              },
"result_count": z.optional(z.int().describe("The number of results in the case of a successful analysis. This is only available for successful analyses.")),
"artifact_size_in_bytes": z.optional(z.int().describe("The size of the artifact. This is only available for successful analyses.")),
"failure_message": z.optional(z.string().describe("The reason of the failure of this repo task. This is only available if the repository task has failed."))
    }))),
"skipped_repositories": z.optional(z.object({
    get "access_mismatch_repos"(){
                return codeScanningVariantAnalysisSkippedRepoGroupSchema
              },
"not_found_repos": z.object({
    "repository_count": z.int().describe("The total number of repositories that were skipped for this reason."),
"repository_full_names": z.array(z.string()).describe("A list of full repository names that were skipped. This list may not include all repositories that were skipped.")
    }),
get "no_codeql_db_repos"(){
                return codeScanningVariantAnalysisSkippedRepoGroupSchema
              },
get "over_limit_repos"(){
                return codeScanningVariantAnalysisSkippedRepoGroupSchema
              }
    }).describe("Information about repositories that were skipped from processing. This information is only available to the user that initiated the variant analysis."))
    }).describe("A run of a CodeQL query against one or more repositories.")

export const codeScanningVariantAnalysisRepoTaskSchema = z.object({
    get "repository"(){
                return simpleRepositorySchema.describe("A GitHub repository.")
              },
get "analysis_status"(){
                return codeScanningVariantAnalysisStatusSchema.describe("The new status of the CodeQL variant analysis repository task.")
              },
"artifact_size_in_bytes": z.optional(z.int().describe("The size of the artifact. This is only available for successful analyses.")),
"result_count": z.optional(z.int().describe("The number of results in the case of a successful analysis. This is only available for successful analyses.")),
"failure_message": z.optional(z.string().describe("The reason of the failure of this repo task. This is only available if the repository task has failed.")),
"database_commit_sha": z.optional(z.string().describe("The SHA of the commit the CodeQL database was built against. This is only available for successful analyses.")),
"source_location_prefix": z.optional(z.string().describe("The source location prefix to use. This is only available for successful analyses.")),
"artifact_url": z.optional(z.string().describe("The URL of the artifact. This is only available for successful analyses."))
    })

/**
 * @description Configuration for code scanning default setup.
 */
export const codeScanningDefaultSetupSchema = z.object({
    "state": z.optional(z.enum(["configured", "not-configured"]).describe("Code scanning default setup has been configured or not.")),
"languages": z.optional(z.array(z.enum(["actions", "c-cpp", "csharp", "go", "java-kotlin", "javascript-typescript", "javascript", "python", "ruby", "typescript", "swift"])).describe("Languages to be analyzed.")),
"runner_type": z.enum(["standard", "labeled"]).describe("Runner type to be used.").nullish(),
"runner_label": z.string().describe("Runner label to be used if the runner type is labeled.").nullish(),
"query_suite": z.optional(z.enum(["default", "extended"]).describe("CodeQL query suite to be used.")),
"threat_model": z.optional(z.enum(["remote", "remote_and_local"]).describe("Threat model to be used for code scanning analysis. Use `remote` to analyze only network sources and `remote_and_local` to include local sources like filesystem access, command-line arguments, database reads, environment variable and standard input.")),
"updated_at": z.iso.datetime({ offset: true }).describe("Timestamp of latest configuration update.").nullish(),
"schedule": z.enum(["weekly"]).describe("The frequency of the periodic analysis.").nullish()
    }).describe("Configuration for code scanning default setup.")

/**
 * @description Configuration for code scanning default setup.
 */
export const codeScanningDefaultSetupUpdateSchema = z.object({
    "state": z.optional(z.enum(["configured", "not-configured"]).describe("The desired state of code scanning default setup.")),
"runner_type": z.optional(z.enum(["standard", "labeled"]).describe("Runner type to be used.")),
"runner_label": z.string().describe("Runner label to be used if the runner type is labeled.").nullish(),
"query_suite": z.optional(z.enum(["default", "extended"]).describe("CodeQL query suite to be used.")),
"threat_model": z.optional(z.enum(["remote", "remote_and_local"]).describe("Threat model to be used for code scanning analysis. Use `remote` to analyze only network sources and `remote_and_local` to include local sources like filesystem access, command-line arguments, database reads, environment variable and standard input.")),
"languages": z.optional(z.array(z.enum(["actions", "c-cpp", "csharp", "go", "java-kotlin", "javascript-typescript", "python", "ruby", "swift"])).describe("CodeQL languages to be analyzed."))
    }).describe("Configuration for code scanning default setup.")

/**
 * @description You can use `run_url` to track the status of the run. This includes a property status and conclusion.\nYou should not rely on this always being an actions workflow run object.
 */
export const codeScanningDefaultSetupUpdateResponseSchema = z.object({
    "run_id": z.optional(z.int().describe("ID of the corresponding run.")),
"run_url": z.optional(z.string().describe("URL of the corresponding run."))
    }).describe("You can use `run_url` to track the status of the run. This includes a property status and conclusion.\nYou should not rely on this always being an actions workflow run object.")

/**
 * @description The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/tags/<tag>`, `refs/pull/<number>/merge`, or `refs/pull/<number>/head`.
 */
export const codeScanningRefFullSchema = z.string().regex(/^refs\/(heads|tags|pull)\/.*$/).describe("The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/tags/<tag>`, `refs/pull/<number>/merge`, or `refs/pull/<number>/head`.")

/**
 * @description A Base64 string representing the SARIF file to upload. You must first compress your SARIF file using [`gzip`](http://www.gnu.org/software/gzip/manual/gzip.html) and then translate the contents of the file into a Base64 encoding string. For more information, see \"[SARIF support for code scanning](https://docs.github.com/code-security/secure-coding/sarif-support-for-code-scanning).\"
 */
export const codeScanningAnalysisSarifFileSchema = z.string().describe("A Base64 string representing the SARIF file to upload. You must first compress your SARIF file using [`gzip`](http://www.gnu.org/software/gzip/manual/gzip.html) and then translate the contents of the file into a Base64 encoding string. For more information, see \"[SARIF support for code scanning](https://docs.github.com/code-security/secure-coding/sarif-support-for-code-scanning).\"")

export const codeScanningSarifsReceiptSchema = z.object({
    get "id"(){
                return codeScanningAnalysisSarifIdSchema.describe("An identifier for the upload.").optional()
              },
"url": z.optional(z.url().describe("The REST API URL for checking the status of the upload."))
    })

export const codeScanningSarifsStatusSchema = z.object({
    "processing_status": z.optional(z.enum(["pending", "complete", "failed"]).describe("`pending` files have not yet been processed, while `complete` means results from the SARIF have been stored. `failed` files have either not been processed at all, or could only be partially processed.")),
"analyses_url": z.url().describe("The REST API URL for getting the analyses associated with the upload.").nullish(),
"errors": z.array(z.string()).describe("Any errors that ocurred during processing of the delivery.").nullish()
    })

/**
 * @description Code security configuration associated with a repository and attachment status
 */
export const codeSecurityConfigurationForRepositorySchema = z.object({
    "status": z.optional(z.enum(["attached", "attaching", "detached", "removed", "enforced", "failed", "updating", "removed_by_enterprise"]).describe("The attachment status of the code security configuration on the repository.")),
get "configuration"(){
                return codeSecurityConfigurationSchema.describe("A code security configuration").optional()
              }
    }).describe("Code security configuration associated with a repository and attachment status")

/**
 * @description A list of errors found in a repo\'s CODEOWNERS file
 */
export const codeownersErrorsSchema = z.object({
    "errors": z.array(z.object({
    "line": z.int().describe("The line number where this errors occurs."),
"column": z.int().describe("The column number where this errors occurs."),
"source": z.optional(z.string().describe("The contents of the line where the error occurs.")),
"kind": z.string().describe("The type of error."),
"suggestion": z.string().describe("Suggested action to fix the error. This will usually be `null`, but is provided for some common errors.").nullish(),
"message": z.string().describe("A human-readable description of the error, combining information from multiple fields, laid out for display in a monospaced typeface (for example, a command-line setting)."),
"path": z.string().describe("The path of the file where the error occured.")
    }))
    }).describe("A list of errors found in a repo's CODEOWNERS file")

/**
 * @description A description of the machine powering a codespace.
 */
export const codespaceMachineSchema = z.object({
    "name": z.string().describe("The name of the machine."),
"display_name": z.string().describe("The display name of the machine includes cores, memory, and storage."),
"operating_system": z.string().describe("The operating system of the machine."),
"storage_in_bytes": z.int().describe("How much storage is available to the codespace."),
"memory_in_bytes": z.int().describe("How much memory is available to the codespace."),
"cpus": z.int().describe("How many cores are available to the codespace."),
"prebuild_availability": z.nullable(z.enum(["none", "ready", "in_progress"]).describe("Whether a prebuild is currently available when creating a codespace for this machine and repository. If a branch was not specified as a ref, the default branch will be assumed. Value will be \"null\" if prebuilds are not supported or prebuild availability could not be determined. Value will be \"none\" if no prebuild is available. Latest values \"ready\" and \"in_progress\" indicate the prebuild availability status."))
    }).describe("A description of the machine powering a codespace.")

/**
 * @description Permission check result for a given devcontainer config.
 */
export const codespacesPermissionsCheckForDevcontainerSchema = z.object({
    "accepted": z.boolean().describe("Whether the user has accepted the permissions defined by the devcontainer config")
    }).describe("Permission check result for a given devcontainer config.")

/**
 * @description Set repository secrets for GitHub Codespaces.
 */
export const repoCodespacesSecretSchema = z.object({
    "name": z.string().describe("The name of the secret."),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true })
    }).describe("Set repository secrets for GitHub Codespaces.")

/**
 * @description Collaborator
 */
export const collaboratorSchema = z.object({
    "login": z.string(),
"id": z.int(),
"email": z.string().nullish(),
"name": z.string().nullish(),
"node_id": z.string(),
"avatar_url": z.url(),
"gravatar_id": z.nullable(z.string()),
"url": z.url(),
"html_url": z.url(),
"followers_url": z.url(),
"following_url": z.string(),
"gists_url": z.string(),
"starred_url": z.string(),
"subscriptions_url": z.url(),
"organizations_url": z.url(),
"repos_url": z.url(),
"events_url": z.string(),
"received_events_url": z.url(),
"type": z.string(),
"site_admin": z.boolean(),
"permissions": z.optional(z.object({
    "pull": z.boolean(),
"triage": z.optional(z.boolean()),
"push": z.boolean(),
"maintain": z.optional(z.boolean()),
"admin": z.boolean()
    })),
"role_name": z.string(),
"user_view_type": z.optional(z.string())
    }).describe("Collaborator")

/**
 * @description Repository invitations let you manage who you collaborate with.
 */
export const repositoryInvitationSchema = z.object({
    "id": z.int().describe("Unique identifier of the repository invitation."),
get "repository"(){
                return minimalRepositorySchema.describe("Minimal Repository")
              },
get "invitee"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
get "inviter"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"permissions": z.enum(["read", "write", "admin", "triage", "maintain"]).describe("The permission associated with the invitation."),
"created_at": z.iso.datetime({ offset: true }),
"expired": z.optional(z.boolean().describe("Whether or not the invitation has expired")),
"url": z.string().describe("URL for the repository invitation"),
"html_url": z.string(),
"node_id": z.string()
    }).describe("Repository invitations let you manage who you collaborate with.")

/**
 * @description Collaborator
 */
export const nullableCollaboratorSchema = z.object({
    "login": z.string(),
"id": z.int(),
"email": z.string().nullish(),
"name": z.string().nullish(),
"node_id": z.string(),
"avatar_url": z.url(),
"gravatar_id": z.nullable(z.string()),
"url": z.url(),
"html_url": z.url(),
"followers_url": z.url(),
"following_url": z.string(),
"gists_url": z.string(),
"starred_url": z.string(),
"subscriptions_url": z.url(),
"organizations_url": z.url(),
"repos_url": z.url(),
"events_url": z.string(),
"received_events_url": z.url(),
"type": z.string(),
"site_admin": z.boolean(),
"permissions": z.optional(z.object({
    "pull": z.boolean(),
"triage": z.optional(z.boolean()),
"push": z.boolean(),
"maintain": z.optional(z.boolean()),
"admin": z.boolean()
    })),
"role_name": z.string(),
"user_view_type": z.optional(z.string())
    }).describe("Collaborator").nullable()

/**
 * @description Repository Collaborator Permission
 */
export const repositoryCollaboratorPermissionSchema = z.object({
    "permission": z.string(),
"role_name": z.string(),
get "user"(){
               return nullableCollaboratorSchema.describe("Collaborator").nullable()
              }
    }).describe("Repository Collaborator Permission")

/**
 * @description Commit Comment
 */
export const commitCommentSchema = z.object({
    "html_url": z.url(),
"url": z.url(),
"id": z.int(),
"node_id": z.string(),
"body": z.string(),
"path": z.nullable(z.string()),
"position": z.nullable(z.int()),
"line": z.nullable(z.int()),
"commit_id": z.string(),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
get "author_association"(){
                return authorAssociationSchema.describe("How the author is associated with the repository.")
              },
get "reactions"(){
                return reactionRollupSchema.optional()
              }
    }).describe("Commit Comment")

/**
 * @description Branch Short
 */
export const branchShortSchema = z.object({
    "name": z.string(),
"commit": z.object({
    "sha": z.string(),
"url": z.string()
    }),
"protected": z.boolean()
    }).describe("Branch Short")

export const simpleCommitStatusSchema = z.object({
    "description": z.nullable(z.string()),
"id": z.int(),
"node_id": z.string(),
"state": z.string(),
"context": z.string(),
"target_url": z.nullable(z.url()),
"required": z.boolean().nullish(),
"avatar_url": z.nullable(z.url()),
"url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true })
    })

/**
 * @description Combined Commit Status
 */
export const combinedCommitStatusSchema = z.object({
    "state": z.string(),
get "statuses"(){
                return z.array(simpleCommitStatusSchema)
              },
"sha": z.string(),
"total_count": z.int(),
get "repository"(){
                return minimalRepositorySchema.describe("Minimal Repository")
              },
"commit_url": z.url(),
"url": z.url()
    }).describe("Combined Commit Status")

/**
 * @description The status of a commit.
 */
export const statusSchema = z.object({
    "url": z.string(),
"avatar_url": z.nullable(z.string()),
"id": z.int(),
"node_id": z.string(),
"state": z.string(),
"description": z.nullable(z.string()),
"target_url": z.nullable(z.string()),
"context": z.string(),
"created_at": z.string(),
"updated_at": z.string(),
get "creator"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              }
    }).describe("The status of a commit.")

/**
 * @description Code of Conduct Simple
 */
export const nullableCodeOfConductSimpleSchema = z.object({
    "url": z.url(),
"key": z.string(),
"name": z.string(),
"html_url": z.nullable(z.url())
    }).describe("Code of Conduct Simple").nullable()

export const nullableCommunityHealthFileSchema = z.object({
    "url": z.url(),
"html_url": z.url()
    }).nullable()

/**
 * @description Community Profile
 */
export const communityProfileSchema = z.object({
    "health_percentage": z.int(),
"description": z.nullable(z.string()),
"documentation": z.nullable(z.string()),
"files": z.object({
    get "code_of_conduct"(){
               return nullableCodeOfConductSimpleSchema.describe("Code of Conduct Simple").nullable()
              },
get "code_of_conduct_file"(){
               return nullableCommunityHealthFileSchema.nullable()
              },
get "license"(){
               return nullableLicenseSimpleSchema.describe("License Simple").nullable()
              },
get "contributing"(){
               return nullableCommunityHealthFileSchema.nullable()
              },
get "readme"(){
               return nullableCommunityHealthFileSchema.nullable()
              },
get "issue_template"(){
               return nullableCommunityHealthFileSchema.nullable()
              },
get "pull_request_template"(){
               return nullableCommunityHealthFileSchema.nullable()
              }
    }),
"updated_at": z.nullable(z.iso.datetime({ offset: true })),
"content_reports_enabled": z.optional(z.boolean())
    }).describe("Community Profile")

/**
 * @description Commit Comparison
 */
export const commitComparisonSchema = z.object({
    "url": z.url(),
"html_url": z.url(),
"permalink_url": z.url(),
"diff_url": z.url(),
"patch_url": z.url(),
get "base_commit"(){
                return commitSchema.describe("Commit")
              },
get "merge_base_commit"(){
                return commitSchema.describe("Commit")
              },
"status": z.enum(["diverged", "ahead", "behind", "identical"]),
"ahead_by": z.int(),
"behind_by": z.int(),
"total_commits": z.int(),
get "commits"(){
                return z.array(commitSchema.describe("Commit"))
              },
get "files"(){
                return z.array(diffEntrySchema.describe("Diff Entry")).optional()
              }
    }).describe("Commit Comparison")

/**
 * @description Content Tree
 */
export const contentTreeSchema = z.object({
    "type": z.string(),
"size": z.int(),
"name": z.string(),
"path": z.string(),
"sha": z.string(),
"content": z.optional(z.string()),
"url": z.url(),
"git_url": z.nullable(z.url()),
"html_url": z.nullable(z.url()),
"download_url": z.nullable(z.url()),
"entries": z.optional(z.array(z.object({
    "type": z.string(),
"size": z.int(),
"name": z.string(),
"path": z.string(),
"sha": z.string(),
"url": z.url(),
"git_url": z.nullable(z.url()),
"html_url": z.nullable(z.url()),
"download_url": z.nullable(z.url()),
"_links": z.object({
    "git": z.nullable(z.url()),
"html": z.nullable(z.url()),
"self": z.url()
    })
    }))),
"encoding": z.optional(z.string()),
"_links": z.object({
    "git": z.nullable(z.url()),
"html": z.nullable(z.url()),
"self": z.url()
    })
    }).describe("Content Tree")

/**
 * @description A list of directory items
 */
export const contentDirectorySchema = z.array(z.object({
    "type": z.enum(["dir", "file", "submodule", "symlink"]),
"size": z.int(),
"name": z.string(),
"path": z.string(),
"content": z.optional(z.string()),
"sha": z.string(),
"url": z.url(),
"git_url": z.nullable(z.url()),
"html_url": z.nullable(z.url()),
"download_url": z.nullable(z.url()),
"_links": z.object({
    "git": z.nullable(z.url()),
"html": z.nullable(z.url()),
"self": z.url()
    })
    })).describe("A list of directory items")

/**
 * @description Content File
 */
export const contentFileSchema = z.object({
    "type": z.enum(["file"]),
"encoding": z.string(),
"size": z.int(),
"name": z.string(),
"path": z.string(),
"content": z.string(),
"sha": z.string(),
"url": z.url(),
"git_url": z.nullable(z.url()),
"html_url": z.nullable(z.url()),
"download_url": z.nullable(z.url()),
"_links": z.object({
    "git": z.nullable(z.url()),
"html": z.nullable(z.url()),
"self": z.url()
    }),
"target": z.optional(z.string()),
"submodule_git_url": z.optional(z.string())
    }).describe("Content File")

/**
 * @description An object describing a symlink
 */
export const contentSymlinkSchema = z.object({
    "type": z.enum(["symlink"]),
"target": z.string(),
"size": z.int(),
"name": z.string(),
"path": z.string(),
"sha": z.string(),
"url": z.url(),
"git_url": z.nullable(z.url()),
"html_url": z.nullable(z.url()),
"download_url": z.nullable(z.url()),
"_links": z.object({
    "git": z.nullable(z.url()),
"html": z.nullable(z.url()),
"self": z.url()
    })
    }).describe("An object describing a symlink")

/**
 * @description An object describing a submodule
 */
export const contentSubmoduleSchema = z.object({
    "type": z.enum(["submodule"]),
"submodule_git_url": z.url(),
"size": z.int(),
"name": z.string(),
"path": z.string(),
"sha": z.string(),
"url": z.url(),
"git_url": z.nullable(z.url()),
"html_url": z.nullable(z.url()),
"download_url": z.nullable(z.url()),
"_links": z.object({
    "git": z.nullable(z.url()),
"html": z.nullable(z.url()),
"self": z.url()
    })
    }).describe("An object describing a submodule")

/**
 * @description File Commit
 */
export const fileCommitSchema = z.object({
    "content": z.nullable(z.object({
    "name": z.optional(z.string()),
"path": z.optional(z.string()),
"sha": z.optional(z.string()),
"size": z.optional(z.int()),
"url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"git_url": z.optional(z.string()),
"download_url": z.optional(z.string()),
"type": z.optional(z.string()),
"_links": z.optional(z.object({
    "self": z.optional(z.string()),
"git": z.optional(z.string()),
"html": z.optional(z.string())
    }))
    })),
"commit": z.object({
    "sha": z.optional(z.string()),
"node_id": z.optional(z.string()),
"url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"author": z.optional(z.object({
    "date": z.optional(z.string()),
"name": z.optional(z.string()),
"email": z.optional(z.string())
    })),
"committer": z.optional(z.object({
    "date": z.optional(z.string()),
"name": z.optional(z.string()),
"email": z.optional(z.string())
    })),
"message": z.optional(z.string()),
"tree": z.optional(z.object({
    "url": z.optional(z.string()),
"sha": z.optional(z.string())
    })),
"parents": z.optional(z.array(z.object({
    "url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"sha": z.optional(z.string())
    }))),
"verification": z.optional(z.object({
    "verified": z.optional(z.boolean()),
"reason": z.optional(z.string()),
"signature": z.string().nullish(),
"payload": z.string().nullish(),
"verified_at": z.string().nullish()
    }))
    })
    }).describe("File Commit")

/**
 * @description The ID of the push protection bypass placeholder. This value is returned on any push protected routes.
 */
export const secretScanningPushProtectionBypassPlaceholderIdSchema = z.string().describe("The ID of the push protection bypass placeholder. This value is returned on any push protected routes.")

/**
 * @description Repository rule violation was detected
 */
export const repositoryRuleViolationErrorSchema = z.object({
    "message": z.optional(z.string()),
"documentation_url": z.optional(z.string()),
"status": z.optional(z.string()),
"metadata": z.optional(z.object({
    "secret_scanning": z.optional(z.object({
    "bypass_placeholders": z.optional(z.array(z.object({
    get "placeholder_id"(){
                return secretScanningPushProtectionBypassPlaceholderIdSchema.describe("The ID of the push protection bypass placeholder. This value is returned on any push protected routes.").optional()
              },
"token_type": z.optional(z.string())
    })))
    }))
    }))
    }).describe("Repository rule violation was detected")

/**
 * @description Contributor
 */
export const contributorSchema = z.object({
    "login": z.optional(z.string()),
"id": z.optional(z.int()),
"node_id": z.optional(z.string()),
"avatar_url": z.optional(z.url()),
"gravatar_id": z.string().nullish(),
"url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"organizations_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"events_url": z.optional(z.string()),
"received_events_url": z.optional(z.url()),
"type": z.string(),
"site_admin": z.optional(z.boolean()),
"contributions": z.int(),
"email": z.optional(z.string()),
"name": z.optional(z.string()),
"user_view_type": z.optional(z.string())
    }).describe("Contributor")

/**
 * @description A Dependabot alert.
 */
export const dependabotAlertSchema = z.object({
    get "number"(){
                return alertNumberSchema.describe("The security alert number.")
              },
"state": z.enum(["auto_dismissed", "dismissed", "fixed", "open"]).describe("The state of the Dependabot alert."),
"dependency": z.object({
    get "package"(){
                return dependabotAlertPackageSchema.describe("Details for the vulnerable package.").optional()
              },
"manifest_path": z.optional(z.string().describe("The full path to the dependency manifest file, relative to the root of the repository.")),
"scope": z.enum(["development", "runtime"]).describe("The execution scope of the vulnerable dependency.").nullish(),
"relationship": z.enum(["unknown", "direct", "transitive"]).describe("The vulnerable dependency's relationship to your project.\n\n> [!NOTE]\n> We are rolling out support for dependency relationship across ecosystems. This value will be \"unknown\" for all dependencies in unsupported ecosystems.\n").nullish()
    }).describe("Details for the vulnerable dependency."),
get "security_advisory"(){
                return dependabotAlertSecurityAdvisorySchema.describe("Details for the GitHub Security Advisory.")
              },
get "security_vulnerability"(){
                return dependabotAlertSecurityVulnerabilitySchema.describe("Details pertaining to one vulnerable version range for the advisory.")
              },
get "url"(){
                return alertUrlSchema.describe("The REST API URL of the alert resource.")
              },
get "html_url"(){
                return alertHtmlUrlSchema.describe("The GitHub URL of the alert resource.")
              },
get "created_at"(){
                return alertCreatedAtSchema.describe("The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.")
              },
get "updated_at"(){
                return alertUpdatedAtSchema.describe("The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.")
              },
get "dismissed_at"(){
               return alertDismissedAtSchema.describe("The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullable()
              },
get "dismissed_by"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"dismissed_reason": z.nullable(z.enum(["fix_started", "inaccurate", "no_bandwidth", "not_used", "tolerable_risk"]).describe("The reason that the alert was dismissed.")),
"dismissed_comment": z.nullable(z.string().max(280).describe("An optional comment associated with the alert's dismissal.")),
get "fixed_at"(){
               return alertFixedAtSchema.describe("The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullable()
              },
get "auto_dismissed_at"(){
                return alertAutoDismissedAtSchema.describe("The time that the alert was auto-dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").optional()
              }
    }).describe("A Dependabot alert.")

/**
 * @description Set secrets for Dependabot.
 */
export const dependabotSecretSchema = z.object({
    "name": z.string().describe("The name of the secret."),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true })
    }).describe("Set secrets for Dependabot.")

/**
 * @description A diff of the dependencies between two commits.
 */
export const dependencyGraphDiffSchema = z.array(z.object({
    "change_type": z.enum(["added", "removed"]),
"manifest": z.string(),
"ecosystem": z.string(),
"name": z.string(),
"version": z.string(),
"package_url": z.nullable(z.string()),
"license": z.nullable(z.string()),
"source_repository_url": z.nullable(z.string()),
"vulnerabilities": z.array(z.object({
    "severity": z.string(),
"advisory_ghsa_id": z.string(),
"advisory_summary": z.string(),
"advisory_url": z.string()
    })),
"scope": z.enum(["unknown", "runtime", "development"]).describe("Where the dependency is utilized. `development` means that the dependency is only utilized in the development environment. `runtime` means that the dependency is utilized at runtime and in the development environment.")
    })).describe("A diff of the dependencies between two commits.")

/**
 * @description A schema for the SPDX JSON format returned by the Dependency Graph.
 */
export const dependencyGraphSpdxSbomSchema = z.object({
    "sbom": z.object({
    "SPDXID": z.string().describe("The SPDX identifier for the SPDX document."),
"spdxVersion": z.string().describe("The version of the SPDX specification that this document conforms to."),
"comment": z.optional(z.string().describe("An optional comment about the SPDX document.")),
"creationInfo": z.object({
    "created": z.string().describe("The date and time the SPDX document was created."),
"creators": z.array(z.string()).describe("The tools that were used to generate the SPDX document.")
    }),
"name": z.string().describe("The name of the SPDX document."),
"dataLicense": z.string().describe("The license under which the SPDX document is licensed."),
"documentNamespace": z.string().describe("The namespace for the SPDX document."),
"packages": z.array(z.object({
    "SPDXID": z.optional(z.string().describe("A unique SPDX identifier for the package.")),
"name": z.optional(z.string().describe("The name of the package.")),
"versionInfo": z.optional(z.string().describe("The version of the package. If the package does not have an exact version specified,\na version range is given.")),
"downloadLocation": z.optional(z.string().describe("The location where the package can be downloaded,\nor NOASSERTION if this has not been determined.")),
"filesAnalyzed": z.optional(z.boolean().describe("Whether the package's file content has been subjected to\nanalysis during the creation of the SPDX document.")),
"licenseConcluded": z.optional(z.string().describe("The license of the package as determined while creating the SPDX document.")),
"licenseDeclared": z.optional(z.string().describe("The license of the package as declared by its author, or NOASSERTION if this information\nwas not available when the SPDX document was created.")),
"supplier": z.optional(z.string().describe("The distribution source of this package, or NOASSERTION if this was not determined.")),
"copyrightText": z.optional(z.string().describe("The copyright holders of the package, and any dates present with those notices, if available.")),
"externalRefs": z.optional(z.array(z.object({
    "referenceCategory": z.string().describe("The category of reference to an external resource this reference refers to."),
"referenceLocator": z.string().describe("A locator for the particular external resource this reference refers to."),
"referenceType": z.string().describe("The category of reference to an external resource this reference refers to.")
    })))
    })),
"relationships": z.optional(z.array(z.object({
    "relationshipType": z.optional(z.string().describe("The type of relationship between the two SPDX elements.")),
"spdxElementId": z.optional(z.string().describe("The SPDX identifier of the package that is the source of the relationship.")),
"relatedSpdxElement": z.optional(z.string().describe("The SPDX identifier of the package that is the target of the relationship."))
    })))
    })
    }).describe("A schema for the SPDX JSON format returned by the Dependency Graph.")

/**
 * @description User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
 */
export const metadataSchema = z.object({
    
    }).catchall(z.union([z.boolean(), z.string(), z.number()]).nullable()).describe("User-defined metadata to store domain-specific information limited to 8 keys with scalar values.")

export const dependencySchema = z.object({
    "package_url": z.optional(z.string().regex(/^pkg/).describe("Package-url (PURL) of dependency. See https://github.com/package-url/purl-spec for more details.")),
get "metadata"(){
                return metadataSchema.describe("User-defined metadata to store domain-specific information limited to 8 keys with scalar values.").optional()
              },
"relationship": z.optional(z.enum(["direct", "indirect"]).describe("A notation of whether a dependency is requested directly by this manifest or is a dependency of another dependency.")),
"scope": z.optional(z.enum(["runtime", "development"]).describe("A notation of whether the dependency is required for the primary build artifact (runtime) or is only used for development. Future versions of this specification may allow for more granular scopes.")),
"dependencies": z.optional(z.array(z.string()).describe("Array of package-url (PURLs) of direct child dependencies."))
    })

export const manifestSchema = z.object({
    "name": z.string().describe("The name of the manifest."),
"file": z.optional(z.object({
    "source_location": z.optional(z.string().describe("The path of the manifest file relative to the root of the Git repository."))
    })),
get "metadata"(){
                return metadataSchema.describe("User-defined metadata to store domain-specific information limited to 8 keys with scalar values.").optional()
              },
"resolved": z.optional(z.object({
    
    }).catchall(z.lazy(() => dependencySchema)).describe("A collection of resolved package dependencies."))
    })

/**
 * @description Create a new snapshot of a repository\'s dependencies.
 */
export const snapshotSchema = z.object({
    "version": z.int().describe("The version of the repository snapshot submission."),
"job": z.object({
    "id": z.string().describe("The external ID of the job."),
"correlator": z.string().describe("Correlator provides a key that is used to group snapshots submitted over time. Only the \"latest\" submitted snapshot for a given combination of `job.correlator` and `detector.name` will be considered when calculating a repository's current dependencies. Correlator should be as unique as it takes to distinguish all detection runs for a given \"wave\" of CI workflow you run. If you're using GitHub Actions, a good default value for this could be the environment variables GITHUB_WORKFLOW and GITHUB_JOB concatenated together. If you're using a build matrix, then you'll also need to add additional key(s) to distinguish between each submission inside a matrix variation."),
"html_url": z.optional(z.string().describe("The url for the job."))
    }),
"sha": z.string().min(40).max(40).describe("The commit SHA associated with this dependency snapshot. Maximum length: 40 characters."),
"ref": z.string().regex(/^refs/).describe("The repository branch that triggered this snapshot."),
"detector": z.object({
    "name": z.string().describe("The name of the detector used."),
"version": z.string().describe("The version of the detector used."),
"url": z.string().describe("The url of the detector used.")
    }).describe("A description of the detector used."),
get "metadata"(){
                return metadataSchema.describe("User-defined metadata to store domain-specific information limited to 8 keys with scalar values.").optional()
              },
"manifests": z.optional(z.object({
    
    }).catchall(z.lazy(() => manifestSchema)).describe("A collection of package manifests, which are a collection of related dependencies declared in a file or representing a logical group of dependencies.")),
"scanned": z.iso.datetime({ offset: true }).describe("The time at which the snapshot was scanned.")
    }).describe("Create a new snapshot of a repository's dependencies.")

/**
 * @description The status of a deployment.
 */
export const deploymentStatusSchema = z.object({
    "url": z.url(),
"id": z.int(),
"node_id": z.string(),
"state": z.enum(["error", "failure", "inactive", "pending", "success", "queued", "in_progress"]).describe("The state of the status."),
get "creator"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"description": z.string().max(140).default("").describe("A short description of the status."),
"environment": z.optional(z.string().default("").describe("The environment of the deployment that the status is for.")),
"target_url": z.url().default("").describe("Closing down notice: the URL to associate with this status."),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"deployment_url": z.url(),
"repository_url": z.url(),
"environment_url": z.optional(z.url().default("").describe("The URL for accessing your environment.")),
"log_url": z.optional(z.url().default("").describe("The URL to associate with this status.")),
get "performed_via_github_app"(){
                return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").optional()
              }
    }).describe("The status of a deployment.")

/**
 * @description The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days).
 */
export const waitTimerSchema = z.int().describe("The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days).")

/**
 * @description The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.
 */
export const deploymentBranchPolicySettingsSchema = z.object({
    "protected_branches": z.boolean().describe("Whether only branches with branch protection rules can deploy to this environment. If `protected_branches` is `true`, `custom_branch_policies` must be `false`; if `protected_branches` is `false`, `custom_branch_policies` must be `true`."),
"custom_branch_policies": z.boolean().describe("Whether only branches that match the specified name patterns can deploy to this environment.  If `custom_branch_policies` is `true`, `protected_branches` must be `false`; if `custom_branch_policies` is `false`, `protected_branches` must be `true`.")
    }).describe("The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.").nullable()

/**
 * @description Details of a deployment environment
 */
export const environmentSchema = z.object({
    "id": z.int().describe("The id of the environment."),
"node_id": z.string(),
"name": z.string().describe("The name of the environment."),
"url": z.string(),
"html_url": z.string(),
"created_at": z.iso.datetime({ offset: true }).describe("The time that the environment was created, in ISO 8601 format."),
"updated_at": z.iso.datetime({ offset: true }).describe("The time that the environment was last updated, in ISO 8601 format."),
"protection_rules": z.optional(z.array(z.union([z.object({
    "id": z.int(),
"node_id": z.string(),
"type": z.string(),
get "wait_timer"(){
                return waitTimerSchema.describe("The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days).").optional()
              }
    }), z.object({
    "id": z.int(),
"node_id": z.string(),
"prevent_self_review": z.optional(z.boolean().describe("Whether deployments to this environment can be approved by the user who created the deployment.")),
"type": z.string(),
"reviewers": z.optional(z.array(z.object({
    get "type"(){
                return deploymentReviewerTypeSchema.describe("The type of reviewer.").optional()
              },
get "reviewer"(){
                return z.union([simpleUserSchema, teamSchema]).optional()
              }
    })).describe("The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed."))
    }), z.object({
    "id": z.int(),
"node_id": z.string(),
"type": z.string()
    })])).describe("Built-in deployment protection rules for the environment.")),
get "deployment_branch_policy"(){
                return deploymentBranchPolicySettingsSchema.describe("The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.").optional()
              }
    }).describe("Details of a deployment environment")

/**
 * @description Whether or not a user who created the job is prevented from approving their own job.
 */
export const preventSelfReviewSchema = z.boolean().describe("Whether or not a user who created the job is prevented from approving their own job.")

/**
 * @description Details of a deployment branch or tag policy.
 */
export const deploymentBranchPolicySchema = z.object({
    "id": z.optional(z.int().describe("The unique identifier of the branch or tag policy.")),
"node_id": z.optional(z.string()),
"name": z.optional(z.string().describe("The name pattern that branches or tags must match in order to deploy to the environment.")),
"type": z.optional(z.enum(["branch", "tag"]).describe("Whether this rule targets a branch or tag."))
    }).describe("Details of a deployment branch or tag policy.")

export const deploymentBranchPolicyNamePatternWithTypeSchema = z.object({
    "name": z.string().describe("The name pattern that branches or tags must match in order to deploy to the environment.\n\nWildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.\nFor more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch)."),
"type": z.optional(z.enum(["branch", "tag"]).describe("Whether this rule targets a branch or tag"))
    })

export const deploymentBranchPolicyNamePatternSchema = z.object({
    "name": z.string().describe("The name pattern that branches must match in order to deploy to the environment.\n\nWildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.\nFor more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).")
    })

/**
 * @description A GitHub App that is providing a custom deployment protection rule.
 */
export const customDeploymentRuleAppSchema = z.object({
    "id": z.int().describe("The unique identifier of the deployment protection rule integration."),
"slug": z.string().describe("The slugified name of the deployment protection rule integration."),
"integration_url": z.string().describe("The URL for the endpoint to get details about the app."),
"node_id": z.string().describe("The node ID for the deployment protection rule integration.")
    }).describe("A GitHub App that is providing a custom deployment protection rule.")

/**
 * @description Deployment protection rule
 */
export const deploymentProtectionRuleSchema = z.object({
    "id": z.int().describe("The unique identifier for the deployment protection rule."),
"node_id": z.string().describe("The node ID for the deployment protection rule."),
"enabled": z.boolean().describe("Whether the deployment protection rule is enabled for the environment."),
get "app"(){
                return customDeploymentRuleAppSchema.describe("A GitHub App that is providing a custom deployment protection rule.")
              }
    }).describe("Deployment protection rule")

/**
 * @description Short Blob
 */
export const shortBlobSchema = z.object({
    "url": z.string(),
"sha": z.string()
    }).describe("Short Blob")

/**
 * @description Blob
 */
export const blobSchema = z.object({
    "content": z.string(),
"encoding": z.string(),
"url": z.url(),
"sha": z.string(),
"size": z.nullable(z.int()),
"node_id": z.string(),
"highlighted_content": z.optional(z.string())
    }).describe("Blob")

/**
 * @description Low-level Git commit operations within a repository
 */
export const gitCommitSchema = z.object({
    "sha": z.string().describe("SHA for the commit"),
"node_id": z.string(),
"url": z.url(),
"author": z.object({
    "date": z.iso.datetime({ offset: true }).describe("Timestamp of the commit"),
"email": z.string().describe("Git email address of the user"),
"name": z.string().describe("Name of the git user")
    }).describe("Identifying information for the git-user"),
"committer": z.object({
    "date": z.iso.datetime({ offset: true }).describe("Timestamp of the commit"),
"email": z.string().describe("Git email address of the user"),
"name": z.string().describe("Name of the git user")
    }).describe("Identifying information for the git-user"),
"message": z.string().describe("Message describing the purpose of the commit"),
"tree": z.object({
    "sha": z.string().describe("SHA for the commit"),
"url": z.url()
    }),
"parents": z.array(z.object({
    "sha": z.string().describe("SHA for the commit"),
"url": z.url(),
"html_url": z.url()
    })),
"verification": z.object({
    "verified": z.boolean(),
"reason": z.string(),
"signature": z.nullable(z.string()),
"payload": z.nullable(z.string()),
"verified_at": z.nullable(z.string())
    }),
"html_url": z.url()
    }).describe("Low-level Git commit operations within a repository")

/**
 * @description Git references within a repository
 */
export const gitRefSchema = z.object({
    "ref": z.string(),
"node_id": z.string(),
"url": z.url(),
"object": z.object({
    "type": z.string(),
"sha": z.string().min(40).max(40).describe("SHA for the reference"),
"url": z.url()
    })
    }).describe("Git references within a repository")

/**
 * @description Metadata for a Git tag
 */
export const gitTagSchema = z.object({
    "node_id": z.string(),
"tag": z.string().describe("Name of the tag"),
"sha": z.string(),
"url": z.url().describe("URL for the tag"),
"message": z.string().describe("Message describing the purpose of the tag"),
"tagger": z.object({
    "date": z.string(),
"email": z.string(),
"name": z.string()
    }),
"object": z.object({
    "sha": z.string(),
"type": z.string(),
"url": z.url()
    }),
get "verification"(){
                return verificationSchema.optional()
              }
    }).describe("Metadata for a Git tag")

/**
 * @description The hierarchy between files in a Git repository.
 */
export const gitTreeSchema = z.object({
    "sha": z.string(),
"url": z.optional(z.url()),
"truncated": z.boolean(),
"tree": z.array(z.object({
    "path": z.string(),
"mode": z.string(),
"type": z.string(),
"sha": z.string(),
"size": z.optional(z.int()),
"url": z.optional(z.string())
    })).describe("Objects specifying a tree structure")
    }).describe("The hierarchy between files in a Git repository.")

export const hookResponseSchema = z.object({
    "code": z.nullable(z.int()),
"status": z.nullable(z.string()),
"message": z.nullable(z.string())
    })

/**
 * @description Webhooks for repositories.
 */
export const hookSchema = z.object({
    "type": z.string(),
"id": z.int().describe("Unique identifier of the webhook."),
"name": z.string().describe("The name of a valid service, use 'web' for a webhook."),
"active": z.boolean().describe("Determines whether the hook is actually triggered on pushes."),
"events": z.array(z.string()).describe("Determines what events the hook is triggered for. Default: ['push']."),
get "config"(){
                return webhookConfigSchema.describe("Configuration object of the webhook")
              },
"updated_at": z.iso.datetime({ offset: true }),
"created_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"test_url": z.url(),
"ping_url": z.url(),
"deliveries_url": z.optional(z.url()),
get "last_response"(){
                return hookResponseSchema
              }
    }).describe("Webhooks for repositories.")

/**
 * @description Check immutable releases
 */
export const checkImmutableReleasesSchema = z.object({
    "enabled": z.boolean().describe("Whether immutable releases are enabled for the repository."),
"enforced_by_owner": z.boolean().describe("Whether immutable releases are enforced by the repository owner.")
    }).describe("Check immutable releases")

/**
 * @description A repository import from an external source.
 */
export const importSchema = z.object({
    "vcs": z.nullable(z.string()),
"use_lfs": z.optional(z.boolean()),
"vcs_url": z.string().describe("The URL of the originating repository."),
"svc_root": z.optional(z.string()),
"tfvc_project": z.optional(z.string()),
"status": z.enum(["auth", "error", "none", "detecting", "choose", "auth_failed", "importing", "mapping", "waiting_to_push", "pushing", "complete", "setup", "unknown", "detection_found_multiple", "detection_found_nothing", "detection_needs_auth"]),
"status_text": z.string().nullish(),
"failed_step": z.string().nullish(),
"error_message": z.string().nullish(),
"import_percent": z.int().nullish(),
"commit_count": z.int().nullish(),
"push_percent": z.int().nullish(),
"has_large_files": z.optional(z.boolean()),
"large_files_size": z.optional(z.int()),
"large_files_count": z.optional(z.int()),
"project_choices": z.optional(z.array(z.object({
    "vcs": z.optional(z.string()),
"tfvc_project": z.optional(z.string()),
"human_name": z.optional(z.string())
    }))),
"message": z.optional(z.string()),
"authors_count": z.int().nullish(),
"url": z.url(),
"html_url": z.url(),
"authors_url": z.url(),
"repository_url": z.url(),
"svn_root": z.optional(z.string())
    }).describe("A repository import from an external source.")

/**
 * @description Porter Author
 */
export const porterAuthorSchema = z.object({
    "id": z.int(),
"remote_id": z.string(),
"remote_name": z.string(),
"email": z.string(),
"name": z.string(),
"url": z.url(),
"import_url": z.url()
    }).describe("Porter Author")

/**
 * @description Porter Large File
 */
export const porterLargeFileSchema = z.object({
    "ref_name": z.string(),
"path": z.string(),
"oid": z.string(),
"size": z.int()
    }).describe("Porter Large File")

/**
 * @description Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
 */
export const nullableIssueSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.url().describe("URL for the issue"),
"repository_url": z.url(),
"labels_url": z.string(),
"comments_url": z.url(),
"events_url": z.url(),
"html_url": z.url(),
"number": z.int().describe("Number uniquely identifying the issue within its repository"),
"state": z.string().describe("State of the issue; either 'open' or 'closed'"),
"state_reason": z.enum(["completed", "reopened", "not_planned", "duplicate"]).describe("The reason for the current state").nullish(),
"title": z.string().describe("Title of the issue"),
"body": z.string().describe("Contents of the issue").nullish(),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"labels": z.array(z.union([z.string(), z.object({
    "id": z.optional(z.int()),
"node_id": z.optional(z.string()),
"url": z.optional(z.url()),
"name": z.optional(z.string()),
"description": z.string().nullish(),
"color": z.string().nullish(),
"default": z.optional(z.boolean())
    })])).describe("Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository"),
get "assignee"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
get "assignees"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).nullish()
              },
get "milestone"(){
               return nullableMilestoneSchema.describe("A collection of related issues and pull requests.").nullable()
              },
"locked": z.boolean(),
"active_lock_reason": z.string().nullish(),
"comments": z.int(),
"pull_request": z.optional(z.object({
    "merged_at": z.iso.datetime({ offset: true }).nullish(),
"diff_url": z.nullable(z.url()),
"html_url": z.nullable(z.url()),
"patch_url": z.nullable(z.url()),
"url": z.nullable(z.url())
    })),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"draft": z.optional(z.boolean()),
get "closed_by"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
"body_html": z.optional(z.string()),
"body_text": z.optional(z.string()),
"timeline_url": z.optional(z.url()),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
get "repository"(){
                return repositorySchema.describe("A repository on GitHub.").optional()
              },
get "performed_via_github_app"(){
                return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").optional()
              },
get "author_association"(){
                return authorAssociationSchema.describe("How the author is associated with the repository.").optional()
              },
get "reactions"(){
                return reactionRollupSchema.optional()
              },
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
"parent_issue_url": z.url().describe("URL to get the parent issue of this issue, if it is a sub-issue").nullish(),
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              }
    }).describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.").nullable()

/**
 * @description Issue Event Label
 */
export const issueEventLabelSchema = z.object({
    "name": z.nullable(z.string()),
"color": z.nullable(z.string())
    }).describe("Issue Event Label")

export const issueEventDismissedReviewSchema = z.object({
    "state": z.string(),
"review_id": z.int(),
"dismissal_message": z.nullable(z.string()),
"dismissal_commit_id": z.string().nullish()
    })

/**
 * @description Issue Event Milestone
 */
export const issueEventMilestoneSchema = z.object({
    "title": z.string()
    }).describe("Issue Event Milestone")

/**
 * @description Issue Event Project Card
 */
export const issueEventProjectCardSchema = z.object({
    "url": z.url(),
"id": z.int(),
"project_url": z.url(),
"project_id": z.int(),
"column_name": z.string(),
"previous_column_name": z.optional(z.string())
    }).describe("Issue Event Project Card")

/**
 * @description Issue Event Rename
 */
export const issueEventRenameSchema = z.object({
    "from": z.string(),
"to": z.string()
    }).describe("Issue Event Rename")

/**
 * @description Issue Event
 */
export const issueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.url(),
get "actor"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.iso.datetime({ offset: true }),
get "issue"(){
                return nullableIssueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.").optional()
              },
get "label"(){
                return issueEventLabelSchema.describe("Issue Event Label").optional()
              },
get "assignee"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
get "assigner"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
get "review_requester"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
get "requested_reviewer"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
get "requested_team"(){
                return teamSchema.describe("Groups of organization members that gives permissions on specified repositories.").optional()
              },
get "dismissed_review"(){
                return issueEventDismissedReviewSchema.optional()
              },
get "milestone"(){
                return issueEventMilestoneSchema.describe("Issue Event Milestone").optional()
              },
get "project_card"(){
                return issueEventProjectCardSchema.describe("Issue Event Project Card").optional()
              },
get "rename"(){
                return issueEventRenameSchema.describe("Issue Event Rename").optional()
              },
get "author_association"(){
                return authorAssociationSchema.describe("How the author is associated with the repository.").optional()
              },
"lock_reason": z.string().nullish(),
get "performed_via_github_app"(){
                return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").optional()
              }
    }).describe("Issue Event")

/**
 * @description Labeled Issue Event
 */
export const labeledIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
"label": z.object({
    "name": z.string(),
"color": z.string()
    })
    }).describe("Labeled Issue Event")

/**
 * @description Unlabeled Issue Event
 */
export const unlabeledIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
"label": z.object({
    "name": z.string(),
"color": z.string()
    })
    }).describe("Unlabeled Issue Event")

/**
 * @description Assigned Issue Event
 */
export const assignedIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return integrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
get "assignee"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "assigner"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    }).describe("Assigned Issue Event")

/**
 * @description Unassigned Issue Event
 */
export const unassignedIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
get "assignee"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "assigner"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    }).describe("Unassigned Issue Event")

/**
 * @description Milestoned Issue Event
 */
export const milestonedIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
"milestone": z.object({
    "title": z.string()
    })
    }).describe("Milestoned Issue Event")

/**
 * @description Demilestoned Issue Event
 */
export const demilestonedIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
"milestone": z.object({
    "title": z.string()
    })
    }).describe("Demilestoned Issue Event")

/**
 * @description Renamed Issue Event
 */
export const renamedIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
"rename": z.object({
    "from": z.string(),
"to": z.string()
    })
    }).describe("Renamed Issue Event")

/**
 * @description Review Requested Issue Event
 */
export const reviewRequestedIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
get "review_requester"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "requested_team"(){
                return teamSchema.describe("Groups of organization members that gives permissions on specified repositories.").optional()
              },
get "requested_reviewer"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    }).describe("Review Requested Issue Event")

/**
 * @description Review Request Removed Issue Event
 */
export const reviewRequestRemovedIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
get "review_requester"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "requested_team"(){
                return teamSchema.describe("Groups of organization members that gives permissions on specified repositories.").optional()
              },
get "requested_reviewer"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    }).describe("Review Request Removed Issue Event")

/**
 * @description Review Dismissed Issue Event
 */
export const reviewDismissedIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
"dismissed_review": z.object({
    "state": z.string(),
"review_id": z.int(),
"dismissal_message": z.nullable(z.string()),
"dismissal_commit_id": z.optional(z.string())
    })
    }).describe("Review Dismissed Issue Event")

/**
 * @description Locked Issue Event
 */
export const lockedIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
"lock_reason": z.nullable(z.string())
    }).describe("Locked Issue Event")

/**
 * @description Added to Project Issue Event
 */
export const addedToProjectIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
"project_card": z.optional(z.object({
    "id": z.int(),
"url": z.url(),
"project_id": z.int(),
"project_url": z.url(),
"column_name": z.string(),
"previous_column_name": z.optional(z.string())
    }))
    }).describe("Added to Project Issue Event")

/**
 * @description Moved Column in Project Issue Event
 */
export const movedColumnInProjectIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
"project_card": z.optional(z.object({
    "id": z.int(),
"url": z.url(),
"project_id": z.int(),
"project_url": z.url(),
"column_name": z.string(),
"previous_column_name": z.optional(z.string())
    }))
    }).describe("Moved Column in Project Issue Event")

/**
 * @description Removed from Project Issue Event
 */
export const removedFromProjectIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
"project_card": z.optional(z.object({
    "id": z.int(),
"url": z.url(),
"project_id": z.int(),
"project_url": z.url(),
"column_name": z.string(),
"previous_column_name": z.optional(z.string())
    }))
    }).describe("Removed from Project Issue Event")

/**
 * @description Converted Note to Issue Issue Event
 */
export const convertedNoteToIssueIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return integrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
"project_card": z.optional(z.object({
    "id": z.int(),
"url": z.url(),
"project_id": z.int(),
"project_url": z.url(),
"column_name": z.string(),
"previous_column_name": z.optional(z.string())
    }))
    }).describe("Converted Note to Issue Issue Event")

/**
 * @description Issue Event for Issue
 */
export const issueEventForIssueSchema = z.union([labeledIssueEventSchema, unlabeledIssueEventSchema, assignedIssueEventSchema, unassignedIssueEventSchema, milestonedIssueEventSchema, demilestonedIssueEventSchema, renamedIssueEventSchema, reviewRequestedIssueEventSchema, reviewRequestRemovedIssueEventSchema, reviewDismissedIssueEventSchema, lockedIssueEventSchema, addedToProjectIssueEventSchema, movedColumnInProjectIssueEventSchema, removedFromProjectIssueEventSchema, convertedNoteToIssueIssueEventSchema]).describe("Issue Event for Issue")

/**
 * @description Color-coded labels help you categorize and filter your issues (just like labels in Gmail).
 */
export const labelSchema = z.object({
    "id": z.int().describe("Unique identifier for the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label"),
"name": z.string().describe("The name of the label."),
"description": z.nullable(z.string().describe("Optional description of the label, such as its purpose.")),
"color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean().describe("Whether this label comes by default in a new repository.")
    }).describe("Color-coded labels help you categorize and filter your issues (just like labels in Gmail).")

/**
 * @description Timeline Comment Event
 */
export const timelineCommentEventSchema = z.object({
    "event": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"id": z.int().describe("Unique identifier of the issue comment"),
"node_id": z.string(),
"url": z.url().describe("URL for the issue comment"),
"body": z.optional(z.string().describe("Contents of the issue comment")),
"body_text": z.optional(z.string()),
"body_html": z.optional(z.string()),
"html_url": z.url(),
get "user"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"issue_url": z.url(),
get "author_association"(){
                return authorAssociationSchema.describe("How the author is associated with the repository.")
              },
get "performed_via_github_app"(){
                return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").optional()
              },
get "reactions"(){
                return reactionRollupSchema.optional()
              }
    }).describe("Timeline Comment Event")

/**
 * @description Timeline Cross Referenced Event
 */
export const timelineCrossReferencedEventSchema = z.object({
    "event": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"source": z.object({
    "type": z.optional(z.string()),
get "issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.").optional()
              }
    })
    }).describe("Timeline Cross Referenced Event")

/**
 * @description Timeline Committed Event
 */
export const timelineCommittedEventSchema = z.object({
    "event": z.optional(z.string()),
"sha": z.string().describe("SHA for the commit"),
"node_id": z.string(),
"url": z.url(),
"author": z.object({
    "date": z.iso.datetime({ offset: true }).describe("Timestamp of the commit"),
"email": z.string().describe("Git email address of the user"),
"name": z.string().describe("Name of the git user")
    }).describe("Identifying information for the git-user"),
"committer": z.object({
    "date": z.iso.datetime({ offset: true }).describe("Timestamp of the commit"),
"email": z.string().describe("Git email address of the user"),
"name": z.string().describe("Name of the git user")
    }).describe("Identifying information for the git-user"),
"message": z.string().describe("Message describing the purpose of the commit"),
"tree": z.object({
    "sha": z.string().describe("SHA for the commit"),
"url": z.url()
    }),
"parents": z.array(z.object({
    "sha": z.string().describe("SHA for the commit"),
"url": z.url(),
"html_url": z.url()
    })),
"verification": z.object({
    "verified": z.boolean(),
"reason": z.string(),
"signature": z.nullable(z.string()),
"payload": z.nullable(z.string()),
"verified_at": z.nullable(z.string())
    }),
"html_url": z.url()
    }).describe("Timeline Committed Event")

/**
 * @description Timeline Reviewed Event
 */
export const timelineReviewedEventSchema = z.object({
    "event": z.string(),
"id": z.int().describe("Unique identifier of the review"),
"node_id": z.string(),
get "user"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"body": z.nullable(z.string().describe("The text of the review.")),
"state": z.string(),
"html_url": z.url(),
"pull_request_url": z.url(),
"_links": z.object({
    "html": z.object({
    "href": z.string()
    }),
"pull_request": z.object({
    "href": z.string()
    })
    }),
"submitted_at": z.optional(z.iso.datetime({ offset: true })),
"updated_at": z.iso.datetime({ offset: true }).nullish(),
"commit_id": z.string().describe("A commit SHA for the review."),
"body_html": z.optional(z.string()),
"body_text": z.optional(z.string()),
get "author_association"(){
                return authorAssociationSchema.describe("How the author is associated with the repository.")
              }
    }).describe("Timeline Reviewed Event")

/**
 * @description Pull Request Review Comments are comments on a portion of the Pull Request\'s diff.
 */
export const pullRequestReviewCommentSchema = z.object({
    "url": z.string().describe("URL for the pull request review comment"),
"pull_request_review_id": z.nullable(z.int().describe("The ID of the pull request review to which the comment belongs.")),
"id": z.int().describe("The ID of the pull request review comment."),
"node_id": z.string().describe("The node ID of the pull request review comment."),
"diff_hunk": z.string().describe("The diff of the line that the comment refers to."),
"path": z.string().describe("The relative path of the file to which the comment applies."),
"position": z.optional(z.int().describe("The line index in the diff to which the comment applies. This field is closing down; use `line` instead.")),
"original_position": z.optional(z.int().describe("The index of the original line in the diff to which the comment applies. This field is closing down; use `original_line` instead.")),
"commit_id": z.string().describe("The SHA of the commit to which the comment applies."),
"original_commit_id": z.string().describe("The SHA of the original commit to which the comment applies."),
"in_reply_to_id": z.optional(z.int().describe("The comment ID to reply to.")),
get "user"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"body": z.string().describe("The text of the comment."),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"html_url": z.url().describe("HTML URL for the pull request review comment."),
"pull_request_url": z.url().describe("URL for the pull request that the review comment belongs to."),
get "author_association"(){
                return authorAssociationSchema.describe("How the author is associated with the repository.")
              },
"_links": z.object({
    "self": z.object({
    "href": z.url()
    }),
"html": z.object({
    "href": z.url()
    }),
"pull_request": z.object({
    "href": z.url()
    })
    }),
"start_line": z.int().describe("The first line of the range for a multi-line comment.").nullish(),
"original_start_line": z.int().describe("The first line of the range for a multi-line comment.").nullish(),
"start_side": z.enum(["LEFT", "RIGHT"]).default("RIGHT").describe("The side of the first line of the range for a multi-line comment.").nullish(),
"line": z.optional(z.int().describe("The line of the blob to which the comment applies. The last line of the range for a multi-line comment")),
"original_line": z.optional(z.int().describe("The line of the blob to which the comment applies. The last line of the range for a multi-line comment")),
"side": z.optional(z.enum(["LEFT", "RIGHT"]).default("RIGHT").describe("The side of the diff to which the comment applies. The side of the last line of the range for a multi-line comment")),
"subject_type": z.optional(z.enum(["line", "file"]).describe("The level at which the comment is targeted, can be a diff line or a file.")),
get "reactions"(){
                return reactionRollupSchema.optional()
              },
"body_html": z.optional(z.string()),
"body_text": z.optional(z.string())
    }).describe("Pull Request Review Comments are comments on a portion of the Pull Request's diff.")

/**
 * @description Timeline Line Commented Event
 */
export const timelineLineCommentedEventSchema = z.object({
    "event": z.optional(z.string()),
"node_id": z.optional(z.string()),
get "comments"(){
                return z.array(pullRequestReviewCommentSchema.describe("Pull Request Review Comments are comments on a portion of the Pull Request's diff.")).optional()
              }
    }).describe("Timeline Line Commented Event")

/**
 * @description Timeline Commit Commented Event
 */
export const timelineCommitCommentedEventSchema = z.object({
    "event": z.optional(z.string()),
"node_id": z.optional(z.string()),
"commit_id": z.optional(z.string()),
get "comments"(){
                return z.array(commitCommentSchema.describe("Commit Comment")).optional()
              }
    }).describe("Timeline Commit Commented Event")

/**
 * @description Timeline Assigned Issue Event
 */
export const timelineAssignedIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
get "assignee"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    }).describe("Timeline Assigned Issue Event")

/**
 * @description Timeline Unassigned Issue Event
 */
export const timelineUnassignedIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
get "assignee"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    }).describe("Timeline Unassigned Issue Event")

/**
 * @description State Change Issue Event
 */
export const stateChangeIssueEventSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
get "actor"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"event": z.string(),
"commit_id": z.nullable(z.string()),
"commit_url": z.nullable(z.string()),
"created_at": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
"state_reason": z.string().nullish()
    }).describe("State Change Issue Event")

/**
 * @description Timeline Event
 */
export const timelineIssueEventsSchema = z.union([labeledIssueEventSchema, unlabeledIssueEventSchema, milestonedIssueEventSchema, demilestonedIssueEventSchema, renamedIssueEventSchema, reviewRequestedIssueEventSchema, reviewRequestRemovedIssueEventSchema, reviewDismissedIssueEventSchema, lockedIssueEventSchema, addedToProjectIssueEventSchema, movedColumnInProjectIssueEventSchema, removedFromProjectIssueEventSchema, convertedNoteToIssueIssueEventSchema, timelineCommentEventSchema, timelineCrossReferencedEventSchema, timelineCommittedEventSchema, timelineReviewedEventSchema, timelineLineCommentedEventSchema, timelineCommitCommentedEventSchema, timelineAssignedIssueEventSchema, timelineUnassignedIssueEventSchema, stateChangeIssueEventSchema]).describe("Timeline Event")

/**
 * @description An SSH key granting access to a single repository.
 */
export const deployKeySchema = z.object({
    "id": z.int(),
"key": z.string(),
"url": z.string(),
"title": z.string(),
"verified": z.boolean(),
"created_at": z.string(),
"read_only": z.boolean(),
"added_by": z.string().nullish(),
"last_used": z.iso.datetime({ offset: true }).nullish(),
"enabled": z.optional(z.boolean())
    }).describe("An SSH key granting access to a single repository.")

/**
 * @description Language
 */
export const languageSchema = z.object({
    
    }).catchall(z.int()).describe("Language")

/**
 * @description License Content
 */
export const licenseContentSchema = z.object({
    "name": z.string(),
"path": z.string(),
"sha": z.string(),
"size": z.int(),
"url": z.url(),
"html_url": z.nullable(z.url()),
"git_url": z.nullable(z.url()),
"download_url": z.nullable(z.url()),
"type": z.string(),
"content": z.string(),
"encoding": z.string(),
"_links": z.object({
    "git": z.nullable(z.url()),
"html": z.nullable(z.url()),
"self": z.url()
    }),
get "license"(){
               return nullableLicenseSimpleSchema.describe("License Simple").nullable()
              }
    }).describe("License Content")

/**
 * @description Results of a successful merge upstream request
 */
export const mergedUpstreamSchema = z.object({
    "message": z.optional(z.string()),
"merge_type": z.optional(z.enum(["merge", "fast-forward", "none"])),
"base_branch": z.optional(z.string())
    }).describe("Results of a successful merge upstream request")

/**
 * @description A collection of related issues and pull requests.
 */
export const milestoneSchema = z.object({
    "url": z.url(),
"html_url": z.url(),
"labels_url": z.url(),
"id": z.int(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"state": z.enum(["open", "closed"]).default("open").describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"description": z.nullable(z.string()),
get "creator"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"open_issues": z.int(),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"due_on": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("A collection of related issues and pull requests.")

export const pagesSourceHashSchema = z.object({
    "branch": z.string(),
"path": z.string()
    })

export const pagesHttpsCertificateSchema = z.object({
    "state": z.enum(["new", "authorization_created", "authorization_pending", "authorized", "authorization_revoked", "issued", "uploaded", "approved", "errored", "bad_authz", "destroy_pending", "dns_changed"]),
"description": z.string(),
"domains": z.array(z.string()).describe("Array of the domain set and its alternate name (if it is configured)"),
"expires_at": z.optional(z.iso.date())
    })

/**
 * @description The configuration for GitHub Pages for a repository.
 */
export const pageSchema = z.object({
    "url": z.url().describe("The API address for accessing this Page resource."),
"status": z.nullable(z.enum(["built", "building", "errored"]).describe("The status of the most recent build of the Page.")),
"cname": z.nullable(z.string().describe("The Pages site's custom domain")),
"protected_domain_state": z.enum(["pending", "verified", "unverified"]).describe("The state if the domain is verified").nullish(),
"pending_domain_unverified_at": z.iso.datetime({ offset: true }).describe("The timestamp when a pending domain becomes unverified.").nullish(),
"custom_404": z.boolean().default(false).describe("Whether the Page has a custom 404 page."),
"html_url": z.optional(z.url().describe("The web address the Page can be accessed from.")),
"build_type": z.enum(["legacy", "workflow"]).describe("The process in which the Page will be built.").nullish(),
get "source"(){
                return pagesSourceHashSchema.optional()
              },
"public": z.boolean().describe("Whether the GitHub Pages site is publicly visible. If set to `true`, the site is accessible to anyone on the internet. If set to `false`, the site will only be accessible to users who have at least `read` access to the repository that published the site."),
get "https_certificate"(){
                return pagesHttpsCertificateSchema.optional()
              },
"https_enforced": z.optional(z.boolean().describe("Whether https is enabled on the domain"))
    }).describe("The configuration for GitHub Pages for a repository.")

/**
 * @description Page Build
 */
export const pageBuildSchema = z.object({
    "url": z.url(),
"status": z.string(),
"error": z.object({
    "message": z.nullable(z.string())
    }),
get "pusher"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"commit": z.string(),
"duration": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true })
    }).describe("Page Build")

/**
 * @description Page Build Status
 */
export const pageBuildStatusSchema = z.object({
    "url": z.url(),
"status": z.string()
    }).describe("Page Build Status")

/**
 * @description The GitHub Pages deployment status.
 */
export const pageDeploymentSchema = z.object({
    "id": z.union([z.int(), z.string()]).describe("The ID of the GitHub Pages deployment. This is the Git SHA of the deployed commit."),
"status_url": z.url().describe("The URI to monitor GitHub Pages deployment status."),
"page_url": z.url().describe("The URI to the deployed GitHub Pages."),
"preview_url": z.optional(z.url().describe("The URI to the deployed GitHub Pages preview."))
    }).describe("The GitHub Pages deployment status.")

export const pagesDeploymentStatusSchema = z.object({
    "status": z.optional(z.enum(["deployment_in_progress", "syncing_files", "finished_file_sync", "updating_pages", "purging_cdn", "deployment_cancelled", "deployment_failed", "deployment_content_failed", "deployment_attempt_error", "deployment_lost", "succeed"]).describe("The current status of the deployment."))
    })

/**
 * @description Pages Health Check Status
 */
export const pagesHealthCheckSchema = z.object({
    "domain": z.optional(z.object({
    "host": z.optional(z.string()),
"uri": z.optional(z.string()),
"nameservers": z.optional(z.string()),
"dns_resolves": z.optional(z.boolean()),
"is_proxied": z.boolean().nullish(),
"is_cloudflare_ip": z.boolean().nullish(),
"is_fastly_ip": z.boolean().nullish(),
"is_old_ip_address": z.boolean().nullish(),
"is_a_record": z.boolean().nullish(),
"has_cname_record": z.boolean().nullish(),
"has_mx_records_present": z.boolean().nullish(),
"is_valid_domain": z.optional(z.boolean()),
"is_apex_domain": z.optional(z.boolean()),
"should_be_a_record": z.boolean().nullish(),
"is_cname_to_github_user_domain": z.boolean().nullish(),
"is_cname_to_pages_dot_github_dot_com": z.boolean().nullish(),
"is_cname_to_fastly": z.boolean().nullish(),
"is_pointed_to_github_pages_ip": z.boolean().nullish(),
"is_non_github_pages_ip_present": z.boolean().nullish(),
"is_pages_domain": z.optional(z.boolean()),
"is_served_by_pages": z.boolean().nullish(),
"is_valid": z.optional(z.boolean()),
"reason": z.string().nullish(),
"responds_to_https": z.optional(z.boolean()),
"enforces_https": z.optional(z.boolean()),
"https_error": z.string().nullish(),
"is_https_eligible": z.boolean().nullish(),
"caa_error": z.string().nullish()
    })),
"alt_domain": z.object({
    "host": z.optional(z.string()),
"uri": z.optional(z.string()),
"nameservers": z.optional(z.string()),
"dns_resolves": z.optional(z.boolean()),
"is_proxied": z.boolean().nullish(),
"is_cloudflare_ip": z.boolean().nullish(),
"is_fastly_ip": z.boolean().nullish(),
"is_old_ip_address": z.boolean().nullish(),
"is_a_record": z.boolean().nullish(),
"has_cname_record": z.boolean().nullish(),
"has_mx_records_present": z.boolean().nullish(),
"is_valid_domain": z.optional(z.boolean()),
"is_apex_domain": z.optional(z.boolean()),
"should_be_a_record": z.boolean().nullish(),
"is_cname_to_github_user_domain": z.boolean().nullish(),
"is_cname_to_pages_dot_github_dot_com": z.boolean().nullish(),
"is_cname_to_fastly": z.boolean().nullish(),
"is_pointed_to_github_pages_ip": z.boolean().nullish(),
"is_non_github_pages_ip_present": z.boolean().nullish(),
"is_pages_domain": z.optional(z.boolean()),
"is_served_by_pages": z.boolean().nullish(),
"is_valid": z.optional(z.boolean()),
"reason": z.string().nullish(),
"responds_to_https": z.optional(z.boolean()),
"enforces_https": z.optional(z.boolean()),
"https_error": z.string().nullish(),
"is_https_eligible": z.boolean().nullish(),
"caa_error": z.string().nullish()
    }).nullish()
    }).describe("Pages Health Check Status")

/**
 * @description Pull requests let you tell others about changes you\'ve pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.
 */
export const pullRequestSchema = z.object({
    "url": z.url(),
"id": z.int(),
"node_id": z.string(),
"html_url": z.url(),
"diff_url": z.url(),
"patch_url": z.url(),
"issue_url": z.url(),
"commits_url": z.url(),
"review_comments_url": z.url(),
"review_comment_url": z.string(),
"comments_url": z.url(),
"statuses_url": z.url(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"locked": z.boolean(),
"title": z.string().describe("The title of the pull request."),
get "user"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"body": z.nullable(z.string()),
"labels": z.array(z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.string(),
"name": z.string(),
"description": z.nullable(z.string()),
"color": z.string(),
"default": z.boolean()
    })),
get "milestone"(){
               return nullableMilestoneSchema.describe("A collection of related issues and pull requests.").nullable()
              },
"active_lock_reason": z.string().nullish(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merge_commit_sha": z.nullable(z.string()),
get "assignee"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
get "assignees"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).nullish()
              },
get "requested_reviewers"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).nullish()
              },
get "requested_teams"(){
                return z.array(teamSimpleSchema.describe("Groups of organization members that gives permissions on specified repositories.")).nullish()
              },
"head": z.object({
    "label": z.string(),
"ref": z.string(),
get "repo"(){
                return repositorySchema.describe("A repository on GitHub.")
              },
"sha": z.string(),
get "user"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    }),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
get "repo"(){
                return repositorySchema.describe("A repository on GitHub.")
              },
"sha": z.string(),
get "user"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    }),
"_links": z.object({
    get "comments"(){
                return linkSchema.describe("Hypermedia Link")
              },
get "commits"(){
                return linkSchema.describe("Hypermedia Link")
              },
get "statuses"(){
                return linkSchema.describe("Hypermedia Link")
              },
get "html"(){
                return linkSchema.describe("Hypermedia Link")
              },
get "issue"(){
                return linkSchema.describe("Hypermedia Link")
              },
get "review_comments"(){
                return linkSchema.describe("Hypermedia Link")
              },
get "review_comment"(){
                return linkSchema.describe("Hypermedia Link")
              },
get "self"(){
                return linkSchema.describe("Hypermedia Link")
              }
    }),
get "author_association"(){
                return authorAssociationSchema.describe("How the author is associated with the repository.")
              },
get "auto_merge"(){
               return autoMergeSchema.describe("The status of auto merging a pull request.").nullable()
              },
"draft": z.optional(z.boolean().describe("Indicates whether or not the pull request is a draft.")),
"merged": z.boolean(),
"mergeable": z.nullable(z.boolean()),
"rebaseable": z.boolean().nullish(),
"mergeable_state": z.string(),
get "merged_by"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"comments": z.int(),
"review_comments": z.int(),
"maintainer_can_modify": z.boolean().describe("Indicates whether maintainers can modify the pull request."),
"commits": z.int(),
"additions": z.int(),
"deletions": z.int(),
"changed_files": z.int()
    }).describe("Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.")

/**
 * @description Pull Request Merge Result
 */
export const pullRequestMergeResultSchema = z.object({
    "sha": z.string(),
"merged": z.boolean(),
"message": z.string()
    }).describe("Pull Request Merge Result")

/**
 * @description Pull Request Review Request
 */
export const pullRequestReviewRequestSchema = z.object({
    get "users"(){
                return z.array(simpleUserSchema.describe("A GitHub user."))
              },
get "teams"(){
                return z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories."))
              }
    }).describe("Pull Request Review Request")

/**
 * @description Pull Request Reviews are reviews on pull requests.
 */
export const pullRequestReviewSchema = z.object({
    "id": z.int().describe("Unique identifier of the review"),
"node_id": z.string(),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"body": z.string().describe("The text of the review."),
"state": z.string(),
"html_url": z.url(),
"pull_request_url": z.url(),
"_links": z.object({
    "html": z.object({
    "href": z.string()
    }),
"pull_request": z.object({
    "href": z.string()
    })
    }),
"submitted_at": z.optional(z.iso.datetime({ offset: true })),
"commit_id": z.nullable(z.string().describe("A commit SHA for the review. If the commit object was garbage collected or forcibly deleted, then it no longer exists in Git and this value will be `null`.")),
"body_html": z.optional(z.string()),
"body_text": z.optional(z.string()),
get "author_association"(){
                return authorAssociationSchema.describe("How the author is associated with the repository.")
              }
    }).describe("Pull Request Reviews are reviews on pull requests.")

/**
 * @description Legacy Review Comment
 */
export const reviewCommentSchema = z.object({
    "url": z.url(),
"pull_request_review_id": z.nullable(z.int()),
"id": z.int(),
"node_id": z.string(),
"diff_hunk": z.string(),
"path": z.string(),
"position": z.nullable(z.int()),
"original_position": z.int(),
"commit_id": z.string(),
"original_commit_id": z.string(),
"in_reply_to_id": z.optional(z.int()),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"body": z.string(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"html_url": z.url(),
"pull_request_url": z.url(),
get "author_association"(){
                return authorAssociationSchema.describe("How the author is associated with the repository.")
              },
"_links": z.object({
    get "self"(){
                return linkSchema.describe("Hypermedia Link")
              },
get "html"(){
                return linkSchema.describe("Hypermedia Link")
              },
get "pull_request"(){
                return linkSchema.describe("Hypermedia Link")
              }
    }),
"body_text": z.optional(z.string()),
"body_html": z.optional(z.string()),
get "reactions"(){
                return reactionRollupSchema.optional()
              },
"side": z.optional(z.enum(["LEFT", "RIGHT"]).default("RIGHT").describe("The side of the first line of the range for a multi-line comment.")),
"start_side": z.enum(["LEFT", "RIGHT"]).default("RIGHT").describe("The side of the first line of the range for a multi-line comment.").nullish(),
"line": z.optional(z.int().describe("The line of the blob to which the comment applies. The last line of the range for a multi-line comment")),
"original_line": z.optional(z.int().describe("The original line of the blob to which the comment applies. The last line of the range for a multi-line comment")),
"start_line": z.int().describe("The first line of the range for a multi-line comment.").nullish(),
"original_start_line": z.int().describe("The original first line of the range for a multi-line comment.").nullish(),
"subject_type": z.optional(z.enum(["line", "file"]).describe("The level at which the comment is targeted, can be a diff line or a file."))
    }).describe("Legacy Review Comment")

/**
 * @description Data related to a release.
 */
export const releaseAssetSchema = z.object({
    "url": z.url(),
"browser_download_url": z.url(),
"id": z.int(),
"node_id": z.string(),
"name": z.string().describe("The file name of the asset."),
"label": z.nullable(z.string()),
"state": z.enum(["uploaded", "open"]).describe("State of the release asset."),
"content_type": z.string(),
"size": z.int(),
"digest": z.nullable(z.string()),
"download_count": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
get "uploader"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              }
    }).describe("Data related to a release.")

/**
 * @description A release.
 */
export const releaseSchema = z.object({
    "url": z.url(),
"html_url": z.url(),
"assets_url": z.url(),
"upload_url": z.string(),
"tarball_url": z.nullable(z.url()),
"zipball_url": z.nullable(z.url()),
"id": z.int(),
"node_id": z.string(),
"tag_name": z.string().describe("The name of the tag."),
"target_commitish": z.string().describe("Specifies the commitish value that determines where the Git tag is created from."),
"name": z.nullable(z.string()),
"body": z.string().nullish(),
"draft": z.boolean().describe("true to create a draft (unpublished) release, false to create a published one."),
"prerelease": z.boolean().describe("Whether to identify the release as a prerelease or a full release."),
"immutable": z.optional(z.boolean().describe("Whether or not the release is immutable.")),
"created_at": z.iso.datetime({ offset: true }),
"published_at": z.nullable(z.iso.datetime({ offset: true })),
"updated_at": z.iso.datetime({ offset: true }).nullish(),
get "author"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "assets"(){
                return z.array(releaseAssetSchema.describe("Data related to a release."))
              },
"body_html": z.optional(z.string()),
"body_text": z.optional(z.string()),
"mentions_count": z.optional(z.int()),
"discussion_url": z.optional(z.url().describe("The URL of the release discussion.")),
get "reactions"(){
                return reactionRollupSchema.optional()
              }
    }).describe("A release.")

/**
 * @description Generated name and body describing a release
 */
export const releaseNotesContentSchema = z.object({
    "name": z.string().describe("The generated name of the release"),
"body": z.string().describe("The generated body describing the contents of the release supporting markdown formatting")
    }).describe("Generated name and body describing a release")

/**
 * @description User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
 */
export const repositoryRuleRulesetInfoSchema = z.object({
    "ruleset_source_type": z.optional(z.enum(["Repository", "Organization"]).describe("The type of source for the ruleset that includes this rule.")),
"ruleset_source": z.optional(z.string().describe("The name of the source of the ruleset that includes this rule.")),
"ruleset_id": z.optional(z.int().describe("The ID of the ruleset that includes this rule."))
    }).describe("User-defined metadata to store domain-specific information limited to 8 keys with scalar values.")

/**
 * @description A repository rule with ruleset details.
 */
export const repositoryRuleDetailedSchema = z.union([repositoryRuleCreationSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleUpdateSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleDeletionSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleRequiredLinearHistorySchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleMergeQueueSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleRequiredDeploymentsSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleRequiredSignaturesSchema.and(repositoryRuleRulesetInfoSchema), repositoryRulePullRequestSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleRequiredStatusChecksSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleNonFastForwardSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleCommitMessagePatternSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleCommitAuthorEmailPatternSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleCommitterEmailPatternSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleBranchNamePatternSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleTagNamePatternSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleFilePathRestrictionSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleMaxFilePathLengthSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleFileExtensionRestrictionSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleMaxFileSizeSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleWorkflowsSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleCodeScanningSchema.and(repositoryRuleRulesetInfoSchema), repositoryRuleCopilotCodeReviewSchema.and(repositoryRuleRulesetInfoSchema)]).describe("A repository rule with ruleset details.")

export const secretScanningAlertSchema = z.object({
    get "number"(){
                return alertNumberSchema.describe("The security alert number.").optional()
              },
get "created_at"(){
                return alertCreatedAtSchema.describe("The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").optional()
              },
get "updated_at"(){
                return nullableAlertUpdatedAtSchema.describe("The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").optional()
              },
get "url"(){
                return alertUrlSchema.describe("The REST API URL of the alert resource.").optional()
              },
get "html_url"(){
                return alertHtmlUrlSchema.describe("The GitHub URL of the alert resource.").optional()
              },
"locations_url": z.optional(z.url().describe("The REST API URL of the code locations for this alert.")),
get "state"(){
                return secretScanningAlertStateSchema.describe("Sets the state of the secret scanning alert. You must provide `resolution` when you set the state to `resolved`.").optional()
              },
get "resolution"(){
                return secretScanningAlertResolutionSchema.describe("**Required when the `state` is `resolved`.** The reason for resolving the alert.").optional()
              },
"resolved_at": z.iso.datetime({ offset: true }).describe("The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullish(),
get "resolved_by"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
"resolution_comment": z.string().describe("An optional comment to resolve an alert.").nullish(),
"secret_type": z.optional(z.string().describe("The type of secret that secret scanning detected.")),
"secret_type_display_name": z.optional(z.string().describe("User-friendly name for the detected secret, matching the `secret_type`.\nFor a list of built-in patterns, see \"[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets).\"")),
"secret": z.optional(z.string().describe("The secret that was detected.")),
"push_protection_bypassed": z.boolean().describe("Whether push protection was bypassed for the detected secret.").nullish(),
get "push_protection_bypassed_by"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
"push_protection_bypassed_at": z.iso.datetime({ offset: true }).describe("The time that push protection was bypassed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullish(),
get "push_protection_bypass_request_reviewer"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
"push_protection_bypass_request_reviewer_comment": z.string().describe("An optional comment when reviewing a push protection bypass.").nullish(),
"push_protection_bypass_request_comment": z.string().describe("An optional comment when requesting a push protection bypass.").nullish(),
"push_protection_bypass_request_html_url": z.url().describe("The URL to a push protection bypass request.").nullish(),
"validity": z.optional(z.enum(["active", "inactive", "unknown"]).describe("The token status as of the latest validity check.")),
"publicly_leaked": z.boolean().describe("Whether the detected secret was publicly leaked.").nullish(),
"multi_repo": z.boolean().describe("Whether the detected secret was found in multiple repositories under the same organization or enterprise.").nullish(),
"is_base64_encoded": z.boolean().describe("A boolean value representing whether or not alert is base64 encoded").nullish(),
get "first_location_detected"(){
                return nullableSecretScanningFirstDetectedLocationSchema.describe("Details on the location where the token was initially detected. This can be a commit, wiki commit, issue, discussion, pull request.\n").optional()
              },
"has_more_locations": z.optional(z.boolean().describe("A boolean value representing whether or not the token in the alert was detected in more than one location.")),
get "assigned_to"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              }
    })

/**
 * @description An optional comment when closing or reopening an alert. Cannot be updated or deleted.
 */
export const secretScanningAlertResolutionCommentSchema = z.string().describe("An optional comment when closing or reopening an alert. Cannot be updated or deleted.").nullable()

export const secretScanningLocationSchema = z.object({
    "type": z.optional(z.enum(["commit", "wiki_commit", "issue_title", "issue_body", "issue_comment", "discussion_title", "discussion_body", "discussion_comment", "pull_request_title", "pull_request_body", "pull_request_comment", "pull_request_review", "pull_request_review_comment"]).describe("The location type. Because secrets may be found in different types of resources (ie. code, comments, issues, pull requests, discussions), this field identifies the type of resource where the secret was found.")),
get "details"(){
                return z.union([secretScanningLocationCommitSchema, secretScanningLocationWikiCommitSchema, secretScanningLocationIssueTitleSchema, secretScanningLocationIssueBodySchema, secretScanningLocationIssueCommentSchema, secretScanningLocationDiscussionTitleSchema, secretScanningLocationDiscussionBodySchema, secretScanningLocationDiscussionCommentSchema, secretScanningLocationPullRequestTitleSchema, secretScanningLocationPullRequestBodySchema, secretScanningLocationPullRequestCommentSchema, secretScanningLocationPullRequestReviewSchema, secretScanningLocationPullRequestReviewCommentSchema]).optional()
              }
    })

/**
 * @description The reason for bypassing push protection.
 */
export const secretScanningPushProtectionBypassReasonSchema = z.enum(["false_positive", "used_in_tests", "will_fix_later"]).describe("The reason for bypassing push protection.")

export const secretScanningPushProtectionBypassSchema = z.object({
    get "reason"(){
                return secretScanningPushProtectionBypassReasonSchema.describe("The reason for bypassing push protection.").optional()
              },
"expire_at": z.iso.datetime({ offset: true }).describe("The time that the bypass will expire in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullish(),
"token_type": z.optional(z.string().describe("The token type this bypass is for."))
    })

/**
 * @description Information on a single scan performed by secret scanning on the repository
 */
export const secretScanningScanSchema = z.object({
    "type": z.optional(z.string().describe("The type of scan")),
"status": z.optional(z.string().describe("The state of the scan. Either \"completed\", \"running\", or \"pending\"")),
"completed_at": z.iso.datetime({ offset: true }).describe("The time that the scan was completed. Empty if the scan is running").nullish(),
"started_at": z.iso.datetime({ offset: true }).describe("The time that the scan was started. Empty if the scan is pending").nullish()
    }).describe("Information on a single scan performed by secret scanning on the repository")

export const secretScanningScanHistorySchema = z.object({
    get "incremental_scans"(){
                return z.array(secretScanningScanSchema.describe("Information on a single scan performed by secret scanning on the repository")).optional()
              },
get "pattern_update_scans"(){
                return z.array(secretScanningScanSchema.describe("Information on a single scan performed by secret scanning on the repository")).optional()
              },
get "backfill_scans"(){
                return z.array(secretScanningScanSchema.describe("Information on a single scan performed by secret scanning on the repository")).optional()
              },
get "custom_pattern_backfill_scans"(){
                return z.array(secretScanningScanSchema.and(z.object({
    "pattern_name": z.optional(z.string().describe("Name of the custom pattern for custom pattern scans")),
"pattern_scope": z.optional(z.string().describe("Level at which the custom pattern is defined, one of \"repository\", \"organization\", or \"enterprise\""))
    }))).optional()
              }
    })

export const repositoryAdvisoryCreateSchema = z.object({
    "summary": z.string().max(1024).describe("A short summary of the advisory."),
"description": z.string().max(65535).describe("A detailed description of what the advisory impacts."),
"cve_id": z.string().describe("The Common Vulnerabilities and Exposures (CVE) ID.").nullish(),
"vulnerabilities": z.array(z.object({
    "package": z.object({
    get "ecosystem"(){
                return securityAdvisoryEcosystemsSchema.describe("The package's language or package management ecosystem.")
              },
"name": z.string().describe("The unique package name within its ecosystem.").nullish()
    }).describe("The name of the package affected by the vulnerability."),
"vulnerable_version_range": z.string().describe("The range of the package versions affected by the vulnerability.").nullish(),
"patched_versions": z.string().describe("The package version(s) that resolve the vulnerability.").nullish(),
"vulnerable_functions": z.array(z.string()).describe("The functions in the package that are affected.").nullish()
    })).describe("A product affected by the vulnerability detailed in a repository security advisory."),
"cwe_ids": z.array(z.string()).describe("A list of Common Weakness Enumeration (CWE) IDs.").nullish(),
"credits": z.array(z.object({
    "login": z.string().describe("The username of the user credited."),
get "type"(){
                return securityAdvisoryCreditTypesSchema.describe("The type of credit the user is receiving.")
              }
    })).describe("A list of users receiving credit for their participation in the security advisory.").nullish(),
"severity": z.enum(["critical", "high", "medium", "low"]).describe("The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.").nullish(),
"cvss_vector_string": z.string().describe("The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.").nullish(),
"start_private_fork": z.optional(z.boolean().default(false).describe("Whether to create a temporary private fork of the repository to collaborate on a fix."))
    })

export const privateVulnerabilityReportCreateSchema = z.object({
    "summary": z.string().max(1024).describe("A short summary of the advisory."),
"description": z.string().max(65535).describe("A detailed description of what the advisory impacts."),
"vulnerabilities": z.array(z.object({
    "package": z.object({
    get "ecosystem"(){
                return securityAdvisoryEcosystemsSchema.describe("The package's language or package management ecosystem.")
              },
"name": z.string().describe("The unique package name within its ecosystem.").nullish()
    }).describe("The name of the package affected by the vulnerability."),
"vulnerable_version_range": z.string().describe("The range of the package versions affected by the vulnerability.").nullish(),
"patched_versions": z.string().describe("The package version(s) that resolve the vulnerability.").nullish(),
"vulnerable_functions": z.array(z.string()).describe("The functions in the package that are affected.").nullish()
    })).describe("An array of products affected by the vulnerability detailed in a repository security advisory.").nullish(),
"cwe_ids": z.array(z.string()).describe("A list of Common Weakness Enumeration (CWE) IDs.").nullish(),
"severity": z.enum(["critical", "high", "medium", "low"]).describe("The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.").nullish(),
"cvss_vector_string": z.string().describe("The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.").nullish(),
"start_private_fork": z.optional(z.boolean().default(false).describe("Whether to create a temporary private fork of the repository to collaborate on a fix."))
    })

export const repositoryAdvisoryUpdateSchema = z.object({
    "summary": z.optional(z.string().max(1024).describe("A short summary of the advisory.")),
"description": z.optional(z.string().max(65535).describe("A detailed description of what the advisory impacts.")),
"cve_id": z.string().describe("The Common Vulnerabilities and Exposures (CVE) ID.").nullish(),
"vulnerabilities": z.optional(z.array(z.object({
    "package": z.object({
    get "ecosystem"(){
                return securityAdvisoryEcosystemsSchema.describe("The package's language or package management ecosystem.")
              },
"name": z.string().describe("The unique package name within its ecosystem.").nullish()
    }).describe("The name of the package affected by the vulnerability."),
"vulnerable_version_range": z.string().describe("The range of the package versions affected by the vulnerability.").nullish(),
"patched_versions": z.string().describe("The package version(s) that resolve the vulnerability.").nullish(),
"vulnerable_functions": z.array(z.string()).describe("The functions in the package that are affected.").nullish()
    })).describe("A product affected by the vulnerability detailed in a repository security advisory.")),
"cwe_ids": z.array(z.string()).describe("A list of Common Weakness Enumeration (CWE) IDs.").nullish(),
"credits": z.array(z.object({
    "login": z.string().describe("The username of the user credited."),
get "type"(){
                return securityAdvisoryCreditTypesSchema.describe("The type of credit the user is receiving.")
              }
    })).describe("A list of users receiving credit for their participation in the security advisory.").nullish(),
"severity": z.enum(["critical", "high", "medium", "low"]).describe("The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.").nullish(),
"cvss_vector_string": z.string().describe("The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.").nullish(),
"state": z.optional(z.enum(["published", "closed", "draft"]).describe("The state of the advisory.")),
"collaborating_users": z.array(z.string()).describe("A list of usernames who have been granted write access to the advisory.").nullish(),
"collaborating_teams": z.array(z.string()).describe("A list of team slugs which have been granted write access to the advisory.").nullish()
    })

/**
 * @description Stargazer
 */
export const stargazerSchema = z.object({
    "starred_at": z.iso.datetime({ offset: true }),
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              }
    }).describe("Stargazer")

/**
 * @description Code Frequency Stat
 */
export const codeFrequencyStatSchema = z.array(z.int()).describe("Code Frequency Stat")

/**
 * @description Commit Activity
 */
export const commitActivitySchema = z.object({
    "days": z.array(z.int()),
"total": z.int(),
"week": z.int()
    }).describe("Commit Activity")

/**
 * @description Contributor Activity
 */
export const contributorActivitySchema = z.object({
    get "author"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"total": z.int(),
"weeks": z.array(z.object({
    "w": z.optional(z.int()),
"a": z.optional(z.int()),
"d": z.optional(z.int()),
"c": z.optional(z.int())
    }))
    }).describe("Contributor Activity")

export const participationStatsSchema = z.object({
    "all": z.array(z.int()),
"owner": z.array(z.int())
    })

/**
 * @description Repository invitations let you manage who you collaborate with.
 */
export const repositorySubscriptionSchema = z.object({
    "subscribed": z.boolean().describe("Determines if notifications should be received from this repository."),
"ignored": z.boolean().describe("Determines if all notifications should be blocked from this repository."),
"reason": z.nullable(z.string()),
"created_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"repository_url": z.url()
    }).describe("Repository invitations let you manage who you collaborate with.")

/**
 * @description Tag
 */
export const tagSchema = z.object({
    "name": z.string(),
"commit": z.object({
    "sha": z.string(),
"url": z.url()
    }),
"zipball_url": z.url(),
"tarball_url": z.url(),
"node_id": z.string()
    }).describe("Tag")

/**
 * @description Tag protection
 */
export const tagProtectionSchema = z.object({
    "id": z.optional(z.int()),
"created_at": z.optional(z.string()),
"updated_at": z.optional(z.string()),
"enabled": z.optional(z.boolean()),
"pattern": z.string()
    }).describe("Tag protection")

/**
 * @description A topic aggregates entities that are related to a subject.
 */
export const topicSchema = z.object({
    "names": z.array(z.string())
    }).describe("A topic aggregates entities that are related to a subject.")

export const trafficSchema = z.object({
    "timestamp": z.iso.datetime({ offset: true }),
"uniques": z.int(),
"count": z.int()
    })

/**
 * @description Clone Traffic
 */
export const cloneTrafficSchema = z.object({
    "count": z.int(),
"uniques": z.int(),
get "clones"(){
                return z.array(trafficSchema)
              }
    }).describe("Clone Traffic")

/**
 * @description Content Traffic
 */
export const contentTrafficSchema = z.object({
    "path": z.string(),
"title": z.string(),
"count": z.int(),
"uniques": z.int()
    }).describe("Content Traffic")

/**
 * @description Referrer Traffic
 */
export const referrerTrafficSchema = z.object({
    "referrer": z.string(),
"count": z.int(),
"uniques": z.int()
    }).describe("Referrer Traffic")

/**
 * @description View Traffic
 */
export const viewTrafficSchema = z.object({
    "count": z.int(),
"uniques": z.int(),
get "views"(){
                return z.array(trafficSchema)
              }
    }).describe("View Traffic")

export const searchResultTextMatchesSchema = z.array(z.object({
    "object_url": z.optional(z.string()),
"object_type": z.string().nullish(),
"property": z.optional(z.string()),
"fragment": z.optional(z.string()),
"matches": z.optional(z.array(z.object({
    "text": z.optional(z.string()),
"indices": z.optional(z.array(z.int()))
    })))
    }))

/**
 * @description Code Search Result Item
 */
export const codeSearchResultItemSchema = z.object({
    "name": z.string(),
"path": z.string(),
"sha": z.string(),
"url": z.url(),
"git_url": z.url(),
"html_url": z.url(),
get "repository"(){
                return minimalRepositorySchema.describe("Minimal Repository")
              },
"score": z.number(),
"file_size": z.optional(z.int()),
"language": z.string().nullish(),
"last_modified_at": z.optional(z.iso.datetime({ offset: true })),
"line_numbers": z.optional(z.array(z.string())),
get "text_matches"(){
                return searchResultTextMatchesSchema.optional()
              }
    }).describe("Code Search Result Item")

/**
 * @description Commit Search Result Item
 */
export const commitSearchResultItemSchema = z.object({
    "url": z.url(),
"sha": z.string(),
"html_url": z.url(),
"comments_url": z.url(),
"commit": z.object({
    "author": z.object({
    "name": z.string(),
"email": z.string(),
"date": z.iso.datetime({ offset: true })
    }),
get "committer"(){
               return nullableGitUserSchema.describe("Metaproperties for Git author/committer information.").nullable()
              },
"comment_count": z.int(),
"message": z.string(),
"tree": z.object({
    "sha": z.string(),
"url": z.url()
    }),
"url": z.url(),
get "verification"(){
                return verificationSchema.optional()
              }
    }),
get "author"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
get "committer"(){
               return nullableGitUserSchema.describe("Metaproperties for Git author/committer information.").nullable()
              },
"parents": z.array(z.object({
    "url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"sha": z.optional(z.string())
    })),
get "repository"(){
                return minimalRepositorySchema.describe("Minimal Repository")
              },
"score": z.number(),
"node_id": z.string(),
get "text_matches"(){
                return searchResultTextMatchesSchema.optional()
              }
    }).describe("Commit Search Result Item")

/**
 * @description Issue Search Result Item
 */
export const issueSearchResultItemSchema = z.object({
    "url": z.url(),
"repository_url": z.url(),
"labels_url": z.string(),
"comments_url": z.url(),
"events_url": z.url(),
"html_url": z.url(),
"id": z.int(),
"node_id": z.string(),
"number": z.int(),
"title": z.string(),
"locked": z.boolean(),
"active_lock_reason": z.string().nullish(),
get "assignees"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).nullish()
              },
get "user"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"labels": z.array(z.object({
    "id": z.optional(z.int()),
"node_id": z.optional(z.string()),
"url": z.optional(z.string()),
"name": z.optional(z.string()),
"color": z.optional(z.string()),
"default": z.optional(z.boolean()),
"description": z.string().nullish()
    })),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              },
"state": z.string(),
"state_reason": z.string().nullish(),
get "assignee"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
get "milestone"(){
               return nullableMilestoneSchema.describe("A collection of related issues and pull requests.").nullable()
              },
"comments": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
get "text_matches"(){
                return searchResultTextMatchesSchema.optional()
              },
"pull_request": z.optional(z.object({
    "merged_at": z.iso.datetime({ offset: true }).nullish(),
"diff_url": z.nullable(z.url()),
"html_url": z.nullable(z.url()),
"patch_url": z.nullable(z.url()),
"url": z.nullable(z.url())
    })),
"body": z.optional(z.string()),
"score": z.number(),
get "author_association"(){
                return authorAssociationSchema.describe("How the author is associated with the repository.")
              },
"draft": z.optional(z.boolean()),
get "repository"(){
                return repositorySchema.describe("A repository on GitHub.").optional()
              },
"body_html": z.optional(z.string()),
"body_text": z.optional(z.string()),
"timeline_url": z.optional(z.url()),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
get "performed_via_github_app"(){
                return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").optional()
              },
get "reactions"(){
                return reactionRollupSchema.optional()
              }
    }).describe("Issue Search Result Item")

/**
 * @description Label Search Result Item
 */
export const labelSearchResultItemSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"url": z.url(),
"name": z.string(),
"color": z.string(),
"default": z.boolean(),
"description": z.nullable(z.string()),
"score": z.number(),
get "text_matches"(){
                return searchResultTextMatchesSchema.optional()
              }
    }).describe("Label Search Result Item")

/**
 * @description Repo Search Result Item
 */
export const repoSearchResultItemSchema = z.object({
    "id": z.int(),
"node_id": z.string(),
"name": z.string(),
"full_name": z.string(),
get "owner"(){
               return nullableSimpleUserSchema.describe("A GitHub user.").nullable()
              },
"private": z.boolean(),
"html_url": z.url(),
"description": z.nullable(z.string()),
"fork": z.boolean(),
"url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"pushed_at": z.iso.datetime({ offset: true }),
"homepage": z.nullable(z.url()),
"size": z.int(),
"stargazers_count": z.int(),
"watchers_count": z.int(),
"language": z.nullable(z.string()),
"forks_count": z.int(),
"open_issues_count": z.int(),
"master_branch": z.optional(z.string()),
"default_branch": z.string(),
"score": z.number(),
"forks_url": z.url(),
"keys_url": z.string(),
"collaborators_url": z.string(),
"teams_url": z.url(),
"hooks_url": z.url(),
"issue_events_url": z.string(),
"events_url": z.url(),
"assignees_url": z.string(),
"branches_url": z.string(),
"tags_url": z.url(),
"blobs_url": z.string(),
"git_tags_url": z.string(),
"git_refs_url": z.string(),
"trees_url": z.string(),
"statuses_url": z.string(),
"languages_url": z.url(),
"stargazers_url": z.url(),
"contributors_url": z.url(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"commits_url": z.string(),
"git_commits_url": z.string(),
"comments_url": z.string(),
"issue_comment_url": z.string(),
"contents_url": z.string(),
"compare_url": z.string(),
"merges_url": z.url(),
"archive_url": z.string(),
"downloads_url": z.url(),
"issues_url": z.string(),
"pulls_url": z.string(),
"milestones_url": z.string(),
"notifications_url": z.string(),
"labels_url": z.string(),
"releases_url": z.string(),
"deployments_url": z.url(),
"git_url": z.string(),
"ssh_url": z.string(),
"clone_url": z.string(),
"svn_url": z.url(),
"forks": z.int(),
"open_issues": z.int(),
"watchers": z.int(),
"topics": z.optional(z.array(z.string())),
"mirror_url": z.nullable(z.url()),
"has_issues": z.boolean(),
"has_projects": z.boolean(),
"has_pages": z.boolean(),
"has_wiki": z.boolean(),
"has_downloads": z.boolean(),
"has_discussions": z.optional(z.boolean()),
"archived": z.boolean(),
"disabled": z.boolean().describe("Returns whether or not this repository disabled."),
"visibility": z.optional(z.string().describe("The repository visibility: public, private, or internal.")),
get "license"(){
               return nullableLicenseSimpleSchema.describe("License Simple").nullable()
              },
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"push": z.boolean(),
"triage": z.optional(z.boolean()),
"pull": z.boolean()
    })),
get "text_matches"(){
                return searchResultTextMatchesSchema.optional()
              },
"temp_clone_token": z.optional(z.string()),
"allow_merge_commit": z.optional(z.boolean()),
"allow_squash_merge": z.optional(z.boolean()),
"allow_rebase_merge": z.optional(z.boolean()),
"allow_auto_merge": z.optional(z.boolean()),
"delete_branch_on_merge": z.optional(z.boolean()),
"allow_forking": z.optional(z.boolean()),
"is_template": z.optional(z.boolean()),
"web_commit_signoff_required": z.optional(z.boolean())
    }).describe("Repo Search Result Item")

/**
 * @description Topic Search Result Item
 */
export const topicSearchResultItemSchema = z.object({
    "name": z.string(),
"display_name": z.nullable(z.string()),
"short_description": z.nullable(z.string()),
"description": z.nullable(z.string()),
"created_by": z.nullable(z.string()),
"released": z.nullable(z.string()),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"featured": z.boolean(),
"curated": z.boolean(),
"score": z.number(),
"repository_count": z.int().nullish(),
"logo_url": z.url().nullish(),
get "text_matches"(){
                return searchResultTextMatchesSchema.optional()
              },
"related": z.array(z.object({
    "topic_relation": z.optional(z.object({
    "id": z.optional(z.int()),
"name": z.optional(z.string()),
"topic_id": z.optional(z.int()),
"relation_type": z.optional(z.string())
    }))
    })).nullish(),
"aliases": z.array(z.object({
    "topic_relation": z.optional(z.object({
    "id": z.optional(z.int()),
"name": z.optional(z.string()),
"topic_id": z.optional(z.int()),
"relation_type": z.optional(z.string())
    }))
    })).nullish()
    }).describe("Topic Search Result Item")

/**
 * @description User Search Result Item
 */
export const userSearchResultItemSchema = z.object({
    "login": z.string(),
"id": z.int(),
"node_id": z.string(),
"avatar_url": z.url(),
"gravatar_id": z.nullable(z.string()),
"url": z.url(),
"html_url": z.url(),
"followers_url": z.url(),
"subscriptions_url": z.url(),
"organizations_url": z.url(),
"repos_url": z.url(),
"received_events_url": z.url(),
"type": z.string(),
"score": z.number(),
"following_url": z.string(),
"gists_url": z.string(),
"starred_url": z.string(),
"events_url": z.string(),
"public_repos": z.optional(z.int()),
"public_gists": z.optional(z.int()),
"followers": z.optional(z.int()),
"following": z.optional(z.int()),
"created_at": z.optional(z.iso.datetime({ offset: true })),
"updated_at": z.optional(z.iso.datetime({ offset: true })),
"name": z.string().nullish(),
"bio": z.string().nullish(),
"email": z.email().nullish(),
"location": z.string().nullish(),
"site_admin": z.boolean(),
"hireable": z.boolean().nullish(),
get "text_matches"(){
                return searchResultTextMatchesSchema.optional()
              },
"blog": z.string().nullish(),
"company": z.string().nullish(),
"suspended_at": z.iso.datetime({ offset: true }).nullish(),
"user_view_type": z.optional(z.string())
    }).describe("User Search Result Item")

/**
 * @description Private User
 */
export const privateUserSchema = z.object({
    "login": z.string(),
"id": z.int(),
"user_view_type": z.optional(z.string()),
"node_id": z.string(),
"avatar_url": z.url(),
"gravatar_id": z.nullable(z.string()),
"url": z.url(),
"html_url": z.url(),
"followers_url": z.url(),
"following_url": z.string(),
"gists_url": z.string(),
"starred_url": z.string(),
"subscriptions_url": z.url(),
"organizations_url": z.url(),
"repos_url": z.url(),
"events_url": z.string(),
"received_events_url": z.url(),
"type": z.string(),
"site_admin": z.boolean(),
"name": z.nullable(z.string()),
"company": z.nullable(z.string()),
"blog": z.nullable(z.string()),
"location": z.nullable(z.string()),
"email": z.nullable(z.email()),
"notification_email": z.email().nullish(),
"hireable": z.nullable(z.boolean()),
"bio": z.nullable(z.string()),
"twitter_username": z.string().nullish(),
"public_repos": z.int(),
"public_gists": z.int(),
"followers": z.int(),
"following": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"private_gists": z.int(),
"total_private_repos": z.int(),
"owned_private_repos": z.int(),
"disk_usage": z.int(),
"collaborators": z.int(),
"two_factor_authentication": z.boolean(),
"plan": z.optional(z.object({
    "collaborators": z.int(),
"name": z.string(),
"space": z.int(),
"private_repos": z.int()
    })),
"business_plus": z.optional(z.boolean()),
"ldap_dn": z.optional(z.string())
    }).describe("Private User")

/**
 * @description Secrets for a GitHub Codespace.
 */
export const codespacesSecretSchema = z.object({
    "name": z.string().describe("The name of the secret"),
"created_at": z.iso.datetime({ offset: true }).describe("The date and time at which the secret was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."),
"updated_at": z.iso.datetime({ offset: true }).describe("The date and time at which the secret was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ."),
"visibility": z.enum(["all", "private", "selected"]).describe("The type of repositories in the organization that the secret is visible to"),
"selected_repositories_url": z.url().describe("The API URL at which the list of repositories this secret is visible to can be retrieved")
    }).describe("Secrets for a GitHub Codespace.")

/**
 * @description The public key used for setting user Codespaces\' Secrets.
 */
export const codespacesUserPublicKeySchema = z.object({
    "key_id": z.string().describe("The identifier for the key."),
"key": z.string().describe("The Base64 encoded public key.")
    }).describe("The public key used for setting user Codespaces' Secrets.")

/**
 * @description An export of a codespace. Also, latest export details for a codespace can be fetched with id = latest
 */
export const codespaceExportDetailsSchema = z.object({
    "state": z.string().describe("State of the latest export").nullish(),
"completed_at": z.iso.datetime({ offset: true }).describe("Completion time of the last export operation").nullish(),
"branch": z.string().describe("Name of the exported branch").nullish(),
"sha": z.string().describe("Git commit SHA of the exported branch").nullish(),
"id": z.optional(z.string().describe("Id for the export details")),
"export_url": z.optional(z.string().describe("Url for fetching export details")),
"html_url": z.string().describe("Web url for the exported branch").nullish()
    }).describe("An export of a codespace. Also, latest export details for a codespace can be fetched with id = latest")

/**
 * @description A codespace.
 */
export const codespaceWithFullRepositorySchema = z.object({
    "id": z.int(),
"name": z.string().describe("Automatically generated name of this codespace."),
"display_name": z.string().describe("Display name for this codespace.").nullish(),
"environment_id": z.nullable(z.string().describe("UUID identifying this codespace's environment.")),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "billable_owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "repository"(){
                return fullRepositorySchema.describe("Full Repository")
              },
get "machine"(){
               return nullableCodespaceMachineSchema.describe("A description of the machine powering a codespace.").nullable()
              },
"devcontainer_path": z.string().describe("Path to devcontainer.json from repo root used to create Codespace.").nullish(),
"prebuild": z.nullable(z.boolean().describe("Whether the codespace was created from a prebuild.")),
"created_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }),
"last_used_at": z.iso.datetime({ offset: true }).describe("Last known time this codespace was started."),
"state": z.enum(["Unknown", "Created", "Queued", "Provisioning", "Available", "Awaiting", "Unavailable", "Deleted", "Moved", "Shutdown", "Archived", "Starting", "ShuttingDown", "Failed", "Exporting", "Updating", "Rebuilding"]).describe("State of this codespace."),
"url": z.url().describe("API URL for this codespace."),
"git_status": z.object({
    "ahead": z.optional(z.int().describe("The number of commits the local repository is ahead of the remote.")),
"behind": z.optional(z.int().describe("The number of commits the local repository is behind the remote.")),
"has_unpushed_changes": z.optional(z.boolean().describe("Whether the local repository has unpushed changes.")),
"has_uncommitted_changes": z.optional(z.boolean().describe("Whether the local repository has uncommitted changes.")),
"ref": z.optional(z.string().describe("The current branch (or SHA if in detached HEAD state) of the local repository."))
    }).describe("Details about the codespace's git repository."),
"location": z.enum(["EastUs", "SouthEastAsia", "WestEurope", "WestUs2"]).describe("The initally assigned location of a new codespace."),
"idle_timeout_minutes": z.nullable(z.int().describe("The number of minutes of inactivity after which this codespace will be automatically stopped.")),
"web_url": z.url().describe("URL to access this codespace on the web."),
"machines_url": z.url().describe("API URL to access available alternate machine types for this codespace."),
"start_url": z.url().describe("API URL to start this codespace."),
"stop_url": z.url().describe("API URL to stop this codespace."),
"publish_url": z.url().describe("API URL to publish this codespace to a new repository.").nullish(),
"pulls_url": z.nullable(z.url().describe("API URL for the Pull Request associated with this codespace, if any.")),
"recent_folders": z.array(z.string()),
"runtime_constraints": z.optional(z.object({
    "allowed_port_privacy_settings": z.array(z.string()).describe("The privacy settings a user can select from when forwarding a port.").nullish()
    })),
"pending_operation": z.boolean().describe("Whether or not a codespace has a pending async operation. This would mean that the codespace is temporarily unavailable. The only thing that you can do with a codespace in this state is delete it.").nullish(),
"pending_operation_disabled_reason": z.string().describe("Text to show user when codespace is disabled by a pending operation").nullish(),
"idle_timeout_notice": z.string().describe("Text to show user when codespace idle timeout minutes has been overriden by an organization policy").nullish(),
"retention_period_minutes": z.int().describe("Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).").nullish(),
"retention_expires_at": z.iso.datetime({ offset: true }).describe("When a codespace will be auto-deleted based on the \"retention_period_minutes\" and \"last_used_at\"").nullish()
    }).describe("A codespace.")

/**
 * @description Email
 */
export const emailSchema = z.object({
    "email": z.email(),
"primary": z.boolean(),
"verified": z.boolean(),
"visibility": z.nullable(z.string())
    }).describe("Email")

/**
 * @description A unique encryption key
 */
export const gpgKeySchema = z.object({
    "id": z.int(),
"name": z.string().nullish(),
"primary_key_id": z.nullable(z.int()),
"key_id": z.string(),
"public_key": z.string(),
"emails": z.array(z.object({
    "email": z.optional(z.string()),
"verified": z.optional(z.boolean())
    })),
"subkeys": z.array(z.object({
    "id": z.optional(z.int()),
"primary_key_id": z.optional(z.int()),
"key_id": z.optional(z.string()),
"public_key": z.optional(z.string()),
"emails": z.optional(z.array(z.object({
    "email": z.optional(z.string()),
"verified": z.optional(z.boolean())
    }))),
"subkeys": z.optional(z.array(z.unknown())),
"can_sign": z.optional(z.boolean()),
"can_encrypt_comms": z.optional(z.boolean()),
"can_encrypt_storage": z.optional(z.boolean()),
"can_certify": z.optional(z.boolean()),
"created_at": z.optional(z.string()),
"expires_at": z.string().nullish(),
"raw_key": z.string().nullish(),
"revoked": z.optional(z.boolean())
    })),
"can_sign": z.boolean(),
"can_encrypt_comms": z.boolean(),
"can_encrypt_storage": z.boolean(),
"can_certify": z.boolean(),
"created_at": z.iso.datetime({ offset: true }),
"expires_at": z.nullable(z.iso.datetime({ offset: true })),
"revoked": z.boolean(),
"raw_key": z.nullable(z.string())
    }).describe("A unique encryption key")

/**
 * @description Key
 */
export const keySchema = z.object({
    "key": z.string(),
"id": z.int(),
"url": z.string(),
"title": z.string(),
"created_at": z.iso.datetime({ offset: true }),
"verified": z.boolean(),
"read_only": z.boolean(),
"last_used": z.iso.datetime({ offset: true }).nullish()
    }).describe("Key")

export const marketplaceAccountSchema = z.object({
    "url": z.url(),
"id": z.int(),
"type": z.string(),
"node_id": z.optional(z.string()),
"login": z.string(),
"email": z.email().nullish(),
"organization_billing_email": z.email().nullish()
    })

/**
 * @description User Marketplace Purchase
 */
export const userMarketplacePurchaseSchema = z.object({
    "billing_cycle": z.string(),
"next_billing_date": z.nullable(z.iso.datetime({ offset: true })),
"unit_count": z.nullable(z.int()),
"on_free_trial": z.boolean(),
"free_trial_ends_on": z.nullable(z.iso.datetime({ offset: true })),
"updated_at": z.nullable(z.iso.datetime({ offset: true })),
get "account"(){
                return marketplaceAccountSchema
              },
get "plan"(){
                return marketplaceListingPlanSchema.describe("Marketplace Listing Plan")
              }
    }).describe("User Marketplace Purchase")

/**
 * @description Social media account
 */
export const socialAccountSchema = z.object({
    "provider": z.string(),
"url": z.string()
    }).describe("Social media account")

/**
 * @description A public SSH key used to sign Git commits
 */
export const sshSigningKeySchema = z.object({
    "key": z.string(),
"id": z.int(),
"title": z.string(),
"created_at": z.iso.datetime({ offset: true })
    }).describe("A public SSH key used to sign Git commits")

/**
 * @description Starred Repository
 */
export const starredRepositorySchema = z.object({
    "starred_at": z.iso.datetime({ offset: true }),
get "repo"(){
                return repositorySchema.describe("A repository on GitHub.")
              }
    }).describe("Starred Repository")

/**
 * @description Hovercard
 */
export const hovercardSchema = z.object({
    "contexts": z.array(z.object({
    "message": z.string(),
"octicon": z.string()
    }))
    }).describe("Hovercard")

/**
 * @description Key Simple
 */
export const keySimpleSchema = z.object({
    "id": z.int(),
"key": z.string(),
"created_at": z.optional(z.iso.datetime({ offset: true })),
"last_used": z.iso.datetime({ offset: true }).nullish()
    }).describe("Key Simple")

export const billingPremiumRequestUsageReportUserSchema = z.object({
    "timePeriod": z.object({
    "year": z.int().describe("The year for the usage report."),
"month": z.optional(z.int().describe("The month for the usage report.")),
"day": z.optional(z.int().describe("The day for the usage report."))
    }),
"user": z.string().describe("The unique identifier of the user."),
"product": z.optional(z.string().describe("The product for the usage report.")),
"model": z.optional(z.string().describe("The model for the usage report.")),
"usageItems": z.array(z.object({
    "product": z.string().describe("Product name."),
"sku": z.string().describe("SKU name."),
"model": z.string().describe("Model name."),
"unitType": z.string().describe("Unit type of the usage line item."),
"pricePerUnit": z.number().describe("Price per unit of the usage line item."),
"grossQuantity": z.number().describe("Gross quantity of the usage line item."),
"grossAmount": z.number().describe("Gross amount of the usage line item."),
"discountQuantity": z.number().describe("Discount quantity of the usage line item."),
"discountAmount": z.number().describe("Discount amount of the usage line item."),
"netQuantity": z.number().describe("Net quantity of the usage line item."),
"netAmount": z.number().describe("Net amount of the usage line item.")
    }))
    })

export const billingUsageReportUserSchema = z.object({
    "usageItems": z.optional(z.array(z.object({
    "date": z.string().describe("Date of the usage line item."),
"product": z.string().describe("Product name."),
"sku": z.string().describe("SKU name."),
"quantity": z.int().describe("Quantity of the usage line item."),
"unitType": z.string().describe("Unit type of the usage line item."),
"pricePerUnit": z.number().describe("Price per unit of the usage line item."),
"grossAmount": z.number().describe("Gross amount of the usage line item."),
"discountAmount": z.number().describe("Discount amount of the usage line item."),
"netAmount": z.number().describe("Net amount of the usage line item."),
"repositoryName": z.optional(z.string().describe("Name of the repository."))
    })))
    })

/**
 * @description An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that\'s part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"
 */
export const enterpriseWebhooksSchema = z.object({
    "description": z.string().describe("A short description of the enterprise.").nullish(),
"html_url": z.url(),
"website_url": z.url().describe("The enterprise's website URL.").nullish(),
"id": z.int().describe("Unique identifier of the enterprise"),
"node_id": z.string(),
"name": z.string().describe("The name of the enterprise."),
"slug": z.string().describe("The slug url identifier for the enterprise."),
"created_at": z.nullable(z.iso.datetime({ offset: true })),
"updated_at": z.nullable(z.iso.datetime({ offset: true })),
"avatar_url": z.url()
    }).describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"")

/**
 * @description The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"
 */
export const simpleInstallationSchema = z.object({
    "id": z.int().describe("The ID of the installation."),
"node_id": z.string().describe("The global node ID of the installation.")
    }).describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"")

/**
 * @description A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.
 */
export const organizationSimpleWebhooksSchema = z.object({
    "login": z.string(),
"id": z.int(),
"node_id": z.string(),
"url": z.url(),
"repos_url": z.url(),
"events_url": z.url(),
"hooks_url": z.string(),
"issues_url": z.string(),
"members_url": z.string(),
"public_members_url": z.string(),
"avatar_url": z.string(),
"description": z.nullable(z.string())
    }).describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")

/**
 * @description The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.
 */
export const repositoryWebhooksSchema = z.object({
    "id": z.int().describe("Unique identifier of the repository"),
"node_id": z.string(),
"name": z.string().describe("The name of the repository."),
"full_name": z.string(),
get "license"(){
               return nullableLicenseSimpleSchema.describe("License Simple").nullable()
              },
get "organization"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
"forks": z.int(),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"pull": z.boolean(),
"triage": z.optional(z.boolean()),
"push": z.boolean(),
"maintain": z.optional(z.boolean())
    })),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"private": z.boolean().default(false).describe("Whether the repository is private or public."),
"html_url": z.url(),
"description": z.nullable(z.string()),
"fork": z.boolean(),
"url": z.url(),
"archive_url": z.string(),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"deployments_url": z.url(),
"downloads_url": z.url(),
"events_url": z.url(),
"forks_url": z.url(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.string(),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"languages_url": z.url(),
"merges_url": z.url(),
"milestones_url": z.string(),
"notifications_url": z.string(),
"pulls_url": z.string(),
"releases_url": z.string(),
"ssh_url": z.string(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"trees_url": z.string(),
"clone_url": z.string(),
"mirror_url": z.nullable(z.url()),
"hooks_url": z.url(),
"svn_url": z.url(),
"homepage": z.nullable(z.url()),
"language": z.nullable(z.string()),
"forks_count": z.int(),
"stargazers_count": z.int(),
"watchers_count": z.int(),
"size": z.int().describe("The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0."),
"default_branch": z.string().describe("The default branch of the repository."),
"open_issues_count": z.int(),
"is_template": z.optional(z.boolean().default(false).describe("Whether this repository acts as a template that can be used to generate new repositories.")),
"topics": z.optional(z.array(z.string())),
"custom_properties": z.optional(z.object({
    
    }).catchall(z.unknown()).describe("The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.")),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_pages": z.boolean(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_discussions": z.optional(z.boolean().default(false).describe("Whether discussions are enabled.")),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"disabled": z.boolean().describe("Returns whether or not this repository disabled."),
"visibility": z.optional(z.string().default("public").describe("The repository visibility: public, private, or internal.")),
"pushed_at": z.nullable(z.iso.datetime({ offset: true })),
"created_at": z.nullable(z.iso.datetime({ offset: true })),
"updated_at": z.nullable(z.iso.datetime({ offset: true })),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"template_repository": z.object({
    "id": z.optional(z.int()),
"node_id": z.optional(z.string()),
"name": z.optional(z.string()),
"full_name": z.optional(z.string()),
"owner": z.optional(z.object({
    "login": z.optional(z.string()),
"id": z.optional(z.int()),
"node_id": z.optional(z.string()),
"avatar_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"type": z.optional(z.string()),
"site_admin": z.optional(z.boolean())
    })),
"private": z.optional(z.boolean()),
"html_url": z.optional(z.string()),
"description": z.optional(z.string()),
"fork": z.optional(z.boolean()),
"url": z.optional(z.string()),
"archive_url": z.optional(z.string()),
"assignees_url": z.optional(z.string()),
"blobs_url": z.optional(z.string()),
"branches_url": z.optional(z.string()),
"collaborators_url": z.optional(z.string()),
"comments_url": z.optional(z.string()),
"commits_url": z.optional(z.string()),
"compare_url": z.optional(z.string()),
"contents_url": z.optional(z.string()),
"contributors_url": z.optional(z.string()),
"deployments_url": z.optional(z.string()),
"downloads_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"forks_url": z.optional(z.string()),
"git_commits_url": z.optional(z.string()),
"git_refs_url": z.optional(z.string()),
"git_tags_url": z.optional(z.string()),
"git_url": z.optional(z.string()),
"issue_comment_url": z.optional(z.string()),
"issue_events_url": z.optional(z.string()),
"issues_url": z.optional(z.string()),
"keys_url": z.optional(z.string()),
"labels_url": z.optional(z.string()),
"languages_url": z.optional(z.string()),
"merges_url": z.optional(z.string()),
"milestones_url": z.optional(z.string()),
"notifications_url": z.optional(z.string()),
"pulls_url": z.optional(z.string()),
"releases_url": z.optional(z.string()),
"ssh_url": z.optional(z.string()),
"stargazers_url": z.optional(z.string()),
"statuses_url": z.optional(z.string()),
"subscribers_url": z.optional(z.string()),
"subscription_url": z.optional(z.string()),
"tags_url": z.optional(z.string()),
"teams_url": z.optional(z.string()),
"trees_url": z.optional(z.string()),
"clone_url": z.optional(z.string()),
"mirror_url": z.optional(z.string()),
"hooks_url": z.optional(z.string()),
"svn_url": z.optional(z.string()),
"homepage": z.optional(z.string()),
"language": z.optional(z.string()),
"forks_count": z.optional(z.int()),
"stargazers_count": z.optional(z.int()),
"watchers_count": z.optional(z.int()),
"size": z.optional(z.int()),
"default_branch": z.optional(z.string()),
"open_issues_count": z.optional(z.int()),
"is_template": z.optional(z.boolean()),
"topics": z.optional(z.array(z.string())),
"has_issues": z.optional(z.boolean()),
"has_projects": z.optional(z.boolean()),
"has_wiki": z.optional(z.boolean()),
"has_pages": z.optional(z.boolean()),
"has_downloads": z.optional(z.boolean()),
"archived": z.optional(z.boolean()),
"disabled": z.optional(z.boolean()),
"visibility": z.optional(z.string()),
"pushed_at": z.optional(z.string()),
"created_at": z.optional(z.string()),
"updated_at": z.optional(z.string()),
"permissions": z.optional(z.object({
    "admin": z.optional(z.boolean()),
"maintain": z.optional(z.boolean()),
"push": z.optional(z.boolean()),
"triage": z.optional(z.boolean()),
"pull": z.optional(z.boolean())
    })),
"allow_rebase_merge": z.optional(z.boolean()),
"temp_clone_token": z.optional(z.string()),
"allow_squash_merge": z.optional(z.boolean()),
"allow_auto_merge": z.optional(z.boolean()),
"delete_branch_on_merge": z.optional(z.boolean()),
"allow_update_branch": z.optional(z.boolean()),
"use_squash_pr_title_as_default": z.optional(z.boolean()),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"allow_merge_commit": z.optional(z.boolean()),
"subscribers_count": z.optional(z.int()),
"network_count": z.optional(z.int())
    }).nullish(),
"temp_clone_token": z.optional(z.string()),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow Auto-merge to be used on pull requests.")),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"allow_update_branch": z.optional(z.boolean().default(false).describe("Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.")),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow forking this repo")),
"web_commit_signoff_required": z.optional(z.boolean().default(false).describe("Whether to require contributors to sign off on web-based commits")),
"subscribers_count": z.optional(z.int()),
"network_count": z.optional(z.int()),
"open_issues": z.int(),
"watchers": z.int(),
"master_branch": z.optional(z.string()),
"starred_at": z.optional(z.string()),
"anonymous_access_enabled": z.optional(z.boolean().describe("Whether anonymous git access is enabled for this repository"))
    }).describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")

/**
 * @description The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings.
 */
export const webhooksRuleSchema = z.object({
    "admin_enforced": z.boolean(),
"allow_deletions_enforcement_level": z.enum(["off", "non_admins", "everyone"]),
"allow_force_pushes_enforcement_level": z.enum(["off", "non_admins", "everyone"]),
"authorized_actor_names": z.array(z.string()),
"authorized_actors_only": z.boolean(),
"authorized_dismissal_actors_only": z.boolean(),
"create_protected": z.optional(z.boolean()),
"created_at": z.iso.datetime({ offset: true }),
"dismiss_stale_reviews_on_push": z.boolean(),
"id": z.int(),
"ignore_approvals_from_contributors": z.boolean(),
"linear_history_requirement_enforcement_level": z.enum(["off", "non_admins", "everyone"]),
"lock_branch_enforcement_level": z.enum(["off", "non_admins", "everyone"]).describe("The enforcement level of the branch lock setting. `off` means the branch is not locked, `non_admins` means the branch is read-only for non_admins, and `everyone` means the branch is read-only for everyone."),
"lock_allows_fork_sync": z.optional(z.boolean().describe("Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow users to pull changes from upstream when the branch is locked. This setting is only applicable for forks.")),
"merge_queue_enforcement_level": z.enum(["off", "non_admins", "everyone"]),
"name": z.string(),
"pull_request_reviews_enforcement_level": z.enum(["off", "non_admins", "everyone"]),
"repository_id": z.int(),
"require_code_owner_review": z.boolean(),
"require_last_push_approval": z.optional(z.boolean().describe("Whether the most recent push must be approved by someone other than the person who pushed it")),
"required_approving_review_count": z.int(),
"required_conversation_resolution_level": z.enum(["off", "non_admins", "everyone"]),
"required_deployments_enforcement_level": z.enum(["off", "non_admins", "everyone"]),
"required_status_checks": z.array(z.string()),
"required_status_checks_enforcement_level": z.enum(["off", "non_admins", "everyone"]),
"signature_requirement_enforcement_level": z.enum(["off", "non_admins", "everyone"]),
"strict_required_status_checks_policy": z.boolean(),
"updated_at": z.iso.datetime({ offset: true })
    }).describe("The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings.")

/**
 * @description A suite of checks performed on the code of a given code change
 */
export const simpleCheckSuiteSchema = z.object({
    "after": z.string().nullish(),
get "app"(){
                return integrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").optional()
              },
"before": z.string().nullish(),
"conclusion": z.enum(["success", "failure", "neutral", "cancelled", "skipped", "timed_out", "action_required", "stale", "startup_failure"]).nullish(),
"created_at": z.optional(z.iso.datetime({ offset: true })),
"head_branch": z.string().nullish(),
"head_sha": z.optional(z.string().describe("The SHA of the head commit that is being checked.")),
"id": z.optional(z.int()),
"node_id": z.optional(z.string()),
get "pull_requests"(){
                return z.array(pullRequestMinimalSchema).optional()
              },
get "repository"(){
                return minimalRepositorySchema.describe("Minimal Repository").optional()
              },
"status": z.optional(z.enum(["queued", "in_progress", "completed", "pending", "waiting"])),
"updated_at": z.optional(z.iso.datetime({ offset: true })),
"url": z.optional(z.string())
    }).describe("A suite of checks performed on the code of a given code change")

/**
 * @description A check performed on the code of a given code change
 */
export const checkRunWithSimpleCheckSuiteSchema = z.object({
    get "app"(){
               return integrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
get "check_suite"(){
                return simpleCheckSuiteSchema.describe("A suite of checks performed on the code of a given code change")
              },
"completed_at": z.nullable(z.iso.datetime({ offset: true })),
"conclusion": z.nullable(z.enum(["waiting", "pending", "startup_failure", "stale", "success", "failure", "neutral", "cancelled", "skipped", "timed_out", "action_required"])),
get "deployment"(){
                return deploymentSimpleSchema.describe("A deployment created as the result of an Actions check run from a workflow that references an environment").optional()
              },
"details_url": z.string(),
"external_id": z.string(),
"head_sha": z.string().describe("The SHA of the commit that is being checked."),
"html_url": z.string(),
"id": z.int().describe("The id of the check."),
"name": z.string().describe("The name of the check."),
"node_id": z.string(),
"output": z.object({
    "annotations_count": z.int(),
"annotations_url": z.url(),
"summary": z.nullable(z.string()),
"text": z.nullable(z.string()),
"title": z.nullable(z.string())
    }),
get "pull_requests"(){
                return z.array(pullRequestMinimalSchema)
              },
"started_at": z.iso.datetime({ offset: true }),
"status": z.enum(["queued", "in_progress", "completed", "pending"]).describe("The phase of the lifecycle that the check is currently in."),
"url": z.string()
    }).describe("A check performed on the code of a given code change")

/**
 * @description The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
 */
export const webhooksCodeScanningCommitOidSchema = z.string().describe("The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.")

/**
 * @description The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
 */
export const webhooksCodeScanningRefSchema = z.string().describe("The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.")

/**
 * @description The pusher type for the event. Can be either `user` or a deploy key.
 */
export const webhooksDeployPusherTypeSchema = z.string().describe("The pusher type for the event. Can be either `user` or a deploy key.")

/**
 * @description The [`git ref`](https://docs.github.com/rest/git/refs#get-a-reference) resource.
 */
export const webhooksRef0Schema = z.string().describe("The [`git ref`](https://docs.github.com/rest/git/refs#get-a-reference) resource.")

/**
 * @description The [`deploy key`](https://docs.github.com/rest/deploy-keys/deploy-keys#get-a-deploy-key) resource.
 */
export const webhooksDeployKeySchema = z.object({
    "added_by": z.string().nullish(),
"created_at": z.string(),
"id": z.int(),
"key": z.string(),
"last_used": z.string().nullish(),
"read_only": z.boolean(),
"title": z.string(),
"url": z.url(),
"verified": z.boolean(),
"enabled": z.optional(z.boolean())
    }).describe("The [`deploy key`](https://docs.github.com/rest/deploy-keys/deploy-keys#get-a-deploy-key) resource.")

export const webhooksWorkflowSchema = z.object({
    "badge_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"html_url": z.url(),
"id": z.int(),
"name": z.string(),
"node_id": z.string(),
"path": z.string(),
"state": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).nullable()

export const webhooksApproverSchema = z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string()),
"user_view_type": z.optional(z.string())
    })

export const webhooksReviewersSchema = z.array(z.object({
    "reviewer": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullish(),
"type": z.optional(z.enum(["User"]))
    }))

export const webhooksWorkflowJobRunSchema = z.object({
    "conclusion": z.unknown(),
"created_at": z.string(),
"environment": z.string(),
"html_url": z.string(),
"id": z.int(),
"name": z.unknown(),
"status": z.string(),
"updated_at": z.string()
    })

export const webhooksUserSchema = z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullable()

export const webhooksAnswerSchema = z.object({
    "author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.string(),
"child_comment_count": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"discussion_id": z.int(),
"html_url": z.string(),
"id": z.int(),
"node_id": z.string(),
"parent_id": z.unknown(),
"reactions": z.optional(z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    })),
"repository_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    })

/**
 * @description A Discussion in a repository.
 */
export const discussionSchema = z.object({
    "active_lock_reason": z.nullable(z.string()),
"answer_chosen_at": z.nullable(z.string()),
"answer_chosen_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"answer_html_url": z.nullable(z.string()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.string(),
"category": z.object({
    "created_at": z.iso.datetime({ offset: true }),
"description": z.string(),
"emoji": z.string(),
"id": z.int(),
"is_answerable": z.boolean(),
"name": z.string(),
"node_id": z.optional(z.string()),
"repository_id": z.int(),
"slug": z.string(),
"updated_at": z.string()
    }),
"comments": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"html_url": z.string(),
"id": z.int(),
"locked": z.boolean(),
"node_id": z.string(),
"number": z.int(),
"reactions": z.optional(z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    })),
"repository_url": z.string(),
"state": z.enum(["open", "closed", "locked", "converting", "transferring"]).describe("The current state of the discussion.\n`converting` means that the discussion is being converted from an issue.\n`transferring` means that the discussion is being transferred from another repository."),
"state_reason": z.nullable(z.enum(["resolved", "outdated", "duplicate", "reopened"]).describe("The reason for the current state")),
"timeline_url": z.optional(z.string()),
"title": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
get "labels"(){
                return z.array(labelSchema.describe("Color-coded labels help you categorize and filter your issues (just like labels in Gmail).")).optional()
              }
    }).describe("A Discussion in a repository.")

export const webhooksCommentSchema = z.object({
    "author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.string(),
"child_comment_count": z.int(),
"created_at": z.string(),
"discussion_id": z.int(),
"html_url": z.string(),
"id": z.int(),
"node_id": z.string(),
"parent_id": z.nullable(z.int()),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"repository_url": z.string(),
"updated_at": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    })

export const webhooksLabelSchema = z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })

/**
 * @description An array of repository objects that the installation can access.
 */
export const webhooksRepositoriesSchema = z.array(z.object({
    "full_name": z.string(),
"id": z.int().describe("Unique identifier of the repository"),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"private": z.boolean().describe("Whether the repository is private or public.")
    })).describe("An array of repository objects that the installation can access.")

/**
 * @description An array of repository objects, which were added to the installation.
 */
export const webhooksRepositoriesAddedSchema = z.array(z.object({
    "full_name": z.string(),
"id": z.int().describe("Unique identifier of the repository"),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"private": z.boolean().describe("Whether the repository is private or public.")
    })).describe("An array of repository objects, which were added to the installation.")

/**
 * @description Describe whether all repositories have been selected or there\'s a selection involved
 */
export const webhooksRepositorySelectionSchema = z.enum(["all", "selected"]).describe("Describe whether all repositories have been selected or there's a selection involved")

/**
 * @description The [comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment) itself.
 */
export const webhooksIssueCommentSchema = z.object({
    "author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.string().describe("Contents of the issue comment"),
"created_at": z.iso.datetime({ offset: true }),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the issue comment"),
"issue_url": z.url(),
"node_id": z.string(),
get "performed_via_github_app"(){
               return integrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the issue comment"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment) itself.")

/**
 * @description The changes to the comment.
 */
export const webhooksChangesSchema = z.object({
    "body": z.optional(z.object({
    "from": z.string().describe("The previous version of the body.")
    }))
    }).describe("The changes to the comment.")

/**
 * @description The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
 */
export const webhooksIssueSchema = z.object({
    "active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.nullable(z.string().describe("Contents of the issue")),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.int(),
"comments_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"draft": z.optional(z.boolean()),
"events_url": z.url(),
"html_url": z.url(),
"id": z.int(),
"labels": z.optional(z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    }))),
"labels_url": z.string(),
"locked": z.optional(z.boolean()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"performed_via_github_app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run", "reminder", "pull_request_review_thread"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write", "admin"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"repository_url": z.url(),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              },
"state": z.optional(z.enum(["open", "closed"]).describe("State of the issue; either 'open' or 'closed'")),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.url()),
"title": z.string().describe("Title of the issue"),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the issue"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.")

/**
 * @description A collection of related issues and pull requests.
 */
export const webhooksMilestoneSchema = z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")

/**
 * @description The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
 */
export const webhooksIssue2Schema = z.object({
    "active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.nullable(z.string().describe("Contents of the issue")),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.int(),
"comments_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"draft": z.optional(z.boolean()),
"events_url": z.url(),
"html_url": z.url(),
"id": z.int(),
"labels": z.optional(z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    }))),
"labels_url": z.string(),
"locked": z.optional(z.boolean()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"performed_via_github_app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"repository_url": z.url(),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              },
"state": z.optional(z.enum(["open", "closed"]).describe("State of the issue; either 'open' or 'closed'")),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.url()),
"title": z.string().describe("Title of the issue"),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the issue"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.")

export const webhooksUserMannequinSchema = z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullable()

export const webhooksMarketplacePurchaseSchema = z.object({
    "account": z.object({
    "id": z.int(),
"login": z.string(),
"node_id": z.string(),
"organization_billing_email": z.nullable(z.string()),
"type": z.string()
    }),
"billing_cycle": z.string(),
"free_trial_ends_on": z.nullable(z.string()),
"next_billing_date": z.nullable(z.string()),
"on_free_trial": z.boolean(),
"plan": z.object({
    "bullets": z.array(z.string().nullable()),
"description": z.string(),
"has_free_trial": z.boolean(),
"id": z.int(),
"monthly_price_in_cents": z.int(),
"name": z.string(),
"price_model": z.enum(["FREE", "FLAT_RATE", "PER_UNIT"]),
"unit_name": z.nullable(z.string()),
"yearly_price_in_cents": z.int()
    }),
"unit_count": z.int()
    })

export const webhooksPreviousMarketplacePurchaseSchema = z.object({
    "account": z.object({
    "id": z.int(),
"login": z.string(),
"node_id": z.string(),
"organization_billing_email": z.nullable(z.string()),
"type": z.string()
    }),
"billing_cycle": z.string(),
"free_trial_ends_on": z.unknown(),
"next_billing_date": z.string().nullish(),
"on_free_trial": z.boolean(),
"plan": z.object({
    "bullets": z.array(z.string()),
"description": z.string(),
"has_free_trial": z.boolean(),
"id": z.int(),
"monthly_price_in_cents": z.int(),
"name": z.string(),
"price_model": z.enum(["FREE", "FLAT_RATE", "PER_UNIT"]),
"unit_name": z.nullable(z.string()),
"yearly_price_in_cents": z.int()
    }),
"unit_count": z.int()
    })

/**
 * @description Groups of organization members that gives permissions on specified repositories.
 */
export const webhooksTeamSchema = z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"notification_setting": z.enum(["notifications_enabled", "notifications_disabled"]).describe("Whether team members will receive notifications when their team is @mentioned"),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team"),
"type": z.enum(["enterprise", "organization"]).describe("The ownership type of the team"),
"organization_id": z.optional(z.int().describe("Unique identifier of the organization to which this team belongs")),
"enterprise_id": z.optional(z.int().describe("Unique identifier of the enterprise to which this team belongs"))
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"notification_setting": z.optional(z.enum(["notifications_enabled", "notifications_disabled"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team")),
"type": z.optional(z.enum(["enterprise", "organization"]).describe("The ownership type of the team")),
"organization_id": z.optional(z.int().describe("Unique identifier of the organization to which this team belongs")),
"enterprise_id": z.optional(z.int().describe("Unique identifier of the enterprise to which this team belongs"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")

/**
 * @description A group of pull requests that the merge queue has grouped together to be merged.
 */
export const mergeGroupSchema = z.object({
    "head_sha": z.string().describe("The SHA of the merge group."),
"head_ref": z.string().describe("The full ref of the merge group."),
"base_sha": z.string().describe("The SHA of the merge group's parent commit."),
"base_ref": z.string().describe("The full ref of the branch the merge group will be merged into."),
get "head_commit"(){
                return simpleCommitSchema.describe("A commit.")
              }
    }).describe("A group of pull requests that the merge queue has grouped together to be merged.")

/**
 * @description The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.
 */
export const nullableRepositoryWebhooksSchema = z.object({
    "id": z.int().describe("Unique identifier of the repository"),
"node_id": z.string(),
"name": z.string().describe("The name of the repository."),
"full_name": z.string(),
get "license"(){
               return nullableLicenseSimpleSchema.describe("License Simple").nullable()
              },
get "organization"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
"forks": z.int(),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"pull": z.boolean(),
"triage": z.optional(z.boolean()),
"push": z.boolean(),
"maintain": z.optional(z.boolean())
    })),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"private": z.boolean().default(false).describe("Whether the repository is private or public."),
"html_url": z.url(),
"description": z.nullable(z.string()),
"fork": z.boolean(),
"url": z.url(),
"archive_url": z.string(),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"deployments_url": z.url(),
"downloads_url": z.url(),
"events_url": z.url(),
"forks_url": z.url(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.string(),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"languages_url": z.url(),
"merges_url": z.url(),
"milestones_url": z.string(),
"notifications_url": z.string(),
"pulls_url": z.string(),
"releases_url": z.string(),
"ssh_url": z.string(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"trees_url": z.string(),
"clone_url": z.string(),
"mirror_url": z.nullable(z.url()),
"hooks_url": z.url(),
"svn_url": z.url(),
"homepage": z.nullable(z.url()),
"language": z.nullable(z.string()),
"forks_count": z.int(),
"stargazers_count": z.int(),
"watchers_count": z.int(),
"size": z.int().describe("The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0."),
"default_branch": z.string().describe("The default branch of the repository."),
"open_issues_count": z.int(),
"is_template": z.optional(z.boolean().default(false).describe("Whether this repository acts as a template that can be used to generate new repositories.")),
"topics": z.optional(z.array(z.string())),
"custom_properties": z.optional(z.object({
    
    }).catchall(z.unknown()).describe("The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.")),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_pages": z.boolean(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_discussions": z.optional(z.boolean().default(false).describe("Whether discussions are enabled.")),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"disabled": z.boolean().describe("Returns whether or not this repository disabled."),
"visibility": z.optional(z.string().default("public").describe("The repository visibility: public, private, or internal.")),
"pushed_at": z.nullable(z.iso.datetime({ offset: true })),
"created_at": z.nullable(z.iso.datetime({ offset: true })),
"updated_at": z.nullable(z.iso.datetime({ offset: true })),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"template_repository": z.object({
    "id": z.optional(z.int()),
"node_id": z.optional(z.string()),
"name": z.optional(z.string()),
"full_name": z.optional(z.string()),
"owner": z.optional(z.object({
    "login": z.optional(z.string()),
"id": z.optional(z.int()),
"node_id": z.optional(z.string()),
"avatar_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"type": z.optional(z.string()),
"site_admin": z.optional(z.boolean())
    })),
"private": z.optional(z.boolean()),
"html_url": z.optional(z.string()),
"description": z.optional(z.string()),
"fork": z.optional(z.boolean()),
"url": z.optional(z.string()),
"archive_url": z.optional(z.string()),
"assignees_url": z.optional(z.string()),
"blobs_url": z.optional(z.string()),
"branches_url": z.optional(z.string()),
"collaborators_url": z.optional(z.string()),
"comments_url": z.optional(z.string()),
"commits_url": z.optional(z.string()),
"compare_url": z.optional(z.string()),
"contents_url": z.optional(z.string()),
"contributors_url": z.optional(z.string()),
"deployments_url": z.optional(z.string()),
"downloads_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"forks_url": z.optional(z.string()),
"git_commits_url": z.optional(z.string()),
"git_refs_url": z.optional(z.string()),
"git_tags_url": z.optional(z.string()),
"git_url": z.optional(z.string()),
"issue_comment_url": z.optional(z.string()),
"issue_events_url": z.optional(z.string()),
"issues_url": z.optional(z.string()),
"keys_url": z.optional(z.string()),
"labels_url": z.optional(z.string()),
"languages_url": z.optional(z.string()),
"merges_url": z.optional(z.string()),
"milestones_url": z.optional(z.string()),
"notifications_url": z.optional(z.string()),
"pulls_url": z.optional(z.string()),
"releases_url": z.optional(z.string()),
"ssh_url": z.optional(z.string()),
"stargazers_url": z.optional(z.string()),
"statuses_url": z.optional(z.string()),
"subscribers_url": z.optional(z.string()),
"subscription_url": z.optional(z.string()),
"tags_url": z.optional(z.string()),
"teams_url": z.optional(z.string()),
"trees_url": z.optional(z.string()),
"clone_url": z.optional(z.string()),
"mirror_url": z.optional(z.string()),
"hooks_url": z.optional(z.string()),
"svn_url": z.optional(z.string()),
"homepage": z.optional(z.string()),
"language": z.optional(z.string()),
"forks_count": z.optional(z.int()),
"stargazers_count": z.optional(z.int()),
"watchers_count": z.optional(z.int()),
"size": z.optional(z.int()),
"default_branch": z.optional(z.string()),
"open_issues_count": z.optional(z.int()),
"is_template": z.optional(z.boolean()),
"topics": z.optional(z.array(z.string())),
"has_issues": z.optional(z.boolean()),
"has_projects": z.optional(z.boolean()),
"has_wiki": z.optional(z.boolean()),
"has_pages": z.optional(z.boolean()),
"has_downloads": z.optional(z.boolean()),
"archived": z.optional(z.boolean()),
"disabled": z.optional(z.boolean()),
"visibility": z.optional(z.string()),
"pushed_at": z.optional(z.string()),
"created_at": z.optional(z.string()),
"updated_at": z.optional(z.string()),
"permissions": z.optional(z.object({
    "admin": z.optional(z.boolean()),
"maintain": z.optional(z.boolean()),
"push": z.optional(z.boolean()),
"triage": z.optional(z.boolean()),
"pull": z.optional(z.boolean())
    })),
"allow_rebase_merge": z.optional(z.boolean()),
"temp_clone_token": z.optional(z.string()),
"allow_squash_merge": z.optional(z.boolean()),
"allow_auto_merge": z.optional(z.boolean()),
"delete_branch_on_merge": z.optional(z.boolean()),
"allow_update_branch": z.optional(z.boolean()),
"use_squash_pr_title_as_default": z.optional(z.boolean()),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"allow_merge_commit": z.optional(z.boolean()),
"subscribers_count": z.optional(z.int()),
"network_count": z.optional(z.int())
    }).nullish(),
"temp_clone_token": z.optional(z.string()),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow Auto-merge to be used on pull requests.")),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"allow_update_branch": z.optional(z.boolean().default(false).describe("Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.")),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow forking this repo")),
"web_commit_signoff_required": z.optional(z.boolean().default(false).describe("Whether to require contributors to sign off on web-based commits")),
"subscribers_count": z.optional(z.int()),
"network_count": z.optional(z.int()),
"open_issues": z.int(),
"watchers": z.int(),
"master_branch": z.optional(z.string()),
"starred_at": z.optional(z.string()),
"anonymous_access_enabled": z.optional(z.boolean().describe("Whether anonymous git access is enabled for this repository"))
    }).describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").nullable()

/**
 * @description A collection of related issues and pull requests.
 */
export const webhooksMilestone3Schema = z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")

/**
 * @description The membership between the user and the organization. Not present when the action is `member_invited`.
 */
export const webhooksMembershipSchema = z.object({
    "organization_url": z.url(),
"role": z.string(),
"direct_membership": z.optional(z.boolean().describe("Whether the user has direct membership in the organization.")),
"enterprise_teams_providing_indirect_membership": z.optional(z.array(z.string()).max(100).describe("The slugs of the enterprise teams providing the user with indirect membership in the organization.\nA limit of 100 enterprise team slugs is returned.")),
"state": z.string(),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The membership between the user and the organization. Not present when the action is `member_invited`.")

/**
 * @description Details of a Personal Access Token Request.
 */
export const personalAccessTokenRequestSchema = z.object({
    "id": z.int().describe("Unique identifier of the request for access via fine-grained personal access token. Used as the `pat_request_id` parameter in the list and review API calls."),
get "owner"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"permissions_added": z.object({
    "organization": z.optional(z.object({
    
    }).catchall(z.string())),
"repository": z.optional(z.object({
    
    }).catchall(z.string())),
"other": z.optional(z.object({
    
    }).catchall(z.string()))
    }).describe("New requested permissions, categorized by type of permission."),
"permissions_upgraded": z.object({
    "organization": z.optional(z.object({
    
    }).catchall(z.string())),
"repository": z.optional(z.object({
    
    }).catchall(z.string())),
"other": z.optional(z.object({
    
    }).catchall(z.string()))
    }).describe("Requested permissions that elevate access for a previously approved request for access, categorized by type of permission."),
"permissions_result": z.object({
    "organization": z.optional(z.object({
    
    }).catchall(z.string())),
"repository": z.optional(z.object({
    
    }).catchall(z.string())),
"other": z.optional(z.object({
    
    }).catchall(z.string()))
    }).describe("Permissions requested, categorized by type of permission. This field incorporates `permissions_added` and `permissions_upgraded`."),
"repository_selection": z.enum(["none", "all", "subset"]).describe("Type of repository selection requested."),
"repository_count": z.nullable(z.int().describe("The number of repositories the token is requesting access to. This field is only populated when `repository_selection` is `subset`.")),
"repositories": z.nullable(z.array(z.object({
    "full_name": z.string(),
"id": z.int().describe("Unique identifier of the repository"),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"private": z.boolean().describe("Whether the repository is private or public.")
    })).describe("An array of repository objects the token is requesting access to. This field is only populated when `repository_selection` is `subset`.")),
"created_at": z.string().describe("Date and time when the request for access was created."),
"token_id": z.int().describe("Unique identifier of the user's token. This field can also be found in audit log events and the organization's settings for their PAT grants."),
"token_name": z.string().describe("The name given to the user's token. This field can also be found in an organization's settings page for Active Tokens."),
"token_expired": z.boolean().describe("Whether the associated fine-grained personal access token has expired."),
"token_expires_at": z.nullable(z.string().describe("Date and time when the associated fine-grained personal access token expires.")),
"token_last_used_at": z.nullable(z.string().describe("Date and time when the associated fine-grained personal access token was last used for authentication."))
    }).describe("Details of a Personal Access Token Request.")

export const webhooksProjectCardSchema = z.object({
    "after_id": z.int().nullish(),
"archived": z.boolean().describe("Whether or not the card is archived"),
"column_id": z.int(),
"column_url": z.url(),
"content_url": z.optional(z.url()),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"id": z.int().describe("The project card's ID"),
"node_id": z.string(),
"note": z.nullable(z.string()),
"project_url": z.url(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    })

export const webhooksProjectSchema = z.object({
    "body": z.nullable(z.string().describe("Body of the project")),
"columns_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"html_url": z.url(),
"id": z.int(),
"name": z.string().describe("Name of the project"),
"node_id": z.string(),
"number": z.int(),
"owner_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of the project; either 'open' or 'closed'"),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    })

export const webhooksProjectColumnSchema = z.object({
    "after_id": z.int().nullish(),
"cards_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"id": z.int().describe("The unique identifier of the project column"),
"name": z.string().describe("Name of the project column"),
"node_id": z.string(),
"project_url": z.url(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    })

export const webhooksProjectChangesSchema = z.object({
    "archived_at": z.optional(z.object({
    "from": z.iso.datetime({ offset: true }).nullish(),
"to": z.iso.datetime({ offset: true }).nullish()
    }))
    })

/**
 * @description An item belonging to a project
 */
export const projectsV2ItemSchema = z.object({
    "id": z.number().describe("The unique identifier of the project item."),
"node_id": z.optional(z.string().describe("The node ID of the project item.")),
"project_node_id": z.optional(z.string().describe("The node ID of the project that contains this item.")),
"content_node_id": z.string().describe("The node ID of the content represented by this item."),
get "content_type"(){
                return projectsV2ItemContentTypeSchema.describe("The type of content tracked in a project item")
              },
get "creator"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
"created_at": z.iso.datetime({ offset: true }).describe("The time when the item was created."),
"updated_at": z.iso.datetime({ offset: true }).describe("The time when the item was last updated."),
"archived_at": z.nullable(z.iso.datetime({ offset: true }).describe("The time when the item was archived."))
    }).describe("An item belonging to a project")

/**
 * @description An option for a single select field
 */
export const projectsV2SingleSelectOptionSchema = z.object({
    "id": z.string().describe("The unique identifier of the option."),
"name": z.string().describe("The display name of the option."),
"color": z.string().describe("The color associated with the option.").nullish(),
"description": z.string().describe("A short description of the option.").nullish()
    }).describe("An option for a single select field")

/**
 * @description An iteration setting for an iteration field
 */
export const projectsV2IterationSettingSchema = z.object({
    "id": z.string().describe("The unique identifier of the iteration setting."),
"title": z.string().describe("The iteration title."),
"title_html": z.optional(z.string().describe("The iteration title, rendered as HTML.")),
"duration": z.number().describe("The duration of the iteration in days.").nullish(),
"start_date": z.string().describe("The start date of the iteration.").nullish(),
"completed": z.optional(z.boolean().describe("Whether the iteration has been completed."))
    }).describe("An iteration setting for an iteration field")

/**
 * @description An status update belonging to a project
 */
export const projectsV2StatusUpdateSchema = z.object({
    "id": z.number().describe("The unique identifier of the status update."),
"node_id": z.string().describe("The node ID of the status update."),
"project_node_id": z.optional(z.string().describe("The node ID of the project that this status update belongs to.")),
get "creator"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
"created_at": z.iso.datetime({ offset: true }).describe("The time when the status update was created."),
"updated_at": z.iso.datetime({ offset: true }).describe("The time when the status update was last updated."),
"status": z.enum(["INACTIVE", "ON_TRACK", "AT_RISK", "OFF_TRACK", "COMPLETE"]).describe("The current status.").nullish(),
"start_date": z.optional(z.iso.date().describe("The start date of the period covered by the update.")),
"target_date": z.optional(z.iso.date().describe("The target date associated with the update.")),
"body": z.string().describe("Body of the status update").nullish()
    }).describe("An status update belonging to a project")

/**
 * @description The pull request number.
 */
export const webhooksNumberSchema = z.int().describe("The pull request number.")

export const pullRequestWebhookSchema = pullRequestSchema.and(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_update_branch": z.optional(z.boolean().describe("Whether to allow updating the pull request's branch.")),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged.")),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., \"Merge pull request #123 from branch-name\").")),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.**"))
    }))

export const webhooksPullRequest5Schema = z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"additions": z.optional(z.int()),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"changed_files": z.optional(z.int()),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.optional(z.int()),
"comments_url": z.url(),
"commits": z.optional(z.int()),
"commits_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"deletions": z.optional(z.int()),
"diff_url": z.url(),
"draft": z.boolean().describe("Indicates whether or not the pull request is a draft."),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether maintainers can modify the pull request.")),
"merge_commit_sha": z.nullable(z.string()),
"mergeable": z.boolean().nullish(),
"mergeable_state": z.optional(z.string()),
"merged": z.boolean().nullish(),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"patch_url": z.url(),
"rebaseable": z.boolean().nullish(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments": z.optional(z.int()),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"statuses_url": z.url(),
"title": z.string().describe("The title of the pull request."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    })

/**
 * @description The [comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request) itself.
 */
export const webhooksReviewCommentSchema = z.object({
    "_links": z.object({
    "html": z.object({
    "href": z.string()
    }),
"pull_request": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    })
    }),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.string().describe("The text of the comment."),
"commit_id": z.string().describe("The SHA of the commit to which the comment applies."),
"created_at": z.iso.datetime({ offset: true }),
"diff_hunk": z.string().describe("The diff of the line that the comment refers to."),
"html_url": z.url().describe("HTML URL for the pull request review comment."),
"id": z.int().describe("The ID of the pull request review comment."),
"in_reply_to_id": z.optional(z.int().describe("The comment ID to reply to.")),
"line": z.nullable(z.int().describe("The line of the blob to which the comment applies. The last line of the range for a multi-line comment")),
"node_id": z.string().describe("The node ID of the pull request review comment."),
"original_commit_id": z.string().describe("The SHA of the original commit to which the comment applies."),
"original_line": z.int().describe("The line of the blob to which the comment applies. The last line of the range for a multi-line comment"),
"original_position": z.int().describe("The index of the original line in the diff to which the comment applies."),
"original_start_line": z.nullable(z.int().describe("The first line of the range for a multi-line comment.")),
"path": z.string().describe("The relative path of the file to which the comment applies."),
"position": z.nullable(z.int().describe("The line index in the diff to which the comment applies.")),
"pull_request_review_id": z.nullable(z.int().describe("The ID of the pull request review to which the comment belongs.")),
"pull_request_url": z.url().describe("URL for the pull request that the review comment belongs to."),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"side": z.enum(["LEFT", "RIGHT"]).describe("The side of the first line of the range for a multi-line comment."),
"start_line": z.nullable(z.int().describe("The first line of the range for a multi-line comment.")),
"start_side": z.nullable(z.enum(["LEFT", "RIGHT"]).default("RIGHT").describe("The side of the first line of the range for a multi-line comment.")),
"subject_type": z.optional(z.enum(["line", "file"]).describe("The level at which the comment is targeted, can be a diff line or a file.")),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the pull request review comment"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request) itself.")

/**
 * @description The review that was affected.
 */
export const webhooksReviewSchema = z.object({
    "_links": z.object({
    "html": z.object({
    "href": z.string()
    }),
"pull_request": z.object({
    "href": z.string()
    })
    }),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.nullable(z.string().describe("The text of the review.")),
"commit_id": z.string().describe("A commit SHA for the review."),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the review"),
"node_id": z.string(),
"pull_request_url": z.url(),
"state": z.string(),
"submitted_at": z.nullable(z.iso.datetime({ offset: true })),
"updated_at": z.iso.datetime({ offset: true }).nullish(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The review that was affected.")

export const webhooksNullableStringSchema = z.string().nullable()

/**
 * @description The [release](https://docs.github.com/rest/releases/releases/#get-a-release) object.
 */
export const webhooksReleaseSchema = z.object({
    "assets": z.array(z.object({
    "browser_download_url": z.url(),
"content_type": z.string(),
"created_at": z.iso.datetime({ offset: true }),
"download_count": z.int(),
"id": z.int(),
"label": z.nullable(z.string()),
"name": z.string().describe("The file name of the asset."),
"node_id": z.string(),
"size": z.int(),
"digest": z.nullable(z.string()),
"state": z.enum(["uploaded"]).describe("State of the release asset."),
"updated_at": z.iso.datetime({ offset: true }),
"uploader": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullish(),
"url": z.url()
    }).describe("Data related to a release.")),
"assets_url": z.url(),
"author": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"body": z.nullable(z.string()),
"created_at": z.nullable(z.iso.datetime({ offset: true })),
"updated_at": z.nullable(z.iso.datetime({ offset: true })),
"discussion_url": z.optional(z.url()),
"draft": z.boolean().describe("Whether the release is a draft or published"),
"html_url": z.url(),
"id": z.int(),
"immutable": z.boolean().describe("Whether or not the release is immutable."),
"name": z.nullable(z.string()),
"node_id": z.string(),
"prerelease": z.boolean().describe("Whether the release is identified as a prerelease or a full release."),
"published_at": z.nullable(z.iso.datetime({ offset: true })),
"reactions": z.optional(z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    })),
"tag_name": z.string().describe("The name of the tag."),
"tarball_url": z.nullable(z.url()),
"target_commitish": z.string().describe("Specifies the commitish value that determines where the Git tag is created from."),
"upload_url": z.string(),
"url": z.url(),
"zipball_url": z.nullable(z.url())
    }).describe("The [release](https://docs.github.com/rest/releases/releases/#get-a-release) object.")

/**
 * @description The [release](https://docs.github.com/rest/releases/releases/#get-a-release) object.
 */
export const webhooksRelease1Schema = z.object({
    "assets": z.array(z.object({
    "browser_download_url": z.url(),
"content_type": z.string(),
"created_at": z.iso.datetime({ offset: true }),
"download_count": z.int(),
"id": z.int(),
"label": z.nullable(z.string()),
"name": z.string().describe("The file name of the asset."),
"node_id": z.string(),
"size": z.int(),
"digest": z.nullable(z.string()),
"state": z.enum(["uploaded"]).describe("State of the release asset."),
"updated_at": z.iso.datetime({ offset: true }),
"uploader": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullish(),
"url": z.url()
    }).describe("Data related to a release.").nullable()),
"assets_url": z.url(),
"author": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"body": z.nullable(z.string()),
"created_at": z.nullable(z.iso.datetime({ offset: true })),
"discussion_url": z.optional(z.url()),
"draft": z.boolean().describe("Whether the release is a draft or published"),
"html_url": z.url(),
"id": z.int(),
"immutable": z.boolean().describe("Whether or not the release is immutable."),
"name": z.nullable(z.string()),
"node_id": z.string(),
"prerelease": z.boolean().describe("Whether the release is identified as a prerelease or a full release."),
"published_at": z.nullable(z.iso.datetime({ offset: true })),
"reactions": z.optional(z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    })),
"tag_name": z.string().describe("The name of the tag."),
"tarball_url": z.nullable(z.url()),
"target_commitish": z.string().describe("Specifies the commitish value that determines where the Git tag is created from."),
"updated_at": z.nullable(z.iso.datetime({ offset: true })),
"upload_url": z.string(),
"url": z.url(),
"zipball_url": z.nullable(z.url())
    }).describe("The [release](https://docs.github.com/rest/releases/releases/#get-a-release) object.")

/**
 * @description The security alert of the vulnerable dependency.
 */
export const webhooksAlertSchema = z.object({
    "affected_package_name": z.string(),
"affected_range": z.string(),
"created_at": z.string(),
"dismiss_reason": z.optional(z.string()),
"dismissed_at": z.optional(z.string()),
"dismisser": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullish(),
"external_identifier": z.string(),
"external_reference": z.nullable(z.url()),
"fix_reason": z.optional(z.string()),
"fixed_at": z.optional(z.iso.datetime({ offset: true })),
"fixed_in": z.optional(z.string()),
"ghsa_id": z.string(),
"id": z.int(),
"node_id": z.string(),
"number": z.int(),
"severity": z.string(),
"state": z.enum(["open"])
    }).describe("The security alert of the vulnerable dependency.")

/**
 * @description The reason for resolving the alert.
 */
export const secretScanningAlertResolutionWebhookSchema = z.enum(["false_positive", "wont_fix", "revoked", "used_in_tests", "pattern_deleted", "pattern_edited"]).describe("The reason for resolving the alert.").nullable()

export const secretScanningAlertWebhookSchema = z.object({
    get "number"(){
                return alertNumberSchema.describe("The security alert number.").optional()
              },
get "created_at"(){
                return alertCreatedAtSchema.describe("The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").optional()
              },
get "updated_at"(){
                return nullableAlertUpdatedAtSchema.describe("The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").optional()
              },
get "url"(){
                return alertUrlSchema.describe("The REST API URL of the alert resource.").optional()
              },
get "html_url"(){
                return alertHtmlUrlSchema.describe("The GitHub URL of the alert resource.").optional()
              },
"locations_url": z.optional(z.url().describe("The REST API URL of the code locations for this alert.")),
get "resolution"(){
                return secretScanningAlertResolutionWebhookSchema.describe("The reason for resolving the alert.").optional()
              },
"resolved_at": z.iso.datetime({ offset: true }).describe("The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullish(),
get "resolved_by"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
"resolution_comment": z.string().describe("An optional comment to resolve an alert.").nullish(),
"secret_type": z.optional(z.string().describe("The type of secret that secret scanning detected.")),
"secret_type_display_name": z.optional(z.string().describe("User-friendly name for the detected secret, matching the `secret_type`.\nFor a list of built-in patterns, see \"[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets).\"")),
"validity": z.optional(z.enum(["active", "inactive", "unknown"]).describe("The token status as of the latest validity check.")),
"push_protection_bypassed": z.boolean().describe("Whether push protection was bypassed for the detected secret.").nullish(),
get "push_protection_bypassed_by"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
"push_protection_bypassed_at": z.iso.datetime({ offset: true }).describe("The time that push protection was bypassed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.").nullish(),
get "push_protection_bypass_request_reviewer"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              },
"push_protection_bypass_request_reviewer_comment": z.string().describe("An optional comment when reviewing a push protection bypass.").nullish(),
"push_protection_bypass_request_comment": z.string().describe("An optional comment when requesting a push protection bypass.").nullish(),
"push_protection_bypass_request_html_url": z.url().describe("The URL to a push protection bypass request.").nullish(),
"publicly_leaked": z.boolean().describe("Whether the detected secret was publicly leaked.").nullish(),
"multi_repo": z.boolean().describe("Whether the detected secret was found in multiple repositories in the same organization or business.").nullish(),
get "assigned_to"(){
                return nullableSimpleUserSchema.describe("A GitHub user.").optional()
              }
    })

/**
 * @description The details of the security advisory, including summary, description, and severity.
 */
export const webhooksSecurityAdvisorySchema = z.object({
    "cvss": z.object({
    "score": z.number(),
"vector_string": z.nullable(z.string())
    }),
get "cvss_severities"(){
                return cvssSeveritiesSchema.optional()
              },
"cwes": z.array(z.object({
    "cwe_id": z.string(),
"name": z.string()
    })),
"description": z.string(),
"ghsa_id": z.string(),
"identifiers": z.array(z.object({
    "type": z.string(),
"value": z.string()
    })),
"published_at": z.string(),
"references": z.array(z.object({
    "url": z.url()
    })),
"severity": z.string(),
"summary": z.string(),
"updated_at": z.string(),
"vulnerabilities": z.array(z.object({
    "first_patched_version": z.nullable(z.object({
    "identifier": z.string()
    })),
"package": z.object({
    "ecosystem": z.string(),
"name": z.string()
    }),
"severity": z.string(),
"vulnerable_version_range": z.string()
    })),
"withdrawn_at": z.nullable(z.string())
    }).describe("The details of the security advisory, including summary, description, and severity.")

export const webhooksSponsorshipSchema = z.object({
    "created_at": z.string(),
"maintainer": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string()),
"user_view_type": z.optional(z.string())
    })),
"node_id": z.string(),
"privacy_level": z.string(),
"sponsor": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"sponsorable": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"tier": z.object({
    "created_at": z.string(),
"description": z.string(),
"is_custom_ammount": z.optional(z.boolean()),
"is_custom_amount": z.optional(z.boolean()),
"is_one_time": z.boolean(),
"monthly_price_in_cents": z.int(),
"monthly_price_in_dollars": z.int(),
"name": z.string(),
"node_id": z.string()
    }).describe("The `tier_changed` and `pending_tier_change` will include the original tier before the change or pending change. For more information, see the pending tier change payload.")
    })

/**
 * @description The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect.
 */
export const webhooksEffectiveDateSchema = z.string().describe("The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect.")

export const webhooksChanges8Schema = z.object({
    "tier": z.object({
    "from": z.object({
    "created_at": z.string(),
"description": z.string(),
"is_custom_ammount": z.optional(z.boolean()),
"is_custom_amount": z.optional(z.boolean()),
"is_one_time": z.boolean(),
"monthly_price_in_cents": z.int(),
"monthly_price_in_dollars": z.int(),
"name": z.string(),
"node_id": z.string()
    }).describe("The `tier_changed` and `pending_tier_change` will include the original tier before the change or pending change. For more information, see the pending tier change payload.")
    })
    })

/**
 * @description Groups of organization members that gives permissions on specified repositories.
 */
export const webhooksTeam1Schema = z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"notification_setting": z.enum(["notifications_enabled", "notifications_disabled"]).describe("Whether team members will receive notifications when their team is @mentioned"),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team"),
"type": z.enum(["enterprise", "organization"]).describe("The ownership type of the team"),
"organization_id": z.optional(z.int().describe("Unique identifier of the organization to which this team belongs")),
"enterprise_id": z.optional(z.int().describe("Unique identifier of the enterprise to which this team belongs"))
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"notification_setting": z.optional(z.enum(["notifications_enabled", "notifications_disabled"]).describe("Whether team members will receive notifications when their team is @mentioned")),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team")),
"type": z.optional(z.enum(["enterprise", "organization"]).describe("The ownership type of the team")),
"organization_id": z.optional(z.int().describe("Unique identifier of the organization to which this team belongs")),
"enterprise_id": z.optional(z.int().describe("Unique identifier of the enterprise to which this team belongs"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")

export const webhookBranchProtectionConfigurationDisabledSchema = z.object({
    "action": z.enum(["disabled"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookBranchProtectionConfigurationEnabledSchema = z.object({
    "action": z.enum(["enabled"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookBranchProtectionRuleCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "rule"(){
                return webhooksRuleSchema.describe("The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookBranchProtectionRuleDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "rule"(){
                return webhooksRuleSchema.describe("The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookBranchProtectionRuleEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.optional(z.object({
    "admin_enforced": z.optional(z.object({
    "from": z.nullable(z.boolean())
    })),
"authorized_actor_names": z.optional(z.object({
    "from": z.array(z.string())
    })),
"authorized_actors_only": z.optional(z.object({
    "from": z.nullable(z.boolean())
    })),
"authorized_dismissal_actors_only": z.optional(z.object({
    "from": z.nullable(z.boolean())
    })),
"linear_history_requirement_enforcement_level": z.optional(z.object({
    "from": z.enum(["off", "non_admins", "everyone"])
    })),
"lock_branch_enforcement_level": z.optional(z.object({
    "from": z.enum(["off", "non_admins", "everyone"])
    })),
"lock_allows_fork_sync": z.optional(z.object({
    "from": z.nullable(z.boolean())
    })),
"pull_request_reviews_enforcement_level": z.optional(z.object({
    "from": z.enum(["off", "non_admins", "everyone"])
    })),
"require_last_push_approval": z.optional(z.object({
    "from": z.nullable(z.boolean())
    })),
"required_status_checks": z.optional(z.object({
    "from": z.array(z.string())
    })),
"required_status_checks_enforcement_level": z.optional(z.object({
    "from": z.enum(["off", "non_admins", "everyone"])
    }))
    }).describe("If the action was `edited`, the changes to the rule.")),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "rule"(){
                return webhooksRuleSchema.describe("The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookCheckRunCompletedSchema = z.object({
    "action": z.optional(z.enum(["completed"])),
get "check_run"(){
                return checkRunWithSimpleCheckSuiteSchema.describe("A check performed on the code of a given code change")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

/**
 * @description The check_run.completed webhook encoded with URL encoding
 */
export const webhookCheckRunCompletedFormEncodedSchema = z.object({
    "payload": z.string().describe("A URL-encoded string of the check_run.completed JSON payload. The decoded payload is a JSON object.")
    }).describe("The check_run.completed webhook encoded with URL encoding")

export const webhookCheckRunCreatedSchema = z.object({
    "action": z.optional(z.enum(["created"])),
get "check_run"(){
                return checkRunWithSimpleCheckSuiteSchema.describe("A check performed on the code of a given code change")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

/**
 * @description The check_run.created webhook encoded with URL encoding
 */
export const webhookCheckRunCreatedFormEncodedSchema = z.object({
    "payload": z.string().describe("A URL-encoded string of the check_run.created JSON payload. The decoded payload is a JSON object.")
    }).describe("The check_run.created webhook encoded with URL encoding")

export const webhookCheckRunRequestedActionSchema = z.object({
    "action": z.enum(["requested_action"]),
get "check_run"(){
                return checkRunWithSimpleCheckSuiteSchema.describe("A check performed on the code of a given code change")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
"requested_action": z.optional(z.object({
    "identifier": z.optional(z.string().describe("The integrator reference of the action requested by the user."))
    }).describe("The action requested by the user.")),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

/**
 * @description The check_run.requested_action webhook encoded with URL encoding
 */
export const webhookCheckRunRequestedActionFormEncodedSchema = z.object({
    "payload": z.string().describe("A URL-encoded string of the check_run.requested_action JSON payload. The decoded payload is a JSON object.")
    }).describe("The check_run.requested_action webhook encoded with URL encoding")

export const webhookCheckRunRerequestedSchema = z.object({
    "action": z.optional(z.enum(["rerequested"])),
get "check_run"(){
                return checkRunWithSimpleCheckSuiteSchema.describe("A check performed on the code of a given code change")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

/**
 * @description The check_run.rerequested webhook encoded with URL encoding
 */
export const webhookCheckRunRerequestedFormEncodedSchema = z.object({
    "payload": z.string().describe("A URL-encoded string of the check_run.rerequested JSON payload. The decoded payload is a JSON object.")
    }).describe("The check_run.rerequested webhook encoded with URL encoding")

export const webhookCheckSuiteCompletedSchema = z.object({
    "action": z.enum(["completed"]),
"check_suite": z.object({
    "after": z.nullable(z.string()),
"app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run", "merge_group", "pull_request_review_thread", "workflow_job", "merge_queue_entry", "security_and_analysis", "projects_v2_item", "secret_scanning_alert_location"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"client_id": z.string().describe("The client ID of the GitHub app").nullish(),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write", "admin"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write", "admin"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."),
"before": z.nullable(z.string()),
"check_runs_url": z.url(),
"conclusion": z.nullable(z.enum(["success", "failure", "neutral", "cancelled", "timed_out", "action_required", "stale", "skipped", "startup_failure"]).describe("The summary conclusion for all check runs that are part of the check suite. This value will be `null` until the check run has `completed`.")),
"created_at": z.iso.datetime({ offset: true }),
"head_branch": z.nullable(z.string().describe("The head branch name the changes are on.")),
"head_commit": z.object({
    "author": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.nullable(z.email()),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"committer": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.nullable(z.email()),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"id": z.string(),
"message": z.string(),
"timestamp": z.string(),
"tree_id": z.string()
    }),
"head_sha": z.string().describe("The SHA of the head commit that is being checked."),
"id": z.int(),
"latest_check_runs_count": z.int(),
"node_id": z.string(),
"pull_requests": z.array(z.object({
    "base": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"head": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"id": z.int(),
"number": z.int(),
"url": z.url()
    })).describe("An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."),
"rerequestable": z.optional(z.boolean()),
"runs_rerequestable": z.optional(z.boolean()),
"status": z.nullable(z.enum(["requested", "in_progress", "completed", "queued", "pending"]).describe("The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.")),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL that points to the check suite API resource.")
    }).describe("The [check_suite](https://docs.github.com/rest/checks/suites#get-a-check-suite)."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookCheckSuiteRequestedSchema = z.object({
    "action": z.enum(["requested"]),
"check_suite": z.object({
    "after": z.nullable(z.string()),
"app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run", "pull_request_review_thread", "workflow_job", "merge_queue_entry", "security_and_analysis", "secret_scanning_alert_location", "projects_v2_item", "merge_group", "repository_import"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"client_id": z.string().describe("Client ID of the GitHub app").nullish(),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write", "admin"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write", "admin"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."),
"before": z.nullable(z.string()),
"check_runs_url": z.url(),
"conclusion": z.nullable(z.enum(["success", "failure", "neutral", "cancelled", "timed_out", "action_required", "stale", "skipped"]).describe("The summary conclusion for all check runs that are part of the check suite. This value will be `null` until the check run has completed.")),
"created_at": z.iso.datetime({ offset: true }),
"head_branch": z.nullable(z.string().describe("The head branch name the changes are on.")),
"head_commit": z.object({
    "author": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.nullable(z.email()),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"committer": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.nullable(z.email()),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"id": z.string(),
"message": z.string(),
"timestamp": z.string(),
"tree_id": z.string()
    }),
"head_sha": z.string().describe("The SHA of the head commit that is being checked."),
"id": z.int(),
"latest_check_runs_count": z.int(),
"node_id": z.string(),
"pull_requests": z.array(z.object({
    "base": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"head": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"id": z.int(),
"number": z.int(),
"url": z.url()
    })).describe("An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."),
"rerequestable": z.optional(z.boolean()),
"runs_rerequestable": z.optional(z.boolean()),
"status": z.nullable(z.enum(["requested", "in_progress", "completed", "queued"]).describe("The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.")),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL that points to the check suite API resource.")
    }).describe("The [check_suite](https://docs.github.com/rest/checks/suites#get-a-check-suite)."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookCheckSuiteRerequestedSchema = z.object({
    "action": z.enum(["rerequested"]),
"check_suite": z.object({
    "after": z.nullable(z.string()),
"app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run", "pull_request_review_thread", "merge_queue_entry", "workflow_job"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"client_id": z.string().describe("The Client ID for the GitHub app").nullish(),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write", "admin"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write", "admin"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."),
"before": z.nullable(z.string()),
"check_runs_url": z.url(),
"conclusion": z.nullable(z.enum(["success", "failure", "neutral", "cancelled", "timed_out", "action_required", "stale"]).describe("The summary conclusion for all check runs that are part of the check suite. This value will be `null` until the check run has completed.")),
"created_at": z.iso.datetime({ offset: true }),
"head_branch": z.nullable(z.string().describe("The head branch name the changes are on.")),
"head_commit": z.object({
    "author": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.nullable(z.email()),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"committer": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.nullable(z.email()),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"id": z.string(),
"message": z.string(),
"timestamp": z.string(),
"tree_id": z.string()
    }),
"head_sha": z.string().describe("The SHA of the head commit that is being checked."),
"id": z.int(),
"latest_check_runs_count": z.int(),
"node_id": z.string(),
"pull_requests": z.array(z.object({
    "base": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"head": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"id": z.int(),
"number": z.int(),
"url": z.url()
    })).describe("An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."),
"rerequestable": z.optional(z.boolean()),
"runs_rerequestable": z.optional(z.boolean()),
"status": z.nullable(z.enum(["requested", "in_progress", "completed", "queued"]).describe("The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.")),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL that points to the check suite API resource.")
    }).describe("The [check_suite](https://docs.github.com/rest/checks/suites#get-a-check-suite)."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookCodeScanningAlertAppearedInBranchSchema = z.object({
    "action": z.enum(["appeared_in_branch"]),
"alert": z.object({
    get "assignees"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).optional()
              },
"created_at": z.iso.datetime({ offset: true }).describe("The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"),
"dismissed_at": z.nullable(z.iso.datetime({ offset: true }).describe("The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"dismissed_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
get "dismissed_comment"(){
                return codeScanningAlertDismissedCommentSchema.describe("The dismissal comment associated with the dismissal of the alert.").optional()
              },
"dismissed_reason": z.nullable(z.enum(["false positive", "won't fix", "used in tests"]).describe("The reason for dismissing or closing the alert.")),
"fixed_at": z.unknown().nullish(),
"html_url": z.url().describe("The GitHub URL of the alert resource."),
"most_recent_instance": z.object({
    "analysis_key": z.string().describe("Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."),
"category": z.optional(z.string().describe("Identifies the configuration under which the analysis was executed.")),
"classifications": z.optional(z.array(z.string())),
"commit_sha": z.optional(z.string()),
"environment": z.string().describe("Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."),
"location": z.optional(z.object({
    "end_column": z.optional(z.int()),
"end_line": z.optional(z.int()),
"path": z.optional(z.string()),
"start_column": z.optional(z.int()),
"start_line": z.optional(z.int())
    })),
"message": z.optional(z.object({
    "text": z.optional(z.string())
    })),
"ref": z.string().describe("The full Git reference, formatted as `refs/heads/<branch name>`."),
"state": z.enum(["open", "dismissed", "fixed"]).describe("State of a code scanning alert.")
    }).nullish(),
"number": z.int().describe("The code scanning alert number."),
"rule": z.object({
    "description": z.string().describe("A short description of the rule used to detect the alert."),
"id": z.string().describe("A unique identifier for the rule used to detect the alert."),
"severity": z.nullable(z.enum(["none", "note", "warning", "error"]).describe("The severity of the alert."))
    }),
"state": z.nullable(z.enum(["open", "dismissed", "fixed"]).describe("State of a code scanning alert. Events for alerts found outside the default branch will return a `null` value until they are dismissed or fixed.")),
"tool": z.object({
    "name": z.string().describe("The name of the tool used to generate the code scanning analysis alert."),
"version": z.nullable(z.string().describe("The version of the tool used to detect the alert."))
    }),
"url": z.url()
    }).describe("The code scanning alert involved in the event."),
get "commit_oid"(){
                return webhooksCodeScanningCommitOidSchema.describe("The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "ref"(){
                return webhooksCodeScanningRefSchema.describe("The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookCodeScanningAlertClosedByUserSchema = z.object({
    "action": z.enum(["closed_by_user"]),
"alert": z.object({
    get "assignees"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).optional()
              },
"created_at": z.iso.datetime({ offset: true }).describe("The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"),
"dismissed_at": z.iso.datetime({ offset: true }).describe("The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."),
"dismissed_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
get "dismissed_comment"(){
                return codeScanningAlertDismissedCommentSchema.describe("The dismissal comment associated with the dismissal of the alert.").optional()
              },
"dismissed_reason": z.nullable(z.enum(["false positive", "won't fix", "used in tests"]).describe("The reason for dismissing or closing the alert.")),
"fixed_at": z.unknown().nullish(),
"html_url": z.url().describe("The GitHub URL of the alert resource."),
"most_recent_instance": z.object({
    "analysis_key": z.string().describe("Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."),
"category": z.optional(z.string().describe("Identifies the configuration under which the analysis was executed.")),
"classifications": z.optional(z.array(z.string())),
"commit_sha": z.optional(z.string()),
"environment": z.string().describe("Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."),
"location": z.optional(z.object({
    "end_column": z.optional(z.int()),
"end_line": z.optional(z.int()),
"path": z.optional(z.string()),
"start_column": z.optional(z.int()),
"start_line": z.optional(z.int())
    })),
"message": z.optional(z.object({
    "text": z.optional(z.string())
    })),
"ref": z.string().describe("The full Git reference, formatted as `refs/heads/<branch name>`."),
"state": z.enum(["open", "dismissed", "fixed"]).describe("State of a code scanning alert.")
    }).nullish(),
"number": z.int().describe("The code scanning alert number."),
"rule": z.object({
    "description": z.string().describe("A short description of the rule used to detect the alert."),
"full_description": z.optional(z.string()),
"help": z.string().nullish(),
"help_uri": z.string().describe("A link to the documentation for the rule used to detect the alert.").nullish(),
"id": z.string().describe("A unique identifier for the rule used to detect the alert."),
"name": z.optional(z.string()),
"severity": z.nullable(z.enum(["none", "note", "warning", "error"]).describe("The severity of the alert.")),
"tags": z.array(z.string()).nullish()
    }),
"state": z.enum(["dismissed", "fixed"]).describe("State of a code scanning alert."),
"tool": z.object({
    "guid": z.string().nullish(),
"name": z.string().describe("The name of the tool used to generate the code scanning analysis alert."),
"version": z.nullable(z.string().describe("The version of the tool used to detect the alert."))
    }),
"url": z.url(),
"dismissal_approved_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish()
    }).describe("The code scanning alert involved in the event."),
get "commit_oid"(){
                return webhooksCodeScanningCommitOidSchema.describe("The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "ref"(){
                return webhooksCodeScanningRefSchema.describe("The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookCodeScanningAlertCreatedSchema = z.object({
    "action": z.enum(["created"]),
"alert": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true }).describe("The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`")),
"dismissed_at": z.unknown(),
"dismissed_by": z.unknown(),
get "dismissed_comment"(){
                return codeScanningAlertDismissedCommentSchema.describe("The dismissal comment associated with the dismissal of the alert.").optional()
              },
"dismissed_reason": z.unknown(),
"fixed_at": z.unknown().nullish(),
"html_url": z.url().describe("The GitHub URL of the alert resource."),
"instances_url": z.optional(z.string()),
"most_recent_instance": z.object({
    "analysis_key": z.string().describe("Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."),
"category": z.optional(z.string().describe("Identifies the configuration under which the analysis was executed.")),
"classifications": z.optional(z.array(z.string())),
"commit_sha": z.optional(z.string()),
"environment": z.string().describe("Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."),
"location": z.optional(z.object({
    "end_column": z.optional(z.int()),
"end_line": z.optional(z.int()),
"path": z.optional(z.string()),
"start_column": z.optional(z.int()),
"start_line": z.optional(z.int())
    })),
"message": z.optional(z.object({
    "text": z.optional(z.string())
    })),
"ref": z.string().describe("The full Git reference, formatted as `refs/heads/<branch name>`."),
"state": z.enum(["open", "dismissed", "fixed"]).describe("State of a code scanning alert.")
    }).nullish(),
"number": z.int().describe("The code scanning alert number."),
"rule": z.object({
    "description": z.string().describe("A short description of the rule used to detect the alert."),
"full_description": z.optional(z.string()),
"help": z.string().nullish(),
"help_uri": z.string().describe("A link to the documentation for the rule used to detect the alert.").nullish(),
"id": z.string().describe("A unique identifier for the rule used to detect the alert."),
"name": z.optional(z.string()),
"severity": z.nullable(z.enum(["none", "note", "warning", "error"]).describe("The severity of the alert.")),
"tags": z.array(z.string()).nullish()
    }),
"state": z.nullable(z.enum(["open", "dismissed"]).describe("State of a code scanning alert. Events for alerts found outside the default branch will return a `null` value until they are dismissed or fixed.")),
"tool": z.nullable(z.object({
    "guid": z.string().nullish(),
"name": z.string().describe("The name of the tool used to generate the code scanning analysis alert."),
"version": z.nullable(z.string().describe("The version of the tool used to detect the alert."))
    })),
"updated_at": z.string().nullish(),
"url": z.url(),
"dismissal_approved_by": z.unknown().nullish(),
get "assignees"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).optional()
              }
    }).describe("The code scanning alert involved in the event."),
get "commit_oid"(){
                return webhooksCodeScanningCommitOidSchema.describe("The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "ref"(){
                return webhooksCodeScanningRefSchema.describe("The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookCodeScanningAlertFixedSchema = z.object({
    "action": z.enum(["fixed"]),
"alert": z.object({
    get "assignees"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).optional()
              },
"created_at": z.iso.datetime({ offset: true }).describe("The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"),
"dismissed_at": z.nullable(z.iso.datetime({ offset: true }).describe("The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"dismissed_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
get "dismissed_comment"(){
                return codeScanningAlertDismissedCommentSchema.describe("The dismissal comment associated with the dismissal of the alert.").optional()
              },
"dismissed_reason": z.nullable(z.enum(["false positive", "won't fix", "used in tests"]).describe("The reason for dismissing or closing the alert.")),
"fixed_at": z.unknown().nullish(),
"html_url": z.url().describe("The GitHub URL of the alert resource."),
"instances_url": z.optional(z.url()),
"most_recent_instance": z.object({
    "analysis_key": z.string().describe("Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."),
"category": z.optional(z.string().describe("Identifies the configuration under which the analysis was executed.")),
"classifications": z.optional(z.array(z.string())),
"commit_sha": z.optional(z.string()),
"environment": z.string().describe("Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."),
"location": z.optional(z.object({
    "end_column": z.optional(z.int()),
"end_line": z.optional(z.int()),
"path": z.optional(z.string()),
"start_column": z.optional(z.int()),
"start_line": z.optional(z.int())
    })),
"message": z.optional(z.object({
    "text": z.optional(z.string())
    })),
"ref": z.string().describe("The full Git reference, formatted as `refs/heads/<branch name>`."),
"state": z.enum(["open", "dismissed", "fixed"]).describe("State of a code scanning alert.")
    }).nullish(),
"number": z.int().describe("The code scanning alert number."),
"rule": z.object({
    "description": z.string().describe("A short description of the rule used to detect the alert."),
"full_description": z.optional(z.string()),
"help": z.string().nullish(),
"help_uri": z.string().describe("A link to the documentation for the rule used to detect the alert.").nullish(),
"id": z.string().describe("A unique identifier for the rule used to detect the alert."),
"name": z.optional(z.string()),
"severity": z.nullable(z.enum(["none", "note", "warning", "error"]).describe("The severity of the alert.")),
"tags": z.array(z.string()).nullish()
    }),
"state": z.nullable(z.enum(["fixed"]).describe("State of a code scanning alert. Events for alerts found outside the default branch will return a `null` value until they are dismissed or fixed.")),
"tool": z.object({
    "guid": z.string().nullish(),
"name": z.string().describe("The name of the tool used to generate the code scanning analysis alert."),
"version": z.nullable(z.string().describe("The version of the tool used to detect the alert."))
    }),
"url": z.url()
    }).describe("The code scanning alert involved in the event."),
get "commit_oid"(){
                return webhooksCodeScanningCommitOidSchema.describe("The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "ref"(){
                return webhooksCodeScanningRefSchema.describe("The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookCodeScanningAlertReopenedSchema = z.object({
    "action": z.enum(["reopened"]),
"alert": z.nullable(z.object({
    get "assignees"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).optional()
              },
"created_at": z.iso.datetime({ offset: true }).describe("The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"),
"dismissed_at": z.nullable(z.string().describe("The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"dismissed_by": z.nullable(z.object({
    
    })),
get "dismissed_comment"(){
                return codeScanningAlertDismissedCommentSchema.describe("The dismissal comment associated with the dismissal of the alert.").optional()
              },
"dismissed_reason": z.nullable(z.string().describe("The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.")),
"fixed_at": z.unknown().nullish(),
"html_url": z.url().describe("The GitHub URL of the alert resource."),
"most_recent_instance": z.object({
    "analysis_key": z.string().describe("Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."),
"category": z.optional(z.string().describe("Identifies the configuration under which the analysis was executed.")),
"classifications": z.optional(z.array(z.string())),
"commit_sha": z.optional(z.string()),
"environment": z.string().describe("Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."),
"location": z.optional(z.object({
    "end_column": z.optional(z.int()),
"end_line": z.optional(z.int()),
"path": z.optional(z.string()),
"start_column": z.optional(z.int()),
"start_line": z.optional(z.int())
    })),
"message": z.optional(z.object({
    "text": z.optional(z.string())
    })),
"ref": z.string().describe("The full Git reference, formatted as `refs/heads/<branch name>`."),
"state": z.enum(["open", "dismissed", "fixed"]).describe("State of a code scanning alert.")
    }).nullish(),
"number": z.int().describe("The code scanning alert number."),
"rule": z.object({
    "description": z.string().describe("A short description of the rule used to detect the alert."),
"full_description": z.optional(z.string()),
"help": z.string().nullish(),
"help_uri": z.string().describe("A link to the documentation for the rule used to detect the alert.").nullish(),
"id": z.string().describe("A unique identifier for the rule used to detect the alert."),
"name": z.optional(z.string()),
"severity": z.nullable(z.enum(["none", "note", "warning", "error"]).describe("The severity of the alert.")),
"tags": z.array(z.string()).nullish()
    }),
"state": z.nullable(z.enum(["open", "dismissed", "fixed"]).describe("State of a code scanning alert. Events for alerts found outside the default branch will return a `null` value until they are dismissed or fixed.")),
"tool": z.object({
    "guid": z.string().nullish(),
"name": z.string().describe("The name of the tool used to generate the code scanning analysis alert."),
"version": z.nullable(z.string().describe("The version of the tool used to detect the alert."))
    }),
"url": z.url()
    }).describe("The code scanning alert involved in the event.")),
"commit_oid": z.nullable(z.string().describe("The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.")),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"ref": z.nullable(z.string().describe("The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.")),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookCodeScanningAlertReopenedByUserSchema = z.object({
    "action": z.enum(["reopened_by_user"]),
"alert": z.object({
    get "assignees"(){
                return z.array(simpleUserSchema.describe("A GitHub user.")).optional()
              },
"created_at": z.iso.datetime({ offset: true }).describe("The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"),
"dismissed_at": z.unknown(),
"dismissed_by": z.unknown(),
get "dismissed_comment"(){
                return codeScanningAlertDismissedCommentSchema.describe("The dismissal comment associated with the dismissal of the alert.").optional()
              },
"dismissed_reason": z.unknown(),
"fixed_at": z.unknown().nullish(),
"html_url": z.url().describe("The GitHub URL of the alert resource."),
"most_recent_instance": z.object({
    "analysis_key": z.string().describe("Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."),
"category": z.optional(z.string().describe("Identifies the configuration under which the analysis was executed.")),
"classifications": z.optional(z.array(z.string())),
"commit_sha": z.optional(z.string()),
"environment": z.string().describe("Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."),
"location": z.optional(z.object({
    "end_column": z.optional(z.int()),
"end_line": z.optional(z.int()),
"path": z.optional(z.string()),
"start_column": z.optional(z.int()),
"start_line": z.optional(z.int())
    })),
"message": z.optional(z.object({
    "text": z.optional(z.string())
    })),
"ref": z.string().describe("The full Git reference, formatted as `refs/heads/<branch name>`."),
"state": z.enum(["open", "dismissed", "fixed"]).describe("State of a code scanning alert.")
    }).nullish(),
"number": z.int().describe("The code scanning alert number."),
"rule": z.object({
    "description": z.string().describe("A short description of the rule used to detect the alert."),
"id": z.string().describe("A unique identifier for the rule used to detect the alert."),
"severity": z.nullable(z.enum(["none", "note", "warning", "error"]).describe("The severity of the alert."))
    }),
"state": z.nullable(z.enum(["open", "fixed"]).describe("State of a code scanning alert. Events for alerts found outside the default branch will return a `null` value until they are dismissed or fixed.")),
"tool": z.object({
    "name": z.string().describe("The name of the tool used to generate the code scanning analysis alert."),
"version": z.nullable(z.string().describe("The version of the tool used to detect the alert."))
    }),
"url": z.url()
    }).describe("The code scanning alert involved in the event."),
get "commit_oid"(){
                return webhooksCodeScanningCommitOidSchema.describe("The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "ref"(){
                return webhooksCodeScanningRefSchema.describe("The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookCommitCommentCreatedSchema = z.object({
    "action": z.enum(["created"]).describe("The action performed. Can be `created`."),
"comment": z.object({
    "author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.string().describe("The text of the comment."),
"commit_id": z.string().describe("The SHA of the commit to which the comment applies."),
"created_at": z.string(),
"html_url": z.url(),
"id": z.int().describe("The ID of the commit comment."),
"line": z.nullable(z.int().describe("The line of the blob to which the comment applies. The last line of the range for a multi-line comment")),
"node_id": z.string().describe("The node ID of the commit comment."),
"path": z.nullable(z.string().describe("The relative path of the file to which the comment applies.")),
"position": z.nullable(z.int().describe("The line index in the diff to which the comment applies.")),
"reactions": z.optional(z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    })),
"updated_at": z.string(),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [commit comment](${externalDocsUpapp/api/description/components/schemas/webhooks/issue-comment-created.yamlrl}/rest/commits/comments#get-a-commit-comment) resource."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookCreateSchema = z.object({
    "description": z.nullable(z.string().describe("The repository's current description.")),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"master_branch": z.string().describe("The name of the repository's default branch (usually `main`)."),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "pusher_type"(){
                return webhooksDeployPusherTypeSchema.describe("The pusher type for the event. Can be either `user` or a deploy key.")
              },
get "ref"(){
                return webhooksRef0Schema.describe("The [`git ref`](https://docs.github.com/rest/git/refs#get-a-reference) resource.")
              },
"ref_type": z.enum(["tag", "branch"]).describe("The type of Git ref object created in the repository."),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookCustomPropertyCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "definition"(){
                return customPropertySchema.describe("Custom property defined on an organization")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookCustomPropertyDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
"definition": z.object({
    "property_name": z.string().describe("The name of the property that was deleted.")
    }),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookCustomPropertyPromotedToEnterpriseSchema = z.object({
    "action": z.enum(["promote_to_enterprise"]),
get "definition"(){
                return customPropertySchema.describe("Custom property defined on an organization")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookCustomPropertyUpdatedSchema = z.object({
    "action": z.enum(["updated"]),
get "definition"(){
                return customPropertySchema.describe("Custom property defined on an organization")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookCustomPropertyValuesUpdatedSchema = z.object({
    "action": z.enum(["updated"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
get "new_property_values"(){
                return z.array(customPropertyValueSchema.describe("Custom property name and associated value")).describe("The new custom property values for the repository.")
              },
get "old_property_values"(){
                return z.array(customPropertyValueSchema.describe("Custom property name and associated value")).describe("The old custom property values for the repository.")
              }
    })

export const webhookDeleteSchema = z.object({
    get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "pusher_type"(){
                return webhooksDeployPusherTypeSchema.describe("The pusher type for the event. Can be either `user` or a deploy key.")
              },
get "ref"(){
                return webhooksRef0Schema.describe("The [`git ref`](https://docs.github.com/rest/git/refs#get-a-reference) resource.")
              },
"ref_type": z.enum(["tag", "branch"]).describe("The type of Git ref object deleted in the repository."),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDependabotAlertAutoDismissedSchema = z.object({
    "action": z.enum(["auto_dismissed"]),
get "alert"(){
                return dependabotAlertSchema.describe("A Dependabot alert.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDependabotAlertAutoReopenedSchema = z.object({
    "action": z.enum(["auto_reopened"]),
get "alert"(){
                return dependabotAlertSchema.describe("A Dependabot alert.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDependabotAlertCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "alert"(){
                return dependabotAlertSchema.describe("A Dependabot alert.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDependabotAlertDismissedSchema = z.object({
    "action": z.enum(["dismissed"]),
get "alert"(){
                return dependabotAlertSchema.describe("A Dependabot alert.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDependabotAlertFixedSchema = z.object({
    "action": z.enum(["fixed"]),
get "alert"(){
                return dependabotAlertSchema.describe("A Dependabot alert.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDependabotAlertReintroducedSchema = z.object({
    "action": z.enum(["reintroduced"]),
get "alert"(){
                return dependabotAlertSchema.describe("A Dependabot alert.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDependabotAlertReopenedSchema = z.object({
    "action": z.enum(["reopened"]),
get "alert"(){
                return dependabotAlertSchema.describe("A Dependabot alert.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDeployKeyCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "key"(){
                return webhooksDeployKeySchema.describe("The [`deploy key`](https://docs.github.com/rest/deploy-keys/deploy-keys#get-a-deploy-key) resource.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDeployKeyDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "key"(){
                return webhooksDeployKeySchema.describe("The [`deploy key`](https://docs.github.com/rest/deploy-keys/deploy-keys#get-a-deploy-key) resource.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDeploymentCreatedSchema = z.object({
    "action": z.enum(["created"]),
"deployment": z.object({
    "created_at": z.string(),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"environment": z.string(),
"id": z.int(),
"node_id": z.string(),
"original_environment": z.string(),
"payload": z.union([z.string(), z.object({
    
    })]),
"performed_via_github_app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run", "workflow_job", "pull_request_review_thread", "merge_queue_entry", "secret_scanning_alert_location", "merge_group"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullish(),
"production_environment": z.optional(z.boolean()),
"ref": z.string(),
"repository_url": z.url(),
"sha": z.string(),
"statuses_url": z.url(),
"task": z.string(),
"transient_environment": z.optional(z.boolean()),
"updated_at": z.string(),
"url": z.url()
    }).describe("The [deployment](https://docs.github.com/rest/deployments/deployments#list-deployments)."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "workflow"(){
               return webhooksWorkflowSchema.nullable()
              },
"workflow_run": z.nullable(z.object({
    "actor": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"artifacts_url": z.optional(z.string()),
"cancel_url": z.optional(z.string()),
"check_suite_id": z.int(),
"check_suite_node_id": z.string(),
"check_suite_url": z.optional(z.string()),
"conclusion": z.nullable(z.enum(["success", "failure", "neutral", "cancelled", "timed_out", "action_required", "stale"])),
"created_at": z.iso.datetime({ offset: true }),
"display_title": z.string(),
"event": z.string(),
"head_branch": z.string(),
"head_commit": z.unknown().nullish(),
"head_repository": z.optional(z.object({
    "archive_url": z.optional(z.string()),
"assignees_url": z.optional(z.string()),
"blobs_url": z.optional(z.string()),
"branches_url": z.optional(z.string()),
"collaborators_url": z.optional(z.string()),
"comments_url": z.optional(z.string()),
"commits_url": z.optional(z.string()),
"compare_url": z.optional(z.string()),
"contents_url": z.optional(z.string()),
"contributors_url": z.optional(z.string()),
"deployments_url": z.optional(z.string()),
"description": z.unknown().nullish(),
"downloads_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"fork": z.optional(z.boolean()),
"forks_url": z.optional(z.string()),
"full_name": z.optional(z.string()),
"git_commits_url": z.optional(z.string()),
"git_refs_url": z.optional(z.string()),
"git_tags_url": z.optional(z.string()),
"hooks_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"issue_comment_url": z.optional(z.string()),
"issue_events_url": z.optional(z.string()),
"issues_url": z.optional(z.string()),
"keys_url": z.optional(z.string()),
"labels_url": z.optional(z.string()),
"languages_url": z.optional(z.string()),
"merges_url": z.optional(z.string()),
"milestones_url": z.optional(z.string()),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"notifications_url": z.optional(z.string()),
"owner": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string())
    })),
"private": z.optional(z.boolean()),
"pulls_url": z.optional(z.string()),
"releases_url": z.optional(z.string()),
"stargazers_url": z.optional(z.string()),
"statuses_url": z.optional(z.string()),
"subscribers_url": z.optional(z.string()),
"subscription_url": z.optional(z.string()),
"tags_url": z.optional(z.string()),
"teams_url": z.optional(z.string()),
"trees_url": z.optional(z.string()),
"url": z.optional(z.string())
    })),
"head_sha": z.string(),
"html_url": z.url(),
"id": z.int(),
"jobs_url": z.optional(z.string()),
"logs_url": z.optional(z.string()),
"name": z.string(),
"node_id": z.string(),
"path": z.string(),
"previous_attempt_url": z.unknown().nullish(),
"pull_requests": z.array(z.object({
    "base": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"head": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"id": z.int(),
"number": z.int(),
"url": z.url()
    })),
"referenced_workflows": z.array(z.object({
    "path": z.string(),
"ref": z.optional(z.string()),
"sha": z.string()
    })).nullish(),
"repository": z.optional(z.object({
    "archive_url": z.optional(z.string()),
"assignees_url": z.optional(z.string()),
"blobs_url": z.optional(z.string()),
"branches_url": z.optional(z.string()),
"collaborators_url": z.optional(z.string()),
"comments_url": z.optional(z.string()),
"commits_url": z.optional(z.string()),
"compare_url": z.optional(z.string()),
"contents_url": z.optional(z.string()),
"contributors_url": z.optional(z.string()),
"deployments_url": z.optional(z.string()),
"description": z.unknown().nullish(),
"downloads_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"fork": z.optional(z.boolean()),
"forks_url": z.optional(z.string()),
"full_name": z.optional(z.string()),
"git_commits_url": z.optional(z.string()),
"git_refs_url": z.optional(z.string()),
"git_tags_url": z.optional(z.string()),
"hooks_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"issue_comment_url": z.optional(z.string()),
"issue_events_url": z.optional(z.string()),
"issues_url": z.optional(z.string()),
"keys_url": z.optional(z.string()),
"labels_url": z.optional(z.string()),
"languages_url": z.optional(z.string()),
"merges_url": z.optional(z.string()),
"milestones_url": z.optional(z.string()),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"notifications_url": z.optional(z.string()),
"owner": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string())
    })),
"private": z.optional(z.boolean()),
"pulls_url": z.optional(z.string()),
"releases_url": z.optional(z.string()),
"stargazers_url": z.optional(z.string()),
"statuses_url": z.optional(z.string()),
"subscribers_url": z.optional(z.string()),
"subscription_url": z.optional(z.string()),
"tags_url": z.optional(z.string()),
"teams_url": z.optional(z.string()),
"trees_url": z.optional(z.string()),
"url": z.optional(z.string())
    })),
"rerun_url": z.optional(z.string()),
"run_attempt": z.int(),
"run_number": z.int(),
"run_started_at": z.iso.datetime({ offset: true }),
"status": z.enum(["requested", "in_progress", "completed", "queued", "waiting", "pending"]),
"triggering_actor": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"workflow_id": z.int(),
"workflow_url": z.optional(z.string())
    }))
    })

export const webhookDeploymentProtectionRuleRequestedSchema = z.object({
    "action": z.optional(z.enum(["requested"])),
"environment": z.optional(z.string().describe("The name of the environment that has the deployment protection rule.")),
"event": z.optional(z.string().describe("The event that triggered the deployment protection rule.")),
"deployment_callback_url": z.optional(z.url().describe("The URL to review the deployment protection rule.")),
get "deployment"(){
                return deploymentSchema.describe("A request for a specific ref(branch,sha,tag) to be deployed").optional()
              },
get "pull_requests"(){
                return z.array(pullRequestSchema.describe("Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.")).optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookDeploymentReviewApprovedSchema = z.object({
    "action": z.enum(["approved"]),
get "approver"(){
                return webhooksApproverSchema.optional()
              },
"comment": z.optional(z.string()),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "reviewers"(){
                return webhooksReviewersSchema.optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"since": z.string(),
get "workflow_job_run"(){
                return webhooksWorkflowJobRunSchema.optional()
              },
"workflow_job_runs": z.optional(z.array(z.object({
    "conclusion": z.unknown().nullish(),
"created_at": z.optional(z.string()),
"environment": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"name": z.string().nullish(),
"status": z.optional(z.string()),
"updated_at": z.optional(z.string())
    }))),
"workflow_run": z.nullable(z.object({
    "actor": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"artifacts_url": z.optional(z.string()),
"cancel_url": z.optional(z.string()),
"check_suite_id": z.int(),
"check_suite_node_id": z.string(),
"check_suite_url": z.optional(z.string()),
"conclusion": z.nullable(z.enum(["success", "failure", "neutral", "cancelled", "timed_out", "action_required", "stale"])),
"created_at": z.iso.datetime({ offset: true }),
"display_title": z.string(),
"event": z.string(),
"head_branch": z.string(),
"head_commit": z.object({
    
    }).nullish(),
"head_repository": z.optional(z.object({
    "archive_url": z.optional(z.string()),
"assignees_url": z.optional(z.string()),
"blobs_url": z.optional(z.string()),
"branches_url": z.optional(z.string()),
"collaborators_url": z.optional(z.string()),
"comments_url": z.optional(z.string()),
"commits_url": z.optional(z.string()),
"compare_url": z.optional(z.string()),
"contents_url": z.optional(z.string()),
"contributors_url": z.optional(z.string()),
"deployments_url": z.optional(z.string()),
"description": z.string().nullish(),
"downloads_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"fork": z.optional(z.boolean()),
"forks_url": z.optional(z.string()),
"full_name": z.optional(z.string()),
"git_commits_url": z.optional(z.string()),
"git_refs_url": z.optional(z.string()),
"git_tags_url": z.optional(z.string()),
"hooks_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"issue_comment_url": z.optional(z.string()),
"issue_events_url": z.optional(z.string()),
"issues_url": z.optional(z.string()),
"keys_url": z.optional(z.string()),
"labels_url": z.optional(z.string()),
"languages_url": z.optional(z.string()),
"merges_url": z.optional(z.string()),
"milestones_url": z.optional(z.string()),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"notifications_url": z.optional(z.string()),
"owner": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string()),
"user_view_type": z.optional(z.string())
    })),
"private": z.optional(z.boolean()),
"pulls_url": z.optional(z.string()),
"releases_url": z.optional(z.string()),
"stargazers_url": z.optional(z.string()),
"statuses_url": z.optional(z.string()),
"subscribers_url": z.optional(z.string()),
"subscription_url": z.optional(z.string()),
"tags_url": z.optional(z.string()),
"teams_url": z.optional(z.string()),
"trees_url": z.optional(z.string()),
"url": z.optional(z.string())
    })),
"head_sha": z.string(),
"html_url": z.url(),
"id": z.int(),
"jobs_url": z.optional(z.string()),
"logs_url": z.optional(z.string()),
"name": z.string(),
"node_id": z.string(),
"path": z.string(),
"previous_attempt_url": z.string().nullish(),
"pull_requests": z.array(z.object({
    "base": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"head": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"id": z.int(),
"number": z.int(),
"url": z.url()
    })),
"referenced_workflows": z.array(z.object({
    "path": z.string(),
"ref": z.optional(z.string()),
"sha": z.string()
    })).nullish(),
"repository": z.optional(z.object({
    "archive_url": z.optional(z.string()),
"assignees_url": z.optional(z.string()),
"blobs_url": z.optional(z.string()),
"branches_url": z.optional(z.string()),
"collaborators_url": z.optional(z.string()),
"comments_url": z.optional(z.string()),
"commits_url": z.optional(z.string()),
"compare_url": z.optional(z.string()),
"contents_url": z.optional(z.string()),
"contributors_url": z.optional(z.string()),
"deployments_url": z.optional(z.string()),
"description": z.string().nullish(),
"downloads_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"fork": z.optional(z.boolean()),
"forks_url": z.optional(z.string()),
"full_name": z.optional(z.string()),
"git_commits_url": z.optional(z.string()),
"git_refs_url": z.optional(z.string()),
"git_tags_url": z.optional(z.string()),
"hooks_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"issue_comment_url": z.optional(z.string()),
"issue_events_url": z.optional(z.string()),
"issues_url": z.optional(z.string()),
"keys_url": z.optional(z.string()),
"labels_url": z.optional(z.string()),
"languages_url": z.optional(z.string()),
"merges_url": z.optional(z.string()),
"milestones_url": z.optional(z.string()),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"notifications_url": z.optional(z.string()),
"owner": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string()),
"user_view_type": z.optional(z.string())
    })),
"private": z.optional(z.boolean()),
"pulls_url": z.optional(z.string()),
"releases_url": z.optional(z.string()),
"stargazers_url": z.optional(z.string()),
"statuses_url": z.optional(z.string()),
"subscribers_url": z.optional(z.string()),
"subscription_url": z.optional(z.string()),
"tags_url": z.optional(z.string()),
"teams_url": z.optional(z.string()),
"trees_url": z.optional(z.string()),
"url": z.optional(z.string())
    })),
"rerun_url": z.optional(z.string()),
"run_attempt": z.int(),
"run_number": z.int(),
"run_started_at": z.iso.datetime({ offset: true }),
"status": z.enum(["requested", "in_progress", "completed", "queued", "waiting", "pending"]),
"triggering_actor": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"workflow_id": z.int(),
"workflow_url": z.optional(z.string())
    }))
    })

export const webhookDeploymentReviewRejectedSchema = z.object({
    "action": z.enum(["rejected"]),
get "approver"(){
                return webhooksApproverSchema.optional()
              },
"comment": z.optional(z.string()),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "reviewers"(){
                return webhooksReviewersSchema.optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"since": z.string(),
get "workflow_job_run"(){
                return webhooksWorkflowJobRunSchema.optional()
              },
"workflow_job_runs": z.optional(z.array(z.object({
    "conclusion": z.string().nullish(),
"created_at": z.optional(z.string()),
"environment": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"name": z.string().nullish(),
"status": z.optional(z.string()),
"updated_at": z.optional(z.string())
    }))),
"workflow_run": z.nullable(z.object({
    "actor": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"artifacts_url": z.optional(z.string()),
"cancel_url": z.optional(z.string()),
"check_suite_id": z.int(),
"check_suite_node_id": z.string(),
"check_suite_url": z.optional(z.string()),
"conclusion": z.nullable(z.enum(["success", "failure", "neutral", "cancelled", "timed_out", "action_required", "stale"])),
"created_at": z.iso.datetime({ offset: true }),
"event": z.string(),
"head_branch": z.string(),
"head_commit": z.object({
    
    }).nullish(),
"head_repository": z.optional(z.object({
    "archive_url": z.optional(z.string()),
"assignees_url": z.optional(z.string()),
"blobs_url": z.optional(z.string()),
"branches_url": z.optional(z.string()),
"collaborators_url": z.optional(z.string()),
"comments_url": z.optional(z.string()),
"commits_url": z.optional(z.string()),
"compare_url": z.optional(z.string()),
"contents_url": z.optional(z.string()),
"contributors_url": z.optional(z.string()),
"deployments_url": z.optional(z.string()),
"description": z.string().nullish(),
"downloads_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"fork": z.optional(z.boolean()),
"forks_url": z.optional(z.string()),
"full_name": z.optional(z.string()),
"git_commits_url": z.optional(z.string()),
"git_refs_url": z.optional(z.string()),
"git_tags_url": z.optional(z.string()),
"hooks_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"issue_comment_url": z.optional(z.string()),
"issue_events_url": z.optional(z.string()),
"issues_url": z.optional(z.string()),
"keys_url": z.optional(z.string()),
"labels_url": z.optional(z.string()),
"languages_url": z.optional(z.string()),
"merges_url": z.optional(z.string()),
"milestones_url": z.optional(z.string()),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"notifications_url": z.optional(z.string()),
"owner": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string()),
"user_view_type": z.optional(z.string())
    })),
"private": z.optional(z.boolean()),
"pulls_url": z.optional(z.string()),
"releases_url": z.optional(z.string()),
"stargazers_url": z.optional(z.string()),
"statuses_url": z.optional(z.string()),
"subscribers_url": z.optional(z.string()),
"subscription_url": z.optional(z.string()),
"tags_url": z.optional(z.string()),
"teams_url": z.optional(z.string()),
"trees_url": z.optional(z.string()),
"url": z.optional(z.string())
    })),
"head_sha": z.string(),
"html_url": z.url(),
"id": z.int(),
"jobs_url": z.optional(z.string()),
"logs_url": z.optional(z.string()),
"name": z.string(),
"node_id": z.string(),
"path": z.string(),
"previous_attempt_url": z.string().nullish(),
"pull_requests": z.array(z.object({
    "base": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"head": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"id": z.int(),
"number": z.int(),
"url": z.url()
    })),
"referenced_workflows": z.array(z.object({
    "path": z.string(),
"ref": z.optional(z.string()),
"sha": z.string()
    })).nullish(),
"repository": z.optional(z.object({
    "archive_url": z.optional(z.string()),
"assignees_url": z.optional(z.string()),
"blobs_url": z.optional(z.string()),
"branches_url": z.optional(z.string()),
"collaborators_url": z.optional(z.string()),
"comments_url": z.optional(z.string()),
"commits_url": z.optional(z.string()),
"compare_url": z.optional(z.string()),
"contents_url": z.optional(z.string()),
"contributors_url": z.optional(z.string()),
"deployments_url": z.optional(z.string()),
"description": z.string().nullish(),
"downloads_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"fork": z.optional(z.boolean()),
"forks_url": z.optional(z.string()),
"full_name": z.optional(z.string()),
"git_commits_url": z.optional(z.string()),
"git_refs_url": z.optional(z.string()),
"git_tags_url": z.optional(z.string()),
"hooks_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"issue_comment_url": z.optional(z.string()),
"issue_events_url": z.optional(z.string()),
"issues_url": z.optional(z.string()),
"keys_url": z.optional(z.string()),
"labels_url": z.optional(z.string()),
"languages_url": z.optional(z.string()),
"merges_url": z.optional(z.string()),
"milestones_url": z.optional(z.string()),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"notifications_url": z.optional(z.string()),
"owner": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string()),
"user_view_type": z.optional(z.string())
    })),
"private": z.optional(z.boolean()),
"pulls_url": z.optional(z.string()),
"releases_url": z.optional(z.string()),
"stargazers_url": z.optional(z.string()),
"statuses_url": z.optional(z.string()),
"subscribers_url": z.optional(z.string()),
"subscription_url": z.optional(z.string()),
"tags_url": z.optional(z.string()),
"teams_url": z.optional(z.string()),
"trees_url": z.optional(z.string()),
"url": z.optional(z.string())
    })),
"rerun_url": z.optional(z.string()),
"run_attempt": z.int(),
"run_number": z.int(),
"run_started_at": z.iso.datetime({ offset: true }),
"status": z.enum(["requested", "in_progress", "completed", "queued", "waiting"]),
"triggering_actor": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"workflow_id": z.int(),
"workflow_url": z.optional(z.string()),
"display_title": z.string()
    }))
    })

export const webhookDeploymentReviewRequestedSchema = z.object({
    "action": z.enum(["requested"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
"environment": z.string(),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "requestor"(){
               return webhooksUserSchema.nullable()
              },
"reviewers": z.array(z.object({
    "reviewer": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.optional(z.string()),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"type": z.optional(z.enum(["User", "Team"]))
    })),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"since": z.string(),
"workflow_job_run": z.object({
    "conclusion": z.unknown(),
"created_at": z.string(),
"environment": z.string(),
"html_url": z.string(),
"id": z.int(),
"name": z.nullable(z.string()),
"status": z.string(),
"updated_at": z.string()
    }),
"workflow_run": z.nullable(z.object({
    "actor": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"artifacts_url": z.optional(z.string()),
"cancel_url": z.optional(z.string()),
"check_suite_id": z.int(),
"check_suite_node_id": z.string(),
"check_suite_url": z.optional(z.string()),
"conclusion": z.nullable(z.enum(["success", "failure", "neutral", "cancelled", "timed_out", "action_required", "stale"])),
"created_at": z.iso.datetime({ offset: true }),
"event": z.string(),
"head_branch": z.string(),
"head_commit": z.object({
    
    }).nullish(),
"head_repository": z.optional(z.object({
    "archive_url": z.optional(z.string()),
"assignees_url": z.optional(z.string()),
"blobs_url": z.optional(z.string()),
"branches_url": z.optional(z.string()),
"collaborators_url": z.optional(z.string()),
"comments_url": z.optional(z.string()),
"commits_url": z.optional(z.string()),
"compare_url": z.optional(z.string()),
"contents_url": z.optional(z.string()),
"contributors_url": z.optional(z.string()),
"deployments_url": z.optional(z.string()),
"description": z.string().nullish(),
"downloads_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"fork": z.optional(z.boolean()),
"forks_url": z.optional(z.string()),
"full_name": z.optional(z.string()),
"git_commits_url": z.optional(z.string()),
"git_refs_url": z.optional(z.string()),
"git_tags_url": z.optional(z.string()),
"hooks_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"issue_comment_url": z.optional(z.string()),
"issue_events_url": z.optional(z.string()),
"issues_url": z.optional(z.string()),
"keys_url": z.optional(z.string()),
"labels_url": z.optional(z.string()),
"languages_url": z.optional(z.string()),
"merges_url": z.optional(z.string()),
"milestones_url": z.optional(z.string()),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"notifications_url": z.optional(z.string()),
"owner": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string()),
"user_view_type": z.optional(z.string())
    })),
"private": z.optional(z.boolean()),
"pulls_url": z.optional(z.string()),
"releases_url": z.optional(z.string()),
"stargazers_url": z.optional(z.string()),
"statuses_url": z.optional(z.string()),
"subscribers_url": z.optional(z.string()),
"subscription_url": z.optional(z.string()),
"tags_url": z.optional(z.string()),
"teams_url": z.optional(z.string()),
"trees_url": z.optional(z.string()),
"url": z.optional(z.string())
    })),
"head_sha": z.string(),
"html_url": z.url(),
"id": z.int(),
"jobs_url": z.optional(z.string()),
"logs_url": z.optional(z.string()),
"name": z.string(),
"node_id": z.string(),
"path": z.string(),
"previous_attempt_url": z.string().nullish(),
"pull_requests": z.array(z.object({
    "base": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"head": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"id": z.int(),
"number": z.int(),
"url": z.url()
    })),
"referenced_workflows": z.array(z.object({
    "path": z.string(),
"ref": z.optional(z.string()),
"sha": z.string()
    })).nullish(),
"repository": z.optional(z.object({
    "archive_url": z.optional(z.string()),
"assignees_url": z.optional(z.string()),
"blobs_url": z.optional(z.string()),
"branches_url": z.optional(z.string()),
"collaborators_url": z.optional(z.string()),
"comments_url": z.optional(z.string()),
"commits_url": z.optional(z.string()),
"compare_url": z.optional(z.string()),
"contents_url": z.optional(z.string()),
"contributors_url": z.optional(z.string()),
"deployments_url": z.optional(z.string()),
"description": z.string().nullish(),
"downloads_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"fork": z.optional(z.boolean()),
"forks_url": z.optional(z.string()),
"full_name": z.optional(z.string()),
"git_commits_url": z.optional(z.string()),
"git_refs_url": z.optional(z.string()),
"git_tags_url": z.optional(z.string()),
"hooks_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"issue_comment_url": z.optional(z.string()),
"issue_events_url": z.optional(z.string()),
"issues_url": z.optional(z.string()),
"keys_url": z.optional(z.string()),
"labels_url": z.optional(z.string()),
"languages_url": z.optional(z.string()),
"merges_url": z.optional(z.string()),
"milestones_url": z.optional(z.string()),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"notifications_url": z.optional(z.string()),
"owner": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string()),
"user_view_type": z.optional(z.string())
    })),
"private": z.optional(z.boolean()),
"pulls_url": z.optional(z.string()),
"releases_url": z.optional(z.string()),
"stargazers_url": z.optional(z.string()),
"statuses_url": z.optional(z.string()),
"subscribers_url": z.optional(z.string()),
"subscription_url": z.optional(z.string()),
"tags_url": z.optional(z.string()),
"teams_url": z.optional(z.string()),
"trees_url": z.optional(z.string()),
"url": z.optional(z.string())
    })),
"rerun_url": z.optional(z.string()),
"run_attempt": z.int(),
"run_number": z.int(),
"run_started_at": z.iso.datetime({ offset: true }),
"status": z.enum(["requested", "in_progress", "completed", "queued", "waiting", "pending"]),
"triggering_actor": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"workflow_id": z.int(),
"workflow_url": z.optional(z.string()),
"display_title": z.string()
    }))
    })

export const webhookDeploymentStatusCreatedSchema = z.object({
    "action": z.enum(["created"]),
"check_run": z.object({
    "completed_at": z.nullable(z.iso.datetime({ offset: true })),
"conclusion": z.nullable(z.enum(["success", "failure", "neutral", "cancelled", "timed_out", "action_required", "stale", "skipped"]).describe("The result of the completed check run. This value will be `null` until the check run has completed.")),
"details_url": z.url(),
"external_id": z.string(),
"head_sha": z.string().describe("The SHA of the commit that is being checked."),
"html_url": z.url(),
"id": z.int().describe("The id of the check."),
"name": z.string().describe("The name of the check run."),
"node_id": z.string(),
"started_at": z.iso.datetime({ offset: true }),
"status": z.enum(["queued", "in_progress", "completed", "waiting", "pending"]).describe("The current status of the check run. Can be `queued`, `in_progress`, or `completed`."),
"url": z.url()
    }).nullish(),
"deployment": z.object({
    "created_at": z.string(),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"environment": z.string(),
"id": z.int(),
"node_id": z.string(),
"original_environment": z.string(),
"payload": z.nullable(z.union([z.string(), z.object({
    
    })])),
"performed_via_github_app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run", "merge_queue_entry", "workflow_job", "pull_request_review_thread", "secret_scanning_alert_location", "merge_group"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullish(),
"production_environment": z.optional(z.boolean()),
"ref": z.string(),
"repository_url": z.url(),
"sha": z.string(),
"statuses_url": z.url(),
"task": z.string(),
"transient_environment": z.optional(z.boolean()),
"updated_at": z.string(),
"url": z.url()
    }).describe("The [deployment](https://docs.github.com/rest/deployments/deployments#list-deployments)."),
"deployment_status": z.object({
    "created_at": z.string(),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"deployment_url": z.url(),
"description": z.string().describe("The optional human-readable description added to the status."),
"environment": z.string(),
"environment_url": z.optional(z.url()),
"id": z.int(),
"log_url": z.optional(z.url()),
"node_id": z.string(),
"performed_via_github_app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run", "pull_request_review_thread", "merge_queue_entry", "workflow_job", "merge_group", "secret_scanning_alert_location"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullish(),
"repository_url": z.url(),
"state": z.string().describe("The new state. Can be `pending`, `success`, `failure`, or `error`."),
"target_url": z.string().describe("The optional link added to the status."),
"updated_at": z.string(),
"url": z.url()
    }).describe("The [deployment status](https://docs.github.com/rest/deployments/statuses#list-deployment-statuses)."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "workflow"(){
                return webhooksWorkflowSchema.optional()
              },
"workflow_run": z.object({
    "actor": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"artifacts_url": z.optional(z.string()),
"cancel_url": z.optional(z.string()),
"check_suite_id": z.int(),
"check_suite_node_id": z.string(),
"check_suite_url": z.optional(z.string()),
"conclusion": z.nullable(z.enum(["success", "failure", "neutral", "cancelled", "timed_out", "action_required", "stale", "startup_failure"])),
"created_at": z.iso.datetime({ offset: true }),
"display_title": z.string(),
"event": z.string(),
"head_branch": z.string(),
"head_commit": z.unknown().nullish(),
"head_repository": z.optional(z.object({
    "archive_url": z.optional(z.string()),
"assignees_url": z.optional(z.string()),
"blobs_url": z.optional(z.string()),
"branches_url": z.optional(z.string()),
"collaborators_url": z.optional(z.string()),
"comments_url": z.optional(z.string()),
"commits_url": z.optional(z.string()),
"compare_url": z.optional(z.string()),
"contents_url": z.optional(z.string()),
"contributors_url": z.optional(z.string()),
"deployments_url": z.optional(z.string()),
"description": z.unknown().nullish(),
"downloads_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"fork": z.optional(z.boolean()),
"forks_url": z.optional(z.string()),
"full_name": z.optional(z.string()),
"git_commits_url": z.optional(z.string()),
"git_refs_url": z.optional(z.string()),
"git_tags_url": z.optional(z.string()),
"hooks_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"issue_comment_url": z.optional(z.string()),
"issue_events_url": z.optional(z.string()),
"issues_url": z.optional(z.string()),
"keys_url": z.optional(z.string()),
"labels_url": z.optional(z.string()),
"languages_url": z.optional(z.string()),
"merges_url": z.optional(z.string()),
"milestones_url": z.optional(z.string()),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"notifications_url": z.optional(z.string()),
"owner": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string())
    })),
"private": z.optional(z.boolean()),
"pulls_url": z.optional(z.string()),
"releases_url": z.optional(z.string()),
"stargazers_url": z.optional(z.string()),
"statuses_url": z.optional(z.string()),
"subscribers_url": z.optional(z.string()),
"subscription_url": z.optional(z.string()),
"tags_url": z.optional(z.string()),
"teams_url": z.optional(z.string()),
"trees_url": z.optional(z.string()),
"url": z.optional(z.string())
    })),
"head_sha": z.string(),
"html_url": z.url(),
"id": z.int(),
"jobs_url": z.optional(z.string()),
"logs_url": z.optional(z.string()),
"name": z.string(),
"node_id": z.string(),
"path": z.string(),
"previous_attempt_url": z.unknown().nullish(),
"pull_requests": z.array(z.object({
    "base": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"head": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"id": z.int(),
"number": z.int(),
"url": z.url()
    })),
"referenced_workflows": z.array(z.object({
    "path": z.string(),
"ref": z.optional(z.string()),
"sha": z.string()
    })).nullish(),
"repository": z.optional(z.object({
    "archive_url": z.optional(z.string()),
"assignees_url": z.optional(z.string()),
"blobs_url": z.optional(z.string()),
"branches_url": z.optional(z.string()),
"collaborators_url": z.optional(z.string()),
"comments_url": z.optional(z.string()),
"commits_url": z.optional(z.string()),
"compare_url": z.optional(z.string()),
"contents_url": z.optional(z.string()),
"contributors_url": z.optional(z.string()),
"deployments_url": z.optional(z.string()),
"description": z.unknown().nullish(),
"downloads_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"fork": z.optional(z.boolean()),
"forks_url": z.optional(z.string()),
"full_name": z.optional(z.string()),
"git_commits_url": z.optional(z.string()),
"git_refs_url": z.optional(z.string()),
"git_tags_url": z.optional(z.string()),
"hooks_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"issue_comment_url": z.optional(z.string()),
"issue_events_url": z.optional(z.string()),
"issues_url": z.optional(z.string()),
"keys_url": z.optional(z.string()),
"labels_url": z.optional(z.string()),
"languages_url": z.optional(z.string()),
"merges_url": z.optional(z.string()),
"milestones_url": z.optional(z.string()),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"notifications_url": z.optional(z.string()),
"owner": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string())
    })),
"private": z.optional(z.boolean()),
"pulls_url": z.optional(z.string()),
"releases_url": z.optional(z.string()),
"stargazers_url": z.optional(z.string()),
"statuses_url": z.optional(z.string()),
"subscribers_url": z.optional(z.string()),
"subscription_url": z.optional(z.string()),
"tags_url": z.optional(z.string()),
"teams_url": z.optional(z.string()),
"trees_url": z.optional(z.string()),
"url": z.optional(z.string())
    })),
"rerun_url": z.optional(z.string()),
"run_attempt": z.int(),
"run_number": z.int(),
"run_started_at": z.iso.datetime({ offset: true }),
"status": z.enum(["requested", "in_progress", "completed", "queued", "waiting", "pending"]),
"triggering_actor": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"workflow_id": z.int(),
"workflow_url": z.optional(z.string())
    }).nullish()
    })

export const webhookDiscussionAnsweredSchema = z.object({
    "action": z.enum(["answered"]),
get "answer"(){
                return webhooksAnswerSchema
              },
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDiscussionCategoryChangedSchema = z.object({
    "action": z.enum(["category_changed"]),
"changes": z.object({
    "category": z.object({
    "from": z.object({
    "created_at": z.iso.datetime({ offset: true }),
"description": z.string(),
"emoji": z.string(),
"id": z.int(),
"is_answerable": z.boolean(),
"name": z.string(),
"node_id": z.optional(z.string()),
"repository_id": z.int(),
"slug": z.string(),
"updated_at": z.string()
    })
    })
    }),
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDiscussionClosedSchema = z.object({
    "action": z.enum(["closed"]),
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDiscussionCommentCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "comment"(){
                return webhooksCommentSchema
              },
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDiscussionCommentDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "comment"(){
                return webhooksCommentSchema
              },
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDiscussionCommentEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.object({
    "body": z.object({
    "from": z.string()
    })
    }),
get "comment"(){
                return webhooksCommentSchema
              },
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDiscussionCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDiscussionDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDiscussionEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.optional(z.object({
    "body": z.optional(z.object({
    "from": z.string()
    })),
"title": z.optional(z.object({
    "from": z.string()
    }))
    })),
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDiscussionLabeledSchema = z.object({
    "action": z.enum(["labeled"]),
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "label"(){
                return webhooksLabelSchema
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDiscussionLockedSchema = z.object({
    "action": z.enum(["locked"]),
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDiscussionPinnedSchema = z.object({
    "action": z.enum(["pinned"]),
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDiscussionReopenedSchema = z.object({
    "action": z.enum(["reopened"]),
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDiscussionTransferredSchema = z.object({
    "action": z.enum(["transferred"]),
"changes": z.object({
    get "new_discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "new_repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              }
    }),
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDiscussionUnansweredSchema = z.object({
    "action": z.enum(["unanswered"]),
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "old_answer"(){
                return webhooksAnswerSchema
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookDiscussionUnlabeledSchema = z.object({
    "action": z.enum(["unlabeled"]),
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "label"(){
                return webhooksLabelSchema
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDiscussionUnlockedSchema = z.object({
    "action": z.enum(["unlocked"]),
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookDiscussionUnpinnedSchema = z.object({
    "action": z.enum(["unpinned"]),
get "discussion"(){
                return discussionSchema.describe("A Discussion in a repository.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

/**
 * @description A user forks a repository.
 */
export const webhookForkSchema = z.object({
    get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
"forkee": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean()),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.optional(z.string()),
"archived": z.optional(z.boolean()),
"assignees_url": z.optional(z.string()),
"blobs_url": z.optional(z.string()),
"branches_url": z.optional(z.string()),
"clone_url": z.optional(z.string()),
"collaborators_url": z.optional(z.string()),
"comments_url": z.optional(z.string()),
"commits_url": z.optional(z.string()),
"compare_url": z.optional(z.string()),
"contents_url": z.optional(z.string()),
"contributors_url": z.optional(z.string()),
"created_at": z.optional(z.string()),
"default_branch": z.optional(z.string()),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.optional(z.string()),
"description": z.string().nullish(),
"disabled": z.optional(z.boolean()),
"downloads_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"fork": z.optional(z.literal(true)),
"forks": z.optional(z.int()),
"forks_count": z.optional(z.int()),
"forks_url": z.optional(z.string()),
"full_name": z.optional(z.string()),
"git_commits_url": z.optional(z.string()),
"git_refs_url": z.optional(z.string()),
"git_tags_url": z.optional(z.string()),
"git_url": z.optional(z.string()),
"has_downloads": z.optional(z.boolean()),
"has_issues": z.optional(z.boolean()),
"has_pages": z.optional(z.boolean()),
"has_projects": z.optional(z.boolean()),
"has_wiki": z.optional(z.boolean()),
"homepage": z.string().nullish(),
"hooks_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.optional(z.string()),
"issue_events_url": z.optional(z.string()),
"issues_url": z.optional(z.string()),
"keys_url": z.optional(z.string()),
"labels_url": z.optional(z.string()),
"language": z.unknown().nullish(),
"languages_url": z.optional(z.string()),
"license": z.object({
    
    }).nullish(),
"master_branch": z.optional(z.string()),
"merges_url": z.optional(z.string()),
"milestones_url": z.optional(z.string()),
"mirror_url": z.unknown().nullish(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"notifications_url": z.optional(z.string()),
"open_issues": z.optional(z.int()),
"open_issues_count": z.optional(z.int()),
"organization": z.optional(z.string()),
"owner": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.optional(z.boolean()),
"public": z.optional(z.boolean()),
"pulls_url": z.optional(z.string()),
"pushed_at": z.optional(z.string()),
"releases_url": z.optional(z.string()),
"role_name": z.string().nullish(),
"size": z.optional(z.int()),
"ssh_url": z.optional(z.string()),
"stargazers": z.optional(z.int()),
"stargazers_count": z.optional(z.int()),
"stargazers_url": z.optional(z.string()),
"statuses_url": z.optional(z.string()),
"subscribers_url": z.optional(z.string()),
"subscription_url": z.optional(z.string()),
"svn_url": z.optional(z.string()),
"tags_url": z.optional(z.string()),
"teams_url": z.optional(z.string()),
"topics": z.optional(z.array(z.unknown())),
"trees_url": z.optional(z.string()),
"updated_at": z.optional(z.string()),
"url": z.optional(z.string()),
"visibility": z.optional(z.string()),
"watchers": z.optional(z.int()),
"watchers_count": z.optional(z.int()),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("The created [`repository`](https://docs.github.com/rest/repos/repos#get-a-repository) resource."),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    }).describe("A user forks a repository.")

export const webhookGithubAppAuthorizationRevokedSchema = z.object({
    "action": z.enum(["revoked"]),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookGollumSchema = z.object({
    get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pages": z.array(z.object({
    "action": z.enum(["created", "edited"]).describe("The action that was performed on the page. Can be `created` or `edited`."),
"html_url": z.url().describe("Points to the HTML wiki page."),
"page_name": z.string().describe("The name of the page."),
"sha": z.string().describe("The latest commit SHA of the page."),
"summary": z.nullable(z.string()),
"title": z.string().describe("The current page title.")
    })).describe("The pages that were updated."),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookInstallationCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return installationSchema.describe("Installation")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repositories"(){
                return webhooksRepositoriesSchema.describe("An array of repository objects that the installation can access.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "requester"(){
                return webhooksUserSchema.optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookInstallationDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return installationSchema.describe("Installation")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repositories"(){
                return webhooksRepositoriesSchema.describe("An array of repository objects that the installation can access.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
"requester": z.unknown().nullish(),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookInstallationNewPermissionsAcceptedSchema = z.object({
    "action": z.enum(["new_permissions_accepted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return installationSchema.describe("Installation")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repositories"(){
                return webhooksRepositoriesSchema.describe("An array of repository objects that the installation can access.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
"requester": z.unknown().nullish(),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookInstallationRepositoriesAddedSchema = z.object({
    "action": z.enum(["added"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return installationSchema.describe("Installation")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repositories_added"(){
                return webhooksRepositoriesAddedSchema.describe("An array of repository objects, which were added to the installation.")
              },
"repositories_removed": z.array(z.object({
    "full_name": z.optional(z.string()),
"id": z.optional(z.int().describe("Unique identifier of the repository")),
"name": z.optional(z.string().describe("The name of the repository.")),
"node_id": z.optional(z.string()),
"private": z.optional(z.boolean().describe("Whether the repository is private or public."))
    })).describe("An array of repository objects, which were removed from the installation."),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "repository_selection"(){
                return webhooksRepositorySelectionSchema.describe("Describe whether all repositories have been selected or there's a selection involved")
              },
get "requester"(){
               return webhooksUserSchema.nullable()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookInstallationRepositoriesRemovedSchema = z.object({
    "action": z.enum(["removed"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return installationSchema.describe("Installation")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repositories_added"(){
                return webhooksRepositoriesAddedSchema.describe("An array of repository objects, which were added to the installation.")
              },
"repositories_removed": z.array(z.object({
    "full_name": z.string(),
"id": z.int().describe("Unique identifier of the repository"),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"private": z.boolean().describe("Whether the repository is private or public.")
    })).describe("An array of repository objects, which were removed from the installation."),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "repository_selection"(){
                return webhooksRepositorySelectionSchema.describe("Describe whether all repositories have been selected or there's a selection involved")
              },
get "requester"(){
               return webhooksUserSchema.nullable()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookInstallationSuspendSchema = z.object({
    "action": z.enum(["suspend"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return installationSchema.describe("Installation")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repositories"(){
                return webhooksRepositoriesSchema.describe("An array of repository objects that the installation can access.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
"requester": z.unknown().nullish(),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookInstallationTargetRenamedSchema = z.object({
    "account": z.object({
    "archived_at": z.string().nullish(),
"avatar_url": z.string(),
"created_at": z.optional(z.string()),
"description": z.unknown().nullish(),
"events_url": z.optional(z.string()),
"followers": z.optional(z.int()),
"followers_url": z.optional(z.string()),
"following": z.optional(z.int()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"has_organization_projects": z.optional(z.boolean()),
"has_repository_projects": z.optional(z.boolean()),
"hooks_url": z.optional(z.string()),
"html_url": z.string(),
"id": z.int(),
"is_verified": z.optional(z.boolean()),
"issues_url": z.optional(z.string()),
"login": z.optional(z.string()),
"members_url": z.optional(z.string()),
"name": z.optional(z.string()),
"node_id": z.string(),
"organizations_url": z.optional(z.string()),
"public_gists": z.optional(z.int()),
"public_members_url": z.optional(z.string()),
"public_repos": z.optional(z.int()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"slug": z.optional(z.string()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"updated_at": z.optional(z.string()),
"url": z.optional(z.string()),
"website_url": z.unknown().nullish(),
"user_view_type": z.optional(z.string())
    }),
"action": z.enum(["renamed"]),
"changes": z.object({
    "login": z.optional(z.object({
    "from": z.string()
    })),
"slug": z.optional(z.object({
    "from": z.string()
    }))
    }),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
"target_type": z.string()
    })

export const webhookInstallationUnsuspendSchema = z.object({
    "action": z.enum(["unsuspend"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return installationSchema.describe("Installation")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repositories"(){
                return webhooksRepositoriesSchema.describe("An array of repository objects that the installation can access.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
"requester": z.unknown().nullish(),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssueCommentCreatedSchema = z.object({
    "action": z.enum(["created"]),
"comment": z.object({
    "author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.string().describe("Contents of the issue comment"),
"created_at": z.iso.datetime({ offset: true }),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the issue comment"),
"issue_url": z.url(),
"node_id": z.string(),
get "performed_via_github_app"(){
               return nullableIntegrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()
              },
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the issue comment"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment) itself."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"issue": z.object({
    "active_lock_reason": z.string().nullish(),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.optional(z.array(z.object({
    
    }).nullable())),
"author_association": z.optional(z.string()),
"body": z.string().nullish(),
"closed_at": z.string().nullish(),
"comments": z.optional(z.int()),
"comments_url": z.optional(z.string()),
"created_at": z.optional(z.string()),
"draft": z.optional(z.boolean()),
"events_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"labels_url": z.optional(z.string()),
"locked": z.boolean(),
"milestone": z.object({
    
    }).nullish(),
"node_id": z.optional(z.string()),
"number": z.optional(z.int()),
"performed_via_github_app": z.object({
    
    }).nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.optional(z.object({
    "+1": z.optional(z.int()),
"-1": z.optional(z.int()),
"confused": z.optional(z.int()),
"eyes": z.optional(z.int()),
"heart": z.optional(z.int()),
"hooray": z.optional(z.int()),
"laugh": z.optional(z.int()),
"rocket": z.optional(z.int()),
"total_count": z.optional(z.int()),
"url": z.optional(z.string())
    })),
"repository_url": z.optional(z.string()),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
"state": z.enum(["open", "closed"]).describe("State of the issue; either 'open' or 'closed'"),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.string()),
"title": z.optional(z.string()),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
"updated_at": z.optional(z.string()),
"url": z.optional(z.string()),
"user": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string())
    }))
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) the comment belongs to."),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssueCommentDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "comment"(){
                return webhooksIssueCommentSchema.describe("The [comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment) itself.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"issue": z.object({
    "active_lock_reason": z.string().nullish(),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.optional(z.array(z.object({
    
    }).nullable())),
"author_association": z.optional(z.string()),
"body": z.string().nullish(),
"closed_at": z.string().nullish(),
"comments": z.optional(z.int()),
"comments_url": z.optional(z.string()),
"created_at": z.optional(z.string()),
"draft": z.optional(z.boolean()),
"events_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"labels_url": z.optional(z.string()),
"locked": z.boolean(),
"milestone": z.object({
    
    }).nullish(),
"node_id": z.optional(z.string()),
"number": z.optional(z.int()),
"performed_via_github_app": z.object({
    
    }).nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.optional(z.object({
    "+1": z.optional(z.int()),
"-1": z.optional(z.int()),
"confused": z.optional(z.int()),
"eyes": z.optional(z.int()),
"heart": z.optional(z.int()),
"hooray": z.optional(z.int()),
"laugh": z.optional(z.int()),
"rocket": z.optional(z.int()),
"total_count": z.optional(z.int()),
"url": z.optional(z.string())
    })),
"repository_url": z.optional(z.string()),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
"state": z.enum(["open", "closed"]).describe("State of the issue; either 'open' or 'closed'"),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.string()),
"title": z.optional(z.string()),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
"updated_at": z.optional(z.string()),
"url": z.optional(z.string()),
"user": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) the comment belongs to."),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssueCommentEditedSchema = z.object({
    "action": z.enum(["edited"]),
get "changes"(){
                return webhooksChangesSchema.describe("The changes to the comment.")
              },
get "comment"(){
                return webhooksIssueCommentSchema.describe("The [comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment) itself.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"issue": z.object({
    "active_lock_reason": z.string().nullish(),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.optional(z.array(z.object({
    
    }).nullable())),
"author_association": z.optional(z.string()),
"body": z.string().nullish(),
"closed_at": z.string().nullish(),
"comments": z.optional(z.int()),
"comments_url": z.optional(z.string()),
"created_at": z.optional(z.string()),
"draft": z.optional(z.boolean()),
"events_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"labels_url": z.optional(z.string()),
"locked": z.boolean(),
"milestone": z.object({
    
    }).nullish(),
"node_id": z.optional(z.string()),
"number": z.optional(z.int()),
"performed_via_github_app": z.object({
    
    }).nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.optional(z.object({
    "+1": z.optional(z.int()),
"-1": z.optional(z.int()),
"confused": z.optional(z.int()),
"eyes": z.optional(z.int()),
"heart": z.optional(z.int()),
"hooray": z.optional(z.int()),
"laugh": z.optional(z.int()),
"rocket": z.optional(z.int()),
"total_count": z.optional(z.int()),
"url": z.optional(z.string())
    })),
"repository_url": z.optional(z.string()),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
"state": z.enum(["open", "closed"]).describe("State of the issue; either 'open' or 'closed'"),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.string()),
"title": z.optional(z.string()),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
"updated_at": z.optional(z.string()),
"url": z.optional(z.string()),
"user": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string())
    }))
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) the comment belongs to."),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssueDependenciesBlockedByAddedSchema = z.object({
    "action": z.enum(["blocked_by_added"]),
"blocked_issue_id": z.number().describe("The ID of the blocked issue."),
get "blocked_issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")
              },
"blocking_issue_id": z.number().describe("The ID of the blocking issue."),
get "blocking_issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")
              },
get "blocking_issue_repo"(){
                return repositorySchema.describe("A repository on GitHub.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssueDependenciesBlockedByRemovedSchema = z.object({
    "action": z.enum(["blocked_by_removed"]),
"blocked_issue_id": z.number().describe("The ID of the blocked issue."),
get "blocked_issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")
              },
"blocking_issue_id": z.number().describe("The ID of the blocking issue."),
get "blocking_issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")
              },
get "blocking_issue_repo"(){
                return repositorySchema.describe("A repository on GitHub.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssueDependenciesBlockingAddedSchema = z.object({
    "action": z.enum(["blocking_added"]),
"blocked_issue_id": z.number().describe("The ID of the blocked issue."),
get "blocked_issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")
              },
get "blocked_issue_repo"(){
                return repositorySchema.describe("A repository on GitHub.")
              },
"blocking_issue_id": z.number().describe("The ID of the blocking issue."),
get "blocking_issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssueDependenciesBlockingRemovedSchema = z.object({
    "action": z.enum(["blocking_removed"]),
"blocked_issue_id": z.number().describe("The ID of the blocked issue."),
get "blocked_issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")
              },
get "blocked_issue_repo"(){
                return repositorySchema.describe("A repository on GitHub.")
              },
"blocking_issue_id": z.number().describe("The ID of the blocking issue."),
get "blocking_issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesAssignedSchema = z.object({
    "action": z.enum(["assigned"]).describe("The action that was performed."),
get "assignee"(){
                return webhooksUserSchema.optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "issue"(){
                return webhooksIssueSchema.describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesClosedSchema = z.object({
    "action": z.enum(["closed"]).describe("The action that was performed."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"issue": z.object({
    "active_lock_reason": z.string().nullish(),
"assignee": z.object({
    
    }).nullish(),
"assignees": z.optional(z.array(z.object({
    
    }).nullable())),
"author_association": z.optional(z.string()),
"body": z.string().nullish(),
"closed_at": z.nullable(z.string()),
"comments": z.optional(z.int()),
"comments_url": z.optional(z.string()),
"created_at": z.optional(z.string()),
"draft": z.optional(z.boolean()),
"events_url": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"labels": z.optional(z.array(z.object({
    
    }).nullable())),
"labels_url": z.optional(z.string()),
"locked": z.optional(z.boolean()),
"milestone": z.object({
    
    }).nullish(),
"node_id": z.optional(z.string()),
"number": z.optional(z.int()),
"performed_via_github_app": z.object({
    
    }).nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.optional(z.object({
    "+1": z.optional(z.int()),
"-1": z.optional(z.int()),
"confused": z.optional(z.int()),
"eyes": z.optional(z.int()),
"heart": z.optional(z.int()),
"hooray": z.optional(z.int()),
"laugh": z.optional(z.int()),
"rocket": z.optional(z.int()),
"total_count": z.optional(z.int()),
"url": z.optional(z.string())
    })),
"repository_url": z.optional(z.string()),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              },
"state": z.enum(["closed", "open"]),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.string()),
"title": z.optional(z.string()),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
"updated_at": z.optional(z.string()),
"url": z.optional(z.string()),
"user": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself."),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"issue": z.object({
    "active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.nullable(z.string().describe("Contents of the issue")),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.int(),
"comments_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"draft": z.optional(z.boolean()),
"events_url": z.url(),
"html_url": z.url(),
"id": z.int(),
"labels": z.optional(z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    }))),
"labels_url": z.string(),
"locked": z.optional(z.boolean()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"performed_via_github_app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run", "reminder"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"repository_url": z.url(),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              },
"state": z.optional(z.enum(["open", "closed"]).describe("State of the issue; either 'open' or 'closed'")),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.url()),
"title": z.string().describe("Title of the issue"),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the issue"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself."),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesDemilestonedSchema = z.object({
    "action": z.enum(["demilestoned"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"issue": z.object({
    "active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url())
    }).nullish(),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.nullable(z.string().describe("Contents of the issue")),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.int(),
"comments_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"draft": z.optional(z.boolean()),
"events_url": z.url(),
"html_url": z.url(),
"id": z.int(),
"labels": z.optional(z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    }).nullable())),
"labels_url": z.string(),
"locked": z.optional(z.boolean()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"performed_via_github_app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write", "admin"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"repository_url": z.url(),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              },
"state": z.optional(z.enum(["open", "closed"]).describe("State of the issue; either 'open' or 'closed'")),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.url()),
"title": z.string().describe("Title of the issue"),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the issue"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself."),
get "milestone"(){
                return webhooksMilestoneSchema.describe("A collection of related issues and pull requests.").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.object({
    "body": z.optional(z.object({
    "from": z.string().describe("The previous version of the body.")
    })),
"title": z.optional(z.object({
    "from": z.string().describe("The previous version of the title.")
    }))
    }).describe("The changes to the issue."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"issue": z.object({
    "active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.nullable(z.string().describe("Contents of the issue")),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.int(),
"comments_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"draft": z.optional(z.boolean()),
"events_url": z.url(),
"html_url": z.url(),
"id": z.int(),
"labels": z.optional(z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    }))),
"labels_url": z.string(),
"locked": z.optional(z.boolean()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"performed_via_github_app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run", "security_and_analysis", "pull_request_review_thread", "reminder"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write", "admin"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"repository_url": z.url(),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              },
"state": z.optional(z.enum(["open", "closed"]).describe("State of the issue; either 'open' or 'closed'")),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.url()),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
"title": z.string().describe("Title of the issue"),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the issue"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself."),
get "label"(){
                return webhooksLabelSchema.optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesLabeledSchema = z.object({
    "action": z.enum(["labeled"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"issue": z.object({
    "active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.nullable(z.string().describe("Contents of the issue")),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.int(),
"comments_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"draft": z.optional(z.boolean()),
"events_url": z.url(),
"html_url": z.url(),
"id": z.int(),
"labels": z.optional(z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    }))),
"labels_url": z.string(),
"locked": z.optional(z.boolean()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"performed_via_github_app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run", "pull_request_review_thread", "reminder"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write", "admin"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"repository_url": z.url(),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              },
"state": z.optional(z.enum(["open", "closed"]).describe("State of the issue; either 'open' or 'closed'")),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.url()),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
"title": z.string().describe("Title of the issue"),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the issue"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself."),
get "label"(){
                return webhooksLabelSchema.optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesLockedSchema = z.object({
    "action": z.enum(["locked"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"issue": z.object({
    "active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.nullable(z.string().describe("Contents of the issue")),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.int(),
"comments_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"draft": z.optional(z.boolean()),
"events_url": z.url(),
"html_url": z.url(),
"id": z.int(),
"labels": z.optional(z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    }).nullable())),
"labels_url": z.string(),
"locked": z.literal(true),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"performed_via_github_app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run", "reminder", "security_and_analysis"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"repository_url": z.url(),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              },
"state": z.optional(z.enum(["open", "closed"]).describe("State of the issue; either 'open' or 'closed'")),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.url()),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
"title": z.string().describe("Title of the issue"),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the issue"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself."),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesMilestonedSchema = z.object({
    "action": z.enum(["milestoned"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"issue": z.object({
    "active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullish(),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.nullable(z.string().describe("Contents of the issue")),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.int(),
"comments_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"draft": z.optional(z.boolean()),
"events_url": z.url(),
"html_url": z.url(),
"id": z.int(),
"labels": z.optional(z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    }).nullable())),
"labels_url": z.string(),
"locked": z.optional(z.boolean()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"performed_via_github_app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run", "reminder"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write", "admin"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"repository_url": z.url(),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              },
"state": z.optional(z.enum(["open", "closed"]).describe("State of the issue; either 'open' or 'closed'")),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.url()),
"title": z.string().describe("Title of the issue"),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the issue"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself."),
get "milestone"(){
                return webhooksMilestoneSchema.describe("A collection of related issues and pull requests.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesOpenedSchema = z.object({
    "action": z.enum(["opened"]),
"changes": z.optional(z.object({
    "old_issue": z.nullable(z.object({
    "active_lock_reason": z.enum(["resolved", "off-topic", "too heated", "spam"]).nullish(),
"assignee": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"assignees": z.optional(z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullable())),
"author_association": z.optional(z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository.")),
"body": z.string().describe("Contents of the issue").nullish(),
"closed_at": z.iso.datetime({ offset: true }).nullish(),
"comments": z.optional(z.int()),
"comments_url": z.optional(z.url()),
"created_at": z.optional(z.iso.datetime({ offset: true })),
"draft": z.optional(z.boolean()),
"events_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"id": z.int(),
"labels": z.optional(z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    }))),
"labels_url": z.optional(z.string()),
"locked": z.optional(z.boolean()),
"milestone": z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.").nullish(),
"node_id": z.optional(z.string()),
"number": z.int(),
"performed_via_github_app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.optional(z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    })),
"repository_url": z.optional(z.url()),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              },
"state": z.optional(z.enum(["open", "closed"]).describe("State of the issue; either 'open' or 'closed'")),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.url()),
"title": z.optional(z.string().describe("Title of the issue")),
"updated_at": z.optional(z.iso.datetime({ offset: true })),
"url": z.optional(z.url().describe("URL for the issue")),
"user": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              }
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.")),
"old_repository": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"custom_properties": z.optional(z.object({
    
    }).catchall(z.unknown()).describe("The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.")),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_discussions": z.optional(z.boolean().describe("Whether the repository has discussions enabled.")),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require commit signoff."))
    }).describe("A git repository")
    })),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"issue": z.object({
    "active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.nullable(z.string().describe("Contents of the issue")),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.int(),
"comments_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"draft": z.optional(z.boolean()),
"events_url": z.url(),
"html_url": z.url(),
"id": z.int(),
"labels": z.optional(z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    }))),
"labels_url": z.string(),
"locked": z.optional(z.boolean()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"performed_via_github_app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run", "security_and_analysis", "pull_request_review_thread", "reminder"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write", "admin"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"repository_url": z.url(),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              },
"state": z.optional(z.enum(["open", "closed"]).describe("State of the issue; either 'open' or 'closed'")),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.url()),
"title": z.string().describe("Title of the issue"),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the issue"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself."),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesPinnedSchema = z.object({
    "action": z.enum(["pinned"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "issue"(){
                return webhooksIssue2Schema.describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesReopenedSchema = z.object({
    "action": z.enum(["reopened"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"issue": z.object({
    "active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullish(),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.nullable(z.string().describe("Contents of the issue")),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.int(),
"comments_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"draft": z.optional(z.boolean()),
"events_url": z.url(),
"html_url": z.url(),
"id": z.int(),
"labels": z.optional(z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    }).nullable())),
"labels_url": z.string(),
"locked": z.optional(z.boolean()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"performed_via_github_app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run", "pull_request_review_thread", "reminder"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write", "admin"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write", "admin"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"repository_url": z.url(),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              },
"state": z.enum(["open", "closed"]).describe("State of the issue; either 'open' or 'closed'"),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.url()),
"title": z.string().describe("Title of the issue"),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the issue"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              }
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself."),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesTransferredSchema = z.object({
    "action": z.enum(["transferred"]),
"changes": z.object({
    "new_issue": z.object({
    "active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.nullable(z.string().describe("Contents of the issue")),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.int(),
"comments_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"draft": z.optional(z.boolean()),
"events_url": z.url(),
"html_url": z.url(),
"id": z.int(),
"labels": z.optional(z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    }))),
"labels_url": z.string(),
"locked": z.optional(z.boolean()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"performed_via_github_app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"repository_url": z.url(),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              },
"state": z.optional(z.enum(["open", "closed"]).describe("State of the issue; either 'open' or 'closed'")),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.url()),
"title": z.string().describe("Title of the issue"),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the issue"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself."),
"new_repository": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"custom_properties": z.optional(z.object({
    
    }).catchall(z.unknown()).describe("The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.")),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository")
    }),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "issue"(){
                return webhooksIssue2Schema.describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesTypedSchema = z.object({
    "action": z.enum(["typed"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "issue"(){
                return webhooksIssueSchema.describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.")
              },
get "type"(){
               return issueTypeSchema.describe("The type of issue.").nullable()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesUnassignedSchema = z.object({
    "action": z.enum(["unassigned"]).describe("The action that was performed."),
get "assignee"(){
                return webhooksUserMannequinSchema.optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "issue"(){
                return webhooksIssueSchema.describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesUnlabeledSchema = z.object({
    "action": z.enum(["unlabeled"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "issue"(){
                return webhooksIssueSchema.describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.")
              },
get "label"(){
                return webhooksLabelSchema.optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesUnlockedSchema = z.object({
    "action": z.enum(["unlocked"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"issue": z.object({
    "active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.nullable(z.string().describe("Contents of the issue")),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.int(),
"comments_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"draft": z.optional(z.boolean()),
"events_url": z.url(),
"html_url": z.url(),
"id": z.int(),
"labels": z.optional(z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    }).nullable())),
"labels_url": z.string(),
"locked": z.literal(false),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"performed_via_github_app": z.object({
    "created_at": z.nullable(z.iso.datetime({ offset: true })),
"description": z.nullable(z.string()),
"events": z.optional(z.array(z.enum(["branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "content_reference", "create", "delete", "deployment", "deployment_review", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "milestone", "organization", "org_block", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "push", "registry_package", "release", "repository", "repository_dispatch", "secret_scanning_alert", "star", "status", "team", "team_add", "watch", "workflow_dispatch", "workflow_run"])).describe("The list of events for the GitHub app")),
"external_url": z.nullable(z.url()),
"html_url": z.url(),
"id": z.nullable(z.int().describe("Unique identifier of the GitHub app")),
"name": z.string().describe("The name of the GitHub app"),
"node_id": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "actions": z.optional(z.enum(["read", "write"])),
"administration": z.optional(z.enum(["read", "write"])),
"checks": z.optional(z.enum(["read", "write"])),
"content_references": z.optional(z.enum(["read", "write"])),
"contents": z.optional(z.enum(["read", "write"])),
"deployments": z.optional(z.enum(["read", "write"])),
"discussions": z.optional(z.enum(["read", "write"])),
"emails": z.optional(z.enum(["read", "write"])),
"environments": z.optional(z.enum(["read", "write"])),
"issues": z.optional(z.enum(["read", "write"])),
"keys": z.optional(z.enum(["read", "write"])),
"members": z.optional(z.enum(["read", "write"])),
"metadata": z.optional(z.enum(["read", "write"])),
"organization_administration": z.optional(z.enum(["read", "write"])),
"organization_hooks": z.optional(z.enum(["read", "write"])),
"organization_packages": z.optional(z.enum(["read", "write"])),
"organization_plan": z.optional(z.enum(["read", "write"])),
"organization_projects": z.optional(z.enum(["read", "write"])),
"organization_secrets": z.optional(z.enum(["read", "write"])),
"organization_self_hosted_runners": z.optional(z.enum(["read", "write"])),
"organization_user_blocking": z.optional(z.enum(["read", "write"])),
"packages": z.optional(z.enum(["read", "write"])),
"pages": z.optional(z.enum(["read", "write"])),
"pull_requests": z.optional(z.enum(["read", "write"])),
"repository_hooks": z.optional(z.enum(["read", "write"])),
"repository_projects": z.optional(z.enum(["read", "write"])),
"secret_scanning_alerts": z.optional(z.enum(["read", "write"])),
"secrets": z.optional(z.enum(["read", "write"])),
"security_events": z.optional(z.enum(["read", "write"])),
"security_scanning_alert": z.optional(z.enum(["read", "write"])),
"single_file": z.optional(z.enum(["read", "write"])),
"statuses": z.optional(z.enum(["read", "write"])),
"team_discussions": z.optional(z.enum(["read", "write"])),
"vulnerability_alerts": z.optional(z.enum(["read", "write"])),
"workflows": z.optional(z.enum(["read", "write"]))
    }).describe("The set of permissions for the GitHub app")),
"slug": z.optional(z.string().describe("The slug name of the GitHub app")),
"updated_at": z.nullable(z.iso.datetime({ offset: true }))
    }).describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullish(),
"pull_request": z.optional(z.object({
    "diff_url": z.optional(z.url()),
"html_url": z.optional(z.url()),
"merged_at": z.iso.datetime({ offset: true }).nullish(),
"patch_url": z.optional(z.url()),
"url": z.optional(z.url())
    })),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"repository_url": z.url(),
get "sub_issues_summary"(){
                return subIssuesSummarySchema.optional()
              },
get "issue_dependencies_summary"(){
                return issueDependenciesSummarySchema.optional()
              },
get "issue_field_values"(){
                return z.array(issueFieldValueSchema.describe("A value assigned to an issue field")).optional()
              },
"state": z.optional(z.enum(["open", "closed"]).describe("State of the issue; either 'open' or 'closed'")),
"state_reason": z.string().nullish(),
"timeline_url": z.optional(z.url()),
"title": z.string().describe("Title of the issue"),
get "type"(){
                return issueTypeSchema.describe("The type of issue.").optional()
              },
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the issue"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself."),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesUnpinnedSchema = z.object({
    "action": z.enum(["unpinned"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "issue"(){
                return webhooksIssue2Schema.describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookIssuesUntypedSchema = z.object({
    "action": z.enum(["untyped"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "issue"(){
                return webhooksIssueSchema.describe("The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.")
              },
get "type"(){
               return issueTypeSchema.describe("The type of issue.").nullable()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookLabelCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "label"(){
                return webhooksLabelSchema
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookLabelDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "label"(){
                return webhooksLabelSchema
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookLabelEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.optional(z.object({
    "color": z.optional(z.object({
    "from": z.string().describe("The previous version of the color if the action was `edited`.")
    })),
"description": z.optional(z.object({
    "from": z.string().describe("The previous version of the description if the action was `edited`.")
    })),
"name": z.optional(z.object({
    "from": z.string().describe("The previous version of the name if the action was `edited`.")
    }))
    }).describe("The changes to the label if the action was `edited`.")),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "label"(){
                return webhooksLabelSchema
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookMarketplacePurchaseCancelledSchema = z.object({
    "action": z.enum(["cancelled"]),
"effective_date": z.string(),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "marketplace_purchase"(){
                return webhooksMarketplacePurchaseSchema
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "previous_marketplace_purchase"(){
                return webhooksPreviousMarketplacePurchaseSchema.optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookMarketplacePurchaseChangedSchema = z.object({
    "action": z.enum(["changed"]),
"effective_date": z.string(),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "marketplace_purchase"(){
                return webhooksMarketplacePurchaseSchema
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"previous_marketplace_purchase": z.optional(z.object({
    "account": z.object({
    "id": z.int(),
"login": z.string(),
"node_id": z.string(),
"organization_billing_email": z.nullable(z.string()),
"type": z.string()
    }),
"billing_cycle": z.string(),
"free_trial_ends_on": z.nullable(z.string()),
"next_billing_date": z.string().nullish(),
"on_free_trial": z.nullable(z.boolean()),
"plan": z.object({
    "bullets": z.array(z.string()),
"description": z.string(),
"has_free_trial": z.boolean(),
"id": z.int(),
"monthly_price_in_cents": z.int(),
"name": z.string(),
"price_model": z.enum(["FREE", "FLAT_RATE", "PER_UNIT"]),
"unit_name": z.nullable(z.string()),
"yearly_price_in_cents": z.int()
    }),
"unit_count": z.int()
    })),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookMarketplacePurchasePendingChangeSchema = z.object({
    "action": z.enum(["pending_change"]),
"effective_date": z.string(),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "marketplace_purchase"(){
                return webhooksMarketplacePurchaseSchema
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"previous_marketplace_purchase": z.optional(z.object({
    "account": z.object({
    "id": z.int(),
"login": z.string(),
"node_id": z.string(),
"organization_billing_email": z.nullable(z.string()),
"type": z.string()
    }),
"billing_cycle": z.string(),
"free_trial_ends_on": z.nullable(z.string()),
"next_billing_date": z.string().nullish(),
"on_free_trial": z.boolean(),
"plan": z.object({
    "bullets": z.array(z.string()),
"description": z.string(),
"has_free_trial": z.boolean(),
"id": z.int(),
"monthly_price_in_cents": z.int(),
"name": z.string(),
"price_model": z.enum(["FREE", "FLAT_RATE", "PER_UNIT"]),
"unit_name": z.nullable(z.string()),
"yearly_price_in_cents": z.int()
    }),
"unit_count": z.int()
    })),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookMarketplacePurchasePendingChangeCancelledSchema = z.object({
    "action": z.enum(["pending_change_cancelled"]),
"effective_date": z.string(),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"marketplace_purchase": z.object({
    "account": z.object({
    "id": z.int(),
"login": z.string(),
"node_id": z.string(),
"organization_billing_email": z.nullable(z.string()),
"type": z.string()
    }),
"billing_cycle": z.string(),
"free_trial_ends_on": z.unknown(),
"next_billing_date": z.nullable(z.string()),
"on_free_trial": z.boolean(),
"plan": z.object({
    "bullets": z.array(z.string()),
"description": z.string(),
"has_free_trial": z.boolean(),
"id": z.int(),
"monthly_price_in_cents": z.int(),
"name": z.string(),
"price_model": z.enum(["FREE", "FLAT_RATE", "PER_UNIT"]),
"unit_name": z.nullable(z.string()),
"yearly_price_in_cents": z.int()
    }),
"unit_count": z.int()
    }),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "previous_marketplace_purchase"(){
                return webhooksPreviousMarketplacePurchaseSchema.optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookMarketplacePurchasePurchasedSchema = z.object({
    "action": z.enum(["purchased"]),
"effective_date": z.string(),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "marketplace_purchase"(){
                return webhooksMarketplacePurchaseSchema
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "previous_marketplace_purchase"(){
                return webhooksPreviousMarketplacePurchaseSchema.optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookMemberAddedSchema = z.object({
    "action": z.enum(["added"]),
"changes": z.optional(z.object({
    "permission": z.optional(z.object({
    "to": z.enum(["write", "admin", "read"])
    }).describe("This field is included for legacy purposes; use the `role_name` field instead. The `maintain`\nrole is mapped to `write` and the `triage` role is mapped to `read`. To determine the role\nassigned to the collaborator, use the `role_name` field instead, which will provide the full\nrole name, including custom roles.")),
"role_name": z.optional(z.object({
    "to": z.string()
    }).describe("The role assigned to the collaborator."))
    })),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "member"(){
               return webhooksUserSchema.nullable()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookMemberEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.object({
    "old_permission": z.optional(z.object({
    "from": z.string().describe("The previous permissions of the collaborator if the action was edited.")
    })),
"permission": z.optional(z.object({
    "from": z.string().nullish(),
"to": z.string().nullish()
    }))
    }).describe("The changes to the collaborator permissions"),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "member"(){
               return webhooksUserSchema.nullable()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookMemberRemovedSchema = z.object({
    "action": z.enum(["removed"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "member"(){
               return webhooksUserSchema.nullable()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookMembershipAddedSchema = z.object({
    "action": z.enum(["added"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "member"(){
               return webhooksUserSchema.nullable()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
"scope": z.enum(["team"]).describe("The scope of the membership. Currently, can only be `team`."),
"sender": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
get "team"(){
                return webhooksTeamSchema.describe("Groups of organization members that gives permissions on specified repositories.")
              }
    })

export const webhookMembershipRemovedSchema = z.object({
    "action": z.enum(["removed"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "member"(){
               return webhooksUserSchema.nullable()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
"scope": z.enum(["team", "organization"]).describe("The scope of the membership. Currently, can only be `team`."),
"sender": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
get "team"(){
                return webhooksTeamSchema.describe("Groups of organization members that gives permissions on specified repositories.")
              }
    })

export const webhookMergeGroupChecksRequestedSchema = z.object({
    "action": z.enum(["checks_requested"]),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "merge_group"(){
                return mergeGroupSchema.describe("A group of pull requests that the merge queue has grouped together to be merged.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookMergeGroupDestroyedSchema = z.object({
    "action": z.enum(["destroyed"]),
"reason": z.optional(z.enum(["merged", "invalidated", "dequeued"]).describe("Explains why the merge group is being destroyed. The group could have been merged, removed from the queue (dequeued), or invalidated by an earlier queue entry being dequeued (invalidated).")),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "merge_group"(){
                return mergeGroupSchema.describe("A group of pull requests that the merge queue has grouped together to be merged.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookMetaDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
"hook": z.object({
    "active": z.boolean(),
"config": z.object({
    "content_type": z.enum(["json", "form"]),
"insecure_ssl": z.string(),
"secret": z.optional(z.string()),
"url": z.url()
    }),
"created_at": z.string(),
"events": z.array(z.enum(["*", "branch_protection_rule", "check_run", "check_suite", "code_scanning_alert", "commit_comment", "create", "delete", "deployment", "deployment_status", "deploy_key", "discussion", "discussion_comment", "fork", "gollum", "issues", "issue_comment", "label", "member", "membership", "meta", "milestone", "organization", "org_block", "package", "page_build", "project", "project_card", "project_column", "public", "pull_request", "pull_request_review", "pull_request_review_comment", "pull_request_review_thread", "push", "registry_package", "release", "repository", "repository_import", "repository_vulnerability_alert", "secret_scanning_alert", "secret_scanning_alert_location", "security_and_analysis", "star", "status", "team", "team_add", "watch", "workflow_job", "workflow_run", "repository_dispatch", "projects_v2_item"])),
"id": z.int(),
"name": z.string(),
"type": z.string(),
"updated_at": z.string()
    }).describe("The deleted webhook. This will contain different keys based on the type of webhook it is: repository, organization, business, app, or GitHub Marketplace."),
"hook_id": z.int().describe("The id of the modified webhook."),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return nullableRepositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookMilestoneClosedSchema = z.object({
    "action": z.enum(["closed"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "milestone"(){
                return webhooksMilestoneSchema.describe("A collection of related issues and pull requests.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookMilestoneCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "milestone"(){
                return webhooksMilestone3Schema.describe("A collection of related issues and pull requests.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookMilestoneDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "milestone"(){
                return webhooksMilestoneSchema.describe("A collection of related issues and pull requests.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookMilestoneEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.object({
    "description": z.optional(z.object({
    "from": z.string().describe("The previous version of the description if the action was `edited`.")
    })),
"due_on": z.optional(z.object({
    "from": z.string().describe("The previous version of the due date if the action was `edited`.")
    })),
"title": z.optional(z.object({
    "from": z.string().describe("The previous version of the title if the action was `edited`.")
    }))
    }).describe("The changes to the milestone if the action was `edited`."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "milestone"(){
                return webhooksMilestoneSchema.describe("A collection of related issues and pull requests.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookMilestoneOpenedSchema = z.object({
    "action": z.enum(["opened"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "milestone"(){
                return webhooksMilestone3Schema.describe("A collection of related issues and pull requests.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookOrgBlockBlockedSchema = z.object({
    "action": z.enum(["blocked"]),
get "blocked_user"(){
               return webhooksUserSchema.nullable()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookOrgBlockUnblockedSchema = z.object({
    "action": z.enum(["unblocked"]),
get "blocked_user"(){
               return webhooksUserSchema.nullable()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookOrganizationDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "membership"(){
                return webhooksMembershipSchema.describe("The membership between the user and the organization. Not present when the action is `member_invited`.").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookOrganizationMemberAddedSchema = z.object({
    "action": z.enum(["member_added"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "membership"(){
                return webhooksMembershipSchema.describe("The membership between the user and the organization. Not present when the action is `member_invited`.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookOrganizationMemberInvitedSchema = z.object({
    "action": z.enum(["member_invited"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"invitation": z.object({
    "created_at": z.iso.datetime({ offset: true }),
"email": z.nullable(z.string()),
"failed_at": z.nullable(z.iso.datetime({ offset: true })),
"failed_reason": z.nullable(z.string()),
"id": z.number(),
"invitation_teams_url": z.url(),
"inviter": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"login": z.nullable(z.string()),
"node_id": z.string(),
"role": z.string(),
"team_count": z.number(),
"invitation_source": z.optional(z.string())
    }).describe("The invitation for the user or email if the action is `member_invited`."),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "user"(){
                return webhooksUserSchema.optional()
              }
    })

export const webhookOrganizationMemberRemovedSchema = z.object({
    "action": z.enum(["member_removed"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "membership"(){
                return webhooksMembershipSchema.describe("The membership between the user and the organization. Not present when the action is `member_invited`.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookOrganizationRenamedSchema = z.object({
    "action": z.enum(["renamed"]),
"changes": z.optional(z.object({
    "login": z.optional(z.object({
    "from": z.optional(z.string())
    }))
    })),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "membership"(){
                return webhooksMembershipSchema.describe("The membership between the user and the organization. Not present when the action is `member_invited`.").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRubygemsMetadataSchema = z.object({
    "name": z.optional(z.string()),
"description": z.optional(z.string()),
"readme": z.optional(z.string()),
"homepage": z.optional(z.string()),
"version_info": z.optional(z.object({
    "version": z.optional(z.string())
    })),
"platform": z.optional(z.string()),
"metadata": z.optional(z.object({
    
    }).catchall(z.string())),
"repo": z.optional(z.string()),
"dependencies": z.optional(z.array(z.object({
    
    }).catchall(z.string()))),
"commit_oid": z.optional(z.string())
    })

export const webhookPackagePublishedSchema = z.object({
    "action": z.enum(["published"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"package": z.object({
    "created_at": z.nullable(z.string()),
"description": z.nullable(z.string()),
"ecosystem": z.string(),
"html_url": z.url(),
"id": z.int(),
"name": z.string(),
"namespace": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"package_type": z.string(),
"package_version": z.nullable(z.object({
    "author": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"body": z.optional(z.union([z.string(), z.object({
    
    })])),
"body_html": z.optional(z.string()),
"container_metadata": z.object({
    "labels": z.object({
    
    }).nullish(),
"manifest": z.object({
    
    }).nullish(),
"tag": z.optional(z.object({
    "digest": z.optional(z.string()),
"name": z.optional(z.string())
    }))
    }).nullish(),
"created_at": z.optional(z.string()),
"description": z.string(),
"docker_metadata": z.optional(z.array(z.object({
    "tags": z.optional(z.array(z.string()))
    }))),
"draft": z.optional(z.boolean()),
"html_url": z.url(),
"id": z.int(),
"installation_command": z.string(),
"manifest": z.optional(z.string()),
"metadata": z.array(z.object({
    
    }).catchall(z.unknown())),
"name": z.string(),
"npm_metadata": z.object({
    "name": z.optional(z.string()),
"version": z.optional(z.string()),
"npm_user": z.optional(z.string()),
"author": z.object({
    
    }).nullish(),
"bugs": z.object({
    
    }).nullish(),
"dependencies": z.optional(z.object({
    
    })),
"dev_dependencies": z.optional(z.object({
    
    })),
"peer_dependencies": z.optional(z.object({
    
    })),
"optional_dependencies": z.optional(z.object({
    
    })),
"description": z.optional(z.string()),
"dist": z.object({
    
    }).nullish(),
"git_head": z.optional(z.string()),
"homepage": z.optional(z.string()),
"license": z.optional(z.string()),
"main": z.optional(z.string()),
"repository": z.object({
    
    }).nullish(),
"scripts": z.optional(z.object({
    
    })),
"id": z.optional(z.string()),
"node_version": z.optional(z.string()),
"npm_version": z.optional(z.string()),
"has_shrinkwrap": z.optional(z.boolean()),
"maintainers": z.optional(z.array(z.object({
    
    }))),
"contributors": z.optional(z.array(z.object({
    
    }))),
"engines": z.optional(z.object({
    
    })),
"keywords": z.optional(z.array(z.string())),
"files": z.optional(z.array(z.string())),
"bin": z.optional(z.object({
    
    })),
"man": z.optional(z.object({
    
    })),
"directories": z.object({
    
    }).nullish(),
"os": z.optional(z.array(z.string())),
"cpu": z.optional(z.array(z.string())),
"readme": z.optional(z.string()),
"installation_command": z.optional(z.string()),
"release_id": z.optional(z.int()),
"commit_oid": z.optional(z.string()),
"published_via_actions": z.optional(z.boolean()),
"deleted_by_id": z.optional(z.int())
    }).nullish(),
"nuget_metadata": z.array(z.object({
    "id": z.optional(z.union([z.int(), z.string()])),
"name": z.optional(z.string()),
"value": z.optional(z.union([z.boolean(), z.int(), z.string(), z.object({
    "url": z.optional(z.string()),
"branch": z.optional(z.string()),
"commit": z.optional(z.string()),
"type": z.optional(z.string())
    })]))
    })).nullish(),
"package_files": z.array(z.object({
    "content_type": z.string(),
"created_at": z.string(),
"download_url": z.url(),
"id": z.int(),
"md5": z.nullable(z.string()),
"name": z.string(),
"sha1": z.nullable(z.string()),
"sha256": z.nullable(z.string()),
"size": z.int(),
"state": z.nullable(z.string()),
"updated_at": z.string()
    })),
"package_url": z.optional(z.string()),
"prerelease": z.optional(z.boolean()),
"release": z.optional(z.object({
    "author": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"created_at": z.string(),
"draft": z.boolean(),
"html_url": z.url(),
"id": z.int(),
"name": z.nullable(z.string()),
"prerelease": z.boolean(),
"published_at": z.string(),
"tag_name": z.string(),
"target_commitish": z.string(),
"url": z.url()
    })),
get "rubygems_metadata"(){
                return z.array(webhookRubygemsMetadataSchema).optional()
              },
"source_url": z.optional(z.string()),
"summary": z.string(),
"tag_name": z.optional(z.string()),
"target_commitish": z.optional(z.string()),
"target_oid": z.optional(z.string()),
"updated_at": z.optional(z.string()),
"version": z.string()
    })),
"registry": z.nullable(z.object({
    "about_url": z.url(),
"name": z.string(),
"type": z.string(),
"url": z.url(),
"vendor": z.string()
    })),
"updated_at": z.nullable(z.string())
    }).describe("Information about the package."),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPackageUpdatedSchema = z.object({
    "action": z.enum(["updated"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"package": z.object({
    "created_at": z.string(),
"description": z.nullable(z.string()),
"ecosystem": z.string(),
"html_url": z.url(),
"id": z.int(),
"name": z.string(),
"namespace": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"package_type": z.string(),
"package_version": z.object({
    "author": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"body": z.string(),
"body_html": z.string(),
"created_at": z.string(),
"description": z.string(),
"docker_metadata": z.optional(z.array(z.object({
    "tags": z.optional(z.array(z.string()))
    }))),
"draft": z.optional(z.boolean()),
"html_url": z.url(),
"id": z.int(),
"installation_command": z.string(),
"manifest": z.optional(z.string()),
"metadata": z.array(z.object({
    
    }).catchall(z.unknown())),
"name": z.string(),
"package_files": z.array(z.object({
    "content_type": z.string(),
"created_at": z.string(),
"download_url": z.url(),
"id": z.int(),
"md5": z.nullable(z.string()),
"name": z.string(),
"sha1": z.nullable(z.string()),
"sha256": z.string(),
"size": z.int(),
"state": z.string(),
"updated_at": z.string()
    })),
"package_url": z.optional(z.string()),
"prerelease": z.optional(z.boolean()),
"release": z.optional(z.object({
    "author": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"created_at": z.string(),
"draft": z.boolean(),
"html_url": z.url(),
"id": z.int(),
"name": z.string(),
"prerelease": z.boolean(),
"published_at": z.string(),
"tag_name": z.string(),
"target_commitish": z.string(),
"url": z.url()
    })),
get "rubygems_metadata"(){
                return z.array(webhookRubygemsMetadataSchema).optional()
              },
"source_url": z.optional(z.url()),
"summary": z.string(),
"tag_name": z.optional(z.string()),
"target_commitish": z.string(),
"target_oid": z.string(),
"updated_at": z.string(),
"version": z.string()
    }),
"registry": z.nullable(z.object({
    "about_url": z.url(),
"name": z.string(),
"type": z.string(),
"url": z.url(),
"vendor": z.string()
    })),
"updated_at": z.string()
    }).describe("Information about the package."),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPageBuildSchema = z.object({
    "build": z.object({
    "commit": z.nullable(z.string()),
"created_at": z.string(),
"duration": z.int(),
"error": z.object({
    "message": z.nullable(z.string())
    }),
"pusher": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"status": z.string(),
"updated_at": z.string(),
"url": z.url()
    }).describe("The [List GitHub Pages builds](https://docs.github.com/rest/pages/pages#list-github-pages-builds) itself."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
"id": z.int(),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPersonalAccessTokenRequestApprovedSchema = z.object({
    "action": z.enum(["approved"]),
get "personal_access_token_request"(){
                return personalAccessTokenRequestSchema.describe("Details of a Personal Access Token Request.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"")
              }
    })

export const webhookPersonalAccessTokenRequestCancelledSchema = z.object({
    "action": z.enum(["cancelled"]),
get "personal_access_token_request"(){
                return personalAccessTokenRequestSchema.describe("Details of a Personal Access Token Request.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"")
              }
    })

export const webhookPersonalAccessTokenRequestCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "personal_access_token_request"(){
                return personalAccessTokenRequestSchema.describe("Details of a Personal Access Token Request.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              }
    })

export const webhookPersonalAccessTokenRequestDeniedSchema = z.object({
    "action": z.enum(["denied"]),
get "personal_access_token_request"(){
                return personalAccessTokenRequestSchema.describe("Details of a Personal Access Token Request.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"")
              }
    })

export const webhookPingSchema = z.object({
    "hook": z.optional(z.object({
    "active": z.boolean().describe("Determines whether the hook is actually triggered for the events it subscribes to."),
"app_id": z.optional(z.int().describe("Only included for GitHub Apps. When you register a new GitHub App, GitHub sends a ping event to the webhook URL you specified during registration. The GitHub App ID sent in this field is required for authenticating an app.")),
"config": z.object({
    get "content_type"(){
                return webhookConfigContentTypeSchema.describe("The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.").optional()
              },
get "insecure_ssl"(){
                return webhookConfigInsecureSslSchema.optional()
              },
get "secret"(){
                return webhookConfigSecretSchema.describe("If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).").optional()
              },
get "url"(){
                return webhookConfigUrlSchema.describe("The URL to which the payloads will be delivered.").optional()
              }
    }),
"created_at": z.iso.datetime({ offset: true }),
"deliveries_url": z.optional(z.url()),
"events": z.array(z.string()).describe("Determines what events the hook is triggered for. Default: ['push']."),
"id": z.int().describe("Unique identifier of the webhook."),
get "last_response"(){
                return hookResponseSchema.optional()
              },
"name": z.enum(["web"]).describe("The type of webhook. The only valid value is 'web'."),
"ping_url": z.optional(z.url()),
"test_url": z.optional(z.url()),
"type": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.optional(z.url())
    }).describe("The webhook that is being pinged")),
"hook_id": z.optional(z.int().describe("The ID of the webhook that triggered the ping.")),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
"zen": z.optional(z.string().describe("Random string of GitHub zen."))
    })

/**
 * @description The webhooks ping payload encoded with URL encoding.
 */
export const webhookPingFormEncodedSchema = z.object({
    "payload": z.string().describe("A URL-encoded string of the ping JSON payload. The decoded payload is a JSON object.")
    }).describe("The webhooks ping payload encoded with URL encoding.")

export const webhookProjectCardConvertedSchema = z.object({
    "action": z.enum(["converted"]),
"changes": z.object({
    "note": z.object({
    "from": z.string()
    })
    }),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "project_card"(){
                return webhooksProjectCardSchema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectCardCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "project_card"(){
                return webhooksProjectCardSchema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectCardDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"project_card": z.object({
    "after_id": z.int().nullish(),
"archived": z.boolean().describe("Whether or not the card is archived"),
"column_id": z.nullable(z.int()),
"column_url": z.url(),
"content_url": z.optional(z.url()),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"id": z.int().describe("The project card's ID"),
"node_id": z.string(),
"note": z.nullable(z.string()),
"project_url": z.url(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }),
get "repository"(){
                return nullableRepositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectCardEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.object({
    "note": z.object({
    "from": z.nullable(z.string())
    })
    }),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "project_card"(){
                return webhooksProjectCardSchema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectCardMovedSchema = z.object({
    "action": z.enum(["moved"]),
"changes": z.optional(z.object({
    "column_id": z.object({
    "from": z.int()
    })
    })),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"project_card": z.object({
    "after_id": z.nullable(z.number()),
"archived": z.optional(z.boolean()),
"column_id": z.optional(z.int()),
"column_url": z.optional(z.string()),
"content_url": z.optional(z.url()),
"created_at": z.optional(z.string()),
"creator": z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string())
    }).nullish(),
"id": z.optional(z.int()),
"node_id": z.optional(z.string()),
"note": z.string().nullish(),
"project_url": z.optional(z.string()),
"updated_at": z.optional(z.string()),
"url": z.optional(z.string())
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectClosedSchema = z.object({
    "action": z.enum(["closed"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "project"(){
                return webhooksProjectSchema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectColumnCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "project_column"(){
                return webhooksProjectColumnSchema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookProjectColumnDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "project_column"(){
                return webhooksProjectColumnSchema
              },
get "repository"(){
                return nullableRepositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookProjectColumnEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.object({
    "name": z.optional(z.object({
    "from": z.string()
    }))
    }),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "project_column"(){
                return webhooksProjectColumnSchema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookProjectColumnMovedSchema = z.object({
    "action": z.enum(["moved"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "project_column"(){
                return webhooksProjectColumnSchema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "project"(){
                return webhooksProjectSchema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "project"(){
                return webhooksProjectSchema
              },
get "repository"(){
                return nullableRepositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookProjectEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.optional(z.object({
    "body": z.optional(z.object({
    "from": z.string().describe("The previous version of the body if the action was `edited`.")
    })),
"name": z.optional(z.object({
    "from": z.string().describe("The changes to the project if the action was `edited`.")
    }))
    }).describe("The changes to the project if the action was `edited`.")),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "project"(){
                return webhooksProjectSchema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookProjectReopenedSchema = z.object({
    "action": z.enum(["reopened"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "project"(){
                return webhooksProjectSchema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectsV2ProjectClosedSchema = z.object({
    "action": z.enum(["closed"]),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "projects_v2"(){
                return projectsV2Schema.describe("A projects v2 project")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

/**
 * @description A project was created
 */
export const webhookProjectsV2ProjectCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "projects_v2"(){
                return projectsV2Schema.describe("A projects v2 project")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    }).describe("A project was created")

export const webhookProjectsV2ProjectDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "projects_v2"(){
                return projectsV2Schema.describe("A projects v2 project")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectsV2ProjectEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.object({
    "description": z.optional(z.object({
    "from": z.string().nullish(),
"to": z.string().nullish()
    })),
"public": z.optional(z.object({
    "from": z.optional(z.boolean()),
"to": z.optional(z.boolean())
    })),
"short_description": z.optional(z.object({
    "from": z.string().nullish(),
"to": z.string().nullish()
    })),
"title": z.optional(z.object({
    "from": z.optional(z.string()),
"to": z.optional(z.string())
    }))
    }),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "projects_v2"(){
                return projectsV2Schema.describe("A projects v2 project")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectsV2ItemArchivedSchema = z.object({
    "action": z.enum(["archived"]),
get "changes"(){
                return webhooksProjectChangesSchema
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "projects_v2_item"(){
                return projectsV2ItemSchema.describe("An item belonging to a project")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectsV2ItemConvertedSchema = z.object({
    "action": z.enum(["converted"]),
"changes": z.object({
    "content_type": z.optional(z.object({
    "from": z.string().nullish(),
"to": z.optional(z.string())
    }))
    }),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "projects_v2_item"(){
                return projectsV2ItemSchema.describe("An item belonging to a project")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectsV2ItemCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "projects_v2_item"(){
                return projectsV2ItemSchema.describe("An item belonging to a project")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectsV2ItemDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "projects_v2_item"(){
                return projectsV2ItemSchema.describe("An item belonging to a project")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectsV2ItemEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.optional(z.union([z.object({
    "field_value": z.object({
    "field_node_id": z.optional(z.string()),
"field_type": z.optional(z.string()),
"field_name": z.optional(z.string()),
"project_number": z.optional(z.int()),
get "from"(){
                return z.union([z.int(), projectsV2SingleSelectOptionSchema, projectsV2IterationSettingSchema, z.string()]).nullish()
              },
get "to"(){
                return z.union([z.int(), projectsV2SingleSelectOptionSchema, projectsV2IterationSettingSchema, z.string()]).nullish()
              }
    })
    }), z.object({
    "body": z.object({
    "from": z.string().nullish(),
"to": z.string().nullish()
    })
    })]).describe("The changes made to the item may involve modifications in the item's fields and draft issue body.\nIt includes altered values for text, number, date, single select, and iteration fields, along with the GraphQL node ID of the changed field.")),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "projects_v2_item"(){
                return projectsV2ItemSchema.describe("An item belonging to a project")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectsV2ItemReorderedSchema = z.object({
    "action": z.enum(["reordered"]),
"changes": z.object({
    "previous_projects_v2_item_node_id": z.optional(z.object({
    "from": z.string().nullish(),
"to": z.string().nullish()
    }))
    }),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "projects_v2_item"(){
                return projectsV2ItemSchema.describe("An item belonging to a project")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectsV2ItemRestoredSchema = z.object({
    "action": z.enum(["restored"]),
get "changes"(){
                return webhooksProjectChangesSchema
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "projects_v2_item"(){
                return projectsV2ItemSchema.describe("An item belonging to a project")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectsV2ProjectReopenedSchema = z.object({
    "action": z.enum(["reopened"]),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "projects_v2"(){
                return projectsV2Schema.describe("A projects v2 project")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectsV2StatusUpdateCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "projects_v2_status_update"(){
                return projectsV2StatusUpdateSchema.describe("An status update belonging to a project")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectsV2StatusUpdateDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "projects_v2_status_update"(){
                return projectsV2StatusUpdateSchema.describe("An status update belonging to a project")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookProjectsV2StatusUpdateEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.optional(z.object({
    "body": z.optional(z.object({
    "from": z.string().nullish(),
"to": z.string().nullish()
    })),
"status": z.optional(z.object({
    "from": z.enum(["INACTIVE", "ON_TRACK", "AT_RISK", "OFF_TRACK", "COMPLETE"]).nullish(),
"to": z.enum(["INACTIVE", "ON_TRACK", "AT_RISK", "OFF_TRACK", "COMPLETE"]).nullish()
    })),
"start_date": z.optional(z.object({
    "from": z.iso.date().nullish(),
"to": z.iso.date().nullish()
    })),
"target_date": z.optional(z.object({
    "from": z.iso.date().nullish(),
"to": z.iso.date().nullish()
    }))
    })),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
get "projects_v2_status_update"(){
                return projectsV2StatusUpdateSchema.describe("An status update belonging to a project")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPublicSchema = z.object({
    get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestAssignedSchema = z.object({
    "action": z.enum(["assigned"]),
get "assignee"(){
               return webhooksUserSchema.nullable()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "number"(){
                return webhooksNumberSchema.describe("The pull request number.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"additions": z.optional(z.int()),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"changed_files": z.optional(z.int()),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.optional(z.int()),
"comments_url": z.url(),
"commits": z.optional(z.int()),
"commits_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"deletions": z.optional(z.int()),
"diff_url": z.url(),
"draft": z.boolean().describe("Indicates whether or not the pull request is a draft."),
"head": z.object({
    "label": z.nullable(z.string()),
"ref": z.string(),
"repo": z.nullable(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository")),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether maintainers can modify the pull request.")),
"merge_commit_sha": z.nullable(z.string()),
"mergeable": z.boolean().nullish(),
"mergeable_state": z.optional(z.string()),
"merged": z.boolean().nullish(),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"patch_url": z.url(),
"rebaseable": z.boolean().nullish(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments": z.optional(z.int()),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"statuses_url": z.url(),
"title": z.string().describe("The title of the pull request."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestAutoMergeDisabledSchema = z.object({
    "action": z.enum(["auto_merge_disabled"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"number": z.int(),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"additions": z.optional(z.int()),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"changed_files": z.optional(z.int()),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.optional(z.int()),
"comments_url": z.url(),
"commits": z.optional(z.int()),
"commits_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"deletions": z.optional(z.int()),
"diff_url": z.url(),
"draft": z.boolean().describe("Indicates whether or not the pull request is a draft."),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether maintainers can modify the pull request.")),
"merge_commit_sha": z.nullable(z.string()),
"mergeable": z.boolean().nullish(),
"mergeable_state": z.optional(z.string()),
"merged": z.boolean().nullish(),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"patch_url": z.url(),
"rebaseable": z.boolean().nullish(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments": z.optional(z.int()),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"statuses_url": z.url(),
"title": z.string().describe("The title of the pull request."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"reason": z.string(),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestAutoMergeEnabledSchema = z.object({
    "action": z.enum(["auto_merge_enabled"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"number": z.int(),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"additions": z.optional(z.int()),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"changed_files": z.optional(z.int()),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.optional(z.int()),
"comments_url": z.url(),
"commits": z.optional(z.int()),
"commits_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"deletions": z.optional(z.int()),
"diff_url": z.url(),
"draft": z.boolean().describe("Indicates whether or not the pull request is a draft."),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether maintainers can modify the pull request.")),
"merge_commit_sha": z.nullable(z.string()),
"mergeable": z.boolean().nullish(),
"mergeable_state": z.optional(z.string()),
"merged": z.boolean().nullish(),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"patch_url": z.url(),
"rebaseable": z.boolean().nullish(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments": z.optional(z.int()),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"statuses_url": z.url(),
"title": z.string().describe("The title of the pull request."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"reason": z.optional(z.string()),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestClosedSchema = z.object({
    "action": z.enum(["closed"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "number"(){
                return webhooksNumberSchema.describe("The pull request number.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "pull_request"(){
                return pullRequestWebhookSchema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestConvertedToDraftSchema = z.object({
    "action": z.enum(["converted_to_draft"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "number"(){
                return webhooksNumberSchema.describe("The pull request number.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "pull_request"(){
                return pullRequestWebhookSchema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestDemilestonedSchema = z.object({
    "action": z.enum(["demilestoned"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "milestone"(){
                return milestoneSchema.describe("A collection of related issues and pull requests.").optional()
              },
get "number"(){
                return webhooksNumberSchema.describe("The pull request number.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "pull_request"(){
                return webhooksPullRequest5Schema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookPullRequestDequeuedSchema = z.object({
    "action": z.enum(["dequeued"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"number": z.int(),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"additions": z.optional(z.int()),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"changed_files": z.optional(z.int()),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.optional(z.int()),
"comments_url": z.url(),
"commits": z.optional(z.int()),
"commits_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"deletions": z.optional(z.int()),
"diff_url": z.url(),
"draft": z.boolean().describe("Indicates whether or not the pull request is a draft."),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether maintainers can modify the pull request.")),
"merge_commit_sha": z.nullable(z.string()),
"mergeable": z.boolean().nullish(),
"mergeable_state": z.optional(z.string()),
"merged": z.boolean().nullish(),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"patch_url": z.url(),
"rebaseable": z.boolean().nullish(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments": z.optional(z.int()),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"statuses_url": z.url(),
"title": z.string().describe("The title of the pull request."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"reason": z.enum(["UNKNOWN_REMOVAL_REASON", "MANUAL", "MERGE", "MERGE_CONFLICT", "CI_FAILURE", "CI_TIMEOUT", "ALREADY_MERGED", "QUEUE_CLEARED", "ROLL_BACK", "BRANCH_PROTECTIONS", "GIT_TREE_INVALID", "INVALID_MERGE_COMMIT"]),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.object({
    "base": z.optional(z.object({
    "ref": z.object({
    "from": z.string()
    }),
"sha": z.object({
    "from": z.string()
    })
    })),
"body": z.optional(z.object({
    "from": z.string().describe("The previous version of the body if the action was `edited`.")
    })),
"title": z.optional(z.object({
    "from": z.string().describe("The previous version of the title if the action was `edited`.")
    }))
    }).describe("The changes to the comment if the action was `edited`."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "number"(){
                return webhooksNumberSchema.describe("The pull request number.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "pull_request"(){
                return pullRequestWebhookSchema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookPullRequestEnqueuedSchema = z.object({
    "action": z.enum(["enqueued"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"number": z.int(),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"additions": z.optional(z.int()),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"changed_files": z.optional(z.int()),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.optional(z.int()),
"comments_url": z.url(),
"commits": z.optional(z.int()),
"commits_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"deletions": z.optional(z.int()),
"diff_url": z.url(),
"draft": z.boolean().describe("Indicates whether or not the pull request is a draft."),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether maintainers can modify the pull request.")),
"merge_commit_sha": z.nullable(z.string()),
"mergeable": z.boolean().nullish(),
"mergeable_state": z.optional(z.string()),
"merged": z.boolean().nullish(),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"patch_url": z.url(),
"rebaseable": z.boolean().nullish(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments": z.optional(z.int()),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"statuses_url": z.url(),
"title": z.string().describe("The title of the pull request."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestLabeledSchema = z.object({
    "action": z.enum(["labeled"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "label"(){
                return webhooksLabelSchema.optional()
              },
get "number"(){
                return webhooksNumberSchema.describe("The pull request number.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"additions": z.optional(z.int()),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"changed_files": z.optional(z.int()),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.optional(z.int()),
"comments_url": z.url(),
"commits": z.optional(z.int()),
"commits_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"deletions": z.optional(z.int()),
"diff_url": z.url(),
"draft": z.boolean().describe("Indicates whether or not the pull request is a draft."),
"head": z.object({
    "label": z.nullable(z.string()),
"ref": z.string(),
"repo": z.nullable(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository")),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether maintainers can modify the pull request.")),
"merge_commit_sha": z.nullable(z.string()),
"mergeable": z.boolean().nullish(),
"mergeable_state": z.optional(z.string()),
"merged": z.boolean().nullish(),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"patch_url": z.url(),
"rebaseable": z.boolean().nullish(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments": z.optional(z.int()),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"statuses_url": z.url(),
"title": z.string().describe("The title of the pull request."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestLockedSchema = z.object({
    "action": z.enum(["locked"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "number"(){
                return webhooksNumberSchema.describe("The pull request number.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"additions": z.optional(z.int()),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"changed_files": z.optional(z.int()),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.optional(z.int()),
"comments_url": z.url(),
"commits": z.optional(z.int()),
"commits_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"deletions": z.optional(z.int()),
"diff_url": z.url(),
"draft": z.boolean().describe("Indicates whether or not the pull request is a draft."),
"head": z.object({
    "label": z.nullable(z.string()),
"ref": z.string(),
"repo": z.nullable(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository")),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether maintainers can modify the pull request.")),
"merge_commit_sha": z.nullable(z.string()),
"mergeable": z.boolean().nullish(),
"mergeable_state": z.optional(z.string()),
"merged": z.boolean().nullish(),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"patch_url": z.url(),
"rebaseable": z.boolean().nullish(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments": z.optional(z.int()),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"statuses_url": z.url(),
"title": z.string().describe("The title of the pull request."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestMilestonedSchema = z.object({
    "action": z.enum(["milestoned"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "milestone"(){
                return milestoneSchema.describe("A collection of related issues and pull requests.").optional()
              },
get "number"(){
                return webhooksNumberSchema.describe("The pull request number.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "pull_request"(){
                return webhooksPullRequest5Schema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookPullRequestOpenedSchema = z.object({
    "action": z.enum(["opened"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "number"(){
                return webhooksNumberSchema.describe("The pull request number.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "pull_request"(){
                return pullRequestWebhookSchema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestReadyForReviewSchema = z.object({
    "action": z.enum(["ready_for_review"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "number"(){
                return webhooksNumberSchema.describe("The pull request number.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "pull_request"(){
                return pullRequestWebhookSchema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestReopenedSchema = z.object({
    "action": z.enum(["reopened"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "number"(){
                return webhooksNumberSchema.describe("The pull request number.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "pull_request"(){
                return pullRequestWebhookSchema
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestReviewCommentCreatedSchema = z.object({
    "action": z.enum(["created"]),
"comment": z.object({
    "_links": z.object({
    "html": z.object({
    "href": z.string()
    }),
"pull_request": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    })
    }),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.string().describe("The text of the comment."),
"commit_id": z.string().describe("The SHA of the commit to which the comment applies."),
"created_at": z.iso.datetime({ offset: true }),
"diff_hunk": z.string().describe("The diff of the line that the comment refers to."),
"html_url": z.url().describe("HTML URL for the pull request review comment."),
"id": z.int().describe("The ID of the pull request review comment."),
"in_reply_to_id": z.optional(z.int().describe("The comment ID to reply to.")),
"line": z.nullable(z.int().describe("The line of the blob to which the comment applies. The last line of the range for a multi-line comment")),
"node_id": z.string().describe("The node ID of the pull request review comment."),
"original_commit_id": z.string().describe("The SHA of the original commit to which the comment applies."),
"original_line": z.nullable(z.int().describe("The line of the blob to which the comment applies. The last line of the range for a multi-line comment")),
"original_position": z.int().describe("The index of the original line in the diff to which the comment applies."),
"original_start_line": z.nullable(z.int().describe("The first line of the range for a multi-line comment.")),
"path": z.string().describe("The relative path of the file to which the comment applies."),
"position": z.nullable(z.int().describe("The line index in the diff to which the comment applies.")),
"pull_request_review_id": z.nullable(z.int().describe("The ID of the pull request review to which the comment belongs.")),
"pull_request_url": z.url().describe("URL for the pull request that the review comment belongs to."),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"side": z.enum(["LEFT", "RIGHT"]).describe("The side of the first line of the range for a multi-line comment."),
"start_line": z.nullable(z.int().describe("The first line of the range for a multi-line comment.")),
"start_side": z.nullable(z.enum(["LEFT", "RIGHT"]).default("RIGHT").describe("The side of the first line of the range for a multi-line comment.")),
"subject_type": z.optional(z.enum(["line", "file"]).describe("The level at which the comment is targeted, can be a diff line or a file.")),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the pull request review comment"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request) itself."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.").nullish(),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"closed_at": z.nullable(z.string()),
"comments_url": z.url(),
"commits_url": z.url(),
"created_at": z.string(),
"diff_url": z.url(),
"draft": z.optional(z.boolean()),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.nullable(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.optional(z.boolean().default(false).describe("Whether discussions are enabled.")),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository")),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"merge_commit_sha": z.nullable(z.string()),
"merged_at": z.nullable(z.string()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"patch_url": z.url(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]),
"statuses_url": z.url(),
"title": z.string(),
"updated_at": z.string(),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestReviewCommentDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "comment"(){
                return webhooksReviewCommentSchema.describe("The [comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request) itself.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.").nullish(),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"closed_at": z.nullable(z.string()),
"comments_url": z.url(),
"commits_url": z.url(),
"created_at": z.string(),
"diff_url": z.url(),
"draft": z.optional(z.boolean()),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.nullable(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository")),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"merge_commit_sha": z.nullable(z.string()),
"merged_at": z.nullable(z.string()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"patch_url": z.url(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]),
"statuses_url": z.url(),
"title": z.string(),
"updated_at": z.string(),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestReviewCommentEditedSchema = z.object({
    "action": z.enum(["edited"]),
get "changes"(){
                return webhooksChangesSchema.describe("The changes to the comment.")
              },
get "comment"(){
                return webhooksReviewCommentSchema.describe("The [comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request) itself.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.").nullish(),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"closed_at": z.nullable(z.string()),
"comments_url": z.url(),
"commits_url": z.url(),
"created_at": z.string(),
"diff_url": z.url(),
"draft": z.optional(z.boolean()),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.nullable(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository")),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"merge_commit_sha": z.nullable(z.string()),
"merged_at": z.nullable(z.string()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"patch_url": z.url(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]),
"statuses_url": z.url(),
"title": z.string(),
"updated_at": z.string(),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"user_view_type": z.optional(z.string()),
"url": z.optional(z.url())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestReviewDismissedSchema = z.object({
    "action": z.enum(["dismissed"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"closed_at": z.nullable(z.string()),
"comments_url": z.url(),
"commits_url": z.url(),
"created_at": z.string(),
"diff_url": z.url(),
"draft": z.boolean(),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.nullable(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository")),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"merge_commit_sha": z.nullable(z.string()),
"merged_at": z.nullable(z.string()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"patch_url": z.url(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]),
"statuses_url": z.url(),
"title": z.string(),
"updated_at": z.string(),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
"review": z.object({
    "_links": z.object({
    "html": z.object({
    "href": z.string()
    }),
"pull_request": z.object({
    "href": z.string()
    })
    }),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.nullable(z.string().describe("The text of the review.")),
"commit_id": z.string().describe("A commit SHA for the review."),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the review"),
"node_id": z.string(),
"pull_request_url": z.url(),
"state": z.enum(["dismissed", "approved", "changes_requested"]),
"submitted_at": z.iso.datetime({ offset: true }),
"updated_at": z.iso.datetime({ offset: true }).nullish(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The review that was affected."),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestReviewEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.object({
    "body": z.optional(z.object({
    "from": z.string().describe("The previous version of the body if the action was `edited`.")
    }))
    }),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int()
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"closed_at": z.nullable(z.string()),
"comments_url": z.url(),
"commits_url": z.url(),
"created_at": z.string(),
"diff_url": z.url(),
"draft": z.boolean(),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.nullable(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int()
    }).describe("A git repository")),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"merge_commit_sha": z.nullable(z.string()),
"merged_at": z.nullable(z.string()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"patch_url": z.url(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]),
"statuses_url": z.url(),
"title": z.string(),
"updated_at": z.string(),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "review"(){
                return webhooksReviewSchema.describe("The review that was affected.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestReviewRequestRemovedSchema = z.union([z.object({
    "action": z.enum(["review_request_removed"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"number": z.int().describe("The pull request number."),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"additions": z.optional(z.int()),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title.")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"changed_files": z.optional(z.int()),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.optional(z.int()),
"comments_url": z.url(),
"commits": z.optional(z.int()),
"commits_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"deletions": z.optional(z.int()),
"diff_url": z.url(),
"draft": z.boolean().describe("Indicates whether or not the pull request is a draft."),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether maintainers can modify the pull request.")),
"merge_commit_sha": z.nullable(z.string()),
"mergeable": z.boolean().nullish(),
"mergeable_state": z.optional(z.string()),
"merged": z.boolean().nullish(),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"patch_url": z.url(),
"rebaseable": z.boolean().nullish(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments": z.optional(z.int()),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"statuses_url": z.url(),
"title": z.string().describe("The title of the pull request."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
"requested_reviewer": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    }), z.object({
    "action": z.enum(["review_request_removed"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"number": z.int().describe("The pull request number."),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"additions": z.optional(z.int()),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"changed_files": z.optional(z.int()),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.optional(z.int()),
"comments_url": z.url(),
"commits": z.optional(z.int()),
"commits_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"deletions": z.optional(z.int()),
"diff_url": z.url(),
"draft": z.boolean().describe("Indicates whether or not the pull request is a draft."),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether maintainers can modify the pull request.")),
"merge_commit_sha": z.nullable(z.string()),
"mergeable": z.boolean().nullish(),
"mergeable_state": z.optional(z.string()),
"merged": z.boolean().nullish(),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"patch_url": z.url(),
"rebaseable": z.boolean().nullish(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments": z.optional(z.int()),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"statuses_url": z.url(),
"title": z.string().describe("The title of the pull request."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
"requested_team": z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).describe("Groups of organization members that gives permissions on specified repositories."),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })])

export const webhookPullRequestReviewRequestedSchema = z.union([z.object({
    "action": z.enum(["review_requested"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"number": z.int().describe("The pull request number."),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"additions": z.optional(z.int()),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"changed_files": z.optional(z.int()),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.optional(z.int()),
"comments_url": z.url(),
"commits": z.optional(z.int()),
"commits_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"deletions": z.optional(z.int()),
"diff_url": z.url(),
"draft": z.boolean().describe("Indicates whether or not the pull request is a draft."),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether maintainers can modify the pull request.")),
"merge_commit_sha": z.nullable(z.string()),
"mergeable": z.boolean().nullish(),
"mergeable_state": z.optional(z.string()),
"merged": z.boolean().nullish(),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"patch_url": z.url(),
"rebaseable": z.boolean().nullish(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments": z.optional(z.int()),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"statuses_url": z.url(),
"title": z.string().describe("The title of the pull request."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
"requested_reviewer": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    }), z.object({
    "action": z.enum(["review_requested"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"number": z.int().describe("The pull request number."),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"additions": z.optional(z.int()),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"changed_files": z.optional(z.int()),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.optional(z.int()),
"comments_url": z.url(),
"commits": z.optional(z.int()),
"commits_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"deletions": z.optional(z.int()),
"diff_url": z.url(),
"draft": z.boolean().describe("Indicates whether or not the pull request is a draft."),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether maintainers can modify the pull request.")),
"merge_commit_sha": z.nullable(z.string()),
"mergeable": z.boolean().nullish(),
"mergeable_state": z.optional(z.string()),
"merged": z.boolean().nullish(),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"patch_url": z.url(),
"rebaseable": z.boolean().nullish(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments": z.optional(z.int()),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"statuses_url": z.url(),
"title": z.string().describe("The title of the pull request."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
"requested_team": z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories."),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })])

export const webhookPullRequestReviewSubmittedSchema = z.object({
    "action": z.enum(["submitted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"closed_at": z.nullable(z.string()),
"comments_url": z.url(),
"commits_url": z.url(),
"created_at": z.string(),
"diff_url": z.url(),
"draft": z.boolean(),
"head": z.object({
    "label": z.nullable(z.string()),
"ref": z.string(),
"repo": z.nullable(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository")),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"merge_commit_sha": z.nullable(z.string()),
"merged_at": z.nullable(z.string()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"patch_url": z.url(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]),
"statuses_url": z.url(),
"title": z.string(),
"updated_at": z.string(),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "review"(){
                return webhooksReviewSchema.describe("The review that was affected.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestReviewThreadResolvedSchema = z.object({
    "action": z.enum(["resolved"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"closed_at": z.nullable(z.string()),
"comments_url": z.url(),
"commits_url": z.url(),
"created_at": z.string(),
"diff_url": z.url(),
"draft": z.boolean(),
"head": z.object({
    "label": z.nullable(z.string()),
"ref": z.string(),
"repo": z.nullable(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository")),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"merge_commit_sha": z.nullable(z.string()),
"merged_at": z.nullable(z.string()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"patch_url": z.url(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]),
"statuses_url": z.url(),
"title": z.string(),
"updated_at": z.string(),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
"thread": z.object({
    "comments": z.array(z.object({
    "_links": z.object({
    "html": z.object({
    "href": z.string()
    }),
"pull_request": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    })
    }),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.string().describe("The text of the comment."),
"commit_id": z.string().describe("The SHA of the commit to which the comment applies."),
"created_at": z.iso.datetime({ offset: true }),
"diff_hunk": z.string().describe("The diff of the line that the comment refers to."),
"html_url": z.url().describe("HTML URL for the pull request review comment."),
"id": z.int().describe("The ID of the pull request review comment."),
"in_reply_to_id": z.optional(z.int().describe("The comment ID to reply to.")),
"line": z.nullable(z.int().describe("The line of the blob to which the comment applies. The last line of the range for a multi-line comment")),
"node_id": z.string().describe("The node ID of the pull request review comment."),
"original_commit_id": z.string().describe("The SHA of the original commit to which the comment applies."),
"original_line": z.nullable(z.int().describe("The line of the blob to which the comment applies. The last line of the range for a multi-line comment")),
"original_position": z.int().describe("The index of the original line in the diff to which the comment applies."),
"original_start_line": z.nullable(z.int().describe("The first line of the range for a multi-line comment.")),
"path": z.string().describe("The relative path of the file to which the comment applies."),
"position": z.nullable(z.int().describe("The line index in the diff to which the comment applies.")),
"pull_request_review_id": z.nullable(z.int().describe("The ID of the pull request review to which the comment belongs.")),
"pull_request_url": z.url().describe("URL for the pull request that the review comment belongs to."),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"side": z.enum(["LEFT", "RIGHT"]).describe("The side of the first line of the range for a multi-line comment."),
"start_line": z.nullable(z.int().describe("The first line of the range for a multi-line comment.")),
"start_side": z.nullable(z.enum(["LEFT", "RIGHT"]).default("RIGHT").describe("The side of the first line of the range for a multi-line comment.")),
"subject_type": z.optional(z.enum(["line", "file"]).describe("The level at which the comment is targeted, can be a diff line or a file.")),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the pull request review comment"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request) itself.")),
"node_id": z.string()
    }),
"updated_at": z.iso.datetime({ offset: true }).nullish()
    })

export const webhookPullRequestReviewThreadUnresolvedSchema = z.object({
    "action": z.enum(["unresolved"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.string().describe("Title for the merge commit message."),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"closed_at": z.nullable(z.string()),
"comments_url": z.url(),
"commits_url": z.url(),
"created_at": z.string(),
"diff_url": z.url(),
"draft": z.boolean(),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"merge_commit_sha": z.nullable(z.string()),
"merged_at": z.nullable(z.string()),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int(),
"patch_url": z.url(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]),
"statuses_url": z.url(),
"title": z.string(),
"updated_at": z.string(),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
"thread": z.object({
    "comments": z.array(z.object({
    "_links": z.object({
    "html": z.object({
    "href": z.string()
    }),
"pull_request": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    })
    }),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"body": z.string().describe("The text of the comment."),
"commit_id": z.string().describe("The SHA of the commit to which the comment applies."),
"created_at": z.iso.datetime({ offset: true }),
"diff_hunk": z.string().describe("The diff of the line that the comment refers to."),
"html_url": z.url().describe("HTML URL for the pull request review comment."),
"id": z.int().describe("The ID of the pull request review comment."),
"in_reply_to_id": z.optional(z.int().describe("The comment ID to reply to.")),
"line": z.nullable(z.int().describe("The line of the blob to which the comment applies. The last line of the range for a multi-line comment")),
"node_id": z.string().describe("The node ID of the pull request review comment."),
"original_commit_id": z.string().describe("The SHA of the original commit to which the comment applies."),
"original_line": z.int().describe("The line of the blob to which the comment applies. The last line of the range for a multi-line comment"),
"original_position": z.int().describe("The index of the original line in the diff to which the comment applies."),
"original_start_line": z.nullable(z.int().describe("The first line of the range for a multi-line comment.")),
"path": z.string().describe("The relative path of the file to which the comment applies."),
"position": z.nullable(z.int().describe("The line index in the diff to which the comment applies.")),
"pull_request_review_id": z.nullable(z.int().describe("The ID of the pull request review to which the comment belongs.")),
"pull_request_url": z.url().describe("URL for the pull request that the review comment belongs to."),
"reactions": z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    }),
"side": z.enum(["LEFT", "RIGHT"]).describe("The side of the first line of the range for a multi-line comment."),
"start_line": z.nullable(z.int().describe("The first line of the range for a multi-line comment.")),
"start_side": z.nullable(z.enum(["LEFT", "RIGHT"]).default("RIGHT").describe("The side of the first line of the range for a multi-line comment.")),
"subject_type": z.optional(z.enum(["line", "file"]).describe("The level at which the comment is targeted, can be a diff line or a file.")),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url().describe("URL for the pull request review comment"),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }).describe("The [comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request) itself.")),
"node_id": z.string()
    }),
"updated_at": z.iso.datetime({ offset: true }).nullish()
    })

export const webhookPullRequestSynchronizeSchema = z.object({
    "action": z.enum(["synchronize"]),
"after": z.string(),
"before": z.string(),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "number"(){
                return webhooksNumberSchema.describe("The pull request number.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"additions": z.optional(z.int()),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"changed_files": z.optional(z.int()),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.optional(z.int()),
"comments_url": z.url(),
"commits": z.optional(z.int()),
"commits_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"deletions": z.optional(z.int()),
"diff_url": z.url(),
"draft": z.boolean().describe("Indicates whether or not the pull request is a draft."),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit message title.")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether maintainers can modify the pull request.")),
"merge_commit_sha": z.nullable(z.string()),
"mergeable": z.boolean().nullish(),
"mergeable_state": z.optional(z.string()),
"merged": z.boolean().nullish(),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"patch_url": z.url(),
"rebaseable": z.boolean().nullish(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments": z.optional(z.int()),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"statuses_url": z.url(),
"title": z.string().describe("The title of the pull request."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestUnassignedSchema = z.object({
    "action": z.enum(["unassigned"]),
get "assignee"(){
                return webhooksUserMannequinSchema.optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "number"(){
                return webhooksNumberSchema.describe("The pull request number.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"additions": z.optional(z.int()),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.nullable(z.string()),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"changed_files": z.optional(z.int()),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.optional(z.int()),
"comments_url": z.url(),
"commits": z.optional(z.int()),
"commits_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"deletions": z.optional(z.int()),
"diff_url": z.url(),
"draft": z.boolean().describe("Indicates whether or not the pull request is a draft."),
"head": z.object({
    "label": z.nullable(z.string()),
"ref": z.string(),
"repo": z.nullable(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository")),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether maintainers can modify the pull request.")),
"merge_commit_sha": z.nullable(z.string()),
"mergeable": z.boolean().nullish(),
"mergeable_state": z.optional(z.string()),
"merged": z.boolean().nullish(),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"patch_url": z.url(),
"rebaseable": z.boolean().nullish(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments": z.optional(z.int()),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"statuses_url": z.url(),
"title": z.string().describe("The title of the pull request."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookPullRequestUnlabeledSchema = z.object({
    "action": z.enum(["unlabeled"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "label"(){
                return webhooksLabelSchema.optional()
              },
get "number"(){
                return webhooksNumberSchema.describe("The pull request number.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"additions": z.optional(z.int()),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.nullable(z.string().describe("Title for the merge commit message.")),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"changed_files": z.optional(z.int()),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.optional(z.int()),
"comments_url": z.url(),
"commits": z.optional(z.int()),
"commits_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"deletions": z.optional(z.int()),
"diff_url": z.url(),
"draft": z.boolean().describe("Indicates whether or not the pull request is a draft."),
"head": z.object({
    "label": z.nullable(z.string()),
"ref": z.string(),
"repo": z.nullable(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit message title.")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository")),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether maintainers can modify the pull request.")),
"merge_commit_sha": z.nullable(z.string()),
"mergeable": z.boolean().nullish(),
"mergeable_state": z.optional(z.string()),
"merged": z.boolean().nullish(),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"patch_url": z.url(),
"rebaseable": z.boolean().nullish(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments": z.optional(z.int()),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"statuses_url": z.url(),
"title": z.string().describe("The title of the pull request."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization", "Mannequin"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPullRequestUnlockedSchema = z.object({
    "action": z.enum(["unlocked"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "number"(){
                return webhooksNumberSchema.describe("The pull request number.")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pull_request": z.object({
    "_links": z.object({
    "comments": z.object({
    "href": z.string()
    }),
"commits": z.object({
    "href": z.string()
    }),
"html": z.object({
    "href": z.string()
    }),
"issue": z.object({
    "href": z.string()
    }),
"review_comment": z.object({
    "href": z.string()
    }),
"review_comments": z.object({
    "href": z.string()
    }),
"self": z.object({
    "href": z.string()
    }),
"statuses": z.object({
    "href": z.string()
    })
    }),
"active_lock_reason": z.nullable(z.enum(["resolved", "off-topic", "too heated", "spam"])),
"additions": z.optional(z.int()),
"assignee": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"assignees": z.array(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullable()),
"author_association": z.enum(["COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "NONE", "OWNER"]).describe("How the author is associated with the repository."),
"auto_merge": z.nullable(z.object({
    "commit_message": z.nullable(z.string().describe("Commit message for the merge commit.")),
"commit_title": z.string().describe("Title for the merge commit message."),
"enabled_by": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"merge_method": z.enum(["merge", "squash", "rebase"]).describe("The merge method to use.")
    }).describe("The status of auto merging a pull request.")),
"base": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"body": z.nullable(z.string()),
"changed_files": z.optional(z.int()),
"closed_at": z.nullable(z.iso.datetime({ offset: true })),
"comments": z.optional(z.int()),
"comments_url": z.url(),
"commits": z.optional(z.int()),
"commits_url": z.url(),
"created_at": z.iso.datetime({ offset: true }),
"deletions": z.optional(z.int()),
"diff_url": z.url(),
"draft": z.boolean().describe("Indicates whether or not the pull request is a draft."),
"head": z.object({
    "label": z.string(),
"ref": z.string(),
"repo": z.nullable(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository")),
"sha": z.string(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
"html_url": z.url(),
"id": z.int(),
"issue_url": z.url(),
"labels": z.array(z.object({
    "color": z.string().describe("6-character hex code, without the leading #, identifying the color"),
"default": z.boolean(),
"description": z.nullable(z.string()),
"id": z.int(),
"name": z.string().describe("The name of the label."),
"node_id": z.string(),
"url": z.url().describe("URL for the label")
    })),
"locked": z.boolean(),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether maintainers can modify the pull request.")),
"merge_commit_sha": z.nullable(z.string()),
"mergeable": z.boolean().nullish(),
"mergeable_state": z.optional(z.string()),
"merged": z.boolean().nullish(),
"merged_at": z.nullable(z.iso.datetime({ offset: true })),
"merged_by": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish(),
"milestone": z.nullable(z.object({
    "closed_at": z.nullable(z.iso.datetime({ offset: true })),
"closed_issues": z.int(),
"created_at": z.iso.datetime({ offset: true }),
"creator": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"description": z.nullable(z.string()),
"due_on": z.nullable(z.iso.datetime({ offset: true })),
"html_url": z.url(),
"id": z.int(),
"labels_url": z.url(),
"node_id": z.string(),
"number": z.int().describe("The number of the milestone."),
"open_issues": z.int(),
"state": z.enum(["open", "closed"]).describe("The state of the milestone."),
"title": z.string().describe("The title of the milestone."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url()
    }).describe("A collection of related issues and pull requests.")),
"node_id": z.string(),
"number": z.int().describe("Number uniquely identifying the pull request within its repository."),
"patch_url": z.url(),
"rebaseable": z.boolean().nullish(),
"requested_reviewers": z.array(z.union([z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }), z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    })])),
"requested_teams": z.array(z.object({
    "deleted": z.optional(z.boolean()),
"description": z.string().describe("Description of the team").nullish(),
"html_url": z.optional(z.url()),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.optional(z.string()),
"name": z.string().describe("Name of the team"),
"node_id": z.optional(z.string()),
"parent": z.object({
    "description": z.nullable(z.string().describe("Description of the team")),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the team"),
"members_url": z.string(),
"name": z.string().describe("Name of the team"),
"node_id": z.string(),
"permission": z.string().describe("Permission that the team will have for its repositories"),
"privacy": z.enum(["open", "closed", "secret"]),
"repositories_url": z.url(),
"slug": z.string(),
"url": z.url().describe("URL for the team")
    }).nullish(),
"permission": z.optional(z.string().describe("Permission that the team will have for its repositories")),
"privacy": z.optional(z.enum(["open", "closed", "secret"])),
"repositories_url": z.optional(z.url()),
"slug": z.optional(z.string()),
"url": z.optional(z.url().describe("URL for the team"))
    }).describe("Groups of organization members that gives permissions on specified repositories.")),
"review_comment_url": z.string(),
"review_comments": z.optional(z.int()),
"review_comments_url": z.url(),
"state": z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`."),
"statuses_url": z.url(),
"title": z.string().describe("The title of the pull request."),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"user": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }))
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookPushSchema = z.object({
    "after": z.string().describe("The SHA of the most recent commit on `ref` after the push."),
get "base_ref"(){
               return webhooksNullableStringSchema.nullable()
              },
"before": z.string().describe("The SHA of the most recent commit on `ref` before the push."),
"commits": z.array(z.object({
    "added": z.optional(z.array(z.string()).describe("An array of files added in the commit. A maximum of 3000 changed files will be reported per commit.")),
"author": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.nullable(z.email()),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"committer": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.nullable(z.email()),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"distinct": z.boolean().describe("Whether this commit is distinct from any that have been pushed before."),
"id": z.string(),
"message": z.string().describe("The commit message."),
"modified": z.optional(z.array(z.string()).describe("An array of files modified by the commit. A maximum of 3000 changed files will be reported per commit.")),
"removed": z.optional(z.array(z.string()).describe("An array of files removed in the commit. A maximum of 3000 changed files will be reported per commit.")),
"timestamp": z.iso.datetime({ offset: true }).describe("The ISO 8601 timestamp of the commit."),
"tree_id": z.string(),
"url": z.url().describe("URL that points to the commit API resource.")
    })).describe("An array of commit objects describing the pushed commits. (Pushed commits are all commits that are included in the `compare` between the `before` commit and the `after` commit.) The array includes a maximum of 2048 commits. If necessary, you can use the [Commits API](https://docs.github.com/rest/commits) to fetch additional commits."),
"compare": z.string().describe("URL that shows the changes in this `ref` update, from the `before` commit to the `after` commit. For a newly created `ref` that is directly based on the default branch, this is the comparison between the head of the default branch and the `after` commit. Otherwise, this shows all commits until the `after` commit."),
"created": z.boolean().describe("Whether this push created the `ref`."),
"deleted": z.boolean().describe("Whether this push deleted the `ref`."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
"forced": z.boolean().describe("Whether this push was a force push of the `ref`."),
"head_commit": z.nullable(z.object({
    "added": z.optional(z.array(z.string()).describe("An array of files added in the commit.")),
"author": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.nullable(z.email()),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"committer": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.nullable(z.email()),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"distinct": z.boolean().describe("Whether this commit is distinct from any that have been pushed before."),
"id": z.string(),
"message": z.string().describe("The commit message."),
"modified": z.optional(z.array(z.string()).describe("An array of files modified by the commit.")),
"removed": z.optional(z.array(z.string()).describe("An array of files removed in the commit.")),
"timestamp": z.iso.datetime({ offset: true }).describe("The ISO 8601 timestamp of the commit."),
"tree_id": z.string(),
"url": z.url().describe("URL that points to the commit API resource.")
    })),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"pusher": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.email().nullish(),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"ref": z.string().describe("The full git ref that was pushed. Example: `refs/heads/main` or `refs/tags/v3.14.1`."),
"repository": z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"custom_properties": z.optional(z.object({
    
    }).catchall(z.unknown()).describe("The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.")),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"has_discussions": z.boolean().default(false).describe("Whether discussions are enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int(),
"web_commit_signoff_required": z.optional(z.boolean().describe("Whether to require contributors to sign off on web-based commits"))
    }).describe("A git repository"),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookRegistryPackagePublishedSchema = z.object({
    "action": z.enum(["published"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"registry_package": z.object({
    "created_at": z.nullable(z.string()),
"description": z.nullable(z.string()),
"ecosystem": z.string(),
"html_url": z.string(),
"id": z.int(),
"name": z.string(),
"namespace": z.string(),
"owner": z.object({
    "avatar_url": z.string(),
"events_url": z.string(),
"followers_url": z.string(),
"following_url": z.string(),
"gists_url": z.string(),
"gravatar_id": z.string(),
"html_url": z.string(),
"id": z.int(),
"login": z.string(),
"node_id": z.string(),
"organizations_url": z.string(),
"received_events_url": z.string(),
"repos_url": z.string(),
"site_admin": z.boolean(),
"starred_url": z.string(),
"subscriptions_url": z.string(),
"type": z.string(),
"url": z.string(),
"user_view_type": z.optional(z.string())
    }),
"package_type": z.string(),
"package_version": z.nullable(z.object({
    "author": z.optional(z.object({
    "avatar_url": z.string(),
"events_url": z.string(),
"followers_url": z.string(),
"following_url": z.string(),
"gists_url": z.string(),
"gravatar_id": z.string(),
"html_url": z.string(),
"id": z.int(),
"login": z.string(),
"node_id": z.string(),
"organizations_url": z.string(),
"received_events_url": z.string(),
"repos_url": z.string(),
"site_admin": z.boolean(),
"starred_url": z.string(),
"subscriptions_url": z.string(),
"type": z.string(),
"url": z.string(),
"user_view_type": z.optional(z.string())
    })),
"body": z.optional(z.union([z.string(), z.object({
    
    })])),
"body_html": z.optional(z.string()),
"container_metadata": z.optional(z.object({
    "labels": z.object({
    
    }).nullish(),
"manifest": z.object({
    
    }).nullish(),
"tag": z.optional(z.object({
    "digest": z.optional(z.string()),
"name": z.optional(z.string())
    }))
    })),
"created_at": z.optional(z.string()),
"description": z.string(),
"docker_metadata": z.optional(z.array(z.object({
    "tags": z.optional(z.array(z.string()))
    }))),
"draft": z.optional(z.boolean()),
"html_url": z.string(),
"id": z.int(),
"installation_command": z.string(),
"manifest": z.optional(z.string()),
"metadata": z.array(z.object({
    
    }).catchall(z.unknown())),
"name": z.string(),
"npm_metadata": z.object({
    "name": z.optional(z.string()),
"version": z.optional(z.string()),
"npm_user": z.optional(z.string()),
"author": z.union([z.string(), z.object({
    
    })]).nullish(),
"bugs": z.union([z.string(), z.object({
    
    })]).nullish(),
"dependencies": z.optional(z.object({
    
    })),
"dev_dependencies": z.optional(z.object({
    
    })),
"peer_dependencies": z.optional(z.object({
    
    })),
"optional_dependencies": z.optional(z.object({
    
    })),
"description": z.optional(z.string()),
"dist": z.union([z.string(), z.object({
    
    })]).nullish(),
"git_head": z.optional(z.string()),
"homepage": z.optional(z.string()),
"license": z.optional(z.string()),
"main": z.optional(z.string()),
"repository": z.union([z.string(), z.object({
    
    })]).nullish(),
"scripts": z.optional(z.object({
    
    })),
"id": z.optional(z.string()),
"node_version": z.optional(z.string()),
"npm_version": z.optional(z.string()),
"has_shrinkwrap": z.optional(z.boolean()),
"maintainers": z.optional(z.array(z.string())),
"contributors": z.optional(z.array(z.string())),
"engines": z.optional(z.object({
    
    })),
"keywords": z.optional(z.array(z.string())),
"files": z.optional(z.array(z.string())),
"bin": z.optional(z.object({
    
    })),
"man": z.optional(z.object({
    
    })),
"directories": z.union([z.string(), z.object({
    
    })]).nullish(),
"os": z.optional(z.array(z.string())),
"cpu": z.optional(z.array(z.string())),
"readme": z.optional(z.string()),
"installation_command": z.optional(z.string()),
"release_id": z.optional(z.int()),
"commit_oid": z.optional(z.string()),
"published_via_actions": z.optional(z.boolean()),
"deleted_by_id": z.optional(z.int())
    }).nullish(),
"nuget_metadata": z.array(z.object({
    "id": z.union([z.int(), z.string(), z.object({
    
    })]).nullish(),
"name": z.optional(z.string()),
"value": z.optional(z.union([z.boolean(), z.int(), z.string(), z.object({
    "url": z.optional(z.string()),
"branch": z.optional(z.string()),
"commit": z.optional(z.string()),
"type": z.optional(z.string())
    })]))
    })).nullish(),
"package_files": z.array(z.object({
    "content_type": z.string(),
"created_at": z.string(),
"download_url": z.string(),
"id": z.int(),
"md5": z.nullable(z.string()),
"name": z.string(),
"sha1": z.nullable(z.string()),
"sha256": z.nullable(z.string()),
"size": z.int(),
"state": z.nullable(z.string()),
"updated_at": z.string()
    })),
"package_url": z.string(),
"prerelease": z.optional(z.boolean()),
"release": z.optional(z.object({
    "author": z.optional(z.object({
    "avatar_url": z.optional(z.string()),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.string()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.string()),
"received_events_url": z.optional(z.string()),
"repos_url": z.optional(z.string()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string()),
"user_view_type": z.optional(z.string())
    })),
"created_at": z.optional(z.string()),
"draft": z.optional(z.boolean()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"name": z.string().nullish(),
"prerelease": z.optional(z.boolean()),
"published_at": z.optional(z.string()),
"tag_name": z.optional(z.string()),
"target_commitish": z.optional(z.string()),
"url": z.optional(z.string())
    })),
get "rubygems_metadata"(){
                return z.array(webhookRubygemsMetadataSchema).optional()
              },
"summary": z.string(),
"tag_name": z.optional(z.string()),
"target_commitish": z.optional(z.string()),
"target_oid": z.optional(z.string()),
"updated_at": z.optional(z.string()),
"version": z.string()
    })),
"registry": z.nullable(z.object({
    "about_url": z.optional(z.string()),
"name": z.optional(z.string()),
"type": z.optional(z.string()),
"url": z.optional(z.string()),
"vendor": z.optional(z.string())
    })),
"updated_at": z.nullable(z.string())
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRegistryPackageUpdatedSchema = z.object({
    "action": z.enum(["updated"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"registry_package": z.object({
    "created_at": z.string(),
"description": z.unknown(),
"ecosystem": z.string(),
"html_url": z.string(),
"id": z.int(),
"name": z.string(),
"namespace": z.string(),
"owner": z.object({
    "avatar_url": z.string(),
"events_url": z.string(),
"followers_url": z.string(),
"following_url": z.string(),
"gists_url": z.string(),
"gravatar_id": z.string(),
"html_url": z.string(),
"id": z.int(),
"login": z.string(),
"node_id": z.string(),
"organizations_url": z.string(),
"received_events_url": z.string(),
"repos_url": z.string(),
"site_admin": z.boolean(),
"starred_url": z.string(),
"subscriptions_url": z.string(),
"type": z.string(),
"url": z.string(),
"user_view_type": z.optional(z.string())
    }),
"package_type": z.string(),
"package_version": z.object({
    "author": z.object({
    "avatar_url": z.string(),
"events_url": z.string(),
"followers_url": z.string(),
"following_url": z.string(),
"gists_url": z.string(),
"gravatar_id": z.string(),
"html_url": z.string(),
"id": z.int(),
"login": z.string(),
"node_id": z.string(),
"organizations_url": z.string(),
"received_events_url": z.string(),
"repos_url": z.string(),
"site_admin": z.boolean(),
"starred_url": z.string(),
"subscriptions_url": z.string(),
"type": z.string(),
"url": z.string(),
"user_view_type": z.optional(z.string())
    }),
"body": z.string(),
"body_html": z.string(),
"created_at": z.string(),
"description": z.string(),
"docker_metadata": z.optional(z.array(z.object({
    "tags": z.optional(z.array(z.string()))
    }).nullable())),
"draft": z.optional(z.boolean()),
"html_url": z.string(),
"id": z.int(),
"installation_command": z.string(),
"manifest": z.optional(z.string()),
"metadata": z.array(z.object({
    
    }).catchall(z.unknown())),
"name": z.string(),
"package_files": z.array(z.object({
    "content_type": z.optional(z.string()),
"created_at": z.optional(z.string()),
"download_url": z.optional(z.string()),
"id": z.optional(z.int()),
"md5": z.string().nullish(),
"name": z.optional(z.string()),
"sha1": z.string().nullish(),
"sha256": z.optional(z.string()),
"size": z.optional(z.int()),
"state": z.optional(z.string()),
"updated_at": z.optional(z.string())
    })),
"package_url": z.string(),
"prerelease": z.optional(z.boolean()),
"release": z.optional(z.object({
    "author": z.object({
    "avatar_url": z.string(),
"events_url": z.string(),
"followers_url": z.string(),
"following_url": z.string(),
"gists_url": z.string(),
"gravatar_id": z.string(),
"html_url": z.string(),
"id": z.int(),
"login": z.string(),
"node_id": z.string(),
"organizations_url": z.string(),
"received_events_url": z.string(),
"repos_url": z.string(),
"site_admin": z.boolean(),
"starred_url": z.string(),
"subscriptions_url": z.string(),
"type": z.string(),
"url": z.string(),
"user_view_type": z.optional(z.string())
    }),
"created_at": z.string(),
"draft": z.boolean(),
"html_url": z.string(),
"id": z.int(),
"name": z.string(),
"prerelease": z.boolean(),
"published_at": z.string(),
"tag_name": z.string(),
"target_commitish": z.string(),
"url": z.string()
    })),
get "rubygems_metadata"(){
                return z.array(webhookRubygemsMetadataSchema).optional()
              },
"summary": z.string(),
"tag_name": z.optional(z.string()),
"target_commitish": z.string(),
"target_oid": z.string(),
"updated_at": z.string(),
"version": z.string()
    }),
"registry": z.nullable(z.object({
    
    })),
"updated_at": z.string()
    }),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookReleaseCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "release"(){
                return webhooksReleaseSchema.describe("The [release](https://docs.github.com/rest/releases/releases/#get-a-release) object.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookReleaseDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "release"(){
                return webhooksReleaseSchema.describe("The [release](https://docs.github.com/rest/releases/releases/#get-a-release) object.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookReleaseEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.object({
    "body": z.optional(z.object({
    "from": z.string().describe("The previous version of the body if the action was `edited`.")
    })),
"name": z.optional(z.object({
    "from": z.string().describe("The previous version of the name if the action was `edited`.")
    })),
"tag_name": z.optional(z.object({
    "from": z.string().describe("The previous version of the tag_name if the action was `edited`.")
    })),
"make_latest": z.optional(z.object({
    "to": z.boolean().describe("Whether this release was explicitly `edited` to be the latest.")
    }))
    }),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "release"(){
                return webhooksReleaseSchema.describe("The [release](https://docs.github.com/rest/releases/releases/#get-a-release) object.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookReleasePrereleasedSchema = z.object({
    "action": z.enum(["prereleased"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"release": z.object({
    "assets": z.array(z.object({
    "browser_download_url": z.url(),
"content_type": z.string(),
"created_at": z.iso.datetime({ offset: true }),
"download_count": z.int(),
"id": z.int(),
"label": z.nullable(z.string()),
"name": z.string().describe("The file name of the asset."),
"node_id": z.string(),
"size": z.int(),
"digest": z.nullable(z.string()),
"state": z.enum(["uploaded"]).describe("State of the release asset."),
"updated_at": z.iso.datetime({ offset: true }),
"uploader": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullish(),
"url": z.url()
    }).describe("Data related to a release.").nullable()),
"assets_url": z.url(),
"author": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"body": z.nullable(z.string()),
"created_at": z.nullable(z.iso.datetime({ offset: true })),
"discussion_url": z.optional(z.url()),
"draft": z.boolean().describe("Whether the release is a draft or published"),
"html_url": z.url(),
"id": z.int(),
"immutable": z.boolean().describe("Whether or not the release is immutable."),
"name": z.nullable(z.string()),
"node_id": z.string(),
"prerelease": z.literal(true).describe("Whether the release is identified as a prerelease or a full release."),
"published_at": z.nullable(z.iso.datetime({ offset: true })),
"reactions": z.optional(z.object({
    "+1": z.int(),
"-1": z.int(),
"confused": z.int(),
"eyes": z.int(),
"heart": z.int(),
"hooray": z.int(),
"laugh": z.int(),
"rocket": z.int(),
"total_count": z.int(),
"url": z.url()
    })),
"tag_name": z.string().describe("The name of the tag."),
"tarball_url": z.nullable(z.url()),
"target_commitish": z.string().describe("Specifies the commitish value that determines where the Git tag is created from."),
"upload_url": z.string(),
"updated_at": z.nullable(z.iso.datetime({ offset: true })),
"url": z.url(),
"zipball_url": z.nullable(z.url())
    }).describe("The [release](https://docs.github.com/rest/releases/releases/#get-a-release) object."),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookReleasePublishedSchema = z.object({
    "action": z.enum(["published"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "release"(){
                return webhooksRelease1Schema.describe("The [release](https://docs.github.com/rest/releases/releases/#get-a-release) object.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookReleaseReleasedSchema = z.object({
    "action": z.enum(["released"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "release"(){
                return webhooksReleaseSchema.describe("The [release](https://docs.github.com/rest/releases/releases/#get-a-release) object.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookReleaseUnpublishedSchema = z.object({
    "action": z.enum(["unpublished"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "release"(){
                return webhooksRelease1Schema.describe("The [release](https://docs.github.com/rest/releases/releases/#get-a-release) object.")
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookRepositoryAdvisoryPublishedSchema = z.object({
    "action": z.enum(["published"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "repository_advisory"(){
                return repositoryAdvisorySchema.describe("A repository security advisory.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookRepositoryAdvisoryReportedSchema = z.object({
    "action": z.enum(["reported"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "repository_advisory"(){
                return repositoryAdvisorySchema.describe("A repository security advisory.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookRepositoryArchivedSchema = z.object({
    "action": z.enum(["archived"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRepositoryCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRepositoryDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRepositoryDispatchSampleSchema = z.object({
    "action": z.string().describe("The `event_type` that was specified in the `POST /repos/{owner}/{repo}/dispatches` request body."),
"branch": z.string(),
"client_payload": z.nullable(z.object({
    
    }).catchall(z.unknown()).describe("The `client_payload` that was specified in the `POST /repos/{owner}/{repo}/dispatches` request body.")),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"")
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRepositoryEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.object({
    "default_branch": z.optional(z.object({
    "from": z.string()
    })),
"description": z.optional(z.object({
    "from": z.nullable(z.string())
    })),
"homepage": z.optional(z.object({
    "from": z.nullable(z.string())
    })),
"topics": z.optional(z.object({
    "from": z.array(z.string()).nullish()
    }))
    }),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRepositoryImportSchema = z.object({
    get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"status": z.enum(["success", "cancelled", "failure"])
    })

export const webhookRepositoryPrivatizedSchema = z.object({
    "action": z.enum(["privatized"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRepositoryPublicizedSchema = z.object({
    "action": z.enum(["publicized"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRepositoryRenamedSchema = z.object({
    "action": z.enum(["renamed"]),
"changes": z.object({
    "repository": z.object({
    "name": z.object({
    "from": z.string()
    })
    })
    }),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRepositoryRulesetCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "repository_ruleset"(){
                return repositoryRulesetSchema.describe("A set of rules to apply when specified conditions are met.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRepositoryRulesetDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "repository_ruleset"(){
                return repositoryRulesetSchema.describe("A set of rules to apply when specified conditions are met.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRepositoryRulesetEditedSchema = z.object({
    "action": z.enum(["edited"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "repository_ruleset"(){
                return repositoryRulesetSchema.describe("A set of rules to apply when specified conditions are met.")
              },
"changes": z.optional(z.object({
    "name": z.optional(z.object({
    "from": z.optional(z.string())
    })),
"enforcement": z.optional(z.object({
    "from": z.optional(z.string())
    })),
"conditions": z.optional(z.object({
    get "added"(){
                return z.array(repositoryRulesetConditionsSchema.describe("Parameters for a repository ruleset ref name condition")).optional()
              },
get "deleted"(){
                return z.array(repositoryRulesetConditionsSchema.describe("Parameters for a repository ruleset ref name condition")).optional()
              },
"updated": z.optional(z.array(z.object({
    get "condition"(){
                return repositoryRulesetConditionsSchema.describe("Parameters for a repository ruleset ref name condition").optional()
              },
"changes": z.optional(z.object({
    "condition_type": z.optional(z.object({
    "from": z.optional(z.string())
    })),
"target": z.optional(z.object({
    "from": z.optional(z.string())
    })),
"include": z.optional(z.object({
    "from": z.optional(z.array(z.string()))
    })),
"exclude": z.optional(z.object({
    "from": z.optional(z.array(z.string()))
    }))
    }))
    })))
    })),
"rules": z.optional(z.object({
    get "added"(){
                return z.array(repositoryRuleSchema.describe("A repository rule.")).optional()
              },
get "deleted"(){
                return z.array(repositoryRuleSchema.describe("A repository rule.")).optional()
              },
"updated": z.optional(z.array(z.object({
    get "rule"(){
                return repositoryRuleSchema.describe("A repository rule.").optional()
              },
"changes": z.optional(z.object({
    "configuration": z.optional(z.object({
    "from": z.optional(z.string())
    })),
"rule_type": z.optional(z.object({
    "from": z.optional(z.string())
    })),
"pattern": z.optional(z.object({
    "from": z.optional(z.string())
    }))
    }))
    })))
    }))
    })),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRepositoryTransferredSchema = z.object({
    "action": z.enum(["transferred"]),
"changes": z.object({
    "owner": z.object({
    "from": z.object({
    "organization": z.optional(z.object({
    "avatar_url": z.url(),
"description": z.nullable(z.string()),
"events_url": z.url(),
"hooks_url": z.url(),
"html_url": z.optional(z.url()),
"id": z.int(),
"issues_url": z.url(),
"login": z.string(),
"members_url": z.string(),
"node_id": z.string(),
"public_members_url": z.string(),
"repos_url": z.url(),
"url": z.url()
    })),
"user": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    }).nullish()
    })
    })
    }),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRepositoryUnarchivedSchema = z.object({
    "action": z.enum(["unarchived"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRepositoryVulnerabilityAlertCreateSchema = z.object({
    "action": z.enum(["create"]),
get "alert"(){
                return webhooksAlertSchema.describe("The security alert of the vulnerable dependency.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRepositoryVulnerabilityAlertDismissSchema = z.object({
    "action": z.enum(["dismiss"]),
"alert": z.object({
    "affected_package_name": z.string(),
"affected_range": z.string(),
"created_at": z.string(),
"dismiss_comment": z.string().nullish(),
"dismiss_reason": z.string(),
"dismissed_at": z.string(),
"dismisser": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"external_identifier": z.string(),
"external_reference": z.nullable(z.url()),
"fix_reason": z.optional(z.string()),
"fixed_at": z.optional(z.iso.datetime({ offset: true })),
"fixed_in": z.optional(z.string()),
"ghsa_id": z.string(),
"id": z.int(),
"node_id": z.string(),
"number": z.int(),
"severity": z.string(),
"state": z.enum(["dismissed"])
    }).describe("The security alert of the vulnerable dependency."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRepositoryVulnerabilityAlertReopenSchema = z.object({
    "action": z.enum(["reopen"]),
get "alert"(){
                return webhooksAlertSchema.describe("The security alert of the vulnerable dependency.")
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookRepositoryVulnerabilityAlertResolveSchema = z.object({
    "action": z.enum(["resolve"]),
"alert": z.object({
    "affected_package_name": z.string(),
"affected_range": z.string(),
"created_at": z.string(),
"dismiss_reason": z.optional(z.string()),
"dismissed_at": z.optional(z.string()),
"dismisser": z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    }).nullish(),
"external_identifier": z.string(),
"external_reference": z.nullable(z.url()),
"fix_reason": z.optional(z.string()),
"fixed_at": z.optional(z.iso.datetime({ offset: true })),
"fixed_in": z.optional(z.string()),
"ghsa_id": z.string(),
"id": z.int(),
"node_id": z.string(),
"number": z.int(),
"severity": z.string(),
"state": z.enum(["fixed", "open"])
    }).describe("The security alert of the vulnerable dependency."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookSecretScanningAlertCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "alert"(){
                return secretScanningAlertWebhookSchema
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookSecretScanningAlertLocationCreatedSchema = z.object({
    "action": z.optional(z.enum(["created"])),
get "alert"(){
                return secretScanningAlertWebhookSchema
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "location"(){
                return secretScanningLocationSchema
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookSecretScanningAlertLocationCreatedFormEncodedSchema = z.object({
    "payload": z.string().describe("A URL-encoded string of the secret_scanning_alert_location.created JSON payload. The decoded payload is a JSON object.")
    })

export const webhookSecretScanningAlertPubliclyLeakedSchema = z.object({
    "action": z.enum(["publicly_leaked"]),
get "alert"(){
                return secretScanningAlertWebhookSchema
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookSecretScanningAlertReopenedSchema = z.object({
    "action": z.enum(["reopened"]),
get "alert"(){
                return secretScanningAlertWebhookSchema
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookSecretScanningAlertResolvedSchema = z.object({
    "action": z.enum(["resolved"]),
get "alert"(){
                return secretScanningAlertWebhookSchema
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookSecretScanningAlertValidatedSchema = z.object({
    "action": z.enum(["validated"]),
get "alert"(){
                return secretScanningAlertWebhookSchema
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookSecretScanningScanCompletedSchema = z.object({
    "action": z.enum(["completed"]),
"type": z.enum(["backfill", "custom-pattern-backfill", "pattern-version-backfill"]).describe("What type of scan was completed"),
"source": z.enum(["git", "issues", "pull-requests", "discussions", "wiki"]).describe("What type of content was scanned"),
"started_at": z.iso.datetime({ offset: true }).describe("The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."),
"completed_at": z.iso.datetime({ offset: true }).describe("The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."),
"secret_types": z.array(z.string()).describe("List of patterns that were updated. This will be empty for normal backfill scans or custom pattern updates").nullish(),
"custom_pattern_name": z.string().describe("If the scan was triggered by a custom pattern update, this will be the name of the pattern that was updated").nullish(),
"custom_pattern_scope": z.enum(["repository", "organization", "enterprise"]).describe("If the scan was triggered by a custom pattern update, this will be the scope of the pattern that was updated").nullish(),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookSecurityAdvisoryPublishedSchema = z.object({
    "action": z.enum(["published"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "security_advisory"(){
                return webhooksSecurityAdvisorySchema.describe("The details of the security advisory, including summary, description, and severity.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookSecurityAdvisoryUpdatedSchema = z.object({
    "action": z.enum(["updated"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "security_advisory"(){
                return webhooksSecurityAdvisorySchema.describe("The details of the security advisory, including summary, description, and severity.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookSecurityAdvisoryWithdrawnSchema = z.object({
    "action": z.enum(["withdrawn"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
"security_advisory": z.object({
    "cvss": z.object({
    "score": z.number(),
"vector_string": z.nullable(z.string())
    }),
get "cvss_severities"(){
                return cvssSeveritiesSchema.optional()
              },
"cwes": z.array(z.object({
    "cwe_id": z.string(),
"name": z.string()
    })),
"description": z.string(),
"ghsa_id": z.string(),
"identifiers": z.array(z.object({
    "type": z.string(),
"value": z.string()
    })),
"published_at": z.string(),
"references": z.array(z.object({
    "url": z.url()
    })),
"severity": z.string(),
"summary": z.string(),
"updated_at": z.string(),
"vulnerabilities": z.array(z.object({
    "first_patched_version": z.nullable(z.object({
    "identifier": z.string()
    })),
"package": z.object({
    "ecosystem": z.string(),
"name": z.string()
    }),
"severity": z.string(),
"vulnerable_version_range": z.string()
    })),
"withdrawn_at": z.string()
    }).describe("The details of the security advisory, including summary, description, and severity."),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookSecurityAndAnalysisSchema = z.object({
    "changes": z.object({
    "from": z.optional(z.object({
    get "security_and_analysis"(){
                return securityAndAnalysisSchema.optional()
              }
    }))
    }),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return fullRepositorySchema.describe("Full Repository")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookSponsorshipCancelledSchema = z.object({
    "action": z.enum(["cancelled"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "sponsorship"(){
                return webhooksSponsorshipSchema
              }
    })

export const webhookSponsorshipCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "sponsorship"(){
                return webhooksSponsorshipSchema
              }
    })

export const webhookSponsorshipEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.object({
    "privacy_level": z.optional(z.object({
    "from": z.string().describe("The `edited` event types include the details about the change when someone edits a sponsorship to change the privacy.")
    }))
    }),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "sponsorship"(){
                return webhooksSponsorshipSchema
              }
    })

export const webhookSponsorshipPendingCancellationSchema = z.object({
    "action": z.enum(["pending_cancellation"]),
get "effective_date"(){
                return webhooksEffectiveDateSchema.describe("The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect.").optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "sponsorship"(){
                return webhooksSponsorshipSchema
              }
    })

export const webhookSponsorshipPendingTierChangeSchema = z.object({
    "action": z.enum(["pending_tier_change"]),
get "changes"(){
                return webhooksChanges8Schema
              },
get "effective_date"(){
                return webhooksEffectiveDateSchema.describe("The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect.").optional()
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "sponsorship"(){
                return webhooksSponsorshipSchema
              }
    })

export const webhookSponsorshipTierChangedSchema = z.object({
    "action": z.enum(["tier_changed"]),
get "changes"(){
                return webhooksChanges8Schema
              },
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "sponsorship"(){
                return webhooksSponsorshipSchema
              }
    })

export const webhookStarCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"starred_at": z.nullable(z.string().describe("The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action."))
    })

export const webhookStarDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"starred_at": z.unknown()
    })

export const webhookStatusSchema = z.object({
    "avatar_url": z.url().nullish(),
"branches": z.array(z.object({
    "commit": z.object({
    "sha": z.nullable(z.string()),
"url": z.nullable(z.url())
    }),
"name": z.string(),
"protected": z.boolean()
    })).describe("An array of branch objects containing the status' SHA. Each branch contains the given SHA, but the SHA may or may not be the head of the branch. The array includes a maximum of 10 branches."),
"commit": z.object({
    "author": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    })),
"comments_url": z.url(),
"commit": z.object({
    "author": z.object({
    "date": z.string(),
"email": z.optional(z.string()),
"name": z.optional(z.string()),
"username": z.optional(z.string())
    }),
"comment_count": z.int(),
"committer": z.object({
    "date": z.string(),
"email": z.optional(z.string()),
"name": z.optional(z.string()),
"username": z.optional(z.string())
    }),
"message": z.string(),
"tree": z.object({
    "sha": z.string(),
"url": z.url()
    }),
"url": z.url(),
"verification": z.object({
    "payload": z.nullable(z.string()),
"reason": z.enum(["expired_key", "not_signing_key", "gpgverify_error", "gpgverify_unavailable", "unsigned", "unknown_signature_type", "no_user", "unverified_email", "bad_email", "unknown_key", "malformed_signature", "invalid", "valid", "bad_cert", "ocsp_pending"]),
"signature": z.nullable(z.string()),
"verified": z.boolean(),
"verified_at": z.nullable(z.string())
    })
    }),
"committer": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.optional(z.int()),
"login": z.optional(z.string()),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    })),
"html_url": z.url(),
"node_id": z.string(),
"parents": z.array(z.object({
    "html_url": z.url(),
"sha": z.string(),
"url": z.url()
    })),
"sha": z.string(),
"url": z.url()
    }),
"context": z.string(),
"created_at": z.string(),
"description": z.nullable(z.string().describe("The optional human-readable description added to the status.")),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
"id": z.int().describe("The unique identifier of the status."),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
"name": z.string(),
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"sha": z.string().describe("The Commit SHA."),
"state": z.enum(["pending", "success", "failure", "error"]).describe("The new state. Can be `pending`, `success`, `failure`, or `error`."),
"target_url": z.nullable(z.string().describe("The optional link added to the status.")),
"updated_at": z.string()
    })

export const webhookSubIssuesParentIssueAddedSchema = z.object({
    "action": z.enum(["parent_issue_added"]),
"parent_issue_id": z.number().describe("The ID of the parent issue."),
get "parent_issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")
              },
get "parent_issue_repo"(){
                return repositorySchema.describe("A repository on GitHub.")
              },
"sub_issue_id": z.number().describe("The ID of the sub-issue."),
get "sub_issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookSubIssuesParentIssueRemovedSchema = z.object({
    "action": z.enum(["parent_issue_removed"]),
"parent_issue_id": z.number().describe("The ID of the parent issue."),
get "parent_issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")
              },
get "parent_issue_repo"(){
                return repositorySchema.describe("A repository on GitHub.")
              },
"sub_issue_id": z.number().describe("The ID of the sub-issue."),
get "sub_issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookSubIssuesSubIssueAddedSchema = z.object({
    "action": z.enum(["sub_issue_added"]),
"sub_issue_id": z.number().describe("The ID of the sub-issue."),
get "sub_issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")
              },
get "sub_issue_repo"(){
                return repositorySchema.describe("A repository on GitHub.")
              },
"parent_issue_id": z.number().describe("The ID of the parent issue."),
get "parent_issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookSubIssuesSubIssueRemovedSchema = z.object({
    "action": z.enum(["sub_issue_removed"]),
"sub_issue_id": z.number().describe("The ID of the sub-issue."),
get "sub_issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")
              },
get "sub_issue_repo"(){
                return repositorySchema.describe("A repository on GitHub.")
              },
"parent_issue_id": z.number().describe("The ID of the parent issue."),
get "parent_issue"(){
                return issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.").optional()
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              }
    })

export const webhookTeamAddSchema = z.object({
    get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "team"(){
                return webhooksTeam1Schema.describe("Groups of organization members that gives permissions on specified repositories.")
              }
    })

export const webhookTeamAddedToRepositorySchema = z.object({
    "action": z.enum(["added_to_repository"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
"repository": z.optional(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"custom_properties": z.optional(z.object({
    
    }).catchall(z.unknown()).describe("The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.")),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int()
    }).describe("A git repository")),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
get "team"(){
                return webhooksTeam1Schema.describe("Groups of organization members that gives permissions on specified repositories.")
              }
    })

export const webhookTeamCreatedSchema = z.object({
    "action": z.enum(["created"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
"repository": z.optional(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"custom_properties": z.optional(z.object({
    
    }).catchall(z.unknown()).describe("The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.")),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int()
    }).describe("A git repository")),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "team"(){
                return webhooksTeam1Schema.describe("Groups of organization members that gives permissions on specified repositories.")
              }
    })

export const webhookTeamDeletedSchema = z.object({
    "action": z.enum(["deleted"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
"repository": z.optional(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"custom_properties": z.optional(z.object({
    
    }).catchall(z.unknown()).describe("The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.")),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int()
    }).describe("A git repository")),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
get "team"(){
                return webhooksTeam1Schema.describe("Groups of organization members that gives permissions on specified repositories.")
              }
    })

export const webhookTeamEditedSchema = z.object({
    "action": z.enum(["edited"]),
"changes": z.object({
    "description": z.optional(z.object({
    "from": z.string().describe("The previous version of the description if the action was `edited`.")
    })),
"name": z.optional(z.object({
    "from": z.string().describe("The previous version of the name if the action was `edited`.")
    })),
"privacy": z.optional(z.object({
    "from": z.string().describe("The previous version of the team's privacy if the action was `edited`.")
    })),
"notification_setting": z.optional(z.object({
    "from": z.string().describe("The previous version of the team's notification setting if the action was `edited`.")
    })),
"repository": z.optional(z.object({
    "permissions": z.object({
    "from": z.object({
    "admin": z.optional(z.boolean().describe("The previous version of the team member's `admin` permission on a repository, if the action was `edited`.")),
"pull": z.optional(z.boolean().describe("The previous version of the team member's `pull` permission on a repository, if the action was `edited`.")),
"push": z.optional(z.boolean().describe("The previous version of the team member's `push` permission on a repository, if the action was `edited`."))
    })
    })
    }))
    }).describe("The changes to the team if the action was `edited`."),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
"repository": z.optional(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"custom_properties": z.optional(z.object({
    
    }).catchall(z.unknown()).describe("The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.")),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int()
    }).describe("A git repository")),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "team"(){
                return webhooksTeam1Schema.describe("Groups of organization members that gives permissions on specified repositories.")
              }
    })

export const webhookTeamRemovedFromRepositorySchema = z.object({
    "action": z.enum(["removed_from_repository"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.")
              },
"repository": z.optional(z.object({
    "allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow auto-merge for pull requests.")),
"allow_forking": z.optional(z.boolean().describe("Whether to allow private forks")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_update_branch": z.optional(z.boolean()),
"archive_url": z.string(),
"archived": z.boolean().default(false).describe("Whether the repository is archived."),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"clone_url": z.url(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"created_at": z.union([z.int(), z.iso.datetime({ offset: true })]),
"custom_properties": z.optional(z.object({
    
    }).catchall(z.unknown()).describe("The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.")),
"default_branch": z.string().describe("The default branch of the repository."),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"disabled": z.optional(z.boolean().describe("Returns whether or not this repository is disabled.")),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks": z.int(),
"forks_count": z.int(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"git_url": z.url(),
"has_downloads": z.boolean().default(true).describe("Whether downloads are enabled."),
"has_issues": z.boolean().default(true).describe("Whether issues are enabled."),
"has_pages": z.boolean(),
"has_projects": z.boolean().default(true).describe("Whether projects are enabled."),
"has_wiki": z.boolean().default(true).describe("Whether the wiki is enabled."),
"homepage": z.nullable(z.string()),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"is_template": z.optional(z.boolean()),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"language": z.nullable(z.string()),
"languages_url": z.url(),
"license": z.nullable(z.object({
    "key": z.string(),
"name": z.string(),
"node_id": z.string(),
"spdx_id": z.string(),
"url": z.nullable(z.url())
    })),
"master_branch": z.optional(z.string()),
"merges_url": z.url(),
"milestones_url": z.string(),
"mirror_url": z.nullable(z.url()),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"open_issues": z.int(),
"open_issues_count": z.int(),
"organization": z.optional(z.string()),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"permissions": z.optional(z.object({
    "admin": z.boolean(),
"maintain": z.optional(z.boolean()),
"pull": z.boolean(),
"push": z.boolean(),
"triage": z.optional(z.boolean())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"public": z.optional(z.boolean()),
"pulls_url": z.string(),
"pushed_at": z.nullable(z.union([z.int(), z.iso.datetime({ offset: true })])),
"releases_url": z.string(),
"role_name": z.string().nullish(),
"size": z.int(),
"ssh_url": z.string(),
"stargazers": z.optional(z.int()),
"stargazers_count": z.int(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"svn_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"topics": z.array(z.string()),
"trees_url": z.string(),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"visibility": z.enum(["public", "private", "internal"]),
"watchers": z.int(),
"watchers_count": z.int()
    }).describe("A git repository")),
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "team"(){
                return webhooksTeam1Schema.describe("Groups of organization members that gives permissions on specified repositories.")
              }
    })

export const webhookWatchStartedSchema = z.object({
    "action": z.enum(["started"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              }
    })

export const webhookWorkflowDispatchSchema = z.object({
    get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
"inputs": z.nullable(z.object({
    
    }).catchall(z.unknown())),
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
"ref": z.string(),
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"workflow": z.string()
    })

export const webhookWorkflowJobCompletedSchema = z.object({
    "action": z.enum(["completed"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"workflow_job": z.object({
    "check_run_url": z.optional(z.string()),
"completed_at": z.optional(z.string()),
"conclusion": z.enum(["success", "failure", "skipped", "cancelled", "action_required", "neutral", "timed_out"]),
"created_at": z.optional(z.string().describe("The time that the job created.")),
"head_sha": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"labels": z.optional(z.array(z.string().nullable())),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"run_attempt": z.optional(z.int()),
"run_id": z.optional(z.int()),
"run_url": z.optional(z.string()),
"runner_group_id": z.number().nullish(),
"runner_group_name": z.string().nullish(),
"runner_id": z.number().nullish(),
"runner_name": z.string().nullish(),
"started_at": z.optional(z.string()),
"status": z.optional(z.string()),
"head_branch": z.string().describe("The name of the current branch.").nullish(),
"workflow_name": z.string().describe("The name of the workflow.").nullish(),
"steps": z.optional(z.array(z.object({
    
    }).nullable())),
"url": z.optional(z.string())
    }),
get "deployment"(){
                return deploymentSchema.describe("A request for a specific ref(branch,sha,tag) to be deployed").optional()
              }
    })

export const webhookWorkflowJobInProgressSchema = z.object({
    "action": z.enum(["in_progress"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"workflow_job": z.object({
    "check_run_url": z.optional(z.string()),
"completed_at": z.string().nullish(),
"conclusion": z.string().nullish(),
"created_at": z.optional(z.string().describe("The time that the job created.")),
"head_sha": z.optional(z.string()),
"html_url": z.optional(z.string()),
"id": z.optional(z.int()),
"labels": z.optional(z.array(z.string())),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"run_attempt": z.optional(z.int()),
"run_id": z.optional(z.int()),
"run_url": z.optional(z.string()),
"runner_group_id": z.number().nullish(),
"runner_group_name": z.string().nullish(),
"runner_id": z.number().nullish(),
"runner_name": z.string().nullish(),
"started_at": z.optional(z.string()),
"status": z.enum(["in_progress", "completed", "queued"]),
"head_branch": z.string().describe("The name of the current branch.").nullish(),
"workflow_name": z.string().describe("The name of the workflow.").nullish(),
"steps": z.array(z.object({
    "completed_at": z.nullable(z.string()),
"conclusion": z.nullable(z.string()),
"name": z.string(),
"number": z.int(),
"started_at": z.nullable(z.string()),
"status": z.enum(["in_progress", "completed", "pending", "queued"])
    })),
"url": z.optional(z.string())
    }),
get "deployment"(){
                return deploymentSchema.describe("A request for a specific ref(branch,sha,tag) to be deployed").optional()
              }
    })

export const webhookWorkflowJobQueuedSchema = z.object({
    "action": z.enum(["queued"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"workflow_job": z.object({
    "check_run_url": z.url(),
"completed_at": z.nullable(z.string()),
"conclusion": z.nullable(z.string()),
"created_at": z.string().describe("The time that the job created."),
"head_sha": z.string(),
"html_url": z.url(),
"id": z.int(),
"labels": z.array(z.string()),
"name": z.string(),
"node_id": z.string(),
"run_attempt": z.int(),
"run_id": z.number(),
"run_url": z.url(),
"runner_group_id": z.nullable(z.int()),
"runner_group_name": z.nullable(z.string()),
"runner_id": z.nullable(z.int()),
"runner_name": z.nullable(z.string()),
"started_at": z.iso.datetime({ offset: true }),
"status": z.enum(["queued", "in_progress", "completed", "waiting"]),
"head_branch": z.nullable(z.string().describe("The name of the current branch.")),
"workflow_name": z.nullable(z.string().describe("The name of the workflow.")),
"steps": z.array(z.object({
    "completed_at": z.nullable(z.string()),
"conclusion": z.nullable(z.enum(["failure", "skipped", "success", "cancelled"])),
"name": z.string(),
"number": z.int(),
"started_at": z.nullable(z.string()),
"status": z.enum(["completed", "in_progress", "queued", "pending"])
    })),
"url": z.url()
    }),
get "deployment"(){
                return deploymentSchema.describe("A request for a specific ref(branch,sha,tag) to be deployed").optional()
              }
    })

export const webhookWorkflowJobWaitingSchema = z.object({
    "action": z.enum(["waiting"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
"workflow_job": z.object({
    "check_run_url": z.url(),
"completed_at": z.nullable(z.string()),
"conclusion": z.nullable(z.string()),
"created_at": z.string().describe("The time that the job created."),
"head_sha": z.string(),
"html_url": z.url(),
"id": z.int(),
"labels": z.array(z.string()),
"name": z.string(),
"node_id": z.string(),
"run_attempt": z.int(),
"run_id": z.number(),
"run_url": z.url(),
"runner_group_id": z.nullable(z.int()),
"runner_group_name": z.nullable(z.string()),
"runner_id": z.nullable(z.int()),
"runner_name": z.nullable(z.string()),
"started_at": z.iso.datetime({ offset: true }),
"head_branch": z.nullable(z.string().describe("The name of the current branch.")),
"workflow_name": z.nullable(z.string().describe("The name of the workflow.")),
"status": z.enum(["queued", "in_progress", "completed", "waiting"]),
"steps": z.array(z.object({
    "completed_at": z.nullable(z.string()),
"conclusion": z.nullable(z.enum(["failure", "skipped", "success", "cancelled"])),
"name": z.string(),
"number": z.int(),
"started_at": z.nullable(z.string()),
"status": z.enum(["completed", "in_progress", "queued", "pending", "waiting"])
    })),
"url": z.url()
    }),
get "deployment"(){
                return deploymentSchema.describe("A request for a specific ref(branch,sha,tag) to be deployed").optional()
              }
    })

export const webhookWorkflowRunCompletedSchema = z.object({
    "action": z.enum(["completed"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "workflow"(){
               return webhooksWorkflowSchema.nullable()
              },
"workflow_run": z.object({
    "actor": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"artifacts_url": z.url(),
"cancel_url": z.url(),
"check_suite_id": z.int(),
"check_suite_node_id": z.string(),
"check_suite_url": z.url(),
"conclusion": z.nullable(z.enum(["action_required", "cancelled", "failure", "neutral", "skipped", "stale", "success", "timed_out", "startup_failure"])),
"created_at": z.iso.datetime({ offset: true }),
"event": z.string(),
"head_branch": z.nullable(z.string()),
"head_commit": z.object({
    "author": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.nullable(z.email()),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"committer": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.nullable(z.email()),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"id": z.string(),
"message": z.string(),
"timestamp": z.string(),
"tree_id": z.string()
    }),
"head_repository": z.object({
    "archive_url": z.string(),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"languages_url": z.url(),
"merges_url": z.url(),
"milestones_url": z.string(),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"pulls_url": z.string(),
"releases_url": z.string(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"trees_url": z.string(),
"url": z.url()
    }),
"head_sha": z.string(),
"html_url": z.url(),
"id": z.int(),
"jobs_url": z.url(),
"logs_url": z.url(),
"name": z.nullable(z.string()),
"node_id": z.string(),
"path": z.string(),
"previous_attempt_url": z.nullable(z.url()),
"pull_requests": z.array(z.object({
    "base": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"head": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"id": z.number(),
"number": z.number(),
"url": z.url()
    }).nullable()),
"referenced_workflows": z.array(z.object({
    "path": z.string(),
"ref": z.optional(z.string()),
"sha": z.string()
    })).nullish(),
"repository": z.object({
    "archive_url": z.string(),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"languages_url": z.url(),
"merges_url": z.url(),
"milestones_url": z.string(),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"pulls_url": z.string(),
"releases_url": z.string(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"trees_url": z.string(),
"url": z.url()
    }),
"rerun_url": z.url(),
"run_attempt": z.int(),
"run_number": z.int(),
"run_started_at": z.iso.datetime({ offset: true }),
"status": z.enum(["requested", "in_progress", "completed", "queued", "pending", "waiting"]),
"triggering_actor": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"workflow_id": z.int(),
"workflow_url": z.url(),
"display_title": z.optional(z.string().describe("The event-specific title associated with the run or the run-name if set, or the value of `run-name` if it is set in the workflow."))
    })
    })

export const webhookWorkflowRunInProgressSchema = z.object({
    "action": z.enum(["in_progress"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "workflow"(){
               return webhooksWorkflowSchema.nullable()
              },
"workflow_run": z.object({
    "actor": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    })),
"artifacts_url": z.url(),
"cancel_url": z.url(),
"check_suite_id": z.int(),
"check_suite_node_id": z.string(),
"check_suite_url": z.url(),
"conclusion": z.nullable(z.enum(["action_required", "cancelled", "failure", "neutral", "skipped", "stale", "success", "timed_out"])),
"created_at": z.iso.datetime({ offset: true }),
"event": z.string(),
"head_branch": z.nullable(z.string()),
"head_commit": z.object({
    "author": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.nullable(z.email()),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"committer": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.nullable(z.email()),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"id": z.string(),
"message": z.string(),
"timestamp": z.string(),
"tree_id": z.string()
    }),
"head_repository": z.object({
    "archive_url": z.string(),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"languages_url": z.url(),
"merges_url": z.url(),
"milestones_url": z.string(),
"name": z.nullable(z.string().describe("The name of the repository.")),
"node_id": z.string(),
"notifications_url": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"pulls_url": z.string(),
"releases_url": z.string(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"trees_url": z.string(),
"url": z.url()
    }),
"head_sha": z.string(),
"html_url": z.url(),
"id": z.int(),
"jobs_url": z.url(),
"logs_url": z.url(),
"name": z.nullable(z.string()),
"node_id": z.string(),
"path": z.string(),
"previous_attempt_url": z.nullable(z.url()),
"pull_requests": z.array(z.object({
    "base": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"head": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"id": z.number(),
"number": z.number(),
"url": z.url()
    }).nullable()),
"referenced_workflows": z.array(z.object({
    "path": z.string(),
"ref": z.optional(z.string()),
"sha": z.string()
    })).nullish(),
"repository": z.object({
    "archive_url": z.string(),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"languages_url": z.url(),
"merges_url": z.url(),
"milestones_url": z.string(),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"pulls_url": z.string(),
"releases_url": z.string(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"trees_url": z.string(),
"url": z.url()
    }),
"rerun_url": z.url(),
"run_attempt": z.int(),
"run_number": z.int(),
"run_started_at": z.iso.datetime({ offset: true }),
"status": z.enum(["requested", "in_progress", "completed", "queued", "pending"]),
"triggering_actor": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url())
    })),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"workflow_id": z.int(),
"workflow_url": z.url()
    })
    })

export const webhookWorkflowRunRequestedSchema = z.object({
    "action": z.enum(["requested"]),
get "enterprise"(){
                return enterpriseWebhooksSchema.describe("An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured\non an enterprise account or an organization that's part of an enterprise account. For more information,\nsee \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"").optional()
              },
get "installation"(){
                return simpleInstallationSchema.describe("The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured\nfor and sent to a GitHub App. For more information,\nsee \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"").optional()
              },
get "organization"(){
                return organizationSimpleWebhooksSchema.describe("A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an\norganization, or when the event occurs from activity in a repository owned by an organization.").optional()
              },
get "repository"(){
                return repositoryWebhooksSchema.describe("The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property\nwhen the event occurs from activity in a repository.")
              },
get "sender"(){
                return simpleUserSchema.describe("A GitHub user.")
              },
get "workflow"(){
               return webhooksWorkflowSchema.nullable()
              },
"workflow_run": z.object({
    "actor": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"artifacts_url": z.url(),
"cancel_url": z.url(),
"check_suite_id": z.int(),
"check_suite_node_id": z.string(),
"check_suite_url": z.url(),
"conclusion": z.nullable(z.enum(["success", "failure", "neutral", "cancelled", "timed_out", "action_required", "stale", "skipped", "startup_failure"])),
"created_at": z.iso.datetime({ offset: true }),
"event": z.string(),
"head_branch": z.nullable(z.string()),
"head_commit": z.object({
    "author": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.nullable(z.email()),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"committer": z.object({
    "date": z.optional(z.iso.datetime({ offset: true })),
"email": z.nullable(z.email()),
"name": z.string().describe("The git author's name."),
"username": z.optional(z.string())
    }).describe("Metaproperties for Git author/committer information."),
"id": z.string(),
"message": z.string(),
"timestamp": z.string(),
"tree_id": z.string()
    }),
"head_repository": z.object({
    "archive_url": z.string(),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"languages_url": z.url(),
"merges_url": z.url(),
"milestones_url": z.string(),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"pulls_url": z.string(),
"releases_url": z.string(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"trees_url": z.string(),
"url": z.url()
    }),
"head_sha": z.string(),
"html_url": z.url(),
"id": z.int(),
"jobs_url": z.url(),
"logs_url": z.url(),
"name": z.nullable(z.string()),
"node_id": z.string(),
"path": z.string(),
"previous_attempt_url": z.nullable(z.url()),
"pull_requests": z.array(z.object({
    "base": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"head": z.object({
    "ref": z.string(),
"repo": z.object({
    "id": z.int(),
"name": z.string(),
"url": z.url()
    }),
"sha": z.string()
    }),
"id": z.number(),
"number": z.number(),
"url": z.url()
    })),
"referenced_workflows": z.array(z.object({
    "path": z.string(),
"ref": z.optional(z.string()),
"sha": z.string()
    })).nullish(),
"repository": z.object({
    "archive_url": z.string(),
"assignees_url": z.string(),
"blobs_url": z.string(),
"branches_url": z.string(),
"collaborators_url": z.string(),
"comments_url": z.string(),
"commits_url": z.string(),
"compare_url": z.string(),
"contents_url": z.string(),
"contributors_url": z.url(),
"deployments_url": z.url(),
"description": z.nullable(z.string()),
"downloads_url": z.url(),
"events_url": z.url(),
"fork": z.boolean(),
"forks_url": z.url(),
"full_name": z.string(),
"git_commits_url": z.string(),
"git_refs_url": z.string(),
"git_tags_url": z.string(),
"hooks_url": z.url(),
"html_url": z.url(),
"id": z.int().describe("Unique identifier of the repository"),
"issue_comment_url": z.string(),
"issue_events_url": z.string(),
"issues_url": z.string(),
"keys_url": z.string(),
"labels_url": z.string(),
"languages_url": z.url(),
"merges_url": z.url(),
"milestones_url": z.string(),
"name": z.string().describe("The name of the repository."),
"node_id": z.string(),
"notifications_url": z.string(),
"owner": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"private": z.boolean().describe("Whether the repository is private or public."),
"pulls_url": z.string(),
"releases_url": z.string(),
"stargazers_url": z.url(),
"statuses_url": z.string(),
"subscribers_url": z.url(),
"subscription_url": z.url(),
"tags_url": z.url(),
"teams_url": z.url(),
"trees_url": z.string(),
"url": z.url()
    }),
"rerun_url": z.url(),
"run_attempt": z.int(),
"run_number": z.int(),
"run_started_at": z.iso.datetime({ offset: true }),
"status": z.enum(["requested", "in_progress", "completed", "queued", "pending", "waiting"]),
"triggering_actor": z.nullable(z.object({
    "avatar_url": z.optional(z.url()),
"deleted": z.optional(z.boolean()),
"email": z.string().nullish(),
"events_url": z.optional(z.string()),
"followers_url": z.optional(z.url()),
"following_url": z.optional(z.string()),
"gists_url": z.optional(z.string()),
"gravatar_id": z.optional(z.string()),
"html_url": z.optional(z.url()),
"id": z.int(),
"login": z.string(),
"name": z.optional(z.string()),
"node_id": z.optional(z.string()),
"organizations_url": z.optional(z.url()),
"received_events_url": z.optional(z.url()),
"repos_url": z.optional(z.url()),
"site_admin": z.optional(z.boolean()),
"starred_url": z.optional(z.string()),
"subscriptions_url": z.optional(z.url()),
"type": z.optional(z.enum(["Bot", "User", "Organization"])),
"url": z.optional(z.url()),
"user_view_type": z.optional(z.string())
    })),
"updated_at": z.iso.datetime({ offset: true }),
"url": z.url(),
"workflow_id": z.int(),
"workflow_url": z.url(),
"display_title": z.string()
    })
    })

export const validationFailedSimpleSchema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const notFoundSchema = basicErrorSchema.describe("Basic Error")

export const badRequestSchema = basicErrorSchema.describe("Basic Error")

export const validationFailedSchema = validationErrorSchema.describe("Validation Error")

export const acceptedSchema = z.object({
    
    })

export const requiresAuthenticationSchema = basicErrorSchema.describe("Basic Error")

export const forbiddenSchema = basicErrorSchema.describe("Basic Error")

export const internalErrorSchema = basicErrorSchema.describe("Basic Error")

export const conflictSchema = basicErrorSchema.describe("Basic Error")

export const serviceUnavailableSchema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const forbiddenGistSchema = z.object({
    "block": z.optional(z.object({
    "reason": z.optional(z.string()),
"created_at": z.optional(z.string()),
"html_url": z.string().nullish()
    })),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const movedPermanentlySchema = basicErrorSchema.describe("Basic Error")

export const billingPremiumRequestUsageReportOrgSchema = z.lazy(() => billingPremiumRequestUsageReportOrgSchema)

export const billingUsageReportOrgSchema = billingUsageReportSchema

export const actionsRunnerJitconfigSchema = z.object({
    get "runner"(){
                return runnerSchema.describe("A self hosted runner")
              },
"encoded_jit_config": z.string().describe("The base64 encoded runner configuration.")
    })

export const actionsRunnerLabelsSchema = z.object({
    "total_count": z.int(),
get "labels"(){
                return z.array(runnerLabelSchema.describe("A label for a self hosted runner"))
              }
    })

export const actionsRunnerLabelsReadonlySchema = z.object({
    "total_count": z.int(),
get "labels"(){
                return z.array(runnerLabelSchema.describe("A label for a self hosted runner"))
              }
    })

export const usageMetricsApiDisabledSchema = basicErrorSchema.describe("Basic Error")

export const goneSchema = basicErrorSchema.describe("Basic Error")

export const temporaryRedirectSchema = basicErrorSchema.describe("Basic Error")

export const codeScanningForbiddenReadSchema = basicErrorSchema.describe("Basic Error")

export const codeScanningForbiddenWriteSchema = basicErrorSchema.describe("Basic Error")

export const codeScanningBadRequestSchema = basicErrorSchema.describe("Basic Error")

export const codeScanningAutofixCreateForbiddenSchema = basicErrorSchema.describe("Basic Error")

export const unprocessableAnalysisSchema = basicErrorSchema.describe("Basic Error")

export const codeScanningConflictSchema = basicErrorSchema.describe("Basic Error")

export const codeScanningInvalidStateSchema = basicErrorSchema.describe("Basic Error")

export const dependencyReviewForbiddenSchema = basicErrorSchema.describe("Basic Error")

export const porterMaintenanceSchema = basicErrorSchema.describe("Basic Error")

export const unacceptableSchema = basicErrorSchema.describe("Basic Error")

export const billingPremiumRequestUsageReportUserSchema = z.lazy(() => billingPremiumRequestUsageReportUserSchema)

export const billingUsageReportUserSchema = z.lazy(() => billingUsageReportUserSchema)

/**
 * @description Response
 */
export const metaRoot200Schema = rootSchema

export const metaRootQueryResponseSchema = metaRoot200Schema

export const securityAdvisoriesListGlobalAdvisoriesQueryParamsSchema = z.object({
    "ghsa_id": z.optional(z.string().describe("If specified, only advisories with this GHSA (GitHub Security Advisory) identifier will be returned.")),
"type": z.enum(["reviewed", "malware", "unreviewed"]).default("reviewed").describe("If specified, only advisories of this type will be returned. By default, a request with no other parameters defined will only return reviewed advisories that are not malware."),
"cve_id": z.optional(z.string().describe("If specified, only advisories with this CVE (Common Vulnerabilities and Exposures) identifier will be returned.")),
get "ecosystem"(){
                return securityAdvisoryEcosystemsSchema.describe("The package's language or package management ecosystem.").optional()
              },
"severity": z.optional(z.enum(["unknown", "low", "medium", "high", "critical"]).describe("If specified, only advisories with these severities will be returned.")),
"cwes": z.optional(z.union([z.array(z.string()), z.string()]).describe("If specified, only advisories with these Common Weakness Enumerations (CWEs) will be returned.\n\nExample: `cwes=79,284,22` or `cwes[]=79&cwes[]=284&cwes[]=22`")),
"is_withdrawn": z.optional(z.boolean().describe("Whether to only return advisories that have been withdrawn.")),
"affects": z.optional(z.union([z.array(z.string()).max(1000), z.string()]).describe("If specified, only return advisories that affect any of `package` or `package@version`. A maximum of 1000 packages can be specified.\nIf the query parameter causes the URL to exceed the maximum URL length supported by your client, you must specify fewer packages.\n\nExample: `affects=package1,package2@1.0.0,package3@2.0.0` or `affects[]=package1&affects[]=package2@1.0.0`")),
"published": z.optional(z.string().describe("If specified, only return advisories that were published on a date or date range.\n\nFor more information on the syntax of the date range, see \"[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\"")),
"updated": z.optional(z.string().describe("If specified, only return advisories that were updated on a date or date range.\n\nFor more information on the syntax of the date range, see \"[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\"")),
"modified": z.optional(z.string().describe("If specified, only show advisories that were updated or published on a date or date range.\n\nFor more information on the syntax of the date range, see \"[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\"")),
"epss_percentage": z.optional(z.string().describe("If specified, only return advisories that have an EPSS percentage score that matches the provided value.\nThe EPSS percentage represents the likelihood of a CVE being exploited.")),
"epss_percentile": z.optional(z.string().describe("If specified, only return advisories that have an EPSS percentile score that matches the provided value.\nThe EPSS percentile represents the relative rank of the CVE's likelihood of being exploited compared to other CVEs.")),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"per_page": z.coerce.number().int().min(1).max(100).default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"sort": z.enum(["updated", "published", "epss_percentage", "epss_percentile"]).default("published").describe("The property to sort the results by.")
    })

/**
 * @description Response
 */
export const securityAdvisoriesListGlobalAdvisories200Schema = z.array(globalAdvisorySchema.describe("A GitHub Security Advisory."))

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const securityAdvisoriesListGlobalAdvisories422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

/**
 * @description Too many requests
 */
export const securityAdvisoriesListGlobalAdvisories429Schema = basicErrorSchema.describe("Basic Error")

export const securityAdvisoriesListGlobalAdvisoriesQueryResponseSchema = securityAdvisoriesListGlobalAdvisories200Schema

export const securityAdvisoriesGetGlobalAdvisoryPathParamsSchema = z.object({
    "ghsa_id": z.string().describe("The GHSA (GitHub Security Advisory) identifier of the advisory.")
    })

/**
 * @description Response
 */
export const securityAdvisoriesGetGlobalAdvisory200Schema = globalAdvisorySchema.describe("A GitHub Security Advisory.")

/**
 * @description Resource not found
 */
export const securityAdvisoriesGetGlobalAdvisory404Schema = basicErrorSchema.describe("Basic Error")

export const securityAdvisoriesGetGlobalAdvisoryQueryResponseSchema = securityAdvisoriesGetGlobalAdvisory200Schema

/**
 * @description Response
 */
export const appsGetAuthenticated200Schema = integrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()

export const appsGetAuthenticatedQueryResponseSchema = appsGetAuthenticated200Schema

export const appsCreateFromManifestPathParamsSchema = z.object({
    "code": z.string()
    })

/**
 * @description Response
 */
export const appsCreateFromManifest201Schema = integrationSchema.and(z.object({
    "client_id": z.string(),
"client_secret": z.string(),
"webhook_secret": z.nullable(z.string()),
"pem": z.string()
    }).catchall(z.unknown()))

/**
 * @description Resource not found
 */
export const appsCreateFromManifest404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const appsCreateFromManifest422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const appsCreateFromManifestMutationResponseSchema = appsCreateFromManifest201Schema

/**
 * @description Response
 */
export const appsGetWebhookConfigForApp200Schema = webhookConfigSchema.describe("Configuration object of the webhook")

export const appsGetWebhookConfigForAppQueryResponseSchema = appsGetWebhookConfigForApp200Schema

/**
 * @description Response
 */
export const appsUpdateWebhookConfigForApp200Schema = webhookConfigSchema.describe("Configuration object of the webhook")

export const appsUpdateWebhookConfigForAppMutationRequestSchema = z.object({
    get "url"(){
                return webhookConfigUrlSchema.describe("The URL to which the payloads will be delivered.").optional()
              },
get "content_type"(){
                return webhookConfigContentTypeSchema.describe("The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.").optional()
              },
get "secret"(){
                return webhookConfigSecretSchema.describe("If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).").optional()
              },
get "insecure_ssl"(){
                return webhookConfigInsecureSslSchema.optional()
              }
    })

export const appsUpdateWebhookConfigForAppMutationResponseSchema = appsUpdateWebhookConfigForApp200Schema

export const appsListWebhookDeliveriesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"cursor": z.optional(z.string().describe("Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors."))
    })

/**
 * @description Response
 */
export const appsListWebhookDeliveries200Schema = z.array(hookDeliveryItemSchema.describe("Delivery made by a webhook, without request and response information."))

/**
 * @description Bad Request
 */
export const appsListWebhookDeliveries400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const appsListWebhookDeliveries422Schema = validationErrorSchema.describe("Validation Error")

export const appsListWebhookDeliveriesQueryResponseSchema = appsListWebhookDeliveries200Schema

export const appsGetWebhookDeliveryPathParamsSchema = z.object({
    "delivery_id": z.coerce.number().int()
    })

/**
 * @description Response
 */
export const appsGetWebhookDelivery200Schema = hookDeliverySchema.describe("Delivery made by a webhook.")

/**
 * @description Bad Request
 */
export const appsGetWebhookDelivery400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const appsGetWebhookDelivery422Schema = validationErrorSchema.describe("Validation Error")

export const appsGetWebhookDeliveryQueryResponseSchema = appsGetWebhookDelivery200Schema

export const appsRedeliverWebhookDeliveryPathParamsSchema = z.object({
    "delivery_id": z.coerce.number().int()
    })

/**
 * @description Accepted
 */
export const appsRedeliverWebhookDelivery202Schema = z.object({
    
    })

/**
 * @description Bad Request
 */
export const appsRedeliverWebhookDelivery400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const appsRedeliverWebhookDelivery422Schema = validationErrorSchema.describe("Validation Error")

export const appsRedeliverWebhookDeliveryMutationResponseSchema = appsRedeliverWebhookDelivery202Schema

export const appsListInstallationRequestsForAuthenticatedAppQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description List of integration installation requests
 */
export const appsListInstallationRequestsForAuthenticatedApp200Schema = z.array(integrationInstallationRequestSchema.describe("Request to install an integration on a target"))

/**
 * @description Not modified
 */
export const appsListInstallationRequestsForAuthenticatedApp304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const appsListInstallationRequestsForAuthenticatedApp401Schema = basicErrorSchema.describe("Basic Error")

export const appsListInstallationRequestsForAuthenticatedAppQueryResponseSchema = appsListInstallationRequestsForAuthenticatedApp200Schema

export const appsListInstallationsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"since": z.optional(z.iso.datetime({ offset: true }).describe("Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"outdated": z.optional(z.string())
    })

/**
 * @description The permissions the installation has are included under the `permissions` key.
 */
export const appsListInstallations200Schema = z.array(installationSchema.describe("Installation"))

export const appsListInstallationsQueryResponseSchema = appsListInstallations200Schema

export const appsGetInstallationPathParamsSchema = z.object({
    "installation_id": z.coerce.number().int().describe("The unique identifier of the installation.")
    })

/**
 * @description Response
 */
export const appsGetInstallation200Schema = installationSchema.describe("Installation")

/**
 * @description Resource not found
 */
export const appsGetInstallation404Schema = basicErrorSchema.describe("Basic Error")

export const appsGetInstallationQueryResponseSchema = appsGetInstallation200Schema

export const appsDeleteInstallationPathParamsSchema = z.object({
    "installation_id": z.coerce.number().int().describe("The unique identifier of the installation.")
    })

/**
 * @description Response
 */
export const appsDeleteInstallation204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const appsDeleteInstallation404Schema = basicErrorSchema.describe("Basic Error")

export const appsDeleteInstallationMutationResponseSchema = appsDeleteInstallation204Schema

export const appsCreateInstallationAccessTokenPathParamsSchema = z.object({
    "installation_id": z.coerce.number().int().describe("The unique identifier of the installation.")
    })

/**
 * @description Response
 */
export const appsCreateInstallationAccessToken201Schema = installationTokenSchema.describe("Authentication token for a GitHub App installed on a user or org.")

/**
 * @description Requires authentication
 */
export const appsCreateInstallationAccessToken401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const appsCreateInstallationAccessToken403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const appsCreateInstallationAccessToken404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const appsCreateInstallationAccessToken422Schema = validationErrorSchema.describe("Validation Error")

export const appsCreateInstallationAccessTokenMutationRequestSchema = z.object({
    "repositories": z.optional(z.array(z.string()).describe("List of repository names that the token should have access to")),
"repository_ids": z.optional(z.array(z.int()).describe("List of repository IDs that the token should have access to")),
get "permissions"(){
                return appPermissionsSchema.describe("The permissions granted to the user access token.").optional()
              }
    })

export const appsCreateInstallationAccessTokenMutationResponseSchema = appsCreateInstallationAccessToken201Schema

export const appsSuspendInstallationPathParamsSchema = z.object({
    "installation_id": z.coerce.number().int().describe("The unique identifier of the installation.")
    })

/**
 * @description Response
 */
export const appsSuspendInstallation204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const appsSuspendInstallation404Schema = basicErrorSchema.describe("Basic Error")

export const appsSuspendInstallationMutationResponseSchema = appsSuspendInstallation204Schema

export const appsUnsuspendInstallationPathParamsSchema = z.object({
    "installation_id": z.coerce.number().int().describe("The unique identifier of the installation.")
    })

/**
 * @description Response
 */
export const appsUnsuspendInstallation204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const appsUnsuspendInstallation404Schema = basicErrorSchema.describe("Basic Error")

export const appsUnsuspendInstallationMutationResponseSchema = appsUnsuspendInstallation204Schema

export const appsDeleteAuthorizationPathParamsSchema = z.object({
    "client_id": z.string().describe("The client ID of the GitHub app.")
    })

/**
 * @description Response
 */
export const appsDeleteAuthorization204Schema = z.unknown()

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const appsDeleteAuthorization422Schema = validationErrorSchema.describe("Validation Error")

export const appsDeleteAuthorizationMutationRequestSchema = z.object({
    "access_token": z.string().describe("The OAuth access token used to authenticate to the GitHub API.")
    })

export const appsDeleteAuthorizationMutationResponseSchema = appsDeleteAuthorization204Schema

export const appsCheckTokenPathParamsSchema = z.object({
    "client_id": z.string().describe("The client ID of the GitHub app.")
    })

/**
 * @description Response
 */
export const appsCheckToken200Schema = authorizationSchema.describe("The authorization for an OAuth app, GitHub App, or a Personal Access Token.")

/**
 * @description Resource not found
 */
export const appsCheckToken404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const appsCheckToken422Schema = validationErrorSchema.describe("Validation Error")

export const appsCheckTokenMutationRequestSchema = z.object({
    "access_token": z.string().describe("The access_token of the OAuth or GitHub application.")
    })

export const appsCheckTokenMutationResponseSchema = appsCheckToken200Schema

export const appsResetTokenPathParamsSchema = z.object({
    "client_id": z.string().describe("The client ID of the GitHub app.")
    })

/**
 * @description Response
 */
export const appsResetToken200Schema = authorizationSchema.describe("The authorization for an OAuth app, GitHub App, or a Personal Access Token.")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const appsResetToken422Schema = validationErrorSchema.describe("Validation Error")

export const appsResetTokenMutationRequestSchema = z.object({
    "access_token": z.string().describe("The access_token of the OAuth or GitHub application.")
    })

export const appsResetTokenMutationResponseSchema = appsResetToken200Schema

export const appsDeleteTokenPathParamsSchema = z.object({
    "client_id": z.string().describe("The client ID of the GitHub app.")
    })

/**
 * @description Response
 */
export const appsDeleteToken204Schema = z.unknown()

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const appsDeleteToken422Schema = validationErrorSchema.describe("Validation Error")

export const appsDeleteTokenMutationRequestSchema = z.object({
    "access_token": z.string().describe("The OAuth access token used to authenticate to the GitHub API.")
    })

export const appsDeleteTokenMutationResponseSchema = appsDeleteToken204Schema

export const appsScopeTokenPathParamsSchema = z.object({
    "client_id": z.string().describe("The client ID of the GitHub app.")
    })

/**
 * @description Response
 */
export const appsScopeToken200Schema = authorizationSchema.describe("The authorization for an OAuth app, GitHub App, or a Personal Access Token.")

/**
 * @description Requires authentication
 */
export const appsScopeToken401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const appsScopeToken403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const appsScopeToken404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const appsScopeToken422Schema = validationErrorSchema.describe("Validation Error")

export const appsScopeTokenMutationRequestSchema = z.object({
    "access_token": z.string().describe("The access token used to authenticate to the GitHub API."),
"target": z.optional(z.string().describe("The name of the user or organization to scope the user access token to. **Required** unless `target_id` is specified.")),
"target_id": z.optional(z.int().describe("The ID of the user or organization to scope the user access token to. **Required** unless `target` is specified.")),
"repositories": z.optional(z.array(z.string()).describe("The list of repository names to scope the user access token to. `repositories` may not be specified if `repository_ids` is specified.")),
"repository_ids": z.optional(z.array(z.int()).describe("The list of repository IDs to scope the user access token to. `repository_ids` may not be specified if `repositories` is specified.")),
get "permissions"(){
                return appPermissionsSchema.describe("The permissions granted to the user access token.").optional()
              }
    })

export const appsScopeTokenMutationResponseSchema = appsScopeToken200Schema

export const appsGetBySlugPathParamsSchema = z.object({
    "app_slug": z.string()
    })

/**
 * @description Response
 */
export const appsGetBySlug200Schema = integrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable()

/**
 * @description Forbidden
 */
export const appsGetBySlug403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const appsGetBySlug404Schema = basicErrorSchema.describe("Basic Error")

export const appsGetBySlugQueryResponseSchema = appsGetBySlug200Schema

export const classroomGetAnAssignmentPathParamsSchema = z.object({
    "assignment_id": z.coerce.number().int().describe("The unique identifier of the classroom assignment.")
    })

/**
 * @description Response
 */
export const classroomGetAnAssignment200Schema = classroomAssignmentSchema.describe("A GitHub Classroom assignment")

/**
 * @description Resource not found
 */
export const classroomGetAnAssignment404Schema = basicErrorSchema.describe("Basic Error")

export const classroomGetAnAssignmentQueryResponseSchema = classroomGetAnAssignment200Schema

export const classroomListAcceptedAssignmentsForAnAssignmentPathParamsSchema = z.object({
    "assignment_id": z.coerce.number().int().describe("The unique identifier of the classroom assignment.")
    })

export const classroomListAcceptedAssignmentsForAnAssignmentQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const classroomListAcceptedAssignmentsForAnAssignment200Schema = z.array(classroomAcceptedAssignmentSchema.describe("A GitHub Classroom accepted assignment"))

export const classroomListAcceptedAssignmentsForAnAssignmentQueryResponseSchema = classroomListAcceptedAssignmentsForAnAssignment200Schema

export const classroomGetAssignmentGradesPathParamsSchema = z.object({
    "assignment_id": z.coerce.number().int().describe("The unique identifier of the classroom assignment.")
    })

/**
 * @description Response
 */
export const classroomGetAssignmentGrades200Schema = z.array(classroomAssignmentGradeSchema.describe("Grade for a student or groups GitHub Classroom assignment"))

/**
 * @description Resource not found
 */
export const classroomGetAssignmentGrades404Schema = basicErrorSchema.describe("Basic Error")

export const classroomGetAssignmentGradesQueryResponseSchema = classroomGetAssignmentGrades200Schema

export const classroomListClassroomsQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const classroomListClassrooms200Schema = z.array(simpleClassroomSchema.describe("A GitHub Classroom classroom"))

export const classroomListClassroomsQueryResponseSchema = classroomListClassrooms200Schema

export const classroomGetAClassroomPathParamsSchema = z.object({
    "classroom_id": z.coerce.number().int().describe("The unique identifier of the classroom.")
    })

/**
 * @description Response
 */
export const classroomGetAClassroom200Schema = classroomSchema.describe("A GitHub Classroom classroom")

/**
 * @description Resource not found
 */
export const classroomGetAClassroom404Schema = basicErrorSchema.describe("Basic Error")

export const classroomGetAClassroomQueryResponseSchema = classroomGetAClassroom200Schema

export const classroomListAssignmentsForAClassroomPathParamsSchema = z.object({
    "classroom_id": z.coerce.number().int().describe("The unique identifier of the classroom.")
    })

export const classroomListAssignmentsForAClassroomQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const classroomListAssignmentsForAClassroom200Schema = z.array(simpleClassroomAssignmentSchema.describe("A GitHub Classroom assignment"))

export const classroomListAssignmentsForAClassroomQueryResponseSchema = classroomListAssignmentsForAClassroom200Schema

/**
 * @description Response
 */
export const codesOfConductGetAllCodesOfConduct200Schema = z.array(codeOfConductSchema.describe("Code Of Conduct"))

/**
 * @description Not modified
 */
export const codesOfConductGetAllCodesOfConduct304Schema = z.unknown()

export const codesOfConductGetAllCodesOfConductQueryResponseSchema = codesOfConductGetAllCodesOfConduct200Schema

export const codesOfConductGetConductCodePathParamsSchema = z.object({
    "key": z.string()
    })

/**
 * @description Response
 */
export const codesOfConductGetConductCode200Schema = codeOfConductSchema.describe("Code Of Conduct")

/**
 * @description Not modified
 */
export const codesOfConductGetConductCode304Schema = z.unknown()

/**
 * @description Resource not found
 */
export const codesOfConductGetConductCode404Schema = basicErrorSchema.describe("Basic Error")

export const codesOfConductGetConductCodeQueryResponseSchema = codesOfConductGetConductCode200Schema

/**
 * @description Accepted
 */
export const credentialsRevoke202Schema = z.object({
    
    })

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const credentialsRevoke422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

/**
 * @description Internal Error
 */
export const credentialsRevoke500Schema = basicErrorSchema.describe("Basic Error")

export const credentialsRevokeMutationRequestSchema = z.object({
    "credentials": z.array(z.string()).min(1).max(1000).describe("A list of credentials to be revoked, up to 1000 per request.")
    })

export const credentialsRevokeMutationResponseSchema = credentialsRevoke202Schema

/**
 * @description Response
 */
export const emojisGet200Schema = z.object({
    
    }).catchall(z.string())

/**
 * @description Not modified
 */
export const emojisGet304Schema = z.unknown()

export const emojisGetQueryResponseSchema = emojisGet200Schema

export const codeSecurityGetConfigurationsForEnterprisePathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name.")
    })

export const codeSecurityGetConfigurationsForEnterpriseQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""))
    })

/**
 * @description Response
 */
export const codeSecurityGetConfigurationsForEnterprise200Schema = z.array(codeSecurityConfigurationSchema.describe("A code security configuration"))

/**
 * @description Forbidden
 */
export const codeSecurityGetConfigurationsForEnterprise403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeSecurityGetConfigurationsForEnterprise404Schema = basicErrorSchema.describe("Basic Error")

export const codeSecurityGetConfigurationsForEnterpriseQueryResponseSchema = codeSecurityGetConfigurationsForEnterprise200Schema

export const codeSecurityCreateConfigurationForEnterprisePathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name.")
    })

/**
 * @description Successfully created code security configuration
 */
export const codeSecurityCreateConfigurationForEnterprise201Schema = codeSecurityConfigurationSchema.describe("A code security configuration")

/**
 * @description Bad Request
 */
export const codeSecurityCreateConfigurationForEnterprise400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codeSecurityCreateConfigurationForEnterprise403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeSecurityCreateConfigurationForEnterprise404Schema = basicErrorSchema.describe("Basic Error")

export const codeSecurityCreateConfigurationForEnterpriseMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the code security configuration. Must be unique within the enterprise."),
"description": z.string().max(255).describe("A description of the code security configuration"),
"advanced_security": z.optional(z.enum(["enabled", "disabled", "code_security", "secret_protection"]).default("disabled").describe("The enablement status of GitHub Advanced Security features. `enabled` will enable both Code Security and Secret Protection features.\n\n> [!WARNING]\n> `code_security` and `secret_protection` are deprecated values for this field. Prefer the individual `code_security` and `secret_protection` fields to set the status of these features.\n")),
"code_security": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of GitHub Code Security features.")),
"dependency_graph": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("enabled").describe("The enablement status of Dependency Graph")),
"dependency_graph_autosubmit_action": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of Automatic dependency submission")),
"dependency_graph_autosubmit_action_options": z.optional(z.object({
    "labeled_runners": z.optional(z.boolean().default(false).describe("Whether to use runners labeled with 'dependency-submission' or standard GitHub runners."))
    }).describe("Feature options for Automatic dependency submission")),
"dependabot_alerts": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of Dependabot alerts")),
"dependabot_security_updates": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of Dependabot security updates")),
get "code_scanning_options"(){
                return codeScanningOptionsSchema.describe("Security Configuration feature options for code scanning").optional()
              },
"code_scanning_default_setup": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of code scanning default setup")),
get "code_scanning_default_setup_options"(){
                return codeScanningDefaultSetupOptionsSchema.describe("Feature options for code scanning default setup").optional()
              },
"code_scanning_delegated_alert_dismissal": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of code scanning delegated alert dismissal")),
"secret_protection": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of GitHub Secret Protection features.")),
"secret_scanning": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of secret scanning")),
"secret_scanning_push_protection": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of secret scanning push protection")),
"secret_scanning_validity_checks": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of secret scanning validity checks")),
"secret_scanning_non_provider_patterns": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of secret scanning non provider patterns")),
"secret_scanning_generic_secrets": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of Copilot secret scanning")),
"secret_scanning_delegated_alert_dismissal": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of secret scanning delegated alert dismissal")),
"private_vulnerability_reporting": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of private vulnerability reporting")),
"enforcement": z.optional(z.enum(["enforced", "unenforced"]).default("enforced").describe("The enforcement status for a security configuration"))
    })

export const codeSecurityCreateConfigurationForEnterpriseMutationResponseSchema = codeSecurityCreateConfigurationForEnterprise201Schema

export const codeSecurityGetDefaultConfigurationsForEnterprisePathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name.")
    })

/**
 * @description Response
 */
export const codeSecurityGetDefaultConfigurationsForEnterprise200Schema = codeSecurityDefaultConfigurationsSchema.describe("A list of default code security configurations")

export const codeSecurityGetDefaultConfigurationsForEnterpriseQueryResponseSchema = codeSecurityGetDefaultConfigurationsForEnterprise200Schema

export const codeSecurityGetSingleConfigurationForEnterprisePathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"configuration_id": z.coerce.number().int().describe("The unique identifier of the code security configuration.")
    })

/**
 * @description Response
 */
export const codeSecurityGetSingleConfigurationForEnterprise200Schema = codeSecurityConfigurationSchema.describe("A code security configuration")

/**
 * @description Not modified
 */
export const codeSecurityGetSingleConfigurationForEnterprise304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const codeSecurityGetSingleConfigurationForEnterprise403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeSecurityGetSingleConfigurationForEnterprise404Schema = basicErrorSchema.describe("Basic Error")

export const codeSecurityGetSingleConfigurationForEnterpriseQueryResponseSchema = codeSecurityGetSingleConfigurationForEnterprise200Schema

export const codeSecurityUpdateEnterpriseConfigurationPathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"configuration_id": z.coerce.number().int().describe("The unique identifier of the code security configuration.")
    })

/**
 * @description Response
 */
export const codeSecurityUpdateEnterpriseConfiguration200Schema = codeSecurityConfigurationSchema.describe("A code security configuration")

/**
 * @description Not modified
 */
export const codeSecurityUpdateEnterpriseConfiguration304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const codeSecurityUpdateEnterpriseConfiguration403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeSecurityUpdateEnterpriseConfiguration404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const codeSecurityUpdateEnterpriseConfiguration409Schema = basicErrorSchema.describe("Basic Error")

export const codeSecurityUpdateEnterpriseConfigurationMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("The name of the code security configuration. Must be unique across the enterprise.")),
"description": z.optional(z.string().max(255).describe("A description of the code security configuration")),
"advanced_security": z.optional(z.enum(["enabled", "disabled", "code_security", "secret_protection"]).describe("The enablement status of GitHub Advanced Security features. `enabled` will enable both Code Security and Secret Protection features.\n\n> [!WARNING]\n> `code_security` and `secret_protection` are deprecated values for this field. Prefer the individual `code_security` and `secret_protection` fields to set the status of these features.\n")),
"code_security": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of GitHub Code Security features.")),
"dependency_graph": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of Dependency Graph")),
"dependency_graph_autosubmit_action": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of Automatic dependency submission")),
"dependency_graph_autosubmit_action_options": z.optional(z.object({
    "labeled_runners": z.optional(z.boolean().describe("Whether to use runners labeled with 'dependency-submission' or standard GitHub runners."))
    }).describe("Feature options for Automatic dependency submission")),
"dependabot_alerts": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of Dependabot alerts")),
"dependabot_security_updates": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of Dependabot security updates")),
"code_scanning_default_setup": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of code scanning default setup")),
get "code_scanning_default_setup_options"(){
                return codeScanningDefaultSetupOptionsSchema.describe("Feature options for code scanning default setup").optional()
              },
"code_scanning_delegated_alert_dismissal": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of code scanning delegated alert dismissal")),
"secret_protection": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of GitHub Secret Protection features.")),
"secret_scanning": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning")),
"secret_scanning_push_protection": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning push protection")),
"secret_scanning_validity_checks": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning validity checks")),
"secret_scanning_non_provider_patterns": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning non-provider patterns")),
"secret_scanning_generic_secrets": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of Copilot secret scanning")),
"secret_scanning_delegated_alert_dismissal": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of secret scanning delegated alert dismissal")),
"private_vulnerability_reporting": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of private vulnerability reporting")),
"enforcement": z.optional(z.enum(["enforced", "unenforced"]).describe("The enforcement status for a security configuration"))
    })

export const codeSecurityUpdateEnterpriseConfigurationMutationResponseSchema = codeSecurityUpdateEnterpriseConfiguration200Schema

export const codeSecurityDeleteConfigurationForEnterprisePathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"configuration_id": z.coerce.number().int().describe("The unique identifier of the code security configuration.")
    })

/**
 * @description A header with no content is returned.
 */
export const codeSecurityDeleteConfigurationForEnterprise204Schema = z.unknown()

/**
 * @description Bad Request
 */
export const codeSecurityDeleteConfigurationForEnterprise400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codeSecurityDeleteConfigurationForEnterprise403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeSecurityDeleteConfigurationForEnterprise404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const codeSecurityDeleteConfigurationForEnterprise409Schema = basicErrorSchema.describe("Basic Error")

export const codeSecurityDeleteConfigurationForEnterpriseMutationResponseSchema = codeSecurityDeleteConfigurationForEnterprise204Schema

export const codeSecurityAttachEnterpriseConfigurationPathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"configuration_id": z.coerce.number().int().describe("The unique identifier of the code security configuration.")
    })

/**
 * @description Accepted
 */
export const codeSecurityAttachEnterpriseConfiguration202Schema = z.object({
    
    })

/**
 * @description Forbidden
 */
export const codeSecurityAttachEnterpriseConfiguration403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeSecurityAttachEnterpriseConfiguration404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const codeSecurityAttachEnterpriseConfiguration409Schema = basicErrorSchema.describe("Basic Error")

export const codeSecurityAttachEnterpriseConfigurationMutationRequestSchema = z.object({
    "scope": z.enum(["all", "all_without_configurations"]).describe("The type of repositories to attach the configuration to.")
    })

export const codeSecurityAttachEnterpriseConfigurationMutationResponseSchema = codeSecurityAttachEnterpriseConfiguration202Schema

export const codeSecuritySetConfigurationAsDefaultForEnterprisePathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"configuration_id": z.coerce.number().int().describe("The unique identifier of the code security configuration.")
    })

/**
 * @description Default successfully changed.
 */
export const codeSecuritySetConfigurationAsDefaultForEnterprise200Schema = z.object({
    "default_for_new_repos": z.optional(z.enum(["all", "none", "private_and_internal", "public"]).describe("Specifies which types of repository this security configuration is applied to by default.")),
get "configuration"(){
                return codeSecurityConfigurationSchema.describe("A code security configuration").optional()
              }
    })

/**
 * @description Forbidden
 */
export const codeSecuritySetConfigurationAsDefaultForEnterprise403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeSecuritySetConfigurationAsDefaultForEnterprise404Schema = basicErrorSchema.describe("Basic Error")

export const codeSecuritySetConfigurationAsDefaultForEnterpriseMutationRequestSchema = z.object({
    "default_for_new_repos": z.optional(z.enum(["all", "none", "private_and_internal", "public"]).describe("Specify which types of repository this security configuration should be applied to by default."))
    })

export const codeSecuritySetConfigurationAsDefaultForEnterpriseMutationResponseSchema = codeSecuritySetConfigurationAsDefaultForEnterprise200Schema

export const codeSecurityGetRepositoriesForEnterpriseConfigurationPathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"configuration_id": z.coerce.number().int().describe("The unique identifier of the code security configuration.")
    })

export const codeSecurityGetRepositoriesForEnterpriseConfigurationQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"status": z.string().default("all").describe("A comma-separated list of statuses. If specified, only repositories with these attachment statuses will be returned.\n\nCan be: `all`, `attached`, `attaching`, `removed`, `enforced`, `failed`, `updating`, `removed_by_enterprise`")
    })

/**
 * @description Response
 */
export const codeSecurityGetRepositoriesForEnterpriseConfiguration200Schema = z.array(codeSecurityConfigurationRepositoriesSchema.describe("Repositories associated with a code security configuration and attachment status"))

/**
 * @description Forbidden
 */
export const codeSecurityGetRepositoriesForEnterpriseConfiguration403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeSecurityGetRepositoriesForEnterpriseConfiguration404Schema = basicErrorSchema.describe("Basic Error")

export const codeSecurityGetRepositoriesForEnterpriseConfigurationQueryResponseSchema = codeSecurityGetRepositoriesForEnterpriseConfiguration200Schema

export const dependabotListAlertsForEnterprisePathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name.")
    })

export const dependabotListAlertsForEnterpriseQueryParamsSchema = z.object({
    "state": z.optional(z.string().describe("A comma-separated list of states. If specified, only alerts with these states will be returned.\n\nCan be: `auto_dismissed`, `dismissed`, `fixed`, `open`")),
"severity": z.optional(z.string().describe("A comma-separated list of severities. If specified, only alerts with these severities will be returned.\n\nCan be: `low`, `medium`, `high`, `critical`")),
"ecosystem": z.optional(z.string().describe("A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.\n\nCan be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`")),
"package": z.optional(z.string().describe("A comma-separated list of package names. If specified, only alerts for these packages will be returned.")),
"epss_percentage": z.optional(z.string().describe("CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as:\n- An exact number (`n`)\n- Comparators such as `>n`, `<n`, `>=n`, `<=n`\n- A range like `n..n`, where `n` is a number from 0.0 to 1.0\n\nFilters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned.")),
"has": z.optional(z.union([z.array(z.enum(["patch"])), z.string()]).describe("Filters the list of alerts based on whether the alert has the given value. If specified, only alerts meeting this criterion will be returned.\nMultiple `has` filters can be passed to filter for alerts that have all of the values. Currently, only `patch` is supported.")),
"scope": z.optional(z.enum(["development", "runtime"]).describe("The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.")),
"sort": z.enum(["created", "updated", "epss_percentage"]).default("created").describe("The property by which to sort the results.\n`created` means when the alert was created.\n`updated` means when the alert's state last changed.\n`epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage."),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const dependabotListAlertsForEnterprise200Schema = z.array(dependabotAlertWithRepositorySchema.describe("A Dependabot alert."))

/**
 * @description Not modified
 */
export const dependabotListAlertsForEnterprise304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const dependabotListAlertsForEnterprise403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const dependabotListAlertsForEnterprise404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const dependabotListAlertsForEnterprise422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const dependabotListAlertsForEnterpriseQueryResponseSchema = dependabotListAlertsForEnterprise200Schema

export const enterpriseTeamsListPathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name.")
    })

export const enterpriseTeamsListQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const enterpriseTeamsList200Schema = z.array(enterpriseTeamSchema.describe("Group of enterprise owners and/or members"))

/**
 * @description Forbidden
 */
export const enterpriseTeamsList403Schema = basicErrorSchema.describe("Basic Error")

export const enterpriseTeamsListQueryResponseSchema = enterpriseTeamsList200Schema

export const enterpriseTeamsCreatePathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name.")
    })

/**
 * @description Response
 */
export const enterpriseTeamsCreate201Schema = enterpriseTeamSchema.describe("Group of enterprise owners and/or members")

export const enterpriseTeamsCreateMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the team."),
"description": z.string().describe("A description of the team.").nullish(),
"sync_to_organizations": z.optional(z.enum(["all", "disabled"]).default("disabled").describe("Retired: this field is no longer supported.\nWhether the enterprise team should be reflected in each organization.\nThis value cannot be set.\n")),
"organization_selection_type": z.optional(z.enum(["disabled", "selected", "all"]).default("disabled").describe("Specifies which organizations in the enterprise should have access to this team. Can be one of `disabled`, `selected`, or `all`.\n`disabled`: The team is not assigned to any organizations. This is the default when you create a new team.\n`selected`: The team is assigned to specific organizations. You can then use the [add organization assignments API](https://docs.github.com/rest/enterprise-teams/enterprise-team-organizations#add-organization-assignments) endpoint.\n`all`: The team is assigned to all current and future organizations in the enterprise.\n")),
"group_id": z.string().describe("The ID of the IdP group to assign team membership with. You can get this value from the [REST API endpoints for SCIM](https://docs.github.com/rest/scim#list-provisioned-scim-groups-for-an-enterprise).").nullish()
    })

export const enterpriseTeamsCreateMutationResponseSchema = enterpriseTeamsCreate201Schema

export const enterpriseTeamMembershipsListPathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"enterprise-team": z.string().describe("The slug version of the enterprise team name. You can also substitute this value with the enterprise team id.")
    })

export const enterpriseTeamMembershipsListQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const enterpriseTeamMembershipsList200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

export const enterpriseTeamMembershipsListQueryResponseSchema = enterpriseTeamMembershipsList200Schema

export const enterpriseTeamMembershipsBulkAddPathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"enterprise-team": z.string().describe("The slug version of the enterprise team name. You can also substitute this value with the enterprise team id.")
    })

/**
 * @description Successfully added team members.
 */
export const enterpriseTeamMembershipsBulkAdd200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

export const enterpriseTeamMembershipsBulkAddMutationRequestSchema = z.object({
    "usernames": z.array(z.string().describe("The handle for the GitHub user account.")).describe("The GitHub user handles to add to the team.")
    })

export const enterpriseTeamMembershipsBulkAddMutationResponseSchema = enterpriseTeamMembershipsBulkAdd200Schema

export const enterpriseTeamMembershipsBulkRemovePathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"enterprise-team": z.string().describe("The slug version of the enterprise team name. You can also substitute this value with the enterprise team id.")
    })

/**
 * @description Successfully removed team members.
 */
export const enterpriseTeamMembershipsBulkRemove200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

export const enterpriseTeamMembershipsBulkRemoveMutationRequestSchema = z.object({
    "usernames": z.array(z.string().describe("The handle for the GitHub user account.")).describe("The GitHub user handles to be removed from the team.")
    })

export const enterpriseTeamMembershipsBulkRemoveMutationResponseSchema = enterpriseTeamMembershipsBulkRemove200Schema

export const enterpriseTeamMembershipsGetPathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"enterprise-team": z.string().describe("The slug version of the enterprise team name. You can also substitute this value with the enterprise team id."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description User is a member of the enterprise team.
 */
export const enterpriseTeamMembershipsGet200Schema = simpleUserSchema.describe("A GitHub user.")

export const enterpriseTeamMembershipsGetQueryResponseSchema = enterpriseTeamMembershipsGet200Schema

export const enterpriseTeamMembershipsAddPathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"enterprise-team": z.string().describe("The slug version of the enterprise team name. You can also substitute this value with the enterprise team id."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Successfully added team member
 */
export const enterpriseTeamMembershipsAdd201Schema = simpleUserSchema.describe("A GitHub user.")

export const enterpriseTeamMembershipsAddMutationResponseSchema = enterpriseTeamMembershipsAdd201Schema

export const enterpriseTeamMembershipsRemovePathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"enterprise-team": z.string().describe("The slug version of the enterprise team name. You can also substitute this value with the enterprise team id."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const enterpriseTeamMembershipsRemove204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const enterpriseTeamMembershipsRemove403Schema = basicErrorSchema.describe("Basic Error")

export const enterpriseTeamMembershipsRemoveMutationResponseSchema = enterpriseTeamMembershipsRemove204Schema

export const enterpriseTeamOrganizationsGetAssignmentsPathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"enterprise-team": z.string().describe("The slug version of the enterprise team name. You can also substitute this value with the enterprise team id.")
    })

export const enterpriseTeamOrganizationsGetAssignmentsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description An array of organizations the team is assigned to
 */
export const enterpriseTeamOrganizationsGetAssignments200Schema = z.array(organizationSimpleSchema.describe("A GitHub organization."))

export const enterpriseTeamOrganizationsGetAssignmentsQueryResponseSchema = enterpriseTeamOrganizationsGetAssignments200Schema

export const enterpriseTeamOrganizationsBulkAddPathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"enterprise-team": z.string().describe("The slug version of the enterprise team name. You can also substitute this value with the enterprise team id.")
    })

/**
 * @description Successfully assigned the enterprise team to organizations.
 */
export const enterpriseTeamOrganizationsBulkAdd200Schema = z.array(organizationSimpleSchema.describe("A GitHub organization."))

export const enterpriseTeamOrganizationsBulkAddMutationRequestSchema = z.object({
    "organization_slugs": z.array(z.string().describe("Organization slug to assign the team to")).describe("Organization slug to assign the team to.")
    })

export const enterpriseTeamOrganizationsBulkAddMutationResponseSchema = enterpriseTeamOrganizationsBulkAdd200Schema

export const enterpriseTeamOrganizationsBulkRemovePathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"enterprise-team": z.string().describe("The slug version of the enterprise team name. You can also substitute this value with the enterprise team id.")
    })

/**
 * @description Successfully unassigned the enterprise team from organizations.
 */
export const enterpriseTeamOrganizationsBulkRemove204Schema = z.unknown()

export const enterpriseTeamOrganizationsBulkRemoveMutationRequestSchema = z.object({
    "organization_slugs": z.array(z.string().describe("Organization slug to unassign the team from")).describe("Organization slug to unassign the team from.")
    })

export const enterpriseTeamOrganizationsBulkRemoveMutationResponseSchema = enterpriseTeamOrganizationsBulkRemove204Schema

export const enterpriseTeamOrganizationsGetAssignmentPathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"enterprise-team": z.string().describe("The slug version of the enterprise team name. You can also substitute this value with the enterprise team id."),
"org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description The team is assigned to the organization
 */
export const enterpriseTeamOrganizationsGetAssignment200Schema = organizationSimpleSchema.describe("A GitHub organization.")

/**
 * @description The team is not assigned to the organization
 */
export const enterpriseTeamOrganizationsGetAssignment404Schema = z.unknown()

export const enterpriseTeamOrganizationsGetAssignmentQueryResponseSchema = enterpriseTeamOrganizationsGetAssignment200Schema

export const enterpriseTeamOrganizationsAddPathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"enterprise-team": z.string().describe("The slug version of the enterprise team name. You can also substitute this value with the enterprise team id."),
"org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Successfully assigned the enterprise team to the organization.
 */
export const enterpriseTeamOrganizationsAdd201Schema = organizationSimpleSchema.describe("A GitHub organization.")

export const enterpriseTeamOrganizationsAddMutationResponseSchema = enterpriseTeamOrganizationsAdd201Schema

export const enterpriseTeamOrganizationsDeletePathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"enterprise-team": z.string().describe("The slug version of the enterprise team name. You can also substitute this value with the enterprise team id."),
"org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Successfully unassigned the enterprise team from the organization.
 */
export const enterpriseTeamOrganizationsDelete204Schema = z.unknown()

export const enterpriseTeamOrganizationsDeleteMutationResponseSchema = enterpriseTeamOrganizationsDelete204Schema

export const enterpriseTeamsGetPathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"team_slug": z.string().describe("The slug of the team name.")
    })

/**
 * @description Response
 */
export const enterpriseTeamsGet200Schema = enterpriseTeamSchema.describe("Group of enterprise owners and/or members")

/**
 * @description Forbidden
 */
export const enterpriseTeamsGet403Schema = basicErrorSchema.describe("Basic Error")

export const enterpriseTeamsGetQueryResponseSchema = enterpriseTeamsGet200Schema

export const enterpriseTeamsUpdatePathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"team_slug": z.string().describe("The slug of the team name.")
    })

/**
 * @description Response
 */
export const enterpriseTeamsUpdate200Schema = enterpriseTeamSchema.describe("Group of enterprise owners and/or members")

/**
 * @description Forbidden
 */
export const enterpriseTeamsUpdate403Schema = basicErrorSchema.describe("Basic Error")

export const enterpriseTeamsUpdateMutationRequestSchema = z.object({
    "name": z.string().describe("A new name for the team.").nullish(),
"description": z.string().describe("A new description for the team.").nullish(),
"sync_to_organizations": z.optional(z.enum(["all", "disabled"]).default("disabled").describe("Retired: this field is no longer supported.\nWhether the enterprise team should be reflected in each organization.\nThis value cannot be changed.\n")),
"organization_selection_type": z.optional(z.enum(["disabled", "selected", "all"]).default("disabled").describe("Specifies which organizations in the enterprise should have access to this team. Can be one of `disabled`, `selected`, or `all`.\n`disabled`: The team is not assigned to any organizations. This is the default when you create a new team.\n`selected`: The team is assigned to specific organizations. You can then use the [add organization assignments API](https://docs.github.com/rest/enterprise-teams/enterprise-team-organizations#add-organization-assignments).\n`all`: The team is assigned to all current and future organizations in the enterprise.\n")),
"group_id": z.string().describe("The ID of the IdP group to assign team membership with. The new IdP group will replace the existing one, or replace existing direct members if the team isn't currently linked to an IdP group.").nullish()
    })

export const enterpriseTeamsUpdateMutationResponseSchema = enterpriseTeamsUpdate200Schema

export const enterpriseTeamsDeletePathParamsSchema = z.object({
    "enterprise": z.string().describe("The slug version of the enterprise name."),
"team_slug": z.string().describe("The slug of the team name.")
    })

/**
 * @description Response
 */
export const enterpriseTeamsDelete204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const enterpriseTeamsDelete403Schema = basicErrorSchema.describe("Basic Error")

export const enterpriseTeamsDeleteMutationResponseSchema = enterpriseTeamsDelete204Schema

export const activityListPublicEventsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(15).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListPublicEvents200Schema = z.array(eventSchema.describe("Event"))

/**
 * @description Not modified
 */
export const activityListPublicEvents304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const activityListPublicEvents403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const activityListPublicEvents503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const activityListPublicEventsQueryResponseSchema = activityListPublicEvents200Schema

/**
 * @description Response
 */
export const activityGetFeeds200Schema = feedSchema.describe("Feed")

export const activityGetFeedsQueryResponseSchema = activityGetFeeds200Schema

export const gistsListQueryParamsSchema = z.object({
    "since": z.optional(z.iso.datetime({ offset: true }).describe("Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const gistsList200Schema = z.array(baseGistSchema.describe("Base Gist"))

/**
 * @description Not modified
 */
export const gistsList304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const gistsList403Schema = basicErrorSchema.describe("Basic Error")

export const gistsListQueryResponseSchema = gistsList200Schema

/**
 * @description Response
 */
export const gistsCreate201Schema = gistSimpleSchema.describe("Gist Simple")

/**
 * @description Not modified
 */
export const gistsCreate304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const gistsCreate403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const gistsCreate404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const gistsCreate422Schema = validationErrorSchema.describe("Validation Error")

export const gistsCreateMutationRequestSchema = z.object({
    "description": z.optional(z.string().describe("Description of the gist")),
"files": z.object({
    
    }).catchall(z.object({
    "content": z.string().describe("Content of the file")
    })).describe("Names and content for the files that make up the gist"),
"public": z.optional(z.union([z.boolean(), z.enum(["true", "false"])]))
    })

export const gistsCreateMutationResponseSchema = gistsCreate201Schema

export const gistsListPublicQueryParamsSchema = z.object({
    "since": z.optional(z.iso.datetime({ offset: true }).describe("Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const gistsListPublic200Schema = z.array(baseGistSchema.describe("Base Gist"))

/**
 * @description Not modified
 */
export const gistsListPublic304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const gistsListPublic403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const gistsListPublic422Schema = validationErrorSchema.describe("Validation Error")

export const gistsListPublicQueryResponseSchema = gistsListPublic200Schema

export const gistsListStarredQueryParamsSchema = z.object({
    "since": z.optional(z.iso.datetime({ offset: true }).describe("Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const gistsListStarred200Schema = z.array(baseGistSchema.describe("Base Gist"))

/**
 * @description Not modified
 */
export const gistsListStarred304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const gistsListStarred401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const gistsListStarred403Schema = basicErrorSchema.describe("Basic Error")

export const gistsListStarredQueryResponseSchema = gistsListStarred200Schema

export const gistsGetPathParamsSchema = z.object({
    "gist_id": z.string().describe("The unique identifier of the gist.")
    })

/**
 * @description Response
 */
export const gistsGet200Schema = gistSimpleSchema.describe("Gist Simple")

/**
 * @description Not modified
 */
export const gistsGet304Schema = z.unknown()

/**
 * @description Forbidden Gist
 */
export const gistsGet403Schema = z.object({
    "block": z.optional(z.object({
    "reason": z.optional(z.string()),
"created_at": z.optional(z.string()),
"html_url": z.string().nullish()
    })),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

/**
 * @description Resource not found
 */
export const gistsGet404Schema = basicErrorSchema.describe("Basic Error")

export const gistsGetQueryResponseSchema = gistsGet200Schema

export const gistsUpdatePathParamsSchema = z.object({
    "gist_id": z.string().describe("The unique identifier of the gist.")
    })

/**
 * @description Response
 */
export const gistsUpdate200Schema = gistSimpleSchema.describe("Gist Simple")

/**
 * @description Resource not found
 */
export const gistsUpdate404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const gistsUpdate422Schema = validationErrorSchema.describe("Validation Error")

export const gistsUpdateMutationRequestSchema = z.object({
    "description": z.optional(z.string().describe("The description of the gist.")),
"files": z.optional(z.object({
    
    }).catchall(z.object({
    "content": z.optional(z.string().describe("The new content of the file.")),
"filename": z.string().describe("The new filename for the file.").nullish()
    }).nullable()).describe("The gist files to be updated, renamed, or deleted. Each `key` must match the current filename\n(including extension) of the targeted gist file. For example: `hello.py`.\n\nTo delete a file, set the whole file to null. For example: `hello.py : null`. The file will also be\ndeleted if the specified object does not contain at least one of `content` or `filename`."))
    }).nullable()

export const gistsUpdateMutationResponseSchema = gistsUpdate200Schema

export const gistsDeletePathParamsSchema = z.object({
    "gist_id": z.string().describe("The unique identifier of the gist.")
    })

/**
 * @description Response
 */
export const gistsDelete204Schema = z.unknown()

/**
 * @description Not modified
 */
export const gistsDelete304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const gistsDelete403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const gistsDelete404Schema = basicErrorSchema.describe("Basic Error")

export const gistsDeleteMutationResponseSchema = gistsDelete204Schema

export const gistsListCommentsPathParamsSchema = z.object({
    "gist_id": z.string().describe("The unique identifier of the gist.")
    })

export const gistsListCommentsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const gistsListComments200Schema = z.array(gistCommentSchema.describe("A comment made to a gist."))

/**
 * @description Not modified
 */
export const gistsListComments304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const gistsListComments403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const gistsListComments404Schema = basicErrorSchema.describe("Basic Error")

export const gistsListCommentsQueryResponseSchema = gistsListComments200Schema

export const gistsCreateCommentPathParamsSchema = z.object({
    "gist_id": z.string().describe("The unique identifier of the gist.")
    })

/**
 * @description Response
 */
export const gistsCreateComment201Schema = gistCommentSchema.describe("A comment made to a gist.")

/**
 * @description Not modified
 */
export const gistsCreateComment304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const gistsCreateComment403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const gistsCreateComment404Schema = basicErrorSchema.describe("Basic Error")

export const gistsCreateCommentMutationRequestSchema = z.object({
    "body": z.string().max(65535).describe("The comment text.")
    })

export const gistsCreateCommentMutationResponseSchema = gistsCreateComment201Schema

export const gistsGetCommentPathParamsSchema = z.object({
    "gist_id": z.string().describe("The unique identifier of the gist."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

/**
 * @description Response
 */
export const gistsGetComment200Schema = gistCommentSchema.describe("A comment made to a gist.")

/**
 * @description Not modified
 */
export const gistsGetComment304Schema = z.unknown()

/**
 * @description Forbidden Gist
 */
export const gistsGetComment403Schema = z.object({
    "block": z.optional(z.object({
    "reason": z.optional(z.string()),
"created_at": z.optional(z.string()),
"html_url": z.string().nullish()
    })),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

/**
 * @description Resource not found
 */
export const gistsGetComment404Schema = basicErrorSchema.describe("Basic Error")

export const gistsGetCommentQueryResponseSchema = gistsGetComment200Schema

export const gistsUpdateCommentPathParamsSchema = z.object({
    "gist_id": z.string().describe("The unique identifier of the gist."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

/**
 * @description Response
 */
export const gistsUpdateComment200Schema = gistCommentSchema.describe("A comment made to a gist.")

/**
 * @description Resource not found
 */
export const gistsUpdateComment404Schema = basicErrorSchema.describe("Basic Error")

export const gistsUpdateCommentMutationRequestSchema = z.object({
    "body": z.string().max(65535).describe("The comment text.")
    })

export const gistsUpdateCommentMutationResponseSchema = gistsUpdateComment200Schema

export const gistsDeleteCommentPathParamsSchema = z.object({
    "gist_id": z.string().describe("The unique identifier of the gist."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

/**
 * @description Response
 */
export const gistsDeleteComment204Schema = z.unknown()

/**
 * @description Not modified
 */
export const gistsDeleteComment304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const gistsDeleteComment403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const gistsDeleteComment404Schema = basicErrorSchema.describe("Basic Error")

export const gistsDeleteCommentMutationResponseSchema = gistsDeleteComment204Schema

export const gistsListCommitsPathParamsSchema = z.object({
    "gist_id": z.string().describe("The unique identifier of the gist.")
    })

export const gistsListCommitsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const gistsListCommits200Schema = z.array(gistCommitSchema.describe("Gist Commit"))

/**
 * @description Not modified
 */
export const gistsListCommits304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const gistsListCommits403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const gistsListCommits404Schema = basicErrorSchema.describe("Basic Error")

export const gistsListCommitsQueryResponseSchema = gistsListCommits200Schema

export const gistsListForksPathParamsSchema = z.object({
    "gist_id": z.string().describe("The unique identifier of the gist.")
    })

export const gistsListForksQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const gistsListForks200Schema = z.array(gistSimpleSchema.describe("Gist Simple"))

/**
 * @description Not modified
 */
export const gistsListForks304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const gistsListForks403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const gistsListForks404Schema = basicErrorSchema.describe("Basic Error")

export const gistsListForksQueryResponseSchema = gistsListForks200Schema

export const gistsForkPathParamsSchema = z.object({
    "gist_id": z.string().describe("The unique identifier of the gist.")
    })

/**
 * @description Response
 */
export const gistsFork201Schema = baseGistSchema.describe("Base Gist")

/**
 * @description Not modified
 */
export const gistsFork304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const gistsFork403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const gistsFork404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const gistsFork422Schema = validationErrorSchema.describe("Validation Error")

export const gistsForkMutationResponseSchema = gistsFork201Schema

export const gistsCheckIsStarredPathParamsSchema = z.object({
    "gist_id": z.string().describe("The unique identifier of the gist.")
    })

/**
 * @description Response if gist is starred
 */
export const gistsCheckIsStarred204Schema = z.unknown()

/**
 * @description Not modified
 */
export const gistsCheckIsStarred304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const gistsCheckIsStarred403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Not Found if gist is not starred
 */
export const gistsCheckIsStarred404Schema = z.object({
    
    })

export const gistsCheckIsStarredQueryResponseSchema = gistsCheckIsStarred204Schema

export const gistsStarPathParamsSchema = z.object({
    "gist_id": z.string().describe("The unique identifier of the gist.")
    })

/**
 * @description Response
 */
export const gistsStar204Schema = z.unknown()

/**
 * @description Not modified
 */
export const gistsStar304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const gistsStar403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const gistsStar404Schema = basicErrorSchema.describe("Basic Error")

export const gistsStarMutationResponseSchema = gistsStar204Schema

export const gistsUnstarPathParamsSchema = z.object({
    "gist_id": z.string().describe("The unique identifier of the gist.")
    })

/**
 * @description Response
 */
export const gistsUnstar204Schema = z.unknown()

/**
 * @description Not modified
 */
export const gistsUnstar304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const gistsUnstar403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const gistsUnstar404Schema = basicErrorSchema.describe("Basic Error")

export const gistsUnstarMutationResponseSchema = gistsUnstar204Schema

export const gistsGetRevisionPathParamsSchema = z.object({
    "gist_id": z.string().describe("The unique identifier of the gist."),
"sha": z.string()
    })

/**
 * @description Response
 */
export const gistsGetRevision200Schema = gistSimpleSchema.describe("Gist Simple")

/**
 * @description Forbidden
 */
export const gistsGetRevision403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const gistsGetRevision404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const gistsGetRevision422Schema = validationErrorSchema.describe("Validation Error")

export const gistsGetRevisionQueryResponseSchema = gistsGetRevision200Schema

/**
 * @description Response
 */
export const gitignoreGetAllTemplates200Schema = z.array(z.string())

/**
 * @description Not modified
 */
export const gitignoreGetAllTemplates304Schema = z.unknown()

export const gitignoreGetAllTemplatesQueryResponseSchema = gitignoreGetAllTemplates200Schema

export const gitignoreGetTemplatePathParamsSchema = z.object({
    "name": z.string()
    })

/**
 * @description Response
 */
export const gitignoreGetTemplate200Schema = gitignoreTemplateSchema.describe("Gitignore Template")

/**
 * @description Not modified
 */
export const gitignoreGetTemplate304Schema = z.unknown()

export const gitignoreGetTemplateQueryResponseSchema = gitignoreGetTemplate200Schema

export const appsListReposAccessibleToInstallationQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const appsListReposAccessibleToInstallation200Schema = z.object({
    "total_count": z.int(),
get "repositories"(){
                return z.array(repositorySchema.describe("A repository on GitHub."))
              },
"repository_selection": z.optional(z.string())
    })

/**
 * @description Not modified
 */
export const appsListReposAccessibleToInstallation304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const appsListReposAccessibleToInstallation401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const appsListReposAccessibleToInstallation403Schema = basicErrorSchema.describe("Basic Error")

export const appsListReposAccessibleToInstallationQueryResponseSchema = appsListReposAccessibleToInstallation200Schema

/**
 * @description Response
 */
export const appsRevokeInstallationAccessToken204Schema = z.unknown()

export const appsRevokeInstallationAccessTokenMutationResponseSchema = appsRevokeInstallationAccessToken204Schema

export const issuesListQueryParamsSchema = z.object({
    "filter": z.enum(["assigned", "created", "mentioned", "subscribed", "repos", "all"]).default("assigned").describe("Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation."),
"state": z.enum(["open", "closed", "all"]).default("open").describe("Indicates the state of the issues to return."),
"labels": z.optional(z.string().describe("A list of comma separated label names. Example: `bug,ui,@high`")),
"sort": z.enum(["created", "updated", "comments"]).default("created").describe("What to sort results by."),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"since": z.optional(z.iso.datetime({ offset: true }).describe("Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"collab": z.optional(z.boolean()),
"orgs": z.optional(z.boolean()),
"owned": z.optional(z.boolean()),
"pulls": z.optional(z.boolean()),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesList200Schema = z.array(issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects."))

/**
 * @description Not modified
 */
export const issuesList304Schema = z.unknown()

/**
 * @description Resource not found
 */
export const issuesList404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const issuesList422Schema = validationErrorSchema.describe("Validation Error")

export const issuesListQueryResponseSchema = issuesList200Schema

export const licensesGetAllCommonlyUsedQueryParamsSchema = z.object({
    "featured": z.optional(z.boolean()),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const licensesGetAllCommonlyUsed200Schema = z.array(licenseSimpleSchema.describe("License Simple"))

/**
 * @description Not modified
 */
export const licensesGetAllCommonlyUsed304Schema = z.unknown()

export const licensesGetAllCommonlyUsedQueryResponseSchema = licensesGetAllCommonlyUsed200Schema

export const licensesGetPathParamsSchema = z.object({
    "license": z.string()
    })

/**
 * @description Response
 */
export const licensesGet200Schema = licenseSchema.describe("License")

/**
 * @description Not modified
 */
export const licensesGet304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const licensesGet403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const licensesGet404Schema = basicErrorSchema.describe("Basic Error")

export const licensesGetQueryResponseSchema = licensesGet200Schema

/**
 * @description Response
 */
export const markdownRender200Schema = z.string()

/**
 * @description Not modified
 */
export const markdownRender304Schema = z.unknown()

export const markdownRenderMutationRequestSchema = z.object({
    "text": z.string().describe("The Markdown text to render in HTML."),
"mode": z.optional(z.enum(["markdown", "gfm"]).default("markdown").describe("The rendering mode.")),
"context": z.optional(z.string().describe("The repository context to use when creating references in `gfm` mode.  For example, setting `context` to `octo-org/octo-repo` will change the text `#42` into an HTML link to issue 42 in the `octo-org/octo-repo` repository."))
    })

export const markdownRenderMutationResponseSchema = markdownRender200Schema

/**
 * @description Response
 */
export const markdownRenderRaw200Schema = z.string()

/**
 * @description Not modified
 */
export const markdownRenderRaw304Schema = z.unknown()

export const markdownRenderRawMutationRequestSchema = z.string()

export const markdownRenderRawMutationResponseSchema = markdownRenderRaw200Schema

export const appsGetSubscriptionPlanForAccountPathParamsSchema = z.object({
    "account_id": z.coerce.number().int().describe("account_id parameter")
    })

/**
 * @description Response
 */
export const appsGetSubscriptionPlanForAccount200Schema = marketplacePurchaseSchema.describe("Marketplace Purchase")

/**
 * @description Requires authentication
 */
export const appsGetSubscriptionPlanForAccount401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Not Found when the account has not purchased the listing
 */
export const appsGetSubscriptionPlanForAccount404Schema = basicErrorSchema.describe("Basic Error")

export const appsGetSubscriptionPlanForAccountQueryResponseSchema = appsGetSubscriptionPlanForAccount200Schema

export const appsListPlansQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const appsListPlans200Schema = z.array(marketplaceListingPlanSchema.describe("Marketplace Listing Plan"))

/**
 * @description Requires authentication
 */
export const appsListPlans401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const appsListPlans404Schema = basicErrorSchema.describe("Basic Error")

export const appsListPlansQueryResponseSchema = appsListPlans200Schema

export const appsListAccountsForPlanPathParamsSchema = z.object({
    "plan_id": z.coerce.number().int().describe("The unique identifier of the plan.")
    })

export const appsListAccountsForPlanQueryParamsSchema = z.object({
    "sort": z.enum(["created", "updated"]).default("created").describe("The property to sort the results by."),
"direction": z.optional(z.enum(["asc", "desc"]).describe("To return the oldest accounts first, set to `asc`. Ignored without the `sort` parameter.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const appsListAccountsForPlan200Schema = z.array(marketplacePurchaseSchema.describe("Marketplace Purchase"))

/**
 * @description Requires authentication
 */
export const appsListAccountsForPlan401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const appsListAccountsForPlan404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const appsListAccountsForPlan422Schema = validationErrorSchema.describe("Validation Error")

export const appsListAccountsForPlanQueryResponseSchema = appsListAccountsForPlan200Schema

export const appsGetSubscriptionPlanForAccountStubbedPathParamsSchema = z.object({
    "account_id": z.coerce.number().int().describe("account_id parameter")
    })

/**
 * @description Response
 */
export const appsGetSubscriptionPlanForAccountStubbed200Schema = marketplacePurchaseSchema.describe("Marketplace Purchase")

/**
 * @description Requires authentication
 */
export const appsGetSubscriptionPlanForAccountStubbed401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Not Found when the account has not purchased the listing
 */
export const appsGetSubscriptionPlanForAccountStubbed404Schema = z.unknown()

export const appsGetSubscriptionPlanForAccountStubbedQueryResponseSchema = appsGetSubscriptionPlanForAccountStubbed200Schema

export const appsListPlansStubbedQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const appsListPlansStubbed200Schema = z.array(marketplaceListingPlanSchema.describe("Marketplace Listing Plan"))

/**
 * @description Requires authentication
 */
export const appsListPlansStubbed401Schema = basicErrorSchema.describe("Basic Error")

export const appsListPlansStubbedQueryResponseSchema = appsListPlansStubbed200Schema

export const appsListAccountsForPlanStubbedPathParamsSchema = z.object({
    "plan_id": z.coerce.number().int().describe("The unique identifier of the plan.")
    })

export const appsListAccountsForPlanStubbedQueryParamsSchema = z.object({
    "sort": z.enum(["created", "updated"]).default("created").describe("The property to sort the results by."),
"direction": z.optional(z.enum(["asc", "desc"]).describe("To return the oldest accounts first, set to `asc`. Ignored without the `sort` parameter.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const appsListAccountsForPlanStubbed200Schema = z.array(marketplacePurchaseSchema.describe("Marketplace Purchase"))

/**
 * @description Requires authentication
 */
export const appsListAccountsForPlanStubbed401Schema = basicErrorSchema.describe("Basic Error")

export const appsListAccountsForPlanStubbedQueryResponseSchema = appsListAccountsForPlanStubbed200Schema

/**
 * @description Response
 */
export const metaGet200Schema = apiOverviewSchema.describe("Api Overview")

/**
 * @description Not modified
 */
export const metaGet304Schema = z.unknown()

export const metaGetQueryResponseSchema = metaGet200Schema

export const activityListPublicEventsForRepoNetworkPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const activityListPublicEventsForRepoNetworkQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListPublicEventsForRepoNetwork200Schema = z.array(eventSchema.describe("Event"))

/**
 * @description Moved permanently
 */
export const activityListPublicEventsForRepoNetwork301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Not modified
 */
export const activityListPublicEventsForRepoNetwork304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const activityListPublicEventsForRepoNetwork403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const activityListPublicEventsForRepoNetwork404Schema = basicErrorSchema.describe("Basic Error")

export const activityListPublicEventsForRepoNetworkQueryResponseSchema = activityListPublicEventsForRepoNetwork200Schema

export const activityListNotificationsForAuthenticatedUserQueryParamsSchema = z.object({
    "all": z.boolean().default(false).describe("If `true`, show notifications marked as read."),
"participating": z.boolean().default(false).describe("If `true`, only shows notifications in which the user is directly participating or mentioned."),
"since": z.optional(z.iso.datetime({ offset: true }).describe("Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"before": z.optional(z.iso.datetime({ offset: true }).describe("Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(50).describe("The number of results per page (max 50). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListNotificationsForAuthenticatedUser200Schema = z.array(threadSchema.describe("Thread"))

/**
 * @description Not modified
 */
export const activityListNotificationsForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const activityListNotificationsForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const activityListNotificationsForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const activityListNotificationsForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const activityListNotificationsForAuthenticatedUserQueryResponseSchema = activityListNotificationsForAuthenticatedUser200Schema

/**
 * @description Response
 */
export const activityMarkNotificationsAsRead202Schema = z.object({
    "message": z.optional(z.string())
    })

/**
 * @description Reset Content
 */
export const activityMarkNotificationsAsRead205Schema = z.unknown()

/**
 * @description Not modified
 */
export const activityMarkNotificationsAsRead304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const activityMarkNotificationsAsRead401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const activityMarkNotificationsAsRead403Schema = basicErrorSchema.describe("Basic Error")

export const activityMarkNotificationsAsReadMutationRequestSchema = z.object({
    "last_read_at": z.optional(z.iso.datetime({ offset: true }).describe("Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.")),
"read": z.optional(z.boolean().describe("Whether the notification has been read."))
    })

export const activityMarkNotificationsAsReadMutationResponseSchema = z.union([activityMarkNotificationsAsRead202Schema, activityMarkNotificationsAsRead205Schema])

export const activityGetThreadPathParamsSchema = z.object({
    "thread_id": z.coerce.number().int().describe("The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).")
    })

/**
 * @description Response
 */
export const activityGetThread200Schema = threadSchema.describe("Thread")

/**
 * @description Not modified
 */
export const activityGetThread304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const activityGetThread401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const activityGetThread403Schema = basicErrorSchema.describe("Basic Error")

export const activityGetThreadQueryResponseSchema = activityGetThread200Schema

export const activityMarkThreadAsReadPathParamsSchema = z.object({
    "thread_id": z.coerce.number().int().describe("The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).")
    })

/**
 * @description Reset Content
 */
export const activityMarkThreadAsRead205Schema = z.unknown()

/**
 * @description Not modified
 */
export const activityMarkThreadAsRead304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const activityMarkThreadAsRead403Schema = basicErrorSchema.describe("Basic Error")

export const activityMarkThreadAsReadMutationResponseSchema = activityMarkThreadAsRead205Schema

export const activityMarkThreadAsDonePathParamsSchema = z.object({
    "thread_id": z.coerce.number().int().describe("The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).")
    })

/**
 * @description No content
 */
export const activityMarkThreadAsDone204Schema = z.unknown()

export const activityMarkThreadAsDoneMutationResponseSchema = activityMarkThreadAsDone204Schema

export const activityGetThreadSubscriptionForAuthenticatedUserPathParamsSchema = z.object({
    "thread_id": z.coerce.number().int().describe("The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).")
    })

/**
 * @description Response
 */
export const activityGetThreadSubscriptionForAuthenticatedUser200Schema = threadSubscriptionSchema.describe("Thread Subscription")

/**
 * @description Not modified
 */
export const activityGetThreadSubscriptionForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const activityGetThreadSubscriptionForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const activityGetThreadSubscriptionForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

export const activityGetThreadSubscriptionForAuthenticatedUserQueryResponseSchema = activityGetThreadSubscriptionForAuthenticatedUser200Schema

export const activitySetThreadSubscriptionPathParamsSchema = z.object({
    "thread_id": z.coerce.number().int().describe("The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).")
    })

/**
 * @description Response
 */
export const activitySetThreadSubscription200Schema = threadSubscriptionSchema.describe("Thread Subscription")

/**
 * @description Not modified
 */
export const activitySetThreadSubscription304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const activitySetThreadSubscription401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const activitySetThreadSubscription403Schema = basicErrorSchema.describe("Basic Error")

export const activitySetThreadSubscriptionMutationRequestSchema = z.object({
    "ignored": z.optional(z.boolean().default(false).describe("Whether to block all notifications from a thread."))
    })

export const activitySetThreadSubscriptionMutationResponseSchema = activitySetThreadSubscription200Schema

export const activityDeleteThreadSubscriptionPathParamsSchema = z.object({
    "thread_id": z.coerce.number().int().describe("The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).")
    })

/**
 * @description Response
 */
export const activityDeleteThreadSubscription204Schema = z.unknown()

/**
 * @description Not modified
 */
export const activityDeleteThreadSubscription304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const activityDeleteThreadSubscription401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const activityDeleteThreadSubscription403Schema = basicErrorSchema.describe("Basic Error")

export const activityDeleteThreadSubscriptionMutationResponseSchema = activityDeleteThreadSubscription204Schema

export const metaGetOctocatQueryParamsSchema = z.object({
    "s": z.optional(z.string().describe("The words to show in Octocat's speech bubble"))
    }).optional()

/**
 * @description Response
 */
export const metaGetOctocat200Schema = z.string()

export const metaGetOctocatQueryResponseSchema = metaGetOctocat200Schema

export const orgsListQueryParamsSchema = z.object({
    "since": z.optional(z.coerce.number().int().describe("An organization ID. Only return organizations with an ID greater than this ID.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const orgsList200Schema = z.array(organizationSimpleSchema.describe("A GitHub organization."))

/**
 * @description Not modified
 */
export const orgsList304Schema = z.unknown()

export const orgsListQueryResponseSchema = orgsList200Schema

export const dependabotRepositoryAccessForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const dependabotRepositoryAccessForOrgQueryParamsSchema = z.object({
    "page": z.coerce.number().int().min(1).default(1).describe("The page number of results to fetch."),
"per_page": z.coerce.number().int().min(1).max(100).default(30).describe("Number of results per page.")
    })

/**
 * @description Response
 */
export const dependabotRepositoryAccessForOrg200Schema = dependabotRepositoryAccessDetailsSchema.describe("Information about repositories that Dependabot is able to access in an organization")

/**
 * @description Forbidden
 */
export const dependabotRepositoryAccessForOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const dependabotRepositoryAccessForOrg404Schema = basicErrorSchema.describe("Basic Error")

export const dependabotRepositoryAccessForOrgQueryResponseSchema = dependabotRepositoryAccessForOrg200Schema

export const dependabotUpdateRepositoryAccessForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const dependabotUpdateRepositoryAccessForOrg204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const dependabotUpdateRepositoryAccessForOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const dependabotUpdateRepositoryAccessForOrg404Schema = basicErrorSchema.describe("Basic Error")

export const dependabotUpdateRepositoryAccessForOrgMutationRequestSchema = z.object({
    "repository_ids_to_add": z.optional(z.array(z.int()).describe("List of repository IDs to add.")),
"repository_ids_to_remove": z.optional(z.array(z.int()).describe("List of repository IDs to remove."))
    })

export const dependabotUpdateRepositoryAccessForOrgMutationResponseSchema = dependabotUpdateRepositoryAccessForOrg204Schema

export const dependabotSetRepositoryAccessDefaultLevelPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const dependabotSetRepositoryAccessDefaultLevel204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const dependabotSetRepositoryAccessDefaultLevel403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const dependabotSetRepositoryAccessDefaultLevel404Schema = basicErrorSchema.describe("Basic Error")

export const dependabotSetRepositoryAccessDefaultLevelMutationRequestSchema = z.object({
    "default_level": z.enum(["public", "internal"]).describe("The default repository access level for Dependabot updates.")
    })

export const dependabotSetRepositoryAccessDefaultLevelMutationResponseSchema = dependabotSetRepositoryAccessDefaultLevel204Schema

export const orgsCustomPropertiesForOrgsGetOrganizationValuesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const orgsCustomPropertiesForOrgsGetOrganizationValues200Schema = z.array(customPropertyValueSchema.describe("Custom property name and associated value"))

/**
 * @description Forbidden
 */
export const orgsCustomPropertiesForOrgsGetOrganizationValues403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsCustomPropertiesForOrgsGetOrganizationValues404Schema = basicErrorSchema.describe("Basic Error")

export const orgsCustomPropertiesForOrgsGetOrganizationValuesQueryResponseSchema = orgsCustomPropertiesForOrgsGetOrganizationValues200Schema

export const orgsCustomPropertiesForOrgsCreateOrUpdateOrganizationValuesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description No Content when custom property values are successfully created or updated
 */
export const orgsCustomPropertiesForOrgsCreateOrUpdateOrganizationValues204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const orgsCustomPropertiesForOrgsCreateOrUpdateOrganizationValues403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsCustomPropertiesForOrgsCreateOrUpdateOrganizationValues404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsCustomPropertiesForOrgsCreateOrUpdateOrganizationValues422Schema = validationErrorSchema.describe("Validation Error")

export const orgsCustomPropertiesForOrgsCreateOrUpdateOrganizationValuesMutationRequestSchema = z.object({
    get "properties"(){
                return z.array(customPropertyValueSchema.describe("Custom property name and associated value")).describe("A list of custom property names and associated values to apply to the organization.")
              }
    })

export const orgsCustomPropertiesForOrgsCreateOrUpdateOrganizationValuesMutationResponseSchema = orgsCustomPropertiesForOrgsCreateOrUpdateOrganizationValues204Schema

export const billingGetGithubBillingPremiumRequestUsageReportOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const billingGetGithubBillingPremiumRequestUsageReportOrgQueryParamsSchema = z.object({
    "year": z.optional(z.coerce.number().int().describe("If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year.")),
"month": z.optional(z.coerce.number().int().describe("If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. Default value is the current month. If no year is specified the default `year` is used.")),
"day": z.optional(z.coerce.number().int().describe("If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used.")),
"user": z.optional(z.string().describe("The user name to query usage for. The name is not case sensitive.")),
"model": z.optional(z.string().describe("The model name to query usage for. The name is not case sensitive.")),
"product": z.optional(z.string().describe("The product name to query usage for. The name is not case sensitive."))
    }).optional()

/**
 * @description Response when getting a billing premium request usage report
 */
export const billingGetGithubBillingPremiumRequestUsageReportOrg200Schema = billingPremiumRequestUsageReportOrgSchema

/**
 * @description Bad Request
 */
export const billingGetGithubBillingPremiumRequestUsageReportOrg400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const billingGetGithubBillingPremiumRequestUsageReportOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const billingGetGithubBillingPremiumRequestUsageReportOrg404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const billingGetGithubBillingPremiumRequestUsageReportOrg500Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const billingGetGithubBillingPremiumRequestUsageReportOrg503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const billingGetGithubBillingPremiumRequestUsageReportOrgQueryResponseSchema = billingGetGithubBillingPremiumRequestUsageReportOrg200Schema

export const billingGetGithubBillingUsageReportOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const billingGetGithubBillingUsageReportOrgQueryParamsSchema = z.object({
    "year": z.optional(z.coerce.number().int().describe("If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year.")),
"month": z.optional(z.coerce.number().int().describe("If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. If no year is specified the default `year` is used.")),
"day": z.optional(z.coerce.number().int().describe("If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used.")),
"hour": z.optional(z.coerce.number().int().describe("If specified, only return results for a single hour. The value of `hour` is an integer between `0` and `23`. If no `year`, `month`, or `day` is specified, the default `year`, `month`, and `day` are used."))
    }).optional()

/**
 * @description Billing usage report response for an organization
 */
export const billingGetGithubBillingUsageReportOrg200Schema = billingUsageReportSchema

/**
 * @description Bad Request
 */
export const billingGetGithubBillingUsageReportOrg400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const billingGetGithubBillingUsageReportOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const billingGetGithubBillingUsageReportOrg500Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const billingGetGithubBillingUsageReportOrg503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const billingGetGithubBillingUsageReportOrgQueryResponseSchema = billingGetGithubBillingUsageReportOrg200Schema

export const orgsGetPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const orgsGet200Schema = organizationFullSchema.describe("Organization Full")

/**
 * @description Resource not found
 */
export const orgsGet404Schema = basicErrorSchema.describe("Basic Error")

export const orgsGetQueryResponseSchema = orgsGet200Schema

export const orgsUpdatePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const orgsUpdate200Schema = organizationFullSchema.describe("Organization Full")

/**
 * @description Conflict
 */
export const orgsUpdate409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed
 */
export const orgsUpdate422Schema = z.union([validationErrorSchema, validationErrorSimpleSchema])

export const orgsUpdateMutationRequestSchema = z.object({
    "billing_email": z.optional(z.string().describe("Billing email address. This address is not publicized.")),
"company": z.optional(z.string().describe("The company name.")),
"email": z.optional(z.string().describe("The publicly visible email address.")),
"twitter_username": z.optional(z.string().describe("The Twitter username of the company.")),
"location": z.optional(z.string().describe("The location.")),
"name": z.optional(z.string().describe("The shorthand name of the company.")),
"description": z.optional(z.string().describe("The description of the company. The maximum size is 160 characters.")),
"has_organization_projects": z.optional(z.boolean().describe("Whether an organization can use organization projects.")),
"has_repository_projects": z.optional(z.boolean().describe("Whether repositories that belong to the organization can use repository projects.")),
"default_repository_permission": z.optional(z.enum(["read", "write", "admin", "none"]).default("read").describe("Default permission level members have for organization repositories.")),
"members_can_create_repositories": z.optional(z.boolean().default(true).describe("Whether of non-admin organization members can create repositories. **Note:** A parameter can override this parameter. See `members_allowed_repository_creation_type` in this table for details.")),
"members_can_create_internal_repositories": z.optional(z.boolean().describe("Whether organization members can create internal repositories, which are visible to all enterprise members. You can only allow members to create internal repositories if your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see \"[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)\" in the GitHub Help documentation.")),
"members_can_create_private_repositories": z.optional(z.boolean().describe("Whether organization members can create private repositories, which are visible to organization members with permission. For more information, see \"[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)\" in the GitHub Help documentation.")),
"members_can_create_public_repositories": z.optional(z.boolean().describe("Whether organization members can create public repositories, which are visible to anyone. For more information, see \"[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)\" in the GitHub Help documentation.")),
"members_allowed_repository_creation_type": z.optional(z.enum(["all", "private", "none"]).describe("Specifies which types of repositories non-admin organization members can create. `private` is only available to repositories that are part of an organization on GitHub Enterprise Cloud. \n**Note:** This parameter is closing down and will be removed in the future. Its return value ignores internal repositories. Using this parameter overrides values set in `members_can_create_repositories`. See the parameter deprecation notice in the operation description for details.")),
"members_can_create_pages": z.optional(z.boolean().default(true).describe("Whether organization members can create GitHub Pages sites. Existing published sites will not be impacted.")),
"members_can_create_public_pages": z.optional(z.boolean().default(true).describe("Whether organization members can create public GitHub Pages sites. Existing published sites will not be impacted.")),
"members_can_create_private_pages": z.optional(z.boolean().default(true).describe("Whether organization members can create private GitHub Pages sites. Existing published sites will not be impacted.")),
"members_can_fork_private_repositories": z.optional(z.boolean().default(false).describe("Whether organization members can fork private organization repositories.")),
"web_commit_signoff_required": z.optional(z.boolean().default(false).describe("Whether contributors to organization repositories are required to sign off on commits they make through GitHub's web interface.")),
"blog": z.optional(z.string()),
"advanced_security_enabled_for_new_repositories": z.optional(z.boolean().describe("**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether GitHub Advanced Security is automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.")),
"dependabot_alerts_enabled_for_new_repositories": z.optional(z.boolean().describe("**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether Dependabot alerts are automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.")),
"dependabot_security_updates_enabled_for_new_repositories": z.optional(z.boolean().describe("**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether Dependabot security updates are automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.")),
"dependency_graph_enabled_for_new_repositories": z.optional(z.boolean().describe("**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether dependency graph is automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.")),
"secret_scanning_enabled_for_new_repositories": z.optional(z.boolean().describe("**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether secret scanning is automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.")),
"secret_scanning_push_protection_enabled_for_new_repositories": z.optional(z.boolean().describe("**Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.\n\nWhether secret scanning push protection is automatically enabled for new repositories and repositories transferred to this organization.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.")),
"secret_scanning_push_protection_custom_link_enabled": z.optional(z.boolean().describe("Whether a custom link is shown to contributors who are blocked from pushing a secret by push protection.")),
"secret_scanning_push_protection_custom_link": z.optional(z.string().describe("If `secret_scanning_push_protection_custom_link_enabled` is true, the URL that will be displayed to contributors who are blocked from pushing a secret.")),
"deploy_keys_enabled_for_repositories": z.optional(z.boolean().describe("Controls whether or not deploy keys may be added and used for repositories in the organization."))
    })

export const orgsUpdateMutationResponseSchema = orgsUpdate200Schema

export const orgsDeletePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Accepted
 */
export const orgsDelete202Schema = z.object({
    
    })

/**
 * @description Forbidden
 */
export const orgsDelete403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsDelete404Schema = basicErrorSchema.describe("Basic Error")

export const orgsDeleteMutationResponseSchema = orgsDelete202Schema

export const actionsGetActionsCacheUsageForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetActionsCacheUsageForOrg200Schema = actionsCacheUsageOrgEnterpriseSchema

export const actionsGetActionsCacheUsageForOrgQueryResponseSchema = actionsGetActionsCacheUsageForOrg200Schema

export const actionsGetActionsCacheUsageByRepoForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const actionsGetActionsCacheUsageByRepoForOrgQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsGetActionsCacheUsageByRepoForOrg200Schema = z.object({
    "total_count": z.int(),
get "repository_cache_usages"(){
                return z.array(actionsCacheUsageByRepositorySchema.describe("GitHub Actions Cache Usage by repository."))
              }
    })

export const actionsGetActionsCacheUsageByRepoForOrgQueryResponseSchema = actionsGetActionsCacheUsageByRepoForOrg200Schema

export const actionsListHostedRunnersForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const actionsListHostedRunnersForOrgQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListHostedRunnersForOrg200Schema = z.object({
    "total_count": z.int(),
get "runners"(){
                return z.array(actionsHostedRunnerSchema.describe("A Github-hosted hosted runner."))
              }
    })

export const actionsListHostedRunnersForOrgQueryResponseSchema = actionsListHostedRunnersForOrg200Schema

export const actionsCreateHostedRunnerForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsCreateHostedRunnerForOrg201Schema = actionsHostedRunnerSchema.describe("A Github-hosted hosted runner.")

export const actionsCreateHostedRunnerForOrgMutationRequestSchema = z.object({
    "name": z.string().describe("Name of the runner. Must be between 1 and 64 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'."),
"image": z.object({
    "id": z.optional(z.string().describe("The unique identifier of the runner image.")),
"source": z.optional(z.enum(["github", "partner", "custom"]).describe("The source of the runner image.")),
"version": z.string().describe("The version of the runner image to deploy. This is relevant only for runners using custom images.").nullish()
    }).describe("The image of runner. To list all available images, use `GET /actions/hosted-runners/images/github-owned` or `GET /actions/hosted-runners/images/partner`."),
"size": z.string().describe("The machine size of the runner. To list available sizes, use `GET actions/hosted-runners/machine-sizes`"),
"runner_group_id": z.int().describe("The existing runner group to add this runner to."),
"maximum_runners": z.optional(z.int().describe("The maximum amount of runners to scale up to. Runners will not auto-scale above this number. Use this setting to limit your cost.")),
"enable_static_ip": z.optional(z.boolean().describe("Whether this runner should be created with a static public IP. Note limit on account. To list limits on account, use `GET actions/hosted-runners/limits`")),
"image_gen": z.optional(z.boolean().default(false).describe("Whether this runner should be used to generate custom images."))
    })

export const actionsCreateHostedRunnerForOrgMutationResponseSchema = actionsCreateHostedRunnerForOrg201Schema

export const actionsListCustomImagesForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsListCustomImagesForOrg200Schema = z.object({
    "total_count": z.int(),
get "images"(){
                return z.array(actionsHostedRunnerCustomImageSchema.describe("Provides details of a custom runner image"))
              }
    })

export const actionsListCustomImagesForOrgQueryResponseSchema = actionsListCustomImagesForOrg200Schema

export const actionsGetCustomImageForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"image_definition_id": z.coerce.number().int().describe("Image definition ID of custom image")
    })

/**
 * @description Response
 */
export const actionsGetCustomImageForOrg200Schema = actionsHostedRunnerCustomImageSchema.describe("Provides details of a custom runner image")

export const actionsGetCustomImageForOrgQueryResponseSchema = actionsGetCustomImageForOrg200Schema

export const actionsDeleteCustomImageFromOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"image_definition_id": z.coerce.number().int().describe("Image definition ID of custom image")
    })

/**
 * @description Response
 */
export const actionsDeleteCustomImageFromOrg204Schema = z.unknown()

export const actionsDeleteCustomImageFromOrgMutationResponseSchema = actionsDeleteCustomImageFromOrg204Schema

export const actionsListCustomImageVersionsForOrgPathParamsSchema = z.object({
    "image_definition_id": z.coerce.number().int().describe("Image definition ID of custom image"),
"org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsListCustomImageVersionsForOrg200Schema = z.object({
    "total_count": z.int(),
get "image_versions"(){
                return z.array(actionsHostedRunnerCustomImageVersionSchema.describe("Provides details of a hosted runner custom image version"))
              }
    })

export const actionsListCustomImageVersionsForOrgQueryResponseSchema = actionsListCustomImageVersionsForOrg200Schema

export const actionsGetCustomImageVersionForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"image_definition_id": z.coerce.number().int().describe("Image definition ID of custom image"),
"version": z.string().regex(/^\d+\.\d+\.\d+$/).describe("Version of a custom image")
    })

/**
 * @description Response
 */
export const actionsGetCustomImageVersionForOrg200Schema = actionsHostedRunnerCustomImageVersionSchema.describe("Provides details of a hosted runner custom image version")

export const actionsGetCustomImageVersionForOrgQueryResponseSchema = actionsGetCustomImageVersionForOrg200Schema

export const actionsDeleteCustomImageVersionFromOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"image_definition_id": z.coerce.number().int().describe("Image definition ID of custom image"),
"version": z.string().regex(/^\d+\.\d+\.\d+$/).describe("Version of a custom image")
    })

/**
 * @description Response
 */
export const actionsDeleteCustomImageVersionFromOrg204Schema = z.unknown()

export const actionsDeleteCustomImageVersionFromOrgMutationResponseSchema = actionsDeleteCustomImageVersionFromOrg204Schema

export const actionsGetHostedRunnersGithubOwnedImagesForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetHostedRunnersGithubOwnedImagesForOrg200Schema = z.object({
    "total_count": z.int(),
get "images"(){
                return z.array(actionsHostedRunnerCuratedImageSchema.describe("Provides details of a hosted runner image"))
              }
    })

export const actionsGetHostedRunnersGithubOwnedImagesForOrgQueryResponseSchema = actionsGetHostedRunnersGithubOwnedImagesForOrg200Schema

export const actionsGetHostedRunnersPartnerImagesForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetHostedRunnersPartnerImagesForOrg200Schema = z.object({
    "total_count": z.int(),
get "images"(){
                return z.array(actionsHostedRunnerCuratedImageSchema.describe("Provides details of a hosted runner image"))
              }
    })

export const actionsGetHostedRunnersPartnerImagesForOrgQueryResponseSchema = actionsGetHostedRunnersPartnerImagesForOrg200Schema

export const actionsGetHostedRunnersLimitsForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetHostedRunnersLimitsForOrg200Schema = actionsHostedRunnerLimitsSchema

export const actionsGetHostedRunnersLimitsForOrgQueryResponseSchema = actionsGetHostedRunnersLimitsForOrg200Schema

export const actionsGetHostedRunnersMachineSpecsForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetHostedRunnersMachineSpecsForOrg200Schema = z.object({
    "total_count": z.int(),
get "machine_specs"(){
                return z.array(actionsHostedRunnerMachineSpecSchema.describe("Provides details of a particular machine spec."))
              }
    })

export const actionsGetHostedRunnersMachineSpecsForOrgQueryResponseSchema = actionsGetHostedRunnersMachineSpecsForOrg200Schema

export const actionsGetHostedRunnersPlatformsForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetHostedRunnersPlatformsForOrg200Schema = z.object({
    "total_count": z.int(),
"platforms": z.array(z.string())
    })

export const actionsGetHostedRunnersPlatformsForOrgQueryResponseSchema = actionsGetHostedRunnersPlatformsForOrg200Schema

export const actionsGetHostedRunnerForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"hosted_runner_id": z.coerce.number().int().describe("Unique identifier of the GitHub-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsGetHostedRunnerForOrg200Schema = actionsHostedRunnerSchema.describe("A Github-hosted hosted runner.")

export const actionsGetHostedRunnerForOrgQueryResponseSchema = actionsGetHostedRunnerForOrg200Schema

export const actionsUpdateHostedRunnerForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"hosted_runner_id": z.coerce.number().int().describe("Unique identifier of the GitHub-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsUpdateHostedRunnerForOrg200Schema = actionsHostedRunnerSchema.describe("A Github-hosted hosted runner.")

export const actionsUpdateHostedRunnerForOrgMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("Name of the runner. Must be between 1 and 64 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'.")),
"runner_group_id": z.optional(z.int().describe("The existing runner group to add this runner to.")),
"maximum_runners": z.optional(z.int().describe("The maximum amount of runners to scale up to. Runners will not auto-scale above this number. Use this setting to limit your cost.")),
"enable_static_ip": z.optional(z.boolean().describe("Whether this runner should be updated with a static public IP. Note limit on account. To list limits on account, use `GET actions/hosted-runners/limits`")),
"image_version": z.string().describe("The version of the runner image to deploy. This is relevant only for runners using custom images.").nullish()
    })

export const actionsUpdateHostedRunnerForOrgMutationResponseSchema = actionsUpdateHostedRunnerForOrg200Schema

export const actionsDeleteHostedRunnerForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"hosted_runner_id": z.coerce.number().int().describe("Unique identifier of the GitHub-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsDeleteHostedRunnerForOrg202Schema = actionsHostedRunnerSchema.describe("A Github-hosted hosted runner.")

export const actionsDeleteHostedRunnerForOrgMutationResponseSchema = actionsDeleteHostedRunnerForOrg202Schema

export const oidcGetOidcCustomSubTemplateForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description A JSON serialized template for OIDC subject claim customization
 */
export const oidcGetOidcCustomSubTemplateForOrg200Schema = oidcCustomSubSchema.describe("Actions OIDC Subject customization")

export const oidcGetOidcCustomSubTemplateForOrgQueryResponseSchema = oidcGetOidcCustomSubTemplateForOrg200Schema

export const oidcUpdateOidcCustomSubTemplateForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Empty response
 */
export const oidcUpdateOidcCustomSubTemplateForOrg201Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Forbidden
 */
export const oidcUpdateOidcCustomSubTemplateForOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const oidcUpdateOidcCustomSubTemplateForOrg404Schema = basicErrorSchema.describe("Basic Error")

export const oidcUpdateOidcCustomSubTemplateForOrgMutationRequestSchema = oidcCustomSubSchema.describe("Actions OIDC Subject customization")

export const oidcUpdateOidcCustomSubTemplateForOrgMutationResponseSchema = oidcUpdateOidcCustomSubTemplateForOrg201Schema

export const actionsGetGithubActionsPermissionsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetGithubActionsPermissionsOrganization200Schema = actionsOrganizationPermissionsSchema

export const actionsGetGithubActionsPermissionsOrganizationQueryResponseSchema = actionsGetGithubActionsPermissionsOrganization200Schema

export const actionsSetGithubActionsPermissionsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsSetGithubActionsPermissionsOrganization204Schema = z.unknown()

export const actionsSetGithubActionsPermissionsOrganizationMutationRequestSchema = z.object({
    get "enabled_repositories"(){
                return enabledRepositoriesSchema.describe("The policy that controls the repositories in the organization that are allowed to run GitHub Actions.")
              },
get "allowed_actions"(){
                return allowedActionsSchema.describe("The permissions policy that controls the actions and reusable workflows that are allowed to run.").optional()
              },
get "sha_pinning_required"(){
                return shaPinningRequiredSchema.describe("Whether actions must be pinned to a full-length commit SHA.").optional()
              }
    })

export const actionsSetGithubActionsPermissionsOrganizationMutationResponseSchema = actionsSetGithubActionsPermissionsOrganization204Schema

export const actionsGetArtifactAndLogRetentionSettingsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetArtifactAndLogRetentionSettingsOrganization200Schema = actionsArtifactAndLogRetentionResponseSchema

/**
 * @description Forbidden
 */
export const actionsGetArtifactAndLogRetentionSettingsOrganization403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const actionsGetArtifactAndLogRetentionSettingsOrganization404Schema = basicErrorSchema.describe("Basic Error")

export const actionsGetArtifactAndLogRetentionSettingsOrganizationQueryResponseSchema = actionsGetArtifactAndLogRetentionSettingsOrganization200Schema

export const actionsSetArtifactAndLogRetentionSettingsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description No content
 */
export const actionsSetArtifactAndLogRetentionSettingsOrganization204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const actionsSetArtifactAndLogRetentionSettingsOrganization403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const actionsSetArtifactAndLogRetentionSettingsOrganization404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const actionsSetArtifactAndLogRetentionSettingsOrganization409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsSetArtifactAndLogRetentionSettingsOrganization422Schema = validationErrorSchema.describe("Validation Error")

export const actionsSetArtifactAndLogRetentionSettingsOrganizationMutationRequestSchema = actionsArtifactAndLogRetentionSchema

export const actionsSetArtifactAndLogRetentionSettingsOrganizationMutationResponseSchema = actionsSetArtifactAndLogRetentionSettingsOrganization204Schema

export const actionsGetForkPrContributorApprovalPermissionsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetForkPrContributorApprovalPermissionsOrganization200Schema = actionsForkPrContributorApprovalSchema

/**
 * @description Resource not found
 */
export const actionsGetForkPrContributorApprovalPermissionsOrganization404Schema = basicErrorSchema.describe("Basic Error")

export const actionsGetForkPrContributorApprovalPermissionsOrganizationQueryResponseSchema = actionsGetForkPrContributorApprovalPermissionsOrganization200Schema

export const actionsSetForkPrContributorApprovalPermissionsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsSetForkPrContributorApprovalPermissionsOrganization204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const actionsSetForkPrContributorApprovalPermissionsOrganization404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsSetForkPrContributorApprovalPermissionsOrganization422Schema = validationErrorSchema.describe("Validation Error")

export const actionsSetForkPrContributorApprovalPermissionsOrganizationMutationRequestSchema = actionsForkPrContributorApprovalSchema

export const actionsSetForkPrContributorApprovalPermissionsOrganizationMutationResponseSchema = actionsSetForkPrContributorApprovalPermissionsOrganization204Schema

export const actionsGetPrivateRepoForkPrWorkflowsSettingsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetPrivateRepoForkPrWorkflowsSettingsOrganization200Schema = actionsForkPrWorkflowsPrivateReposSchema

/**
 * @description Forbidden
 */
export const actionsGetPrivateRepoForkPrWorkflowsSettingsOrganization403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const actionsGetPrivateRepoForkPrWorkflowsSettingsOrganization404Schema = basicErrorSchema.describe("Basic Error")

export const actionsGetPrivateRepoForkPrWorkflowsSettingsOrganizationQueryResponseSchema = actionsGetPrivateRepoForkPrWorkflowsSettingsOrganization200Schema

export const actionsSetPrivateRepoForkPrWorkflowsSettingsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Empty response for successful settings update
 */
export const actionsSetPrivateRepoForkPrWorkflowsSettingsOrganization204Schema = z.unknown()

/**
 * @description Forbidden - Fork PR workflow settings for private repositories are managed by the enterprise owner
 */
export const actionsSetPrivateRepoForkPrWorkflowsSettingsOrganization403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const actionsSetPrivateRepoForkPrWorkflowsSettingsOrganization404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsSetPrivateRepoForkPrWorkflowsSettingsOrganization422Schema = validationErrorSchema.describe("Validation Error")

export const actionsSetPrivateRepoForkPrWorkflowsSettingsOrganizationMutationRequestSchema = actionsForkPrWorkflowsPrivateReposRequestSchema

export const actionsSetPrivateRepoForkPrWorkflowsSettingsOrganizationMutationResponseSchema = actionsSetPrivateRepoForkPrWorkflowsSettingsOrganization204Schema

export const actionsListSelectedRepositoriesEnabledGithubActionsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const actionsListSelectedRepositoriesEnabledGithubActionsOrganizationQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListSelectedRepositoriesEnabledGithubActionsOrganization200Schema = z.object({
    "total_count": z.number(),
get "repositories"(){
                return z.array(repositorySchema.describe("A repository on GitHub."))
              }
    })

export const actionsListSelectedRepositoriesEnabledGithubActionsOrganizationQueryResponseSchema = actionsListSelectedRepositoriesEnabledGithubActionsOrganization200Schema

export const actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsSetSelectedRepositoriesEnabledGithubActionsOrganization204Schema = z.unknown()

export const actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationMutationRequestSchema = z.object({
    "selected_repository_ids": z.array(z.int().describe("Unique identifier of the repository.")).describe("List of repository IDs to enable for GitHub Actions.")
    })

export const actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationMutationResponseSchema = actionsSetSelectedRepositoriesEnabledGithubActionsOrganization204Schema

export const actionsEnableSelectedRepositoryGithubActionsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"repository_id": z.coerce.number().int().describe("The unique identifier of the repository.")
    })

/**
 * @description Response
 */
export const actionsEnableSelectedRepositoryGithubActionsOrganization204Schema = z.unknown()

export const actionsEnableSelectedRepositoryGithubActionsOrganizationMutationResponseSchema = actionsEnableSelectedRepositoryGithubActionsOrganization204Schema

export const actionsDisableSelectedRepositoryGithubActionsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"repository_id": z.coerce.number().int().describe("The unique identifier of the repository.")
    })

/**
 * @description Response
 */
export const actionsDisableSelectedRepositoryGithubActionsOrganization204Schema = z.unknown()

export const actionsDisableSelectedRepositoryGithubActionsOrganizationMutationResponseSchema = actionsDisableSelectedRepositoryGithubActionsOrganization204Schema

export const actionsGetAllowedActionsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetAllowedActionsOrganization200Schema = selectedActionsSchema

export const actionsGetAllowedActionsOrganizationQueryResponseSchema = actionsGetAllowedActionsOrganization200Schema

export const actionsSetAllowedActionsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsSetAllowedActionsOrganization204Schema = z.unknown()

export const actionsSetAllowedActionsOrganizationMutationRequestSchema = selectedActionsSchema

export const actionsSetAllowedActionsOrganizationMutationResponseSchema = actionsSetAllowedActionsOrganization204Schema

export const actionsGetSelfHostedRunnersPermissionsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetSelfHostedRunnersPermissionsOrganization200Schema = selfHostedRunnersSettingsSchema

/**
 * @description Forbidden
 */
export const actionsGetSelfHostedRunnersPermissionsOrganization403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const actionsGetSelfHostedRunnersPermissionsOrganization404Schema = basicErrorSchema.describe("Basic Error")

export const actionsGetSelfHostedRunnersPermissionsOrganizationQueryResponseSchema = actionsGetSelfHostedRunnersPermissionsOrganization200Schema

export const actionsSetSelfHostedRunnersPermissionsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description No content
 */
export const actionsSetSelfHostedRunnersPermissionsOrganization204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const actionsSetSelfHostedRunnersPermissionsOrganization403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const actionsSetSelfHostedRunnersPermissionsOrganization404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const actionsSetSelfHostedRunnersPermissionsOrganization409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsSetSelfHostedRunnersPermissionsOrganization422Schema = validationErrorSchema.describe("Validation Error")

export const actionsSetSelfHostedRunnersPermissionsOrganizationMutationRequestSchema = z.object({
    "enabled_repositories": z.enum(["all", "selected", "none"]).describe("The policy that controls whether self-hosted runners can be used in the organization")
    })

export const actionsSetSelfHostedRunnersPermissionsOrganizationMutationResponseSchema = actionsSetSelfHostedRunnersPermissionsOrganization204Schema

export const actionsListSelectedRepositoriesSelfHostedRunnersOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const actionsListSelectedRepositoriesSelfHostedRunnersOrganizationQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListSelectedRepositoriesSelfHostedRunnersOrganization200Schema = z.object({
    "total_count": z.optional(z.int()),
get "repositories"(){
                return z.array(repositorySchema.describe("A repository on GitHub.")).optional()
              }
    })

/**
 * @description Forbidden
 */
export const actionsListSelectedRepositoriesSelfHostedRunnersOrganization403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const actionsListSelectedRepositoriesSelfHostedRunnersOrganization404Schema = basicErrorSchema.describe("Basic Error")

export const actionsListSelectedRepositoriesSelfHostedRunnersOrganizationQueryResponseSchema = actionsListSelectedRepositoriesSelfHostedRunnersOrganization200Schema

export const actionsSetSelectedRepositoriesSelfHostedRunnersOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description No content
 */
export const actionsSetSelectedRepositoriesSelfHostedRunnersOrganization204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const actionsSetSelectedRepositoriesSelfHostedRunnersOrganization403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const actionsSetSelectedRepositoriesSelfHostedRunnersOrganization404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsSetSelectedRepositoriesSelfHostedRunnersOrganization422Schema = validationErrorSchema.describe("Validation Error")

export const actionsSetSelectedRepositoriesSelfHostedRunnersOrganizationMutationRequestSchema = z.object({
    "selected_repository_ids": z.array(z.int()).describe("IDs of repositories that can use repository-level self-hosted runners")
    })

export const actionsSetSelectedRepositoriesSelfHostedRunnersOrganizationMutationResponseSchema = actionsSetSelectedRepositoriesSelfHostedRunnersOrganization204Schema

export const actionsEnableSelectedRepositorySelfHostedRunnersOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"repository_id": z.coerce.number().int().describe("The unique identifier of the repository.")
    })

/**
 * @description No content
 */
export const actionsEnableSelectedRepositorySelfHostedRunnersOrganization204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const actionsEnableSelectedRepositorySelfHostedRunnersOrganization403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const actionsEnableSelectedRepositorySelfHostedRunnersOrganization404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const actionsEnableSelectedRepositorySelfHostedRunnersOrganization409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsEnableSelectedRepositorySelfHostedRunnersOrganization422Schema = validationErrorSchema.describe("Validation Error")

export const actionsEnableSelectedRepositorySelfHostedRunnersOrganizationMutationResponseSchema = actionsEnableSelectedRepositorySelfHostedRunnersOrganization204Schema

export const actionsDisableSelectedRepositorySelfHostedRunnersOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"repository_id": z.coerce.number().int().describe("The unique identifier of the repository.")
    })

/**
 * @description No content
 */
export const actionsDisableSelectedRepositorySelfHostedRunnersOrganization204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const actionsDisableSelectedRepositorySelfHostedRunnersOrganization403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const actionsDisableSelectedRepositorySelfHostedRunnersOrganization404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const actionsDisableSelectedRepositorySelfHostedRunnersOrganization409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsDisableSelectedRepositorySelfHostedRunnersOrganization422Schema = validationErrorSchema.describe("Validation Error")

export const actionsDisableSelectedRepositorySelfHostedRunnersOrganizationMutationResponseSchema = actionsDisableSelectedRepositorySelfHostedRunnersOrganization204Schema

export const actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetGithubActionsDefaultWorkflowPermissionsOrganization200Schema = actionsGetDefaultWorkflowPermissionsSchema

export const actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationQueryResponseSchema = actionsGetGithubActionsDefaultWorkflowPermissionsOrganization200Schema

export const actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Success response
 */
export const actionsSetGithubActionsDefaultWorkflowPermissionsOrganization204Schema = z.unknown()

export const actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationMutationRequestSchema = actionsSetDefaultWorkflowPermissionsSchema

export const actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationMutationResponseSchema = actionsSetGithubActionsDefaultWorkflowPermissionsOrganization204Schema

export const actionsListSelfHostedRunnerGroupsForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const actionsListSelfHostedRunnerGroupsForOrgQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"visible_to_repository": z.optional(z.string().describe("Only return runner groups that are allowed to be used by this repository."))
    })

/**
 * @description Response
 */
export const actionsListSelfHostedRunnerGroupsForOrg200Schema = z.object({
    "total_count": z.number(),
get "runner_groups"(){
                return z.array(runnerGroupsOrgSchema)
              }
    })

export const actionsListSelfHostedRunnerGroupsForOrgQueryResponseSchema = actionsListSelfHostedRunnerGroupsForOrg200Schema

export const actionsCreateSelfHostedRunnerGroupForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsCreateSelfHostedRunnerGroupForOrg201Schema = runnerGroupsOrgSchema

export const actionsCreateSelfHostedRunnerGroupForOrgMutationRequestSchema = z.object({
    "name": z.string().describe("Name of the runner group."),
"visibility": z.optional(z.enum(["selected", "all", "private"]).default("all").describe("Visibility of a runner group. You can select all repositories, select individual repositories, or limit access to private repositories.")),
"selected_repository_ids": z.optional(z.array(z.int().describe("Unique identifier of the repository.")).describe("List of repository IDs that can access the runner group.")),
"runners": z.optional(z.array(z.int().describe("Unique identifier of the runner.")).describe("List of runner IDs to add to the runner group.")),
"allows_public_repositories": z.optional(z.boolean().default(false).describe("Whether the runner group can be used by `public` repositories.")),
"restricted_to_workflows": z.optional(z.boolean().default(false).describe("If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.")),
"selected_workflows": z.optional(z.array(z.string().describe("Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.")).describe("List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.")),
"network_configuration_id": z.optional(z.string().describe("The identifier of a hosted compute network configuration."))
    })

export const actionsCreateSelfHostedRunnerGroupForOrgMutationResponseSchema = actionsCreateSelfHostedRunnerGroupForOrg201Schema

export const actionsGetSelfHostedRunnerGroupForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_group_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner group.")
    })

/**
 * @description Response
 */
export const actionsGetSelfHostedRunnerGroupForOrg200Schema = runnerGroupsOrgSchema

export const actionsGetSelfHostedRunnerGroupForOrgQueryResponseSchema = actionsGetSelfHostedRunnerGroupForOrg200Schema

export const actionsUpdateSelfHostedRunnerGroupForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_group_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner group.")
    })

/**
 * @description Response
 */
export const actionsUpdateSelfHostedRunnerGroupForOrg200Schema = runnerGroupsOrgSchema

export const actionsUpdateSelfHostedRunnerGroupForOrgMutationRequestSchema = z.object({
    "name": z.string().describe("Name of the runner group."),
"visibility": z.optional(z.enum(["selected", "all", "private"]).describe("Visibility of a runner group. You can select all repositories, select individual repositories, or all private repositories.")),
"allows_public_repositories": z.optional(z.boolean().default(false).describe("Whether the runner group can be used by `public` repositories.")),
"restricted_to_workflows": z.optional(z.boolean().default(false).describe("If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.")),
"selected_workflows": z.optional(z.array(z.string().describe("Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.")).describe("List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.")),
"network_configuration_id": z.string().describe("The identifier of a hosted compute network configuration.").nullish()
    })

export const actionsUpdateSelfHostedRunnerGroupForOrgMutationResponseSchema = actionsUpdateSelfHostedRunnerGroupForOrg200Schema

export const actionsDeleteSelfHostedRunnerGroupFromOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_group_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner group.")
    })

/**
 * @description Response
 */
export const actionsDeleteSelfHostedRunnerGroupFromOrg204Schema = z.unknown()

export const actionsDeleteSelfHostedRunnerGroupFromOrgMutationResponseSchema = actionsDeleteSelfHostedRunnerGroupFromOrg204Schema

export const actionsListGithubHostedRunnersInGroupForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_group_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner group.")
    })

export const actionsListGithubHostedRunnersInGroupForOrgQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListGithubHostedRunnersInGroupForOrg200Schema = z.object({
    "total_count": z.number(),
get "runners"(){
                return z.array(actionsHostedRunnerSchema.describe("A Github-hosted hosted runner."))
              }
    })

export const actionsListGithubHostedRunnersInGroupForOrgQueryResponseSchema = actionsListGithubHostedRunnersInGroupForOrg200Schema

export const actionsListRepoAccessToSelfHostedRunnerGroupInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_group_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner group.")
    })

export const actionsListRepoAccessToSelfHostedRunnerGroupInOrgQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListRepoAccessToSelfHostedRunnerGroupInOrg200Schema = z.object({
    "total_count": z.number(),
get "repositories"(){
                return z.array(minimalRepositorySchema.describe("Minimal Repository"))
              }
    })

export const actionsListRepoAccessToSelfHostedRunnerGroupInOrgQueryResponseSchema = actionsListRepoAccessToSelfHostedRunnerGroupInOrg200Schema

export const actionsSetRepoAccessToSelfHostedRunnerGroupInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_group_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner group.")
    })

/**
 * @description Response
 */
export const actionsSetRepoAccessToSelfHostedRunnerGroupInOrg204Schema = z.unknown()

export const actionsSetRepoAccessToSelfHostedRunnerGroupInOrgMutationRequestSchema = z.object({
    "selected_repository_ids": z.array(z.int().describe("Unique identifier of the repository.")).describe("List of repository IDs that can access the runner group.")
    })

export const actionsSetRepoAccessToSelfHostedRunnerGroupInOrgMutationResponseSchema = actionsSetRepoAccessToSelfHostedRunnerGroupInOrg204Schema

export const actionsAddRepoAccessToSelfHostedRunnerGroupInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_group_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner group."),
"repository_id": z.coerce.number().int().describe("The unique identifier of the repository.")
    })

/**
 * @description Response
 */
export const actionsAddRepoAccessToSelfHostedRunnerGroupInOrg204Schema = z.unknown()

export const actionsAddRepoAccessToSelfHostedRunnerGroupInOrgMutationResponseSchema = actionsAddRepoAccessToSelfHostedRunnerGroupInOrg204Schema

export const actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_group_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner group."),
"repository_id": z.coerce.number().int().describe("The unique identifier of the repository.")
    })

/**
 * @description Response
 */
export const actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg204Schema = z.unknown()

export const actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgMutationResponseSchema = actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg204Schema

export const actionsListSelfHostedRunnersInGroupForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_group_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner group.")
    })

export const actionsListSelfHostedRunnersInGroupForOrgQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListSelfHostedRunnersInGroupForOrg200Schema = z.object({
    "total_count": z.number(),
get "runners"(){
                return z.array(runnerSchema.describe("A self hosted runner"))
              }
    })

export const actionsListSelfHostedRunnersInGroupForOrgQueryResponseSchema = actionsListSelfHostedRunnersInGroupForOrg200Schema

export const actionsSetSelfHostedRunnersInGroupForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_group_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner group.")
    })

/**
 * @description Response
 */
export const actionsSetSelfHostedRunnersInGroupForOrg204Schema = z.unknown()

export const actionsSetSelfHostedRunnersInGroupForOrgMutationRequestSchema = z.object({
    "runners": z.array(z.int().describe("Unique identifier of the runner.")).describe("List of runner IDs to add to the runner group.")
    })

export const actionsSetSelfHostedRunnersInGroupForOrgMutationResponseSchema = actionsSetSelfHostedRunnersInGroupForOrg204Schema

export const actionsAddSelfHostedRunnerToGroupForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_group_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner group."),
"runner_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsAddSelfHostedRunnerToGroupForOrg204Schema = z.unknown()

export const actionsAddSelfHostedRunnerToGroupForOrgMutationResponseSchema = actionsAddSelfHostedRunnerToGroupForOrg204Schema

export const actionsRemoveSelfHostedRunnerFromGroupForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_group_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner group."),
"runner_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsRemoveSelfHostedRunnerFromGroupForOrg204Schema = z.unknown()

export const actionsRemoveSelfHostedRunnerFromGroupForOrgMutationResponseSchema = actionsRemoveSelfHostedRunnerFromGroupForOrg204Schema

export const actionsListSelfHostedRunnersForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const actionsListSelfHostedRunnersForOrgQueryParamsSchema = z.object({
    "name": z.optional(z.string().describe("The name of a self-hosted runner.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListSelfHostedRunnersForOrg200Schema = z.object({
    "total_count": z.int(),
get "runners"(){
                return z.array(runnerSchema.describe("A self hosted runner"))
              }
    })

export const actionsListSelfHostedRunnersForOrgQueryResponseSchema = actionsListSelfHostedRunnersForOrg200Schema

export const actionsListRunnerApplicationsForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsListRunnerApplicationsForOrg200Schema = z.array(runnerApplicationSchema.describe("Runner Application"))

export const actionsListRunnerApplicationsForOrgQueryResponseSchema = actionsListRunnerApplicationsForOrg200Schema

export const actionsGenerateRunnerJitconfigForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGenerateRunnerJitconfigForOrg201Schema = z.object({
    get "runner"(){
                return runnerSchema.describe("A self hosted runner")
              },
"encoded_jit_config": z.string().describe("The base64 encoded runner configuration.")
    })

/**
 * @description Resource not found
 */
export const actionsGenerateRunnerJitconfigForOrg404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const actionsGenerateRunnerJitconfigForOrg409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsGenerateRunnerJitconfigForOrg422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const actionsGenerateRunnerJitconfigForOrgMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the new runner."),
"runner_group_id": z.int().describe("The ID of the runner group to register the runner to."),
"labels": z.array(z.string()).min(1).max(100).describe("The names of the custom labels to add to the runner. **Minimum items**: 1. **Maximum items**: 100."),
"work_folder": z.optional(z.string().default("_work").describe("The working directory to be used for job execution, relative to the runner install directory."))
    })

export const actionsGenerateRunnerJitconfigForOrgMutationResponseSchema = actionsGenerateRunnerJitconfigForOrg201Schema

export const actionsCreateRegistrationTokenForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsCreateRegistrationTokenForOrg201Schema = authenticationTokenSchema.describe("Authentication Token")

export const actionsCreateRegistrationTokenForOrgMutationResponseSchema = actionsCreateRegistrationTokenForOrg201Schema

export const actionsCreateRemoveTokenForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsCreateRemoveTokenForOrg201Schema = authenticationTokenSchema.describe("Authentication Token")

export const actionsCreateRemoveTokenForOrgMutationResponseSchema = actionsCreateRemoveTokenForOrg201Schema

export const actionsGetSelfHostedRunnerForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsGetSelfHostedRunnerForOrg200Schema = runnerSchema.describe("A self hosted runner")

export const actionsGetSelfHostedRunnerForOrgQueryResponseSchema = actionsGetSelfHostedRunnerForOrg200Schema

export const actionsDeleteSelfHostedRunnerFromOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsDeleteSelfHostedRunnerFromOrg204Schema = z.unknown()

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsDeleteSelfHostedRunnerFromOrg422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const actionsDeleteSelfHostedRunnerFromOrgMutationResponseSchema = actionsDeleteSelfHostedRunnerFromOrg204Schema

export const actionsListLabelsForSelfHostedRunnerForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsListLabelsForSelfHostedRunnerForOrg200Schema = z.object({
    "total_count": z.int(),
get "labels"(){
                return z.array(runnerLabelSchema.describe("A label for a self hosted runner"))
              }
    })

/**
 * @description Resource not found
 */
export const actionsListLabelsForSelfHostedRunnerForOrg404Schema = basicErrorSchema.describe("Basic Error")

export const actionsListLabelsForSelfHostedRunnerForOrgQueryResponseSchema = actionsListLabelsForSelfHostedRunnerForOrg200Schema

export const actionsAddCustomLabelsToSelfHostedRunnerForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsAddCustomLabelsToSelfHostedRunnerForOrg200Schema = z.object({
    "total_count": z.int(),
get "labels"(){
                return z.array(runnerLabelSchema.describe("A label for a self hosted runner"))
              }
    })

/**
 * @description Resource not found
 */
export const actionsAddCustomLabelsToSelfHostedRunnerForOrg404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsAddCustomLabelsToSelfHostedRunnerForOrg422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const actionsAddCustomLabelsToSelfHostedRunnerForOrgMutationRequestSchema = z.object({
    "labels": z.array(z.string()).min(1).max(100).describe("The names of the custom labels to add to the runner.")
    })

export const actionsAddCustomLabelsToSelfHostedRunnerForOrgMutationResponseSchema = actionsAddCustomLabelsToSelfHostedRunnerForOrg200Schema

export const actionsSetCustomLabelsForSelfHostedRunnerForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsSetCustomLabelsForSelfHostedRunnerForOrg200Schema = z.object({
    "total_count": z.int(),
get "labels"(){
                return z.array(runnerLabelSchema.describe("A label for a self hosted runner"))
              }
    })

/**
 * @description Resource not found
 */
export const actionsSetCustomLabelsForSelfHostedRunnerForOrg404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsSetCustomLabelsForSelfHostedRunnerForOrg422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const actionsSetCustomLabelsForSelfHostedRunnerForOrgMutationRequestSchema = z.object({
    "labels": z.array(z.string()).min(0).max(100).describe("The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.")
    })

export const actionsSetCustomLabelsForSelfHostedRunnerForOrgMutationResponseSchema = actionsSetCustomLabelsForSelfHostedRunnerForOrg200Schema

export const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg200Schema = z.object({
    "total_count": z.int(),
get "labels"(){
                return z.array(runnerLabelSchema.describe("A label for a self hosted runner"))
              }
    })

/**
 * @description Resource not found
 */
export const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg404Schema = basicErrorSchema.describe("Basic Error")

export const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgMutationResponseSchema = actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg200Schema

export const actionsRemoveCustomLabelFromSelfHostedRunnerForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"runner_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner."),
"name": z.string().describe("The name of a self-hosted runner's custom label.")
    })

/**
 * @description Response
 */
export const actionsRemoveCustomLabelFromSelfHostedRunnerForOrg200Schema = z.object({
    "total_count": z.int(),
get "labels"(){
                return z.array(runnerLabelSchema.describe("A label for a self hosted runner"))
              }
    })

/**
 * @description Resource not found
 */
export const actionsRemoveCustomLabelFromSelfHostedRunnerForOrg404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsRemoveCustomLabelFromSelfHostedRunnerForOrg422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const actionsRemoveCustomLabelFromSelfHostedRunnerForOrgMutationResponseSchema = actionsRemoveCustomLabelFromSelfHostedRunnerForOrg200Schema

export const actionsListOrgSecretsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const actionsListOrgSecretsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListOrgSecrets200Schema = z.object({
    "total_count": z.int(),
get "secrets"(){
                return z.array(organizationActionsSecretSchema.describe("Secrets for GitHub Actions for an organization."))
              }
    })

export const actionsListOrgSecretsQueryResponseSchema = actionsListOrgSecrets200Schema

export const actionsGetOrgPublicKeyPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetOrgPublicKey200Schema = actionsPublicKeySchema.describe("The public key used for setting Actions Secrets.")

export const actionsGetOrgPublicKeyQueryResponseSchema = actionsGetOrgPublicKey200Schema

export const actionsGetOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const actionsGetOrgSecret200Schema = organizationActionsSecretSchema.describe("Secrets for GitHub Actions for an organization.")

export const actionsGetOrgSecretQueryResponseSchema = actionsGetOrgSecret200Schema

export const actionsCreateOrUpdateOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response when creating a secret
 */
export const actionsCreateOrUpdateOrgSecret201Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Response when updating a secret
 */
export const actionsCreateOrUpdateOrgSecret204Schema = z.unknown()

export const actionsCreateOrUpdateOrgSecretMutationRequestSchema = z.object({
    "encrypted_value": z.string().regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$/).describe("Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/actions/secrets#get-an-organization-public-key) endpoint."),
"key_id": z.string().describe("ID of the key you used to encrypt the secret."),
"visibility": z.enum(["all", "private", "selected"]).describe("Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret."),
"selected_repository_ids": z.optional(z.array(z.int()).describe("An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret) endpoints."))
    })

export const actionsCreateOrUpdateOrgSecretMutationResponseSchema = z.union([actionsCreateOrUpdateOrgSecret201Schema, actionsCreateOrUpdateOrgSecret204Schema])

export const actionsDeleteOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const actionsDeleteOrgSecret204Schema = z.unknown()

export const actionsDeleteOrgSecretMutationResponseSchema = actionsDeleteOrgSecret204Schema

export const actionsListSelectedReposForOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

export const actionsListSelectedReposForOrgSecretQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListSelectedReposForOrgSecret200Schema = z.object({
    "total_count": z.int(),
get "repositories"(){
                return z.array(minimalRepositorySchema.describe("Minimal Repository"))
              }
    })

export const actionsListSelectedReposForOrgSecretQueryResponseSchema = actionsListSelectedReposForOrgSecret200Schema

export const actionsSetSelectedReposForOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const actionsSetSelectedReposForOrgSecret204Schema = z.unknown()

export const actionsSetSelectedReposForOrgSecretMutationRequestSchema = z.object({
    "selected_repository_ids": z.array(z.int()).describe("An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Add selected repository to an organization secret](https://docs.github.com/rest/actions/secrets#add-selected-repository-to-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret) endpoints.")
    })

export const actionsSetSelectedReposForOrgSecretMutationResponseSchema = actionsSetSelectedReposForOrgSecret204Schema

export const actionsAddSelectedRepoToOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret."),
"repository_id": z.coerce.number().int()
    })

/**
 * @description No Content when repository was added to the selected list
 */
export const actionsAddSelectedRepoToOrgSecret204Schema = z.unknown()

/**
 * @description Conflict when visibility type is not set to selected
 */
export const actionsAddSelectedRepoToOrgSecret409Schema = z.unknown()

export const actionsAddSelectedRepoToOrgSecretMutationResponseSchema = actionsAddSelectedRepoToOrgSecret204Schema

export const actionsRemoveSelectedRepoFromOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret."),
"repository_id": z.coerce.number().int()
    })

/**
 * @description Response when repository was removed from the selected list
 */
export const actionsRemoveSelectedRepoFromOrgSecret204Schema = z.unknown()

/**
 * @description Conflict when visibility type not set to selected
 */
export const actionsRemoveSelectedRepoFromOrgSecret409Schema = z.unknown()

export const actionsRemoveSelectedRepoFromOrgSecretMutationResponseSchema = actionsRemoveSelectedRepoFromOrgSecret204Schema

export const actionsListOrgVariablesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const actionsListOrgVariablesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(10).describe("The number of results per page (max 30). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListOrgVariables200Schema = z.object({
    "total_count": z.int(),
get "variables"(){
                return z.array(organizationActionsVariableSchema.describe("Organization variable for GitHub Actions."))
              }
    })

export const actionsListOrgVariablesQueryResponseSchema = actionsListOrgVariables200Schema

export const actionsCreateOrgVariablePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response when creating a variable
 */
export const actionsCreateOrgVariable201Schema = emptyObjectSchema.describe("An object without any properties.")

export const actionsCreateOrgVariableMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the variable."),
"value": z.string().describe("The value of the variable."),
"visibility": z.enum(["all", "private", "selected"]).describe("The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable."),
"selected_repository_ids": z.optional(z.array(z.int()).describe("An array of repository ids that can access the organization variable. You can only provide a list of repository ids when the `visibility` is set to `selected`."))
    })

export const actionsCreateOrgVariableMutationResponseSchema = actionsCreateOrgVariable201Schema

export const actionsGetOrgVariablePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"name": z.string().describe("The name of the variable.")
    })

/**
 * @description Response
 */
export const actionsGetOrgVariable200Schema = organizationActionsVariableSchema.describe("Organization variable for GitHub Actions.")

export const actionsGetOrgVariableQueryResponseSchema = actionsGetOrgVariable200Schema

export const actionsUpdateOrgVariablePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"name": z.string().describe("The name of the variable.")
    })

/**
 * @description Response
 */
export const actionsUpdateOrgVariable204Schema = z.unknown()

export const actionsUpdateOrgVariableMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("The name of the variable.")),
"value": z.optional(z.string().describe("The value of the variable.")),
"visibility": z.optional(z.enum(["all", "private", "selected"]).describe("The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable.")),
"selected_repository_ids": z.optional(z.array(z.int()).describe("An array of repository ids that can access the organization variable. You can only provide a list of repository ids when the `visibility` is set to `selected`."))
    })

export const actionsUpdateOrgVariableMutationResponseSchema = actionsUpdateOrgVariable204Schema

export const actionsDeleteOrgVariablePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"name": z.string().describe("The name of the variable.")
    })

/**
 * @description Response
 */
export const actionsDeleteOrgVariable204Schema = z.unknown()

export const actionsDeleteOrgVariableMutationResponseSchema = actionsDeleteOrgVariable204Schema

export const actionsListSelectedReposForOrgVariablePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"name": z.string().describe("The name of the variable.")
    })

export const actionsListSelectedReposForOrgVariableQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListSelectedReposForOrgVariable200Schema = z.object({
    "total_count": z.int(),
get "repositories"(){
                return z.array(minimalRepositorySchema.describe("Minimal Repository"))
              }
    })

/**
 * @description Response when the visibility of the variable is not set to `selected`
 */
export const actionsListSelectedReposForOrgVariable409Schema = z.unknown()

export const actionsListSelectedReposForOrgVariableQueryResponseSchema = actionsListSelectedReposForOrgVariable200Schema

export const actionsSetSelectedReposForOrgVariablePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"name": z.string().describe("The name of the variable.")
    })

/**
 * @description Response
 */
export const actionsSetSelectedReposForOrgVariable204Schema = z.unknown()

/**
 * @description Response when the visibility of the variable is not set to `selected`
 */
export const actionsSetSelectedReposForOrgVariable409Schema = z.unknown()

export const actionsSetSelectedReposForOrgVariableMutationRequestSchema = z.object({
    "selected_repository_ids": z.array(z.int()).describe("The IDs of the repositories that can access the organization variable.")
    })

export const actionsSetSelectedReposForOrgVariableMutationResponseSchema = actionsSetSelectedReposForOrgVariable204Schema

export const actionsAddSelectedRepoToOrgVariablePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"name": z.string().describe("The name of the variable."),
"repository_id": z.coerce.number().int()
    })

/**
 * @description Response
 */
export const actionsAddSelectedRepoToOrgVariable204Schema = z.unknown()

/**
 * @description Response when the visibility of the variable is not set to `selected`
 */
export const actionsAddSelectedRepoToOrgVariable409Schema = z.unknown()

export const actionsAddSelectedRepoToOrgVariableMutationResponseSchema = actionsAddSelectedRepoToOrgVariable204Schema

export const actionsRemoveSelectedRepoFromOrgVariablePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"name": z.string().describe("The name of the variable."),
"repository_id": z.coerce.number().int()
    })

/**
 * @description Response
 */
export const actionsRemoveSelectedRepoFromOrgVariable204Schema = z.unknown()

/**
 * @description Response when the visibility of the variable is not set to `selected`
 */
export const actionsRemoveSelectedRepoFromOrgVariable409Schema = z.unknown()

export const actionsRemoveSelectedRepoFromOrgVariableMutationResponseSchema = actionsRemoveSelectedRepoFromOrgVariable204Schema

export const orgsCreateArtifactStorageRecordPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Artifact metadata storage record stored successfully.
 */
export const orgsCreateArtifactStorageRecord200Schema = z.object({
    "total_count": z.optional(z.int()),
"storage_records": z.optional(z.array(z.object({
    "id": z.optional(z.int()),
"name": z.optional(z.string()),
"digest": z.optional(z.string()),
"artifact_url": z.string().nullish(),
"registry_url": z.optional(z.string()),
"repository": z.string().nullish(),
"status": z.optional(z.string()),
"created_at": z.optional(z.string()),
"updated_at": z.optional(z.string())
    })))
    })

export const orgsCreateArtifactStorageRecordMutationRequestSchema = z.object({
    "name": z.string().min(1).describe("The name of the artifact."),
"digest": z.string().regex(/^sha256:[a-f0-9]{64}$/).describe("The digest of the artifact (algorithm:hex-encoded-digest)."),
"artifact_url": z.optional(z.url().describe("The URL where the artifact is stored.")),
"path": z.optional(z.url().describe("The path of the artifact.")),
"registry_url": z.url().min(1).describe("The base URL of the artifact registry."),
"repository": z.optional(z.string().describe("The repository name within the registry.")),
"status": z.optional(z.enum(["active", "eol", "deleted"]).default("active").describe("The status of the artifact (e.g., active, inactive)."))
    })

export const orgsCreateArtifactStorageRecordMutationResponseSchema = orgsCreateArtifactStorageRecord200Schema

export const orgsListArtifactStorageRecordsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"subject_digest": z.string().regex(/^sha256:[a-f0-9]{64}$/).describe("The parameter should be set to the attestation's subject's SHA256 digest, in the form `sha256:HEX_DIGEST`.")
    })

/**
 * @description Response
 */
export const orgsListArtifactStorageRecords200Schema = z.object({
    "total_count": z.optional(z.int().describe("The number of storage records for this digest and organization")),
"storage_records": z.optional(z.array(z.object({
    "id": z.optional(z.int()),
"name": z.optional(z.string()),
"digest": z.optional(z.string()),
"artifact_url": z.optional(z.string()),
"registry_url": z.optional(z.string()),
"repository": z.optional(z.string()),
"status": z.optional(z.string()),
"created_at": z.optional(z.string()),
"updated_at": z.optional(z.string())
    })))
    })

export const orgsListArtifactStorageRecordsQueryResponseSchema = orgsListArtifactStorageRecords200Schema

export const orgsListAttestationsBulkPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const orgsListAttestationsBulkQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""))
    })

/**
 * @description Response
 */
export const orgsListAttestationsBulk200Schema = z.object({
    "attestations_subject_digests": z.optional(z.object({
    
    }).catchall(z.array(z.object({
    "bundle": z.optional(z.object({
    "mediaType": z.optional(z.string()),
"verificationMaterial": z.optional(z.object({
    
    }).catchall(z.unknown())),
"dsseEnvelope": z.optional(z.object({
    
    }).catchall(z.unknown()))
    }).describe("The bundle of the attestation.")),
"repository_id": z.optional(z.int()),
"bundle_url": z.optional(z.string())
    })).nullable()).describe("Mapping of subject digest to bundles.")),
"page_info": z.optional(z.object({
    "has_next": z.optional(z.boolean().describe("Indicates whether there is a next page.")),
"has_previous": z.optional(z.boolean().describe("Indicates whether there is a previous page.")),
"next": z.optional(z.string().describe("The cursor to the next page.")),
"previous": z.optional(z.string().describe("The cursor to the previous page."))
    }).describe("Information about the current page."))
    })

export const orgsListAttestationsBulkMutationRequestSchema = z.object({
    "subject_digests": z.array(z.string()).min(1).max(1024).describe("List of subject digests to fetch attestations for."),
"predicate_type": z.optional(z.string().describe("Optional filter for fetching attestations with a given predicate type.\nThis option accepts `provenance`, `sbom`, `release`, or freeform text\nfor custom predicate types."))
    })

export const orgsListAttestationsBulkMutationResponseSchema = orgsListAttestationsBulk200Schema

export const orgsDeleteAttestationsBulkPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const orgsDeleteAttestationsBulk200Schema = z.unknown()

/**
 * @description Resource not found
 */
export const orgsDeleteAttestationsBulk404Schema = basicErrorSchema.describe("Basic Error")

export const orgsDeleteAttestationsBulkMutationRequestSchema = z.union([z.object({
    "subject_digests": z.array(z.string()).min(1).max(1024).describe("List of subject digests associated with the artifact attestations to delete.")
    }), z.object({
    "attestation_ids": z.array(z.int()).min(1).max(1024).describe("List of unique IDs associated with the artifact attestations to delete.")
    })]).describe("The request body must include either `subject_digests` or `attestation_ids`, but not both.")

export const orgsDeleteAttestationsBulkMutationResponseSchema = orgsDeleteAttestationsBulk200Schema

export const orgsDeleteAttestationsBySubjectDigestPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"subject_digest": z.string().describe("Subject Digest")
    })

/**
 * @description Response
 */
export const orgsDeleteAttestationsBySubjectDigest200Schema = z.unknown()

/**
 * @description Response
 */
export const orgsDeleteAttestationsBySubjectDigest204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const orgsDeleteAttestationsBySubjectDigest404Schema = basicErrorSchema.describe("Basic Error")

export const orgsDeleteAttestationsBySubjectDigestMutationResponseSchema = z.union([orgsDeleteAttestationsBySubjectDigest200Schema, orgsDeleteAttestationsBySubjectDigest204Schema])

export const orgsListAttestationRepositoriesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const orgsListAttestationRepositoriesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"predicate_type": z.optional(z.string().describe("Optional filter for fetching attestations with a given predicate type.\nThis option accepts `provenance`, `sbom`, `release`, or freeform text\nfor custom predicate types."))
    })

/**
 * @description Response
 */
export const orgsListAttestationRepositories200Schema = z.array(z.object({
    "id": z.optional(z.int()),
"name": z.optional(z.string())
    }))

export const orgsListAttestationRepositoriesQueryResponseSchema = orgsListAttestationRepositories200Schema

export const orgsDeleteAttestationsByIdPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"attestation_id": z.coerce.number().int().describe("Attestation ID")
    })

/**
 * @description Response
 */
export const orgsDeleteAttestationsById200Schema = z.unknown()

/**
 * @description Response
 */
export const orgsDeleteAttestationsById204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const orgsDeleteAttestationsById403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsDeleteAttestationsById404Schema = basicErrorSchema.describe("Basic Error")

export const orgsDeleteAttestationsByIdMutationResponseSchema = z.union([orgsDeleteAttestationsById200Schema, orgsDeleteAttestationsById204Schema])

export const orgsListAttestationsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"subject_digest": z.string().describe("The parameter should be set to the attestation's subject's SHA256 digest, in the form `sha256:HEX_DIGEST`.")
    })

export const orgsListAttestationsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"predicate_type": z.optional(z.string().describe("Optional filter for fetching attestations with a given predicate type.\nThis option accepts `provenance`, `sbom`, `release`, or freeform text\nfor custom predicate types."))
    })

/**
 * @description Response
 */
export const orgsListAttestations200Schema = z.object({
    "attestations": z.optional(z.array(z.object({
    "bundle": z.optional(z.object({
    "mediaType": z.optional(z.string()),
"verificationMaterial": z.optional(z.object({
    
    }).catchall(z.unknown())),
"dsseEnvelope": z.optional(z.object({
    
    }).catchall(z.unknown()))
    }).describe("The attestation's Sigstore Bundle.\nRefer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information.")),
"repository_id": z.optional(z.int()),
"bundle_url": z.optional(z.string()),
"initiator": z.optional(z.string())
    })))
    })

export const orgsListAttestationsQueryResponseSchema = orgsListAttestations200Schema

export const orgsListBlockedUsersPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const orgsListBlockedUsersQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const orgsListBlockedUsers200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

export const orgsListBlockedUsersQueryResponseSchema = orgsListBlockedUsers200Schema

export const orgsCheckBlockedUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description If the user is blocked
 */
export const orgsCheckBlockedUser204Schema = z.unknown()

/**
 * @description If the user is not blocked
 */
export const orgsCheckBlockedUser404Schema = basicErrorSchema.describe("Basic Error")

export const orgsCheckBlockedUserQueryResponseSchema = orgsCheckBlockedUser204Schema

export const orgsBlockUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const orgsBlockUser204Schema = z.unknown()

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsBlockUser422Schema = validationErrorSchema.describe("Validation Error")

export const orgsBlockUserMutationResponseSchema = orgsBlockUser204Schema

export const orgsUnblockUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const orgsUnblockUser204Schema = z.unknown()

export const orgsUnblockUserMutationResponseSchema = orgsUnblockUser204Schema

export const campaignsListOrgCampaignsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const campaignsListOrgCampaignsQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
get "state"(){
                return campaignStateSchema.describe("Indicates whether a campaign is open or closed").optional()
              },
"sort": z.enum(["created", "updated", "ends_at", "published"]).default("created").describe("The property by which to sort the results.")
    })

/**
 * @description Response
 */
export const campaignsListOrgCampaigns200Schema = z.array(campaignSummarySchema.describe("The campaign metadata and alert stats."))

/**
 * @description Resource not found
 */
export const campaignsListOrgCampaigns404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const campaignsListOrgCampaigns503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const campaignsListOrgCampaignsQueryResponseSchema = campaignsListOrgCampaigns200Schema

export const campaignsCreateCampaignPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const campaignsCreateCampaign200Schema = campaignSummarySchema.describe("The campaign metadata and alert stats.")

/**
 * @description Bad Request
 */
export const campaignsCreateCampaign400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const campaignsCreateCampaign404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Unprocessable Entity
 */
export const campaignsCreateCampaign422Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Too Many Requests
 */
export const campaignsCreateCampaign429Schema = z.unknown()

/**
 * @description Service unavailable
 */
export const campaignsCreateCampaign503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const campaignsCreateCampaignMutationRequestSchema = z.unknown()

export const campaignsCreateCampaignMutationResponseSchema = campaignsCreateCampaign200Schema

export const campaignsGetCampaignSummaryPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"campaign_number": z.coerce.number().int().describe("The campaign number.")
    })

/**
 * @description Response
 */
export const campaignsGetCampaignSummary200Schema = campaignSummarySchema.describe("The campaign metadata and alert stats.")

/**
 * @description Resource not found
 */
export const campaignsGetCampaignSummary404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Unprocessable Entity
 */
export const campaignsGetCampaignSummary422Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const campaignsGetCampaignSummary503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const campaignsGetCampaignSummaryQueryResponseSchema = campaignsGetCampaignSummary200Schema

export const campaignsUpdateCampaignPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"campaign_number": z.coerce.number().int().describe("The campaign number.")
    })

/**
 * @description Response
 */
export const campaignsUpdateCampaign200Schema = campaignSummarySchema.describe("The campaign metadata and alert stats.")

/**
 * @description Bad Request
 */
export const campaignsUpdateCampaign400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const campaignsUpdateCampaign404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Unprocessable Entity
 */
export const campaignsUpdateCampaign422Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const campaignsUpdateCampaign503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const campaignsUpdateCampaignMutationRequestSchema = z.object({
    "name": z.optional(z.string().min(1).max(50).describe("The name of the campaign")),
"description": z.optional(z.string().min(1).max(255).describe("A description for the campaign")),
"managers": z.optional(z.array(z.string()).max(10).describe("The logins of the users to set as the campaign managers. At this time, only a single manager can be supplied.")),
"team_managers": z.optional(z.array(z.string().describe("The slug of each team")).max(10).describe("The slugs of the teams to set as the campaign managers.")),
"ends_at": z.optional(z.iso.datetime({ offset: true }).describe("The end date and time of the campaign, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.")),
"contact_link": z.url().describe("The contact link of the campaign. Must be a URI.").nullish(),
get "state"(){
                return campaignStateSchema.describe("Indicates whether a campaign is open or closed").optional()
              }
    })

export const campaignsUpdateCampaignMutationResponseSchema = campaignsUpdateCampaign200Schema

export const campaignsDeleteCampaignPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"campaign_number": z.coerce.number().int().describe("The campaign number.")
    })

/**
 * @description Deletion successful
 */
export const campaignsDeleteCampaign204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const campaignsDeleteCampaign404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const campaignsDeleteCampaign503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const campaignsDeleteCampaignMutationResponseSchema = campaignsDeleteCampaign204Schema

export const codeScanningListAlertsForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const codeScanningListAlertsForOrgQueryParamsSchema = z.object({
    get "tool_name"(){
                return codeScanningAnalysisToolNameSchema.describe("The name of the tool used to generate the code scanning analysis.").optional()
              },
get "tool_guid"(){
                return codeScanningAnalysisToolGuidSchema.describe("The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.").optional()
              },
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
get "state"(){
                return codeScanningAlertStateQuerySchema.describe("State of a code scanning alert.").optional()
              },
"sort": z.enum(["created", "updated"]).default("created").describe("The property by which to sort the results."),
get "severity"(){
                return codeScanningAlertSeveritySchema.describe("Severity of a code scanning alert.").optional()
              }
    })

/**
 * @description Response
 */
export const codeScanningListAlertsForOrg200Schema = z.array(codeScanningOrganizationAlertItemsSchema)

/**
 * @description Resource not found
 */
export const codeScanningListAlertsForOrg404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningListAlertsForOrg503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningListAlertsForOrgQueryResponseSchema = codeScanningListAlertsForOrg200Schema

export const codeSecurityGetConfigurationsForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const codeSecurityGetConfigurationsForOrgQueryParamsSchema = z.object({
    "target_type": z.enum(["global", "all"]).default("all").describe("The target type of the code security configuration"),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""))
    })

/**
 * @description Response
 */
export const codeSecurityGetConfigurationsForOrg200Schema = z.array(codeSecurityConfigurationSchema.describe("A code security configuration"))

/**
 * @description Forbidden
 */
export const codeSecurityGetConfigurationsForOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeSecurityGetConfigurationsForOrg404Schema = basicErrorSchema.describe("Basic Error")

export const codeSecurityGetConfigurationsForOrgQueryResponseSchema = codeSecurityGetConfigurationsForOrg200Schema

export const codeSecurityCreateConfigurationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Successfully created code security configuration
 */
export const codeSecurityCreateConfiguration201Schema = codeSecurityConfigurationSchema.describe("A code security configuration")

export const codeSecurityCreateConfigurationMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the code security configuration. Must be unique within the organization."),
"description": z.string().max(255).describe("A description of the code security configuration"),
"advanced_security": z.optional(z.enum(["enabled", "disabled", "code_security", "secret_protection"]).default("disabled").describe("The enablement status of GitHub Advanced Security features. `enabled` will enable both Code Security and Secret Protection features.\n\n> [!WARNING]\n> `code_security` and `secret_protection` are deprecated values for this field. Prefer the individual `code_security` and `secret_protection` fields to set the status of these features.\n")),
"code_security": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of GitHub Code Security features.")),
"dependency_graph": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("enabled").describe("The enablement status of Dependency Graph")),
"dependency_graph_autosubmit_action": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of Automatic dependency submission")),
"dependency_graph_autosubmit_action_options": z.optional(z.object({
    "labeled_runners": z.optional(z.boolean().default(false).describe("Whether to use runners labeled with 'dependency-submission' or standard GitHub runners."))
    }).describe("Feature options for Automatic dependency submission")),
"dependabot_alerts": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of Dependabot alerts")),
"dependabot_security_updates": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of Dependabot security updates")),
get "code_scanning_options"(){
                return codeScanningOptionsSchema.describe("Security Configuration feature options for code scanning").optional()
              },
"code_scanning_default_setup": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of code scanning default setup")),
get "code_scanning_default_setup_options"(){
                return codeScanningDefaultSetupOptionsSchema.describe("Feature options for code scanning default setup").optional()
              },
"code_scanning_delegated_alert_dismissal": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("not_set").describe("The enablement status of code scanning delegated alert dismissal")),
"secret_protection": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of GitHub Secret Protection features.")),
"secret_scanning": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of secret scanning")),
"secret_scanning_push_protection": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of secret scanning push protection")),
"secret_scanning_delegated_bypass": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of secret scanning delegated bypass")),
"secret_scanning_delegated_bypass_options": z.optional(z.object({
    "reviewers": z.optional(z.array(z.object({
    "reviewer_id": z.int().describe("The ID of the team or role selected as a bypass reviewer"),
"reviewer_type": z.enum(["TEAM", "ROLE"]).describe("The type of the bypass reviewer")
    })).describe("The bypass reviewers for secret scanning delegated bypass"))
    }).describe("Feature options for secret scanning delegated bypass")),
"secret_scanning_validity_checks": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of secret scanning validity checks")),
"secret_scanning_non_provider_patterns": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of secret scanning non provider patterns")),
"secret_scanning_generic_secrets": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of Copilot secret scanning")),
"secret_scanning_delegated_alert_dismissal": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning delegated alert dismissal")),
"private_vulnerability_reporting": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of private vulnerability reporting")),
"enforcement": z.optional(z.enum(["enforced", "unenforced"]).default("enforced").describe("The enforcement status for a security configuration"))
    })

export const codeSecurityCreateConfigurationMutationResponseSchema = codeSecurityCreateConfiguration201Schema

export const codeSecurityGetDefaultConfigurationsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const codeSecurityGetDefaultConfigurations200Schema = codeSecurityDefaultConfigurationsSchema.describe("A list of default code security configurations")

/**
 * @description Not modified
 */
export const codeSecurityGetDefaultConfigurations304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const codeSecurityGetDefaultConfigurations403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeSecurityGetDefaultConfigurations404Schema = basicErrorSchema.describe("Basic Error")

export const codeSecurityGetDefaultConfigurationsQueryResponseSchema = codeSecurityGetDefaultConfigurations200Schema

export const codeSecurityDetachConfigurationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description A header with no content is returned.
 */
export const codeSecurityDetachConfiguration204Schema = z.unknown()

/**
 * @description Bad Request
 */
export const codeSecurityDetachConfiguration400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codeSecurityDetachConfiguration403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeSecurityDetachConfiguration404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const codeSecurityDetachConfiguration409Schema = basicErrorSchema.describe("Basic Error")

export const codeSecurityDetachConfigurationMutationRequestSchema = z.object({
    "selected_repository_ids": z.optional(z.array(z.int().describe("Unique identifier of the repository.")).min(1).max(250).describe("An array of repository IDs to detach from configurations. Up to 250 IDs can be provided."))
    })

export const codeSecurityDetachConfigurationMutationResponseSchema = codeSecurityDetachConfiguration204Schema

export const codeSecurityGetConfigurationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"configuration_id": z.coerce.number().int().describe("The unique identifier of the code security configuration.")
    })

/**
 * @description Response
 */
export const codeSecurityGetConfiguration200Schema = codeSecurityConfigurationSchema.describe("A code security configuration")

/**
 * @description Not modified
 */
export const codeSecurityGetConfiguration304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const codeSecurityGetConfiguration403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeSecurityGetConfiguration404Schema = basicErrorSchema.describe("Basic Error")

export const codeSecurityGetConfigurationQueryResponseSchema = codeSecurityGetConfiguration200Schema

export const codeSecurityUpdateConfigurationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"configuration_id": z.coerce.number().int().describe("The unique identifier of the code security configuration.")
    })

/**
 * @description Response when a configuration is updated
 */
export const codeSecurityUpdateConfiguration200Schema = codeSecurityConfigurationSchema.describe("A code security configuration")

/**
 * @description Response when no new updates are made
 */
export const codeSecurityUpdateConfiguration204Schema = z.unknown()

export const codeSecurityUpdateConfigurationMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("The name of the code security configuration. Must be unique within the organization.")),
"description": z.optional(z.string().max(255).describe("A description of the code security configuration")),
"advanced_security": z.optional(z.enum(["enabled", "disabled", "code_security", "secret_protection"]).describe("The enablement status of GitHub Advanced Security features. `enabled` will enable both Code Security and Secret Protection features.\n\n> [!WARNING]\n> `code_security` and `secret_protection` are deprecated values for this field. Prefer the individual `code_security` and `secret_protection` fields to set the status of these features.\n")),
"code_security": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of GitHub Code Security features.")),
"dependency_graph": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of Dependency Graph")),
"dependency_graph_autosubmit_action": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of Automatic dependency submission")),
"dependency_graph_autosubmit_action_options": z.optional(z.object({
    "labeled_runners": z.optional(z.boolean().describe("Whether to use runners labeled with 'dependency-submission' or standard GitHub runners."))
    }).describe("Feature options for Automatic dependency submission")),
"dependabot_alerts": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of Dependabot alerts")),
"dependabot_security_updates": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of Dependabot security updates")),
"code_scanning_default_setup": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of code scanning default setup")),
get "code_scanning_default_setup_options"(){
                return codeScanningDefaultSetupOptionsSchema.describe("Feature options for code scanning default setup").optional()
              },
"code_scanning_delegated_alert_dismissal": z.optional(z.enum(["enabled", "disabled", "not_set"]).default("disabled").describe("The enablement status of code scanning delegated alert dismissal")),
"secret_protection": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of GitHub Secret Protection features.")),
"secret_scanning": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning")),
"secret_scanning_push_protection": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning push protection")),
"secret_scanning_delegated_bypass": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning delegated bypass")),
"secret_scanning_delegated_bypass_options": z.optional(z.object({
    "reviewers": z.optional(z.array(z.object({
    "reviewer_id": z.int().describe("The ID of the team or role selected as a bypass reviewer"),
"reviewer_type": z.enum(["TEAM", "ROLE"]).describe("The type of the bypass reviewer")
    })).describe("The bypass reviewers for secret scanning delegated bypass"))
    }).describe("Feature options for secret scanning delegated bypass")),
"secret_scanning_validity_checks": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning validity checks")),
"secret_scanning_non_provider_patterns": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning non-provider patterns")),
"secret_scanning_generic_secrets": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of Copilot secret scanning")),
"secret_scanning_delegated_alert_dismissal": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of secret scanning delegated alert dismissal")),
"private_vulnerability_reporting": z.optional(z.enum(["enabled", "disabled", "not_set"]).describe("The enablement status of private vulnerability reporting")),
"enforcement": z.optional(z.enum(["enforced", "unenforced"]).describe("The enforcement status for a security configuration"))
    })

export const codeSecurityUpdateConfigurationMutationResponseSchema = z.union([codeSecurityUpdateConfiguration200Schema, codeSecurityUpdateConfiguration204Schema])

export const codeSecurityDeleteConfigurationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"configuration_id": z.coerce.number().int().describe("The unique identifier of the code security configuration.")
    })

/**
 * @description A header with no content is returned.
 */
export const codeSecurityDeleteConfiguration204Schema = z.unknown()

/**
 * @description Bad Request
 */
export const codeSecurityDeleteConfiguration400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codeSecurityDeleteConfiguration403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeSecurityDeleteConfiguration404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const codeSecurityDeleteConfiguration409Schema = basicErrorSchema.describe("Basic Error")

export const codeSecurityDeleteConfigurationMutationResponseSchema = codeSecurityDeleteConfiguration204Schema

export const codeSecurityAttachConfigurationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"configuration_id": z.coerce.number().int().describe("The unique identifier of the code security configuration.")
    })

/**
 * @description Accepted
 */
export const codeSecurityAttachConfiguration202Schema = z.object({
    
    })

export const codeSecurityAttachConfigurationMutationRequestSchema = z.object({
    "scope": z.enum(["all", "all_without_configurations", "public", "private_or_internal", "selected"]).describe("The type of repositories to attach the configuration to. `selected` means the configuration will be attached to only the repositories specified by `selected_repository_ids`"),
"selected_repository_ids": z.optional(z.array(z.int().describe("Unique identifier of the repository.")).describe("An array of repository IDs to attach the configuration to. You can only provide a list of repository ids when the `scope` is set to `selected`."))
    })

export const codeSecurityAttachConfigurationMutationResponseSchema = codeSecurityAttachConfiguration202Schema

export const codeSecuritySetConfigurationAsDefaultPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"configuration_id": z.coerce.number().int().describe("The unique identifier of the code security configuration.")
    })

/**
 * @description Default successfully changed.
 */
export const codeSecuritySetConfigurationAsDefault200Schema = z.object({
    "default_for_new_repos": z.optional(z.enum(["all", "none", "private_and_internal", "public"]).describe("Specifies which types of repository this security configuration is applied to by default.")),
get "configuration"(){
                return codeSecurityConfigurationSchema.describe("A code security configuration").optional()
              }
    })

/**
 * @description Forbidden
 */
export const codeSecuritySetConfigurationAsDefault403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeSecuritySetConfigurationAsDefault404Schema = basicErrorSchema.describe("Basic Error")

export const codeSecuritySetConfigurationAsDefaultMutationRequestSchema = z.object({
    "default_for_new_repos": z.optional(z.enum(["all", "none", "private_and_internal", "public"]).describe("Specify which types of repository this security configuration should be applied to by default."))
    })

export const codeSecuritySetConfigurationAsDefaultMutationResponseSchema = codeSecuritySetConfigurationAsDefault200Schema

export const codeSecurityGetRepositoriesForConfigurationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"configuration_id": z.coerce.number().int().describe("The unique identifier of the code security configuration.")
    })

export const codeSecurityGetRepositoriesForConfigurationQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"status": z.string().default("all").describe("A comma-separated list of statuses. If specified, only repositories with these attachment statuses will be returned.\n\nCan be: `all`, `attached`, `attaching`, `detached`, `removed`, `enforced`, `failed`, `updating`, `removed_by_enterprise`")
    })

/**
 * @description Response
 */
export const codeSecurityGetRepositoriesForConfiguration200Schema = z.array(codeSecurityConfigurationRepositoriesSchema.describe("Repositories associated with a code security configuration and attachment status"))

/**
 * @description Forbidden
 */
export const codeSecurityGetRepositoriesForConfiguration403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeSecurityGetRepositoriesForConfiguration404Schema = basicErrorSchema.describe("Basic Error")

export const codeSecurityGetRepositoriesForConfigurationQueryResponseSchema = codeSecurityGetRepositoriesForConfiguration200Schema

export const codespacesListInOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const codespacesListInOrganizationQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const codespacesListInOrganization200Schema = z.object({
    "total_count": z.int(),
get "codespaces"(){
                return z.array(codespaceSchema.describe("A codespace."))
              }
    })

/**
 * @description Not modified
 */
export const codespacesListInOrganization304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const codespacesListInOrganization401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesListInOrganization403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesListInOrganization404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesListInOrganization500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesListInOrganizationQueryResponseSchema = codespacesListInOrganization200Schema

export const codespacesSetCodespacesAccessPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response when successfully modifying permissions.
 */
export const codespacesSetCodespacesAccess204Schema = z.unknown()

/**
 * @description Not modified
 */
export const codespacesSetCodespacesAccess304Schema = z.unknown()

/**
 * @description Users are neither members nor collaborators of this organization.
 */
export const codespacesSetCodespacesAccess400Schema = z.unknown()

/**
 * @description Resource not found
 */
export const codespacesSetCodespacesAccess404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const codespacesSetCodespacesAccess422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Internal Error
 */
export const codespacesSetCodespacesAccess500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesSetCodespacesAccessMutationRequestSchema = z.object({
    "visibility": z.enum(["disabled", "selected_members", "all_members", "all_members_and_outside_collaborators"]).describe("Which users can access codespaces in the organization. `disabled` means that no users can access codespaces in the organization."),
"selected_usernames": z.optional(z.array(z.string()).max(100).describe("The usernames of the organization members who should have access to codespaces in the organization. Required when `visibility` is `selected_members`. The provided list of usernames will replace any existing value."))
    })

export const codespacesSetCodespacesAccessMutationResponseSchema = codespacesSetCodespacesAccess204Schema

export const codespacesSetCodespacesAccessUsersPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response when successfully modifying permissions.
 */
export const codespacesSetCodespacesAccessUsers204Schema = z.unknown()

/**
 * @description Not modified
 */
export const codespacesSetCodespacesAccessUsers304Schema = z.unknown()

/**
 * @description Users are neither members nor collaborators of this organization.
 */
export const codespacesSetCodespacesAccessUsers400Schema = z.unknown()

/**
 * @description Resource not found
 */
export const codespacesSetCodespacesAccessUsers404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const codespacesSetCodespacesAccessUsers422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Internal Error
 */
export const codespacesSetCodespacesAccessUsers500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesSetCodespacesAccessUsersMutationRequestSchema = z.object({
    "selected_usernames": z.array(z.string()).max(100).describe("The usernames of the organization members whose codespaces be billed to the organization.")
    })

export const codespacesSetCodespacesAccessUsersMutationResponseSchema = codespacesSetCodespacesAccessUsers204Schema

export const codespacesDeleteCodespacesAccessUsersPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response when successfully modifying permissions.
 */
export const codespacesDeleteCodespacesAccessUsers204Schema = z.unknown()

/**
 * @description Not modified
 */
export const codespacesDeleteCodespacesAccessUsers304Schema = z.unknown()

/**
 * @description Users are neither members nor collaborators of this organization.
 */
export const codespacesDeleteCodespacesAccessUsers400Schema = z.unknown()

/**
 * @description Resource not found
 */
export const codespacesDeleteCodespacesAccessUsers404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const codespacesDeleteCodespacesAccessUsers422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Internal Error
 */
export const codespacesDeleteCodespacesAccessUsers500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesDeleteCodespacesAccessUsersMutationRequestSchema = z.object({
    "selected_usernames": z.array(z.string()).max(100).describe("The usernames of the organization members whose codespaces should not be billed to the organization.")
    })

export const codespacesDeleteCodespacesAccessUsersMutationResponseSchema = codespacesDeleteCodespacesAccessUsers204Schema

export const codespacesListOrgSecretsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const codespacesListOrgSecretsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const codespacesListOrgSecrets200Schema = z.object({
    "total_count": z.int(),
get "secrets"(){
                return z.array(codespacesOrgSecretSchema.describe("Secrets for a GitHub Codespace."))
              }
    })

export const codespacesListOrgSecretsQueryResponseSchema = codespacesListOrgSecrets200Schema

export const codespacesGetOrgPublicKeyPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const codespacesGetOrgPublicKey200Schema = codespacesPublicKeySchema.describe("The public key used for setting Codespaces secrets.")

export const codespacesGetOrgPublicKeyQueryResponseSchema = codespacesGetOrgPublicKey200Schema

export const codespacesGetOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const codespacesGetOrgSecret200Schema = codespacesOrgSecretSchema.describe("Secrets for a GitHub Codespace.")

export const codespacesGetOrgSecretQueryResponseSchema = codespacesGetOrgSecret200Schema

export const codespacesCreateOrUpdateOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response when creating a secret
 */
export const codespacesCreateOrUpdateOrgSecret201Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Response when updating a secret
 */
export const codespacesCreateOrUpdateOrgSecret204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const codespacesCreateOrUpdateOrgSecret404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const codespacesCreateOrUpdateOrgSecret422Schema = validationErrorSchema.describe("Validation Error")

export const codespacesCreateOrUpdateOrgSecretMutationRequestSchema = z.object({
    "encrypted_value": z.optional(z.string().regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$/).describe("The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/codespaces/organization-secrets#get-an-organization-public-key) endpoint.")),
"key_id": z.optional(z.string().describe("The ID of the key you used to encrypt the secret.")),
"visibility": z.enum(["all", "private", "selected"]).describe("Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret."),
"selected_repository_ids": z.optional(z.array(z.int()).describe("An array of repository IDs that can access the organization secret. You can only provide a list of repository IDs when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#remove-selected-repository-from-an-organization-secret) endpoints."))
    })

export const codespacesCreateOrUpdateOrgSecretMutationResponseSchema = z.union([codespacesCreateOrUpdateOrgSecret201Schema, codespacesCreateOrUpdateOrgSecret204Schema])

export const codespacesDeleteOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const codespacesDeleteOrgSecret204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const codespacesDeleteOrgSecret404Schema = basicErrorSchema.describe("Basic Error")

export const codespacesDeleteOrgSecretMutationResponseSchema = codespacesDeleteOrgSecret204Schema

export const codespacesListSelectedReposForOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

export const codespacesListSelectedReposForOrgSecretQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const codespacesListSelectedReposForOrgSecret200Schema = z.object({
    "total_count": z.int(),
get "repositories"(){
                return z.array(minimalRepositorySchema.describe("Minimal Repository"))
              }
    })

/**
 * @description Resource not found
 */
export const codespacesListSelectedReposForOrgSecret404Schema = basicErrorSchema.describe("Basic Error")

export const codespacesListSelectedReposForOrgSecretQueryResponseSchema = codespacesListSelectedReposForOrgSecret200Schema

export const codespacesSetSelectedReposForOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const codespacesSetSelectedReposForOrgSecret204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const codespacesSetSelectedReposForOrgSecret404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict when visibility type not set to selected
 */
export const codespacesSetSelectedReposForOrgSecret409Schema = z.unknown()

export const codespacesSetSelectedReposForOrgSecretMutationRequestSchema = z.object({
    "selected_repository_ids": z.array(z.int()).describe("An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#remove-selected-repository-from-an-organization-secret) endpoints.")
    })

export const codespacesSetSelectedReposForOrgSecretMutationResponseSchema = codespacesSetSelectedReposForOrgSecret204Schema

export const codespacesAddSelectedRepoToOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret."),
"repository_id": z.coerce.number().int()
    })

/**
 * @description No Content when repository was added to the selected list
 */
export const codespacesAddSelectedRepoToOrgSecret204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const codespacesAddSelectedRepoToOrgSecret404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict when visibility type is not set to selected
 */
export const codespacesAddSelectedRepoToOrgSecret409Schema = z.unknown()

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const codespacesAddSelectedRepoToOrgSecret422Schema = validationErrorSchema.describe("Validation Error")

export const codespacesAddSelectedRepoToOrgSecretMutationResponseSchema = codespacesAddSelectedRepoToOrgSecret204Schema

export const codespacesRemoveSelectedRepoFromOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret."),
"repository_id": z.coerce.number().int()
    })

/**
 * @description Response when repository was removed from the selected list
 */
export const codespacesRemoveSelectedRepoFromOrgSecret204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const codespacesRemoveSelectedRepoFromOrgSecret404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict when visibility type not set to selected
 */
export const codespacesRemoveSelectedRepoFromOrgSecret409Schema = z.unknown()

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const codespacesRemoveSelectedRepoFromOrgSecret422Schema = validationErrorSchema.describe("Validation Error")

export const codespacesRemoveSelectedRepoFromOrgSecretMutationResponseSchema = codespacesRemoveSelectedRepoFromOrgSecret204Schema

export const copilotGetCopilotOrganizationDetailsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description OK
 */
export const copilotGetCopilotOrganizationDetails200Schema = copilotOrganizationDetailsSchema.describe("Information about the seat breakdown and policies set for an organization with a Copilot Business or Copilot Enterprise subscription.")

/**
 * @description Requires authentication
 */
export const copilotGetCopilotOrganizationDetails401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const copilotGetCopilotOrganizationDetails403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const copilotGetCopilotOrganizationDetails404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description There is a problem with your account\'s associated payment method.
 */
export const copilotGetCopilotOrganizationDetails422Schema = z.unknown()

/**
 * @description Internal Error
 */
export const copilotGetCopilotOrganizationDetails500Schema = basicErrorSchema.describe("Basic Error")

export const copilotGetCopilotOrganizationDetailsQueryResponseSchema = copilotGetCopilotOrganizationDetails200Schema

export const copilotListCopilotSeatsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const copilotListCopilotSeatsQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(50).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const copilotListCopilotSeats200Schema = z.object({
    "total_seats": z.optional(z.int().describe("Total number of Copilot seats for the organization currently being billed.")),
get "seats"(){
                return z.array(copilotSeatDetailsSchema.describe("Information about a Copilot Business seat assignment for a user, team, or organization.")).optional()
              }
    })

/**
 * @description Requires authentication
 */
export const copilotListCopilotSeats401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const copilotListCopilotSeats403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const copilotListCopilotSeats404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const copilotListCopilotSeats500Schema = basicErrorSchema.describe("Basic Error")

export const copilotListCopilotSeatsQueryResponseSchema = copilotListCopilotSeats200Schema

export const copilotAddCopilotSeatsForTeamsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description OK
 */
export const copilotAddCopilotSeatsForTeams201Schema = z.object({
    "seats_created": z.int()
    }).describe("The total number of seats created for members of the specified team(s).")

/**
 * @description Requires authentication
 */
export const copilotAddCopilotSeatsForTeams401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const copilotAddCopilotSeatsForTeams403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const copilotAddCopilotSeatsForTeams404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Copilot Business or Enterprise is not enabled for this organization, billing has not been set up for this organization, a public code suggestions policy has not been set for this organization, or the organization\'s Copilot access setting is set to enable Copilot for all users or is unconfigured.
 */
export const copilotAddCopilotSeatsForTeams422Schema = z.unknown()

/**
 * @description Internal Error
 */
export const copilotAddCopilotSeatsForTeams500Schema = basicErrorSchema.describe("Basic Error")

export const copilotAddCopilotSeatsForTeamsMutationRequestSchema = z.object({
    "selected_teams": z.array(z.string()).min(1).describe("List of team names within the organization to which to grant access to GitHub Copilot.")
    })

export const copilotAddCopilotSeatsForTeamsMutationResponseSchema = copilotAddCopilotSeatsForTeams201Schema

export const copilotCancelCopilotSeatAssignmentForTeamsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description OK
 */
export const copilotCancelCopilotSeatAssignmentForTeams200Schema = z.object({
    "seats_cancelled": z.int()
    }).describe("The total number of seats set to \"pending cancellation\" for members of the specified team(s).")

/**
 * @description Requires authentication
 */
export const copilotCancelCopilotSeatAssignmentForTeams401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const copilotCancelCopilotSeatAssignmentForTeams403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const copilotCancelCopilotSeatAssignmentForTeams404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Copilot Business or Enterprise is not enabled for this organization, billing has not been set up for this organization, a public code suggestions policy has not been set for this organization, or the organization\'s Copilot access setting is set to enable Copilot for all users or is unconfigured.
 */
export const copilotCancelCopilotSeatAssignmentForTeams422Schema = z.unknown()

/**
 * @description Internal Error
 */
export const copilotCancelCopilotSeatAssignmentForTeams500Schema = basicErrorSchema.describe("Basic Error")

export const copilotCancelCopilotSeatAssignmentForTeamsMutationRequestSchema = z.object({
    "selected_teams": z.array(z.string()).min(1).describe("The names of teams from which to revoke access to GitHub Copilot.")
    })

export const copilotCancelCopilotSeatAssignmentForTeamsMutationResponseSchema = copilotCancelCopilotSeatAssignmentForTeams200Schema

export const copilotAddCopilotSeatsForUsersPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description OK
 */
export const copilotAddCopilotSeatsForUsers201Schema = z.object({
    "seats_created": z.int()
    }).describe("The total number of seats created for the specified user(s).")

/**
 * @description Requires authentication
 */
export const copilotAddCopilotSeatsForUsers401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const copilotAddCopilotSeatsForUsers403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const copilotAddCopilotSeatsForUsers404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Copilot Business or Enterprise is not enabled for this organization, billing has not been set up for this organization, a public code suggestions policy has not been set for this organization, or the organization\'s Copilot access setting is set to enable Copilot for all users or is unconfigured.
 */
export const copilotAddCopilotSeatsForUsers422Schema = z.unknown()

/**
 * @description Internal Error
 */
export const copilotAddCopilotSeatsForUsers500Schema = basicErrorSchema.describe("Basic Error")

export const copilotAddCopilotSeatsForUsersMutationRequestSchema = z.object({
    "selected_usernames": z.array(z.string()).min(1).describe("The usernames of the organization members to be granted access to GitHub Copilot.")
    })

export const copilotAddCopilotSeatsForUsersMutationResponseSchema = copilotAddCopilotSeatsForUsers201Schema

export const copilotCancelCopilotSeatAssignmentForUsersPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description OK
 */
export const copilotCancelCopilotSeatAssignmentForUsers200Schema = z.object({
    "seats_cancelled": z.int()
    }).describe("The total number of seats set to \"pending cancellation\" for the specified users.")

/**
 * @description Requires authentication
 */
export const copilotCancelCopilotSeatAssignmentForUsers401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const copilotCancelCopilotSeatAssignmentForUsers403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const copilotCancelCopilotSeatAssignmentForUsers404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Copilot Business or Enterprise is not enabled for this organization, billing has not been set up for this organization, a public code suggestions policy has not been set for this organization, the seat management setting is set to enable Copilot for all users or is unconfigured, or a user\'s seat cannot be cancelled because it was assigned to them via a team.
 */
export const copilotCancelCopilotSeatAssignmentForUsers422Schema = z.unknown()

/**
 * @description Internal Error
 */
export const copilotCancelCopilotSeatAssignmentForUsers500Schema = basicErrorSchema.describe("Basic Error")

export const copilotCancelCopilotSeatAssignmentForUsersMutationRequestSchema = z.object({
    "selected_usernames": z.array(z.string()).min(1).describe("The usernames of the organization members for which to revoke access to GitHub Copilot.")
    })

export const copilotCancelCopilotSeatAssignmentForUsersMutationResponseSchema = copilotCancelCopilotSeatAssignmentForUsers200Schema

export const copilotCopilotMetricsForOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const copilotCopilotMetricsForOrganizationQueryParamsSchema = z.object({
    "since": z.optional(z.string().describe("Show usage metrics since this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`). Maximum value is 100 days ago.")),
"until": z.optional(z.string().describe("Show usage metrics until this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`) and should not preceed the `since` date if it is passed.")),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(100).describe("The number of days of metrics to display per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const copilotCopilotMetricsForOrganization200Schema = z.array(copilotUsageMetricsDaySchema.describe("Copilot usage metrics for a given day."))

/**
 * @description Forbidden
 */
export const copilotCopilotMetricsForOrganization403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const copilotCopilotMetricsForOrganization404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Copilot Usage Merics API setting is disabled at the organization or enterprise level.
 */
export const copilotCopilotMetricsForOrganization422Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const copilotCopilotMetricsForOrganization500Schema = basicErrorSchema.describe("Basic Error")

export const copilotCopilotMetricsForOrganizationQueryResponseSchema = copilotCopilotMetricsForOrganization200Schema

export const dependabotListAlertsForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const dependabotListAlertsForOrgQueryParamsSchema = z.object({
    "state": z.optional(z.string().describe("A comma-separated list of states. If specified, only alerts with these states will be returned.\n\nCan be: `auto_dismissed`, `dismissed`, `fixed`, `open`")),
"severity": z.optional(z.string().describe("A comma-separated list of severities. If specified, only alerts with these severities will be returned.\n\nCan be: `low`, `medium`, `high`, `critical`")),
"ecosystem": z.optional(z.string().describe("A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.\n\nCan be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`")),
"package": z.optional(z.string().describe("A comma-separated list of package names. If specified, only alerts for these packages will be returned.")),
"epss_percentage": z.optional(z.string().describe("CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as:\n- An exact number (`n`)\n- Comparators such as `>n`, `<n`, `>=n`, `<=n`\n- A range like `n..n`, where `n` is a number from 0.0 to 1.0\n\nFilters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned.")),
"artifact_registry_url": z.optional(z.string().describe("A comma-separated list of artifact registry URLs. If specified, only alerts for repositories with storage records matching these URLs will be returned.")),
"artifact_registry": z.optional(z.string().describe("A comma-separated list of Artifact Registry name strings. If specified, only alerts for repositories with storage records matching these registries will be returned.\n\nCan be: `jfrog-artifactory`")),
"has": z.optional(z.union([z.array(z.enum(["patch", "deployment"])), z.string()]).describe("Filters the list of alerts based on whether the alert has the given value. If specified, only alerts meeting this criterion will be returned.\nMultiple `has` filters can be passed to filter for alerts that have all of the values.")),
"runtime_risk": z.optional(z.string().describe("A comma-separated list of runtime risk strings. If specified, only alerts for repositories with deployment records matching these risks will be returned.\n\nCan be: `critical-resource`, `internet-exposed`, `sensitive-data`, `lateral-movement`")),
"scope": z.optional(z.enum(["development", "runtime"]).describe("The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.")),
"sort": z.enum(["created", "updated", "epss_percentage"]).default("created").describe("The property by which to sort the results.\n`created` means when the alert was created.\n`updated` means when the alert's state last changed.\n`epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage."),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const dependabotListAlertsForOrg200Schema = z.array(dependabotAlertWithRepositorySchema.describe("A Dependabot alert."))

/**
 * @description Not modified
 */
export const dependabotListAlertsForOrg304Schema = z.unknown()

/**
 * @description Bad Request
 */
export const dependabotListAlertsForOrg400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const dependabotListAlertsForOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const dependabotListAlertsForOrg404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const dependabotListAlertsForOrg422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const dependabotListAlertsForOrgQueryResponseSchema = dependabotListAlertsForOrg200Schema

export const dependabotListOrgSecretsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const dependabotListOrgSecretsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const dependabotListOrgSecrets200Schema = z.object({
    "total_count": z.int(),
get "secrets"(){
                return z.array(organizationDependabotSecretSchema.describe("Secrets for GitHub Dependabot for an organization."))
              }
    })

export const dependabotListOrgSecretsQueryResponseSchema = dependabotListOrgSecrets200Schema

export const dependabotGetOrgPublicKeyPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const dependabotGetOrgPublicKey200Schema = dependabotPublicKeySchema.describe("The public key used for setting Dependabot Secrets.")

export const dependabotGetOrgPublicKeyQueryResponseSchema = dependabotGetOrgPublicKey200Schema

export const dependabotGetOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const dependabotGetOrgSecret200Schema = organizationDependabotSecretSchema.describe("Secrets for GitHub Dependabot for an organization.")

export const dependabotGetOrgSecretQueryResponseSchema = dependabotGetOrgSecret200Schema

export const dependabotCreateOrUpdateOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response when creating a secret
 */
export const dependabotCreateOrUpdateOrgSecret201Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Response when updating a secret
 */
export const dependabotCreateOrUpdateOrgSecret204Schema = z.unknown()

export const dependabotCreateOrUpdateOrgSecretMutationRequestSchema = z.object({
    "encrypted_value": z.optional(z.string().regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$/).describe("Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/dependabot/secrets#get-an-organization-public-key) endpoint.")),
"key_id": z.optional(z.string().describe("ID of the key you used to encrypt the secret.")),
"visibility": z.enum(["all", "private", "selected"]).describe("Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret."),
"selected_repository_ids": z.optional(z.array(z.union([z.int(), z.string()])).describe("An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret) endpoints. Use integers when possible, as strings are supported only to maintain backwards compatibility and may be removed in the future."))
    })

export const dependabotCreateOrUpdateOrgSecretMutationResponseSchema = z.union([dependabotCreateOrUpdateOrgSecret201Schema, dependabotCreateOrUpdateOrgSecret204Schema])

export const dependabotDeleteOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const dependabotDeleteOrgSecret204Schema = z.unknown()

export const dependabotDeleteOrgSecretMutationResponseSchema = dependabotDeleteOrgSecret204Schema

export const dependabotListSelectedReposForOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

export const dependabotListSelectedReposForOrgSecretQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const dependabotListSelectedReposForOrgSecret200Schema = z.object({
    "total_count": z.int(),
get "repositories"(){
                return z.array(minimalRepositorySchema.describe("Minimal Repository"))
              }
    })

export const dependabotListSelectedReposForOrgSecretQueryResponseSchema = dependabotListSelectedReposForOrgSecret200Schema

export const dependabotSetSelectedReposForOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const dependabotSetSelectedReposForOrgSecret204Schema = z.unknown()

export const dependabotSetSelectedReposForOrgSecretMutationRequestSchema = z.object({
    "selected_repository_ids": z.array(z.int()).describe("An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret) endpoints.")
    })

export const dependabotSetSelectedReposForOrgSecretMutationResponseSchema = dependabotSetSelectedReposForOrgSecret204Schema

export const dependabotAddSelectedRepoToOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret."),
"repository_id": z.coerce.number().int()
    })

/**
 * @description No Content when repository was added to the selected list
 */
export const dependabotAddSelectedRepoToOrgSecret204Schema = z.unknown()

/**
 * @description Conflict when visibility type is not set to selected
 */
export const dependabotAddSelectedRepoToOrgSecret409Schema = z.unknown()

export const dependabotAddSelectedRepoToOrgSecretMutationResponseSchema = dependabotAddSelectedRepoToOrgSecret204Schema

export const dependabotRemoveSelectedRepoFromOrgSecretPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret."),
"repository_id": z.coerce.number().int()
    })

/**
 * @description Response when repository was removed from the selected list
 */
export const dependabotRemoveSelectedRepoFromOrgSecret204Schema = z.unknown()

/**
 * @description Conflict when visibility type not set to selected
 */
export const dependabotRemoveSelectedRepoFromOrgSecret409Schema = z.unknown()

export const dependabotRemoveSelectedRepoFromOrgSecretMutationResponseSchema = dependabotRemoveSelectedRepoFromOrgSecret204Schema

export const packagesListDockerMigrationConflictingPackagesForOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const packagesListDockerMigrationConflictingPackagesForOrganization200Schema = z.array(packageSchema.describe("A software package"))

/**
 * @description Requires authentication
 */
export const packagesListDockerMigrationConflictingPackagesForOrganization401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesListDockerMigrationConflictingPackagesForOrganization403Schema = basicErrorSchema.describe("Basic Error")

export const packagesListDockerMigrationConflictingPackagesForOrganizationQueryResponseSchema = packagesListDockerMigrationConflictingPackagesForOrganization200Schema

export const activityListPublicOrgEventsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const activityListPublicOrgEventsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListPublicOrgEvents200Schema = z.array(eventSchema.describe("Event"))

export const activityListPublicOrgEventsQueryResponseSchema = activityListPublicOrgEvents200Schema

export const orgsListFailedInvitationsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const orgsListFailedInvitationsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const orgsListFailedInvitations200Schema = z.array(organizationInvitationSchema.describe("Organization Invitation"))

/**
 * @description Resource not found
 */
export const orgsListFailedInvitations404Schema = basicErrorSchema.describe("Basic Error")

export const orgsListFailedInvitationsQueryResponseSchema = orgsListFailedInvitations200Schema

export const orgsListWebhooksPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const orgsListWebhooksQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const orgsListWebhooks200Schema = z.array(orgHookSchema.describe("Org Hook"))

/**
 * @description Resource not found
 */
export const orgsListWebhooks404Schema = basicErrorSchema.describe("Basic Error")

export const orgsListWebhooksQueryResponseSchema = orgsListWebhooks200Schema

export const orgsCreateWebhookPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const orgsCreateWebhook201Schema = orgHookSchema.describe("Org Hook")

/**
 * @description Resource not found
 */
export const orgsCreateWebhook404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsCreateWebhook422Schema = validationErrorSchema.describe("Validation Error")

export const orgsCreateWebhookMutationRequestSchema = z.object({
    "name": z.string().describe("Must be passed as \"web\"."),
"config": z.object({
    get "url"(){
                return webhookConfigUrlSchema.describe("The URL to which the payloads will be delivered.")
              },
get "content_type"(){
                return webhookConfigContentTypeSchema.describe("The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.").optional()
              },
get "secret"(){
                return webhookConfigSecretSchema.describe("If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).").optional()
              },
get "insecure_ssl"(){
                return webhookConfigInsecureSslSchema.optional()
              },
"username": z.optional(z.string()),
"password": z.optional(z.string())
    }).describe("Key/value pairs to provide settings for this webhook."),
"events": z.optional(z.array(z.string()).describe("Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. Set to `[\"*\"]` to receive all possible events.")),
"active": z.optional(z.boolean().default(true).describe("Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications."))
    })

export const orgsCreateWebhookMutationResponseSchema = orgsCreateWebhook201Schema

export const orgsGetWebhookPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.")
    })

/**
 * @description Response
 */
export const orgsGetWebhook200Schema = orgHookSchema.describe("Org Hook")

/**
 * @description Resource not found
 */
export const orgsGetWebhook404Schema = basicErrorSchema.describe("Basic Error")

export const orgsGetWebhookQueryResponseSchema = orgsGetWebhook200Schema

export const orgsUpdateWebhookPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.")
    })

/**
 * @description Response
 */
export const orgsUpdateWebhook200Schema = orgHookSchema.describe("Org Hook")

/**
 * @description Resource not found
 */
export const orgsUpdateWebhook404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsUpdateWebhook422Schema = validationErrorSchema.describe("Validation Error")

export const orgsUpdateWebhookMutationRequestSchema = z.object({
    "config": z.optional(z.object({
    get "url"(){
                return webhookConfigUrlSchema.describe("The URL to which the payloads will be delivered.")
              },
get "content_type"(){
                return webhookConfigContentTypeSchema.describe("The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.").optional()
              },
get "secret"(){
                return webhookConfigSecretSchema.describe("If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).").optional()
              },
get "insecure_ssl"(){
                return webhookConfigInsecureSslSchema.optional()
              }
    }).describe("Key/value pairs to provide settings for this webhook.")),
"events": z.optional(z.array(z.string()).describe("Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.")),
"active": z.optional(z.boolean().default(true).describe("Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.")),
"name": z.optional(z.string())
    })

export const orgsUpdateWebhookMutationResponseSchema = orgsUpdateWebhook200Schema

export const orgsDeleteWebhookPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.")
    })

/**
 * @description Response
 */
export const orgsDeleteWebhook204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const orgsDeleteWebhook404Schema = basicErrorSchema.describe("Basic Error")

export const orgsDeleteWebhookMutationResponseSchema = orgsDeleteWebhook204Schema

export const orgsGetWebhookConfigForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.")
    })

/**
 * @description Response
 */
export const orgsGetWebhookConfigForOrg200Schema = webhookConfigSchema.describe("Configuration object of the webhook")

export const orgsGetWebhookConfigForOrgQueryResponseSchema = orgsGetWebhookConfigForOrg200Schema

export const orgsUpdateWebhookConfigForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.")
    })

/**
 * @description Response
 */
export const orgsUpdateWebhookConfigForOrg200Schema = webhookConfigSchema.describe("Configuration object of the webhook")

export const orgsUpdateWebhookConfigForOrgMutationRequestSchema = z.object({
    get "url"(){
                return webhookConfigUrlSchema.describe("The URL to which the payloads will be delivered.").optional()
              },
get "content_type"(){
                return webhookConfigContentTypeSchema.describe("The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.").optional()
              },
get "secret"(){
                return webhookConfigSecretSchema.describe("If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).").optional()
              },
get "insecure_ssl"(){
                return webhookConfigInsecureSslSchema.optional()
              }
    })

export const orgsUpdateWebhookConfigForOrgMutationResponseSchema = orgsUpdateWebhookConfigForOrg200Schema

export const orgsListWebhookDeliveriesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.")
    })

export const orgsListWebhookDeliveriesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"cursor": z.optional(z.string().describe("Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors."))
    })

/**
 * @description Response
 */
export const orgsListWebhookDeliveries200Schema = z.array(hookDeliveryItemSchema.describe("Delivery made by a webhook, without request and response information."))

/**
 * @description Bad Request
 */
export const orgsListWebhookDeliveries400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsListWebhookDeliveries422Schema = validationErrorSchema.describe("Validation Error")

export const orgsListWebhookDeliveriesQueryResponseSchema = orgsListWebhookDeliveries200Schema

export const orgsGetWebhookDeliveryPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery."),
"delivery_id": z.coerce.number().int()
    })

/**
 * @description Response
 */
export const orgsGetWebhookDelivery200Schema = hookDeliverySchema.describe("Delivery made by a webhook.")

/**
 * @description Bad Request
 */
export const orgsGetWebhookDelivery400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsGetWebhookDelivery422Schema = validationErrorSchema.describe("Validation Error")

export const orgsGetWebhookDeliveryQueryResponseSchema = orgsGetWebhookDelivery200Schema

export const orgsRedeliverWebhookDeliveryPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery."),
"delivery_id": z.coerce.number().int()
    })

/**
 * @description Accepted
 */
export const orgsRedeliverWebhookDelivery202Schema = z.object({
    
    })

/**
 * @description Bad Request
 */
export const orgsRedeliverWebhookDelivery400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsRedeliverWebhookDelivery422Schema = validationErrorSchema.describe("Validation Error")

export const orgsRedeliverWebhookDeliveryMutationResponseSchema = orgsRedeliverWebhookDelivery202Schema

export const orgsPingWebhookPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.")
    })

/**
 * @description Response
 */
export const orgsPingWebhook204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const orgsPingWebhook404Schema = basicErrorSchema.describe("Basic Error")

export const orgsPingWebhookMutationResponseSchema = orgsPingWebhook204Schema

export const apiInsightsGetRouteStatsByActorPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"actor_type": z.enum(["installation", "classic_pat", "fine_grained_pat", "oauth_app", "github_app_user_to_server"]).describe("The type of the actor"),
"actor_id": z.coerce.number().int().describe("The ID of the actor")
    })

export const apiInsightsGetRouteStatsByActorQueryParamsSchema = z.object({
    "min_timestamp": z.string().describe("The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."),
"max_timestamp": z.optional(z.string().describe("The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"page": z.optional(z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"per_page": z.optional(z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"direction": z.optional(z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by.")),
"sort": z.optional(z.array(z.enum(["last_rate_limited_timestamp", "last_request_timestamp", "rate_limited_request_count", "http_method", "api_route", "total_request_count"]).default("total_request_count")).describe("The property to sort the results by.")),
"api_route_substring": z.optional(z.string().describe("Providing a substring will filter results where the API route contains the substring. This is a case-insensitive search."))
    })

/**
 * @description Response
 */
export const apiInsightsGetRouteStatsByActor200Schema = apiInsightsRouteStatsSchema.describe("API Insights usage route stats for an actor")

export const apiInsightsGetRouteStatsByActorQueryResponseSchema = apiInsightsGetRouteStatsByActor200Schema

export const apiInsightsGetSubjectStatsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const apiInsightsGetSubjectStatsQueryParamsSchema = z.object({
    "min_timestamp": z.string().describe("The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."),
"max_timestamp": z.optional(z.string().describe("The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"page": z.optional(z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"per_page": z.optional(z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"direction": z.optional(z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by.")),
"sort": z.optional(z.array(z.enum(["last_rate_limited_timestamp", "last_request_timestamp", "rate_limited_request_count", "subject_name", "total_request_count"]).default("total_request_count")).describe("The property to sort the results by.")),
"subject_name_substring": z.optional(z.string().describe("Providing a substring will filter results where the subject name contains the substring. This is a case-insensitive search."))
    })

/**
 * @description Response
 */
export const apiInsightsGetSubjectStats200Schema = apiInsightsSubjectStatsSchema.describe("API Insights usage subject stats for an organization")

export const apiInsightsGetSubjectStatsQueryResponseSchema = apiInsightsGetSubjectStats200Schema

export const apiInsightsGetSummaryStatsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const apiInsightsGetSummaryStatsQueryParamsSchema = z.object({
    "min_timestamp": z.string().describe("The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."),
"max_timestamp": z.optional(z.string().describe("The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."))
    })

/**
 * @description Response
 */
export const apiInsightsGetSummaryStats200Schema = apiInsightsSummaryStatsSchema.describe("API Insights usage summary stats for an organization")

export const apiInsightsGetSummaryStatsQueryResponseSchema = apiInsightsGetSummaryStats200Schema

export const apiInsightsGetSummaryStatsByUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"user_id": z.string().describe("The ID of the user to query for stats")
    })

export const apiInsightsGetSummaryStatsByUserQueryParamsSchema = z.object({
    "min_timestamp": z.string().describe("The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."),
"max_timestamp": z.optional(z.string().describe("The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."))
    })

/**
 * @description Response
 */
export const apiInsightsGetSummaryStatsByUser200Schema = apiInsightsSummaryStatsSchema.describe("API Insights usage summary stats for an organization")

export const apiInsightsGetSummaryStatsByUserQueryResponseSchema = apiInsightsGetSummaryStatsByUser200Schema

export const apiInsightsGetSummaryStatsByActorPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"actor_type": z.enum(["installation", "classic_pat", "fine_grained_pat", "oauth_app", "github_app_user_to_server"]).describe("The type of the actor"),
"actor_id": z.coerce.number().int().describe("The ID of the actor")
    })

export const apiInsightsGetSummaryStatsByActorQueryParamsSchema = z.object({
    "min_timestamp": z.string().describe("The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."),
"max_timestamp": z.optional(z.string().describe("The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."))
    })

/**
 * @description Response
 */
export const apiInsightsGetSummaryStatsByActor200Schema = apiInsightsSummaryStatsSchema.describe("API Insights usage summary stats for an organization")

export const apiInsightsGetSummaryStatsByActorQueryResponseSchema = apiInsightsGetSummaryStatsByActor200Schema

export const apiInsightsGetTimeStatsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const apiInsightsGetTimeStatsQueryParamsSchema = z.object({
    "min_timestamp": z.string().describe("The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."),
"max_timestamp": z.optional(z.string().describe("The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"timestamp_increment": z.string().describe("The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)")
    })

/**
 * @description Response
 */
export const apiInsightsGetTimeStats200Schema = apiInsightsTimeStatsSchema.describe("API Insights usage time stats for an organization")

export const apiInsightsGetTimeStatsQueryResponseSchema = apiInsightsGetTimeStats200Schema

export const apiInsightsGetTimeStatsByUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"user_id": z.string().describe("The ID of the user to query for stats")
    })

export const apiInsightsGetTimeStatsByUserQueryParamsSchema = z.object({
    "min_timestamp": z.string().describe("The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."),
"max_timestamp": z.optional(z.string().describe("The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"timestamp_increment": z.string().describe("The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)")
    })

/**
 * @description Response
 */
export const apiInsightsGetTimeStatsByUser200Schema = apiInsightsTimeStatsSchema.describe("API Insights usage time stats for an organization")

export const apiInsightsGetTimeStatsByUserQueryResponseSchema = apiInsightsGetTimeStatsByUser200Schema

export const apiInsightsGetTimeStatsByActorPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"actor_type": z.enum(["installation", "classic_pat", "fine_grained_pat", "oauth_app", "github_app_user_to_server"]).describe("The type of the actor"),
"actor_id": z.coerce.number().int().describe("The ID of the actor")
    })

export const apiInsightsGetTimeStatsByActorQueryParamsSchema = z.object({
    "min_timestamp": z.string().describe("The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."),
"max_timestamp": z.optional(z.string().describe("The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"timestamp_increment": z.string().describe("The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)")
    })

/**
 * @description Response
 */
export const apiInsightsGetTimeStatsByActor200Schema = apiInsightsTimeStatsSchema.describe("API Insights usage time stats for an organization")

export const apiInsightsGetTimeStatsByActorQueryResponseSchema = apiInsightsGetTimeStatsByActor200Schema

export const apiInsightsGetUserStatsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"user_id": z.string().describe("The ID of the user to query for stats")
    })

export const apiInsightsGetUserStatsQueryParamsSchema = z.object({
    "min_timestamp": z.string().describe("The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."),
"max_timestamp": z.optional(z.string().describe("The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"page": z.optional(z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"per_page": z.optional(z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"direction": z.optional(z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by.")),
"sort": z.optional(z.array(z.enum(["last_rate_limited_timestamp", "last_request_timestamp", "rate_limited_request_count", "subject_name", "total_request_count"]).default("total_request_count")).describe("The property to sort the results by.")),
"actor_name_substring": z.optional(z.string().describe("Providing a substring will filter results where the actor name contains the substring. This is a case-insensitive search."))
    })

/**
 * @description Response
 */
export const apiInsightsGetUserStats200Schema = apiInsightsUserStatsSchema.describe("API Insights usage stats for a user")

export const apiInsightsGetUserStatsQueryResponseSchema = apiInsightsGetUserStats200Schema

export const appsGetOrgInstallationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const appsGetOrgInstallation200Schema = installationSchema.describe("Installation")

export const appsGetOrgInstallationQueryResponseSchema = appsGetOrgInstallation200Schema

export const orgsListAppInstallationsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const orgsListAppInstallationsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const orgsListAppInstallations200Schema = z.object({
    "total_count": z.int(),
get "installations"(){
                return z.array(installationSchema.describe("Installation"))
              }
    })

export const orgsListAppInstallationsQueryResponseSchema = orgsListAppInstallations200Schema

export const interactionsGetRestrictionsForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const interactionsGetRestrictionsForOrg200Schema = z.union([interactionLimitResponseSchema, z.object({
    
    })])

export const interactionsGetRestrictionsForOrgQueryResponseSchema = interactionsGetRestrictionsForOrg200Schema

export const interactionsSetRestrictionsForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const interactionsSetRestrictionsForOrg200Schema = interactionLimitResponseSchema.describe("Interaction limit settings.")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const interactionsSetRestrictionsForOrg422Schema = validationErrorSchema.describe("Validation Error")

export const interactionsSetRestrictionsForOrgMutationRequestSchema = interactionLimitSchema.describe("Limit interactions to a specific type of user for a specified duration")

export const interactionsSetRestrictionsForOrgMutationResponseSchema = interactionsSetRestrictionsForOrg200Schema

export const interactionsRemoveRestrictionsForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const interactionsRemoveRestrictionsForOrg204Schema = z.unknown()

export const interactionsRemoveRestrictionsForOrgMutationResponseSchema = interactionsRemoveRestrictionsForOrg204Schema

export const orgsListPendingInvitationsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const orgsListPendingInvitationsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"role": z.enum(["all", "admin", "direct_member", "billing_manager", "hiring_manager"]).default("all").describe("Filter invitations by their member role."),
"invitation_source": z.enum(["all", "member", "scim"]).default("all").describe("Filter invitations by their invitation source.")
    })

/**
 * @description Response
 */
export const orgsListPendingInvitations200Schema = z.array(organizationInvitationSchema.describe("Organization Invitation"))

/**
 * @description Resource not found
 */
export const orgsListPendingInvitations404Schema = basicErrorSchema.describe("Basic Error")

export const orgsListPendingInvitationsQueryResponseSchema = orgsListPendingInvitations200Schema

export const orgsCreateInvitationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const orgsCreateInvitation201Schema = organizationInvitationSchema.describe("Organization Invitation")

/**
 * @description Resource not found
 */
export const orgsCreateInvitation404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsCreateInvitation422Schema = validationErrorSchema.describe("Validation Error")

export const orgsCreateInvitationMutationRequestSchema = z.object({
    "invitee_id": z.optional(z.int().describe("**Required unless you provide `email`**. GitHub user ID for the person you are inviting.")),
"email": z.optional(z.string().describe("**Required unless you provide `invitee_id`**. Email address of the person you are inviting, which can be an existing GitHub user.")),
"role": z.optional(z.enum(["admin", "direct_member", "billing_manager", "reinstate"]).default("direct_member").describe("The role for the new member. \n * `admin` - Organization owners with full administrative rights to the organization and complete access to all repositories and teams.  \n * `direct_member` - Non-owner organization members with ability to see other members and join teams by invitation.  \n * `billing_manager` - Non-owner organization members with ability to manage the billing settings of your organization. \n * `reinstate` - The previous role assigned to the invitee before they were removed from your organization. Can be one of the roles listed above. Only works if the invitee was previously part of your organization.")),
"team_ids": z.optional(z.array(z.int()).describe("Specify IDs for the teams you want to invite new members to."))
    })

export const orgsCreateInvitationMutationResponseSchema = orgsCreateInvitation201Schema

export const orgsCancelInvitationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"invitation_id": z.coerce.number().int().describe("The unique identifier of the invitation.")
    })

/**
 * @description Response
 */
export const orgsCancelInvitation204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const orgsCancelInvitation404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsCancelInvitation422Schema = validationErrorSchema.describe("Validation Error")

export const orgsCancelInvitationMutationResponseSchema = orgsCancelInvitation204Schema

export const orgsListInvitationTeamsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"invitation_id": z.coerce.number().int().describe("The unique identifier of the invitation.")
    })

export const orgsListInvitationTeamsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const orgsListInvitationTeams200Schema = z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories."))

/**
 * @description Resource not found
 */
export const orgsListInvitationTeams404Schema = basicErrorSchema.describe("Basic Error")

export const orgsListInvitationTeamsQueryResponseSchema = orgsListInvitationTeams200Schema

export const orgsListIssueTypesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const orgsListIssueTypes200Schema = z.array(issueTypeSchema.describe("The type of issue.").nullable())

/**
 * @description Resource not found
 */
export const orgsListIssueTypes404Schema = basicErrorSchema.describe("Basic Error")

export const orgsListIssueTypesQueryResponseSchema = orgsListIssueTypes200Schema

export const orgsCreateIssueTypePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const orgsCreateIssueType200Schema = issueTypeSchema.describe("The type of issue.").nullable()

/**
 * @description Resource not found
 */
export const orgsCreateIssueType404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsCreateIssueType422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const orgsCreateIssueTypeMutationRequestSchema = organizationCreateIssueTypeSchema

export const orgsCreateIssueTypeMutationResponseSchema = orgsCreateIssueType200Schema

export const orgsUpdateIssueTypePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"issue_type_id": z.coerce.number().int().describe("The unique identifier of the issue type.")
    })

/**
 * @description Response
 */
export const orgsUpdateIssueType200Schema = issueTypeSchema.describe("The type of issue.").nullable()

/**
 * @description Resource not found
 */
export const orgsUpdateIssueType404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsUpdateIssueType422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const orgsUpdateIssueTypeMutationRequestSchema = organizationUpdateIssueTypeSchema

export const orgsUpdateIssueTypeMutationResponseSchema = orgsUpdateIssueType200Schema

export const orgsDeleteIssueTypePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"issue_type_id": z.coerce.number().int().describe("The unique identifier of the issue type.")
    })

/**
 * @description Response
 */
export const orgsDeleteIssueType204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const orgsDeleteIssueType404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsDeleteIssueType422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const orgsDeleteIssueTypeMutationResponseSchema = orgsDeleteIssueType204Schema

export const issuesListForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const issuesListForOrgQueryParamsSchema = z.object({
    "filter": z.enum(["assigned", "created", "mentioned", "subscribed", "repos", "all"]).default("assigned").describe("Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation."),
"state": z.enum(["open", "closed", "all"]).default("open").describe("Indicates the state of the issues to return."),
"labels": z.optional(z.string().describe("A list of comma separated label names. Example: `bug,ui,@high`")),
"type": z.optional(z.string().describe("Can be the name of an issue type.")),
"sort": z.enum(["created", "updated", "comments"]).default("created").describe("What to sort results by."),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"since": z.optional(z.iso.datetime({ offset: true }).describe("Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesListForOrg200Schema = z.array(issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects."))

/**
 * @description Resource not found
 */
export const issuesListForOrg404Schema = basicErrorSchema.describe("Basic Error")

export const issuesListForOrgQueryResponseSchema = issuesListForOrg200Schema

export const orgsListMembersPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const orgsListMembersQueryParamsSchema = z.object({
    "filter": z.enum(["2fa_disabled", "2fa_insecure", "all"]).default("all").describe("Filter members returned in the list. `2fa_disabled` means that only members without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled will be returned. `2fa_insecure` means that only members with [insecure 2FA methods](https://docs.github.com/organizations/keeping-your-organization-secure/managing-two-factor-authentication-for-your-organization/requiring-two-factor-authentication-in-your-organization#requiring-secure-methods-of-two-factor-authentication-in-your-organization) will be returned. These options are only available for organization owners."),
"role": z.enum(["all", "admin", "member"]).default("all").describe("Filter members returned by their role."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const orgsListMembers200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsListMembers422Schema = validationErrorSchema.describe("Validation Error")

export const orgsListMembersQueryResponseSchema = orgsListMembers200Schema

export const orgsCheckMembershipForUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response if requester is an organization member and user is a member
 */
export const orgsCheckMembershipForUser204Schema = z.unknown()

/**
 * @description Response if requester is not an organization member
 */
export const orgsCheckMembershipForUser302Schema = z.unknown()

/**
 * @description Not Found if requester is an organization member and user is not a member
 */
export const orgsCheckMembershipForUser404Schema = z.unknown()

export const orgsCheckMembershipForUserQueryResponseSchema = orgsCheckMembershipForUser204Schema

export const orgsRemoveMemberPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const orgsRemoveMember204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const orgsRemoveMember403Schema = basicErrorSchema.describe("Basic Error")

export const orgsRemoveMemberMutationResponseSchema = orgsRemoveMember204Schema

export const codespacesGetCodespacesForUserInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

export const codespacesGetCodespacesForUserInOrgQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const codespacesGetCodespacesForUserInOrg200Schema = z.object({
    "total_count": z.int(),
get "codespaces"(){
                return z.array(codespaceSchema.describe("A codespace."))
              }
    })

/**
 * @description Not modified
 */
export const codespacesGetCodespacesForUserInOrg304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const codespacesGetCodespacesForUserInOrg401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesGetCodespacesForUserInOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesGetCodespacesForUserInOrg404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesGetCodespacesForUserInOrg500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesGetCodespacesForUserInOrgQueryResponseSchema = codespacesGetCodespacesForUserInOrg200Schema

export const codespacesDeleteFromOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account."),
"codespace_name": z.string().describe("The name of the codespace.")
    })

/**
 * @description Accepted
 */
export const codespacesDeleteFromOrganization202Schema = z.object({
    
    })

/**
 * @description Not modified
 */
export const codespacesDeleteFromOrganization304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const codespacesDeleteFromOrganization401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesDeleteFromOrganization403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesDeleteFromOrganization404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesDeleteFromOrganization500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesDeleteFromOrganizationMutationResponseSchema = codespacesDeleteFromOrganization202Schema

export const codespacesStopInOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account."),
"codespace_name": z.string().describe("The name of the codespace.")
    })

/**
 * @description Response
 */
export const codespacesStopInOrganization200Schema = codespaceSchema.describe("A codespace.")

/**
 * @description Not modified
 */
export const codespacesStopInOrganization304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const codespacesStopInOrganization401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesStopInOrganization403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesStopInOrganization404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesStopInOrganization500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesStopInOrganizationMutationResponseSchema = codespacesStopInOrganization200Schema

export const copilotGetCopilotSeatDetailsForUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description The user\'s GitHub Copilot seat details, including usage.
 */
export const copilotGetCopilotSeatDetailsForUser200Schema = copilotSeatDetailsSchema.describe("Information about a Copilot Business seat assignment for a user, team, or organization.")

/**
 * @description Requires authentication
 */
export const copilotGetCopilotSeatDetailsForUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const copilotGetCopilotSeatDetailsForUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const copilotGetCopilotSeatDetailsForUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Copilot Business or Enterprise is not enabled for this organization or the user has a pending organization invitation.
 */
export const copilotGetCopilotSeatDetailsForUser422Schema = z.unknown()

/**
 * @description Internal Error
 */
export const copilotGetCopilotSeatDetailsForUser500Schema = basicErrorSchema.describe("Basic Error")

export const copilotGetCopilotSeatDetailsForUserQueryResponseSchema = copilotGetCopilotSeatDetailsForUser200Schema

export const orgsGetMembershipForUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const orgsGetMembershipForUser200Schema = orgMembershipSchema.describe("Org Membership")

/**
 * @description Forbidden
 */
export const orgsGetMembershipForUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsGetMembershipForUser404Schema = basicErrorSchema.describe("Basic Error")

export const orgsGetMembershipForUserQueryResponseSchema = orgsGetMembershipForUser200Schema

export const orgsSetMembershipForUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const orgsSetMembershipForUser200Schema = orgMembershipSchema.describe("Org Membership")

/**
 * @description Forbidden
 */
export const orgsSetMembershipForUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsSetMembershipForUser422Schema = validationErrorSchema.describe("Validation Error")

export const orgsSetMembershipForUserMutationRequestSchema = z.object({
    "role": z.optional(z.enum(["admin", "member"]).default("member").describe("The role to give the user in the organization. Can be one of:  \n * `admin` - The user will become an owner of the organization.  \n * `member` - The user will become a non-owner member of the organization."))
    })

export const orgsSetMembershipForUserMutationResponseSchema = orgsSetMembershipForUser200Schema

export const orgsRemoveMembershipForUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const orgsRemoveMembershipForUser204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const orgsRemoveMembershipForUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsRemoveMembershipForUser404Schema = basicErrorSchema.describe("Basic Error")

export const orgsRemoveMembershipForUserMutationResponseSchema = orgsRemoveMembershipForUser204Schema

export const migrationsListForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const migrationsListForOrgQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"exclude": z.optional(z.array(z.enum(["repositories"]).describe("Allowed values that can be passed to the exclude param.")).describe("Exclude attributes from the API response to improve performance"))
    })

/**
 * @description Response
 */
export const migrationsListForOrg200Schema = z.array(migrationSchema.describe("A migration."))

export const migrationsListForOrgQueryResponseSchema = migrationsListForOrg200Schema

export const migrationsStartForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const migrationsStartForOrg201Schema = migrationSchema.describe("A migration.")

/**
 * @description Resource not found
 */
export const migrationsStartForOrg404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const migrationsStartForOrg422Schema = validationErrorSchema.describe("Validation Error")

export const migrationsStartForOrgMutationRequestSchema = z.object({
    "repositories": z.array(z.string()).describe("A list of arrays indicating which repositories should be migrated."),
"lock_repositories": z.optional(z.boolean().default(false).describe("Indicates whether repositories should be locked (to prevent manipulation) while migrating data.")),
"exclude_metadata": z.optional(z.boolean().default(false).describe("Indicates whether metadata should be excluded and only git source should be included for the migration.")),
"exclude_git_data": z.optional(z.boolean().default(false).describe("Indicates whether the repository git data should be excluded from the migration.")),
"exclude_attachments": z.optional(z.boolean().default(false).describe("Indicates whether attachments should be excluded from the migration (to reduce migration archive file size).")),
"exclude_releases": z.optional(z.boolean().default(false).describe("Indicates whether releases should be excluded from the migration (to reduce migration archive file size).")),
"exclude_owner_projects": z.optional(z.boolean().default(false).describe("Indicates whether projects owned by the organization or users should be excluded. from the migration.")),
"org_metadata_only": z.optional(z.boolean().default(false).describe("Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags).")),
"exclude": z.optional(z.array(z.enum(["repositories"])).describe("Exclude related items from being returned in the response in order to improve performance of the request."))
    })

export const migrationsStartForOrgMutationResponseSchema = migrationsStartForOrg201Schema

export const migrationsGetStatusForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"migration_id": z.coerce.number().int().describe("The unique identifier of the migration.")
    })

export const migrationsGetStatusForOrgQueryParamsSchema = z.object({
    "exclude": z.optional(z.array(z.enum(["repositories"]).describe("Allowed values that can be passed to the exclude param.")).describe("Exclude attributes from the API response to improve performance"))
    }).optional()

/**
 * @description *   `pending`, which means the migration hasn\'t started yet.\n*   `exporting`, which means the migration is in progress.\n*   `exported`, which means the migration finished successfully.\n*   `failed`, which means the migration failed.
 */
export const migrationsGetStatusForOrg200Schema = migrationSchema.describe("A migration.")

/**
 * @description Resource not found
 */
export const migrationsGetStatusForOrg404Schema = basicErrorSchema.describe("Basic Error")

export const migrationsGetStatusForOrgQueryResponseSchema = migrationsGetStatusForOrg200Schema

export const migrationsDownloadArchiveForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"migration_id": z.coerce.number().int().describe("The unique identifier of the migration.")
    })

/**
 * @description Response
 */
export const migrationsDownloadArchiveForOrg302Schema = z.unknown()

/**
 * @description Resource not found
 */
export const migrationsDownloadArchiveForOrg404Schema = basicErrorSchema.describe("Basic Error")

export const migrationsDownloadArchiveForOrgQueryResponseSchema = z.unknown()

export const migrationsDeleteArchiveForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"migration_id": z.coerce.number().int().describe("The unique identifier of the migration.")
    })

/**
 * @description Response
 */
export const migrationsDeleteArchiveForOrg204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const migrationsDeleteArchiveForOrg404Schema = basicErrorSchema.describe("Basic Error")

export const migrationsDeleteArchiveForOrgMutationResponseSchema = migrationsDeleteArchiveForOrg204Schema

export const migrationsUnlockRepoForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"migration_id": z.coerce.number().int().describe("The unique identifier of the migration."),
"repo_name": z.string().describe("repo_name parameter")
    })

/**
 * @description Response
 */
export const migrationsUnlockRepoForOrg204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const migrationsUnlockRepoForOrg404Schema = basicErrorSchema.describe("Basic Error")

export const migrationsUnlockRepoForOrgMutationResponseSchema = migrationsUnlockRepoForOrg204Schema

export const migrationsListReposForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"migration_id": z.coerce.number().int().describe("The unique identifier of the migration.")
    })

export const migrationsListReposForOrgQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const migrationsListReposForOrg200Schema = z.array(minimalRepositorySchema.describe("Minimal Repository"))

/**
 * @description Resource not found
 */
export const migrationsListReposForOrg404Schema = basicErrorSchema.describe("Basic Error")

export const migrationsListReposForOrgQueryResponseSchema = migrationsListReposForOrg200Schema

export const orgsListOrgRolesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response - list of organization roles
 */
export const orgsListOrgRoles200Schema = z.object({
    "total_count": z.optional(z.int().describe("The total number of organization roles available to the organization.")),
get "roles"(){
                return z.array(organizationRoleSchema.describe("Organization roles")).describe("The list of organization roles available to the organization.").optional()
              }
    })

/**
 * @description Resource not found
 */
export const orgsListOrgRoles404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsListOrgRoles422Schema = validationErrorSchema.describe("Validation Error")

export const orgsListOrgRolesQueryResponseSchema = orgsListOrgRoles200Schema

export const orgsRevokeAllOrgRolesTeamPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name.")
    })

/**
 * @description Response
 */
export const orgsRevokeAllOrgRolesTeam204Schema = z.unknown()

export const orgsRevokeAllOrgRolesTeamMutationResponseSchema = orgsRevokeAllOrgRolesTeam204Schema

export const orgsAssignTeamToOrgRolePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"role_id": z.coerce.number().int().describe("The unique identifier of the role.")
    })

/**
 * @description Response
 */
export const orgsAssignTeamToOrgRole204Schema = z.unknown()

/**
 * @description Response if the organization, team or role does not exist.
 */
export const orgsAssignTeamToOrgRole404Schema = z.unknown()

/**
 * @description Response if the organization roles feature is not enabled for the organization, or validation failed.
 */
export const orgsAssignTeamToOrgRole422Schema = z.unknown()

export const orgsAssignTeamToOrgRoleMutationResponseSchema = orgsAssignTeamToOrgRole204Schema

export const orgsRevokeOrgRoleTeamPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"role_id": z.coerce.number().int().describe("The unique identifier of the role.")
    })

/**
 * @description Response
 */
export const orgsRevokeOrgRoleTeam204Schema = z.unknown()

export const orgsRevokeOrgRoleTeamMutationResponseSchema = orgsRevokeOrgRoleTeam204Schema

export const orgsRevokeAllOrgRolesUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const orgsRevokeAllOrgRolesUser204Schema = z.unknown()

export const orgsRevokeAllOrgRolesUserMutationResponseSchema = orgsRevokeAllOrgRolesUser204Schema

export const orgsAssignUserToOrgRolePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account."),
"role_id": z.coerce.number().int().describe("The unique identifier of the role.")
    })

/**
 * @description Response
 */
export const orgsAssignUserToOrgRole204Schema = z.unknown()

/**
 * @description Response if the organization, user or role does not exist.
 */
export const orgsAssignUserToOrgRole404Schema = z.unknown()

/**
 * @description Response if the organization roles feature is not enabled enabled for the organization, the validation failed, or the user is not an organization member.
 */
export const orgsAssignUserToOrgRole422Schema = z.unknown()

export const orgsAssignUserToOrgRoleMutationResponseSchema = orgsAssignUserToOrgRole204Schema

export const orgsRevokeOrgRoleUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account."),
"role_id": z.coerce.number().int().describe("The unique identifier of the role.")
    })

/**
 * @description Response
 */
export const orgsRevokeOrgRoleUser204Schema = z.unknown()

export const orgsRevokeOrgRoleUserMutationResponseSchema = orgsRevokeOrgRoleUser204Schema

export const orgsGetOrgRolePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"role_id": z.coerce.number().int().describe("The unique identifier of the role.")
    })

/**
 * @description Response
 */
export const orgsGetOrgRole200Schema = organizationRoleSchema.describe("Organization roles")

/**
 * @description Resource not found
 */
export const orgsGetOrgRole404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsGetOrgRole422Schema = validationErrorSchema.describe("Validation Error")

export const orgsGetOrgRoleQueryResponseSchema = orgsGetOrgRole200Schema

export const orgsListOrgRoleTeamsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"role_id": z.coerce.number().int().describe("The unique identifier of the role.")
    })

export const orgsListOrgRoleTeamsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response - List of assigned teams
 */
export const orgsListOrgRoleTeams200Schema = z.array(teamRoleAssignmentSchema.describe("The Relationship a Team has with a role.")).describe("List of teams assigned to the organization role")

/**
 * @description Response if the organization or role does not exist.
 */
export const orgsListOrgRoleTeams404Schema = z.unknown()

/**
 * @description Response if the organization roles feature is not enabled or validation failed.
 */
export const orgsListOrgRoleTeams422Schema = z.unknown()

export const orgsListOrgRoleTeamsQueryResponseSchema = orgsListOrgRoleTeams200Schema

export const orgsListOrgRoleUsersPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"role_id": z.coerce.number().int().describe("The unique identifier of the role.")
    })

export const orgsListOrgRoleUsersQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response - List of assigned users
 */
export const orgsListOrgRoleUsers200Schema = z.array(userRoleAssignmentSchema.describe("The Relationship a User has with a role.")).describe("List of users assigned to the organization role")

/**
 * @description Response if the organization or role does not exist.
 */
export const orgsListOrgRoleUsers404Schema = z.unknown()

/**
 * @description Response if the organization roles feature is not enabled or validation failed.
 */
export const orgsListOrgRoleUsers422Schema = z.unknown()

export const orgsListOrgRoleUsersQueryResponseSchema = orgsListOrgRoleUsers200Schema

export const orgsListOutsideCollaboratorsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const orgsListOutsideCollaboratorsQueryParamsSchema = z.object({
    "filter": z.enum(["2fa_disabled", "2fa_insecure", "all"]).default("all").describe("Filter the list of outside collaborators. `2fa_disabled` means that only outside collaborators without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled will be returned. `2fa_insecure` means that only outside collaborators with [insecure 2FA methods](https://docs.github.com/organizations/keeping-your-organization-secure/managing-two-factor-authentication-for-your-organization/requiring-two-factor-authentication-in-your-organization#requiring-secure-methods-of-two-factor-authentication-in-your-organization) will be returned."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const orgsListOutsideCollaborators200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

export const orgsListOutsideCollaboratorsQueryResponseSchema = orgsListOutsideCollaborators200Schema

export const orgsConvertMemberToOutsideCollaboratorPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description User is getting converted asynchronously
 */
export const orgsConvertMemberToOutsideCollaborator202Schema = z.object({
    
    })

/**
 * @description User was converted
 */
export const orgsConvertMemberToOutsideCollaborator204Schema = z.unknown()

/**
 * @description Forbidden if user is the last owner of the organization, not a member of the organization, or if the enterprise enforces a policy for inviting outside collaborators. For more information, see \"[Enforcing repository management policies in your enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories).\"
 */
export const orgsConvertMemberToOutsideCollaborator403Schema = z.unknown()

/**
 * @description Resource not found
 */
export const orgsConvertMemberToOutsideCollaborator404Schema = basicErrorSchema.describe("Basic Error")

export const orgsConvertMemberToOutsideCollaboratorMutationRequestSchema = z.object({
    "async": z.optional(z.boolean().default(false).describe("When set to `true`, the request will be performed asynchronously. Returns a 202 status code when the job is successfully queued."))
    })

export const orgsConvertMemberToOutsideCollaboratorMutationResponseSchema = z.union([orgsConvertMemberToOutsideCollaborator202Schema, orgsConvertMemberToOutsideCollaborator204Schema])

export const orgsRemoveOutsideCollaboratorPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const orgsRemoveOutsideCollaborator204Schema = z.unknown()

/**
 * @description Unprocessable Entity if user is a member of the organization
 */
export const orgsRemoveOutsideCollaborator422Schema = z.object({
    "message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const orgsRemoveOutsideCollaboratorMutationResponseSchema = orgsRemoveOutsideCollaborator204Schema

export const packagesListPackagesForOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const packagesListPackagesForOrganizationQueryParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"visibility": z.optional(z.enum(["public", "private", "internal"]).describe("The selected visibility of the packages.  This parameter is optional and only filters an existing result set.\n\nThe `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.\nFor the list of GitHub Packages registries that support granular permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"")),
"page": z.optional(z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"per_page": z.optional(z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""))
    })

/**
 * @description Response
 */
export const packagesListPackagesForOrganization200Schema = z.array(packageSchema.describe("A software package"))

/**
 * @description The value of `per_page` multiplied by `page` cannot be greater than 10000.
 */
export const packagesListPackagesForOrganization400Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const packagesListPackagesForOrganization401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesListPackagesForOrganization403Schema = basicErrorSchema.describe("Basic Error")

export const packagesListPackagesForOrganizationQueryResponseSchema = packagesListPackagesForOrganization200Schema

export const packagesGetPackageForOrganizationPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const packagesGetPackageForOrganization200Schema = packageSchema.describe("A software package")

export const packagesGetPackageForOrganizationQueryResponseSchema = packagesGetPackageForOrganization200Schema

export const packagesDeletePackageForOrgPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const packagesDeletePackageForOrg204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const packagesDeletePackageForOrg401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesDeletePackageForOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const packagesDeletePackageForOrg404Schema = basicErrorSchema.describe("Basic Error")

export const packagesDeletePackageForOrgMutationResponseSchema = packagesDeletePackageForOrg204Schema

export const packagesRestorePackageForOrgPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const packagesRestorePackageForOrgQueryParamsSchema = z.object({
    "token": z.optional(z.string().describe("package token"))
    }).optional()

/**
 * @description Response
 */
export const packagesRestorePackageForOrg204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const packagesRestorePackageForOrg401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesRestorePackageForOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const packagesRestorePackageForOrg404Schema = basicErrorSchema.describe("Basic Error")

export const packagesRestorePackageForOrgMutationResponseSchema = packagesRestorePackageForOrg204Schema

export const packagesGetAllPackageVersionsForPackageOwnedByOrgPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const packagesGetAllPackageVersionsForPackageOwnedByOrgQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"state": z.enum(["active", "deleted"]).default("active").describe("The state of the package, either active or deleted.")
    })

/**
 * @description Response
 */
export const packagesGetAllPackageVersionsForPackageOwnedByOrg200Schema = z.array(packageVersionSchema.describe("A version of a software package"))

/**
 * @description Requires authentication
 */
export const packagesGetAllPackageVersionsForPackageOwnedByOrg401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesGetAllPackageVersionsForPackageOwnedByOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const packagesGetAllPackageVersionsForPackageOwnedByOrg404Schema = basicErrorSchema.describe("Basic Error")

export const packagesGetAllPackageVersionsForPackageOwnedByOrgQueryResponseSchema = packagesGetAllPackageVersionsForPackageOwnedByOrg200Schema

export const packagesGetPackageVersionForOrganizationPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"org": z.string().describe("The organization name. The name is not case sensitive."),
"package_version_id": z.coerce.number().int().describe("Unique identifier of the package version.")
    })

/**
 * @description Response
 */
export const packagesGetPackageVersionForOrganization200Schema = packageVersionSchema.describe("A version of a software package")

export const packagesGetPackageVersionForOrganizationQueryResponseSchema = packagesGetPackageVersionForOrganization200Schema

export const packagesDeletePackageVersionForOrgPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"org": z.string().describe("The organization name. The name is not case sensitive."),
"package_version_id": z.coerce.number().int().describe("Unique identifier of the package version.")
    })

/**
 * @description Response
 */
export const packagesDeletePackageVersionForOrg204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const packagesDeletePackageVersionForOrg401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesDeletePackageVersionForOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const packagesDeletePackageVersionForOrg404Schema = basicErrorSchema.describe("Basic Error")

export const packagesDeletePackageVersionForOrgMutationResponseSchema = packagesDeletePackageVersionForOrg204Schema

export const packagesRestorePackageVersionForOrgPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"org": z.string().describe("The organization name. The name is not case sensitive."),
"package_version_id": z.coerce.number().int().describe("Unique identifier of the package version.")
    })

/**
 * @description Response
 */
export const packagesRestorePackageVersionForOrg204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const packagesRestorePackageVersionForOrg401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesRestorePackageVersionForOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const packagesRestorePackageVersionForOrg404Schema = basicErrorSchema.describe("Basic Error")

export const packagesRestorePackageVersionForOrgMutationResponseSchema = packagesRestorePackageVersionForOrg204Schema

export const orgsListPatGrantRequestsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const orgsListPatGrantRequestsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"sort": z.enum(["created_at"]).default("created_at").describe("The property by which to sort the results."),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"owner": z.optional(z.array(z.string()).max(10).describe("A list of owner usernames to use to filter the results.")),
"repository": z.optional(z.string().describe("The name of the repository to use to filter the results.")),
"permission": z.optional(z.string().describe("The permission to use to filter the results.")),
"last_used_before": z.optional(z.iso.datetime({ offset: true }).describe("Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"last_used_after": z.optional(z.iso.datetime({ offset: true }).describe("Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"token_id": z.optional(z.array(z.string()).max(50).describe("The ID of the token"))
    })

/**
 * @description Response
 */
export const orgsListPatGrantRequests200Schema = z.array(organizationProgrammaticAccessGrantRequestSchema.describe("Minimal representation of an organization programmatic access grant request for enumerations"))

/**
 * @description Forbidden
 */
export const orgsListPatGrantRequests403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsListPatGrantRequests404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsListPatGrantRequests422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Internal Error
 */
export const orgsListPatGrantRequests500Schema = basicErrorSchema.describe("Basic Error")

export const orgsListPatGrantRequestsQueryResponseSchema = orgsListPatGrantRequests200Schema

export const orgsReviewPatGrantRequestsInBulkPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Accepted
 */
export const orgsReviewPatGrantRequestsInBulk202Schema = z.object({
    
    })

/**
 * @description Forbidden
 */
export const orgsReviewPatGrantRequestsInBulk403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsReviewPatGrantRequestsInBulk404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsReviewPatGrantRequestsInBulk422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Internal Error
 */
export const orgsReviewPatGrantRequestsInBulk500Schema = basicErrorSchema.describe("Basic Error")

export const orgsReviewPatGrantRequestsInBulkMutationRequestSchema = z.object({
    "pat_request_ids": z.optional(z.array(z.int()).min(1).max(100).describe("Unique identifiers of the requests for access via fine-grained personal access token. Must be formed of between 1 and 100 `pat_request_id` values.")),
"action": z.enum(["approve", "deny"]).describe("Action to apply to the requests."),
"reason": z.string().max(1024).describe("Reason for approving or denying the requests. Max 1024 characters.").nullish()
    })

export const orgsReviewPatGrantRequestsInBulkMutationResponseSchema = orgsReviewPatGrantRequestsInBulk202Schema

export const orgsReviewPatGrantRequestPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"pat_request_id": z.coerce.number().int().describe("Unique identifier of the request for access via fine-grained personal access token.")
    })

/**
 * @description A header with no content is returned.
 */
export const orgsReviewPatGrantRequest204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const orgsReviewPatGrantRequest403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsReviewPatGrantRequest404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsReviewPatGrantRequest422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Internal Error
 */
export const orgsReviewPatGrantRequest500Schema = basicErrorSchema.describe("Basic Error")

export const orgsReviewPatGrantRequestMutationRequestSchema = z.object({
    "action": z.enum(["approve", "deny"]).describe("Action to apply to the request."),
"reason": z.string().max(1024).describe("Reason for approving or denying the request. Max 1024 characters.").nullish()
    })

export const orgsReviewPatGrantRequestMutationResponseSchema = orgsReviewPatGrantRequest204Schema

export const orgsListPatGrantRequestRepositoriesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"pat_request_id": z.coerce.number().int().describe("Unique identifier of the request for access via fine-grained personal access token.")
    })

export const orgsListPatGrantRequestRepositoriesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const orgsListPatGrantRequestRepositories200Schema = z.array(minimalRepositorySchema.describe("Minimal Repository"))

/**
 * @description Forbidden
 */
export const orgsListPatGrantRequestRepositories403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsListPatGrantRequestRepositories404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const orgsListPatGrantRequestRepositories500Schema = basicErrorSchema.describe("Basic Error")

export const orgsListPatGrantRequestRepositoriesQueryResponseSchema = orgsListPatGrantRequestRepositories200Schema

export const orgsListPatGrantsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const orgsListPatGrantsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"sort": z.enum(["created_at"]).default("created_at").describe("The property by which to sort the results."),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"owner": z.optional(z.array(z.string()).max(10).describe("A list of owner usernames to use to filter the results.")),
"repository": z.optional(z.string().describe("The name of the repository to use to filter the results.")),
"permission": z.optional(z.string().describe("The permission to use to filter the results.")),
"last_used_before": z.optional(z.iso.datetime({ offset: true }).describe("Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"last_used_after": z.optional(z.iso.datetime({ offset: true }).describe("Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"token_id": z.optional(z.array(z.string()).max(50).describe("The ID of the token"))
    })

/**
 * @description Response
 */
export const orgsListPatGrants200Schema = z.array(organizationProgrammaticAccessGrantSchema.describe("Minimal representation of an organization programmatic access grant for enumerations"))

/**
 * @description Forbidden
 */
export const orgsListPatGrants403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsListPatGrants404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsListPatGrants422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Internal Error
 */
export const orgsListPatGrants500Schema = basicErrorSchema.describe("Basic Error")

export const orgsListPatGrantsQueryResponseSchema = orgsListPatGrants200Schema

export const orgsUpdatePatAccessesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Accepted
 */
export const orgsUpdatePatAccesses202Schema = z.object({
    
    })

/**
 * @description Forbidden
 */
export const orgsUpdatePatAccesses403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsUpdatePatAccesses404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsUpdatePatAccesses422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Internal Error
 */
export const orgsUpdatePatAccesses500Schema = basicErrorSchema.describe("Basic Error")

export const orgsUpdatePatAccessesMutationRequestSchema = z.object({
    "action": z.enum(["revoke"]).describe("Action to apply to the fine-grained personal access token."),
"pat_ids": z.array(z.int().describe("Unique identifier of the fine-grained personal access token.")).min(1).max(100).describe("The IDs of the fine-grained personal access tokens.")
    })

export const orgsUpdatePatAccessesMutationResponseSchema = orgsUpdatePatAccesses202Schema

export const orgsUpdatePatAccessPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"pat_id": z.coerce.number().int().describe("The unique identifier of the fine-grained personal access token.")
    })

/**
 * @description A header with no content is returned.
 */
export const orgsUpdatePatAccess204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const orgsUpdatePatAccess403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsUpdatePatAccess404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsUpdatePatAccess422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Internal Error
 */
export const orgsUpdatePatAccess500Schema = basicErrorSchema.describe("Basic Error")

export const orgsUpdatePatAccessMutationRequestSchema = z.object({
    "action": z.enum(["revoke"]).describe("Action to apply to the fine-grained personal access token.")
    })

export const orgsUpdatePatAccessMutationResponseSchema = orgsUpdatePatAccess204Schema

export const orgsListPatGrantRepositoriesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"pat_id": z.coerce.number().int().describe("Unique identifier of the fine-grained personal access token.")
    })

export const orgsListPatGrantRepositoriesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const orgsListPatGrantRepositories200Schema = z.array(minimalRepositorySchema.describe("Minimal Repository"))

/**
 * @description Forbidden
 */
export const orgsListPatGrantRepositories403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsListPatGrantRepositories404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const orgsListPatGrantRepositories500Schema = basicErrorSchema.describe("Basic Error")

export const orgsListPatGrantRepositoriesQueryResponseSchema = orgsListPatGrantRepositories200Schema

export const privateRegistriesListOrgPrivateRegistriesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const privateRegistriesListOrgPrivateRegistriesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const privateRegistriesListOrgPrivateRegistries200Schema = z.object({
    "total_count": z.int(),
get "configurations"(){
                return z.array(orgPrivateRegistryConfigurationSchema.describe("Private registry configuration for an organization"))
              }
    })

/**
 * @description Bad Request
 */
export const privateRegistriesListOrgPrivateRegistries400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const privateRegistriesListOrgPrivateRegistries404Schema = basicErrorSchema.describe("Basic Error")

export const privateRegistriesListOrgPrivateRegistriesQueryResponseSchema = privateRegistriesListOrgPrivateRegistries200Schema

export const privateRegistriesCreateOrgPrivateRegistryPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description The organization private registry configuration
 */
export const privateRegistriesCreateOrgPrivateRegistry201Schema = orgPrivateRegistryConfigurationWithSelectedRepositoriesSchema.describe("Private registry configuration for an organization")

/**
 * @description Resource not found
 */
export const privateRegistriesCreateOrgPrivateRegistry404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const privateRegistriesCreateOrgPrivateRegistry422Schema = validationErrorSchema.describe("Validation Error")

export const privateRegistriesCreateOrgPrivateRegistryMutationRequestSchema = z.object({
    "registry_type": z.enum(["maven_repository", "nuget_feed", "goproxy_server", "npm_registry", "rubygems_server", "cargo_registry", "composer_repository", "docker_registry", "git_source", "helm_registry", "hex_organization", "hex_repository", "pub_repository", "python_index", "terraform_registry"]).describe("The registry type."),
"url": z.url().describe("The URL of the private registry."),
"username": z.string().describe("The username to use when authenticating with the private registry. This field should be omitted if the private registry does not require a username for authentication.").nullish(),
"encrypted_value": z.string().regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$/).describe("The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get private registries public key for an organization](https://docs.github.com/rest/private-registries/organization-configurations#get-private-registries-public-key-for-an-organization) endpoint."),
"key_id": z.string().describe("The ID of the key you used to encrypt the secret."),
"visibility": z.enum(["all", "private", "selected"]).describe("Which type of organization repositories have access to the private registry. `selected` means only the repositories specified by `selected_repository_ids` can access the private registry."),
"selected_repository_ids": z.optional(z.array(z.int()).describe("An array of repository IDs that can access the organization private registry. You can only provide a list of repository IDs when `visibility` is set to `selected`. You can manage the list of selected repositories using the [Update a private registry for an organization](https://docs.github.com/rest/private-registries/organization-configurations#update-a-private-registry-for-an-organization) endpoint. This field should be omitted if `visibility` is set to `all` or `private`."))
    })

export const privateRegistriesCreateOrgPrivateRegistryMutationResponseSchema = privateRegistriesCreateOrgPrivateRegistry201Schema

export const privateRegistriesGetOrgPublicKeyPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const privateRegistriesGetOrgPublicKey200Schema = z.object({
    "key_id": z.string().describe("The identifier for the key."),
"key": z.string().describe("The Base64 encoded public key.")
    })

/**
 * @description Resource not found
 */
export const privateRegistriesGetOrgPublicKey404Schema = basicErrorSchema.describe("Basic Error")

export const privateRegistriesGetOrgPublicKeyQueryResponseSchema = privateRegistriesGetOrgPublicKey200Schema

export const privateRegistriesGetOrgPrivateRegistryPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description The specified private registry configuration for the organization
 */
export const privateRegistriesGetOrgPrivateRegistry200Schema = orgPrivateRegistryConfigurationSchema.describe("Private registry configuration for an organization")

/**
 * @description Resource not found
 */
export const privateRegistriesGetOrgPrivateRegistry404Schema = basicErrorSchema.describe("Basic Error")

export const privateRegistriesGetOrgPrivateRegistryQueryResponseSchema = privateRegistriesGetOrgPrivateRegistry200Schema

export const privateRegistriesUpdateOrgPrivateRegistryPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const privateRegistriesUpdateOrgPrivateRegistry204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const privateRegistriesUpdateOrgPrivateRegistry404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const privateRegistriesUpdateOrgPrivateRegistry422Schema = validationErrorSchema.describe("Validation Error")

export const privateRegistriesUpdateOrgPrivateRegistryMutationRequestSchema = z.object({
    "registry_type": z.optional(z.enum(["maven_repository", "nuget_feed", "goproxy_server", "npm_registry", "rubygems_server", "cargo_registry", "composer_repository", "docker_registry", "git_source", "helm_registry", "hex_organization", "hex_repository", "pub_repository", "python_index", "terraform_registry"]).describe("The registry type.")),
"url": z.optional(z.url().describe("The URL of the private registry.")),
"username": z.string().describe("The username to use when authenticating with the private registry. This field should be omitted if the private registry does not require a username for authentication.").nullish(),
"encrypted_value": z.optional(z.string().regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$/).describe("The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get private registries public key for an organization](https://docs.github.com/rest/private-registries/organization-configurations#get-private-registries-public-key-for-an-organization) endpoint.")),
"key_id": z.optional(z.string().describe("The ID of the key you used to encrypt the secret.")),
"visibility": z.optional(z.enum(["all", "private", "selected"]).describe("Which type of organization repositories have access to the private registry. `selected` means only the repositories specified by `selected_repository_ids` can access the private registry.")),
"selected_repository_ids": z.optional(z.array(z.int()).describe("An array of repository IDs that can access the organization private registry. You can only provide a list of repository IDs when `visibility` is set to `selected`. This field should be omitted if `visibility` is set to `all` or `private`."))
    })

export const privateRegistriesUpdateOrgPrivateRegistryMutationResponseSchema = privateRegistriesUpdateOrgPrivateRegistry204Schema

export const privateRegistriesDeleteOrgPrivateRegistryPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const privateRegistriesDeleteOrgPrivateRegistry204Schema = z.unknown()

/**
 * @description Bad Request
 */
export const privateRegistriesDeleteOrgPrivateRegistry400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const privateRegistriesDeleteOrgPrivateRegistry404Schema = basicErrorSchema.describe("Basic Error")

export const privateRegistriesDeleteOrgPrivateRegistryMutationResponseSchema = privateRegistriesDeleteOrgPrivateRegistry204Schema

export const projectsClassicListForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const projectsClassicListForOrgQueryParamsSchema = z.object({
    "state": z.enum(["open", "closed", "all"]).default("open").describe("Indicates the state of the projects to return."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const projectsClassicListForOrg200Schema = z.array(projectSchema.describe("Projects are a way to organize columns and cards of work."))

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const projectsClassicListForOrg422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const projectsClassicListForOrgQueryResponseSchema = projectsClassicListForOrg200Schema

export const projectsClassicCreateForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const projectsClassicCreateForOrg201Schema = projectSchema.describe("Projects are a way to organize columns and cards of work.")

/**
 * @description Requires authentication
 */
export const projectsClassicCreateForOrg401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicCreateForOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const projectsClassicCreateForOrg404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const projectsClassicCreateForOrg410Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const projectsClassicCreateForOrg422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const projectsClassicCreateForOrgMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the project."),
"body": z.optional(z.string().describe("The description of the project."))
    })

export const projectsClassicCreateForOrgMutationResponseSchema = projectsClassicCreateForOrg201Schema

export const projectsListForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const projectsListForOrgQueryParamsSchema = z.object({
    "q": z.optional(z.string().describe("Limit results to projects of the specified type.")),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const projectsListForOrg200Schema = z.array(projectsV2Schema.describe("A projects v2 project"))

/**
 * @description Not modified
 */
export const projectsListForOrg304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsListForOrg401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsListForOrg403Schema = basicErrorSchema.describe("Basic Error")

export const projectsListForOrgQueryResponseSchema = projectsListForOrg200Schema

export const projectsGetForOrgPathParamsSchema = z.object({
    "project_number": z.coerce.number().int().describe("The project's number."),
"org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const projectsGetForOrg200Schema = projectsV2Schema.describe("A projects v2 project")

/**
 * @description Not modified
 */
export const projectsGetForOrg304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsGetForOrg401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsGetForOrg403Schema = basicErrorSchema.describe("Basic Error")

export const projectsGetForOrgQueryResponseSchema = projectsGetForOrg200Schema

export const projectsListFieldsForOrgPathParamsSchema = z.object({
    "project_number": z.coerce.number().int().describe("The project's number."),
"org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const projectsListFieldsForOrgQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""))
    })

/**
 * @description Response
 */
export const projectsListFieldsForOrg200Schema = z.array(projectsV2FieldSchema.describe("A field inside a projects v2 project"))

/**
 * @description Not modified
 */
export const projectsListFieldsForOrg304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsListFieldsForOrg401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsListFieldsForOrg403Schema = basicErrorSchema.describe("Basic Error")

export const projectsListFieldsForOrgQueryResponseSchema = projectsListFieldsForOrg200Schema

export const projectsGetFieldForOrgPathParamsSchema = z.object({
    "project_number": z.coerce.number().int().describe("The project's number."),
"field_id": z.coerce.number().int().describe("The unique identifier of the field."),
"org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const projectsGetFieldForOrg200Schema = projectsV2FieldSchema.describe("A field inside a projects v2 project")

/**
 * @description Not modified
 */
export const projectsGetFieldForOrg304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsGetFieldForOrg401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsGetFieldForOrg403Schema = basicErrorSchema.describe("Basic Error")

export const projectsGetFieldForOrgQueryResponseSchema = projectsGetFieldForOrg200Schema

export const projectsListItemsForOrgPathParamsSchema = z.object({
    "project_number": z.coerce.number().int().describe("The project's number."),
"org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const projectsListItemsForOrgQueryParamsSchema = z.object({
    "q": z.optional(z.string().describe("Search query to filter items, see [Filtering projects](https://docs.github.com/issues/planning-and-tracking-with-projects/customizing-views-in-your-project/filtering-projects) for more information.")),
"fields": z.optional(z.union([z.array(z.string()).max(50), z.string()]).describe("Limit results to specific fields, by their IDs. If not specified, the title field will be returned.\n\nExample: `fields[]=123&fields[]=456&fields[]=789` or `fields=123,456,789`")),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const projectsListItemsForOrg200Schema = z.array(projectsV2ItemWithContentSchema.describe("An item belonging to a project"))

/**
 * @description Not modified
 */
export const projectsListItemsForOrg304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsListItemsForOrg401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsListItemsForOrg403Schema = basicErrorSchema.describe("Basic Error")

export const projectsListItemsForOrgQueryResponseSchema = projectsListItemsForOrg200Schema

export const projectsAddItemForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"project_number": z.coerce.number().int().describe("The project's number.")
    })

/**
 * @description Response
 */
export const projectsAddItemForOrg201Schema = projectsV2ItemSimpleSchema.describe("An item belonging to a project")

/**
 * @description Not modified
 */
export const projectsAddItemForOrg304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsAddItemForOrg401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsAddItemForOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Details of the item to add to the project.
 */
export const projectsAddItemForOrgMutationRequestSchema = z.object({
    "type": z.enum(["Issue", "PullRequest"]).describe("The type of item to add to the project. Must be either Issue or PullRequest."),
"id": z.int().describe("The numeric ID of the issue or pull request to add to the project.")
    })

export const projectsAddItemForOrgMutationResponseSchema = projectsAddItemForOrg201Schema

export const projectsGetOrgItemPathParamsSchema = z.object({
    "project_number": z.coerce.number().int().describe("The project's number."),
"org": z.string().describe("The organization name. The name is not case sensitive."),
"item_id": z.coerce.number().int().describe("The unique identifier of the project item.")
    })

export const projectsGetOrgItemQueryParamsSchema = z.object({
    "fields": z.optional(z.union([z.array(z.string()).max(50), z.string()]).describe("Limit results to specific fields, by their IDs. If not specified, the title field will be returned.\n\nExample: fields[]=123&fields[]=456&fields[]=789 or fields=123,456,789"))
    }).optional()

/**
 * @description Response
 */
export const projectsGetOrgItem200Schema = projectsV2ItemWithContentSchema.describe("An item belonging to a project")

/**
 * @description Not modified
 */
export const projectsGetOrgItem304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsGetOrgItem401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsGetOrgItem403Schema = basicErrorSchema.describe("Basic Error")

export const projectsGetOrgItemQueryResponseSchema = projectsGetOrgItem200Schema

export const projectsUpdateItemForOrgPathParamsSchema = z.object({
    "project_number": z.coerce.number().int().describe("The project's number."),
"org": z.string().describe("The organization name. The name is not case sensitive."),
"item_id": z.coerce.number().int().describe("The unique identifier of the project item.")
    })

/**
 * @description Response
 */
export const projectsUpdateItemForOrg200Schema = projectsV2ItemWithContentSchema.describe("An item belonging to a project")

/**
 * @description Requires authentication
 */
export const projectsUpdateItemForOrg401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsUpdateItemForOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const projectsUpdateItemForOrg404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const projectsUpdateItemForOrg422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Field updates to apply to the project item. Only text, number, date, single select, and iteration fields are supported.
 */
export const projectsUpdateItemForOrgMutationRequestSchema = z.object({
    "fields": z.array(z.object({
    "id": z.int().describe("The ID of the project field to update."),
"value": z.nullable(z.union([z.string(), z.number()]).describe("The new value for the field:\n- For text, number, and date fields, provide the new value directly.\n- For single select and iteration fields, provide the ID of the option or iteration.\n- To clear the field, set this to null."))
    })).describe("A list of field updates to apply.")
    })

export const projectsUpdateItemForOrgMutationResponseSchema = projectsUpdateItemForOrg200Schema

export const projectsDeleteItemForOrgPathParamsSchema = z.object({
    "project_number": z.coerce.number().int().describe("The project's number."),
"org": z.string().describe("The organization name. The name is not case sensitive."),
"item_id": z.coerce.number().int().describe("The unique identifier of the project item.")
    })

/**
 * @description Response
 */
export const projectsDeleteItemForOrg204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsDeleteItemForOrg401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsDeleteItemForOrg403Schema = basicErrorSchema.describe("Basic Error")

export const projectsDeleteItemForOrgMutationResponseSchema = projectsDeleteItemForOrg204Schema

export const orgsCustomPropertiesForReposGetOrganizationDefinitionsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const orgsCustomPropertiesForReposGetOrganizationDefinitions200Schema = z.array(customPropertySchema.describe("Custom property defined on an organization"))

/**
 * @description Forbidden
 */
export const orgsCustomPropertiesForReposGetOrganizationDefinitions403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsCustomPropertiesForReposGetOrganizationDefinitions404Schema = basicErrorSchema.describe("Basic Error")

export const orgsCustomPropertiesForReposGetOrganizationDefinitionsQueryResponseSchema = orgsCustomPropertiesForReposGetOrganizationDefinitions200Schema

export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinitionsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinitions200Schema = z.array(customPropertySchema.describe("Custom property defined on an organization"))

/**
 * @description Forbidden
 */
export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinitions403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinitions404Schema = basicErrorSchema.describe("Basic Error")

export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinitionsMutationRequestSchema = z.object({
    get "properties"(){
                return z.array(customPropertySchema.describe("Custom property defined on an organization")).min(1).max(100).describe("The array of custom properties to create or update.")
              }
    })

export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinitionsMutationResponseSchema = orgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinitions200Schema

export const orgsCustomPropertiesForReposGetOrganizationDefinitionPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"custom_property_name": z.string().describe("The custom property name")
    })

/**
 * @description Response
 */
export const orgsCustomPropertiesForReposGetOrganizationDefinition200Schema = customPropertySchema.describe("Custom property defined on an organization")

/**
 * @description Forbidden
 */
export const orgsCustomPropertiesForReposGetOrganizationDefinition403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsCustomPropertiesForReposGetOrganizationDefinition404Schema = basicErrorSchema.describe("Basic Error")

export const orgsCustomPropertiesForReposGetOrganizationDefinitionQueryResponseSchema = orgsCustomPropertiesForReposGetOrganizationDefinition200Schema

export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinitionPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"custom_property_name": z.string().describe("The custom property name")
    })

/**
 * @description Response
 */
export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinition200Schema = customPropertySchema.describe("Custom property defined on an organization")

/**
 * @description Forbidden
 */
export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinition403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinition404Schema = basicErrorSchema.describe("Basic Error")

export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinitionMutationRequestSchema = customPropertySetPayloadSchema.describe("Custom property set payload")

export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinitionMutationResponseSchema = orgsCustomPropertiesForReposCreateOrUpdateOrganizationDefinition200Schema

export const orgsCustomPropertiesForReposDeleteOrganizationDefinitionPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"custom_property_name": z.string().describe("The custom property name")
    })

/**
 * @description A header with no content is returned.
 */
export const orgsCustomPropertiesForReposDeleteOrganizationDefinition204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const orgsCustomPropertiesForReposDeleteOrganizationDefinition403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsCustomPropertiesForReposDeleteOrganizationDefinition404Schema = basicErrorSchema.describe("Basic Error")

export const orgsCustomPropertiesForReposDeleteOrganizationDefinitionMutationResponseSchema = orgsCustomPropertiesForReposDeleteOrganizationDefinition204Schema

export const orgsCustomPropertiesForReposGetOrganizationValuesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const orgsCustomPropertiesForReposGetOrganizationValuesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"repository_query": z.optional(z.string().describe("Finds repositories in the organization with a query containing one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See \"[Searching for repositories](https://docs.github.com/articles/searching-for-repositories/)\" for a detailed list of qualifiers."))
    })

/**
 * @description Response
 */
export const orgsCustomPropertiesForReposGetOrganizationValues200Schema = z.array(orgRepoCustomPropertyValuesSchema.describe("List of custom property values for a repository"))

/**
 * @description Forbidden
 */
export const orgsCustomPropertiesForReposGetOrganizationValues403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsCustomPropertiesForReposGetOrganizationValues404Schema = basicErrorSchema.describe("Basic Error")

export const orgsCustomPropertiesForReposGetOrganizationValuesQueryResponseSchema = orgsCustomPropertiesForReposGetOrganizationValues200Schema

export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationValuesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description No Content when custom property values are successfully created or updated
 */
export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationValues204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationValues403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationValues404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationValues422Schema = validationErrorSchema.describe("Validation Error")

export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationValuesMutationRequestSchema = z.object({
    "repository_names": z.array(z.string()).min(1).max(30).describe("The names of repositories that the custom property values will be applied to."),
get "properties"(){
                return z.array(customPropertyValueSchema.describe("Custom property name and associated value")).describe("List of custom property names and associated values to apply to the repositories.")
              }
    })

export const orgsCustomPropertiesForReposCreateOrUpdateOrganizationValuesMutationResponseSchema = orgsCustomPropertiesForReposCreateOrUpdateOrganizationValues204Schema

export const orgsListPublicMembersPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const orgsListPublicMembersQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const orgsListPublicMembers200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

export const orgsListPublicMembersQueryResponseSchema = orgsListPublicMembers200Schema

export const orgsCheckPublicMembershipForUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response if user is a public member
 */
export const orgsCheckPublicMembershipForUser204Schema = z.unknown()

/**
 * @description Not Found if user is not a public member
 */
export const orgsCheckPublicMembershipForUser404Schema = z.unknown()

export const orgsCheckPublicMembershipForUserQueryResponseSchema = orgsCheckPublicMembershipForUser204Schema

export const orgsSetPublicMembershipForAuthenticatedUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const orgsSetPublicMembershipForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const orgsSetPublicMembershipForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

export const orgsSetPublicMembershipForAuthenticatedUserMutationResponseSchema = orgsSetPublicMembershipForAuthenticatedUser204Schema

export const orgsRemovePublicMembershipForAuthenticatedUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const orgsRemovePublicMembershipForAuthenticatedUser204Schema = z.unknown()

export const orgsRemovePublicMembershipForAuthenticatedUserMutationResponseSchema = orgsRemovePublicMembershipForAuthenticatedUser204Schema

export const reposListForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const reposListForOrgQueryParamsSchema = z.object({
    "type": z.enum(["all", "public", "private", "forks", "sources", "member"]).default("all").describe("Specifies the types of repositories you want returned."),
"sort": z.enum(["created", "updated", "pushed", "full_name"]).default("created").describe("The property to sort the results by."),
"direction": z.optional(z.enum(["asc", "desc"]).describe("The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListForOrg200Schema = z.array(minimalRepositorySchema.describe("Minimal Repository"))

export const reposListForOrgQueryResponseSchema = reposListForOrg200Schema

export const reposCreateInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposCreateInOrg201Schema = fullRepositorySchema.describe("Full Repository")

/**
 * @description Forbidden
 */
export const reposCreateInOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposCreateInOrg422Schema = validationErrorSchema.describe("Validation Error")

export const reposCreateInOrgMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the repository."),
"description": z.optional(z.string().describe("A short description of the repository.")),
"homepage": z.optional(z.string().describe("A URL with more information about the repository.")),
"private": z.optional(z.boolean().default(false).describe("Whether the repository is private.")),
"visibility": z.optional(z.enum(["public", "private"]).describe("The visibility of the repository.")),
"has_issues": z.optional(z.boolean().default(true).describe("Either `true` to enable issues for this repository or `false` to disable them.")),
"has_projects": z.optional(z.boolean().default(true).describe("Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.")),
"has_wiki": z.optional(z.boolean().default(true).describe("Either `true` to enable the wiki for this repository or `false` to disable it.")),
"has_downloads": z.optional(z.boolean().default(true).describe("Whether downloads are enabled.")),
"is_template": z.optional(z.boolean().default(false).describe("Either `true` to make this repo available as a template repository or `false` to prevent it.")),
"team_id": z.optional(z.int().describe("The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.")),
"auto_init": z.optional(z.boolean().default(false).describe("Pass `true` to create an initial commit with empty README.")),
"gitignore_template": z.optional(z.string().describe("Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, \"Haskell\".")),
"license_template": z.optional(z.string().describe("Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://docs.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, \"mit\" or \"mpl-2.0\".")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.")),
"allow_auto_merge": z.optional(z.boolean().default(false).describe("Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.")),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion. **The authenticated user must be an organization owner to set this property to `true`.**")),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("Required when using `squash_merge_commit_message`.\n\nThe default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("Required when using `merge_commit_message`.\n\nThe default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"custom_properties": z.optional(z.object({
    
    }).catchall(z.unknown()).describe("The custom properties for the new repository. The keys are the custom property names, and the values are the corresponding custom property values."))
    })

export const reposCreateInOrgMutationResponseSchema = reposCreateInOrg201Schema

export const reposGetOrgRulesetsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const reposGetOrgRulesetsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"targets": z.optional(z.string().describe("A comma-separated list of rule targets to filter by.\nIf provided, only rulesets that apply to the specified targets will be returned.\nFor example, `branch,tag,push`.\n"))
    })

/**
 * @description Response
 */
export const reposGetOrgRulesets200Schema = z.array(repositoryRulesetSchema.describe("A set of rules to apply when specified conditions are met."))

/**
 * @description Resource not found
 */
export const reposGetOrgRulesets404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposGetOrgRulesets500Schema = basicErrorSchema.describe("Basic Error")

export const reposGetOrgRulesetsQueryResponseSchema = reposGetOrgRulesets200Schema

export const reposCreateOrgRulesetPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposCreateOrgRuleset201Schema = repositoryRulesetSchema.describe("A set of rules to apply when specified conditions are met.")

/**
 * @description Resource not found
 */
export const reposCreateOrgRuleset404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposCreateOrgRuleset500Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Request body
 */
export const reposCreateOrgRulesetMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the ruleset."),
"target": z.optional(z.enum(["branch", "tag", "push", "repository"]).default("branch").describe("The target of the ruleset")),
get "enforcement"(){
                return repositoryRuleEnforcementSchema.describe("The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).")
              },
get "bypass_actors"(){
                return z.array(repositoryRulesetBypassActorSchema.describe("An actor that can bypass rules in a ruleset")).describe("The actors that can bypass the rules in this ruleset").optional()
              },
get "conditions"(){
                return orgRulesetConditionsSchema.describe("Conditions for an organization ruleset.\nThe branch and tag rulesets conditions object should contain both `repository_name` and `ref_name` properties, or both `repository_id` and `ref_name` properties, or both `repository_property` and `ref_name` properties.\nThe push rulesets conditions object does not require the `ref_name` property.\nFor repository policy rulesets, the conditions object should only contain the `repository_name`, the `repository_id`, or the `repository_property`.").optional()
              },
get "rules"(){
                return z.array(orgRulesSchema.describe("A repository rule.")).describe("An array of rules within the ruleset.").optional()
              }
    })

export const reposCreateOrgRulesetMutationResponseSchema = reposCreateOrgRuleset201Schema

export const reposGetOrgRuleSuitesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const reposGetOrgRuleSuitesQueryParamsSchema = z.object({
    "ref": z.optional(z.string().describe("The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.")),
"repository_name": z.optional(z.string().describe("The name of the repository to filter on.")),
"time_period": z.enum(["hour", "day", "week", "month"]).default("day").describe("The time period to filter by.\n\nFor example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for rule suites that occurred in the past 7 days (168 hours)."),
"actor_name": z.optional(z.string().describe("The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.")),
"rule_suite_result": z.enum(["pass", "fail", "bypass", "all"]).default("all").describe("The rule suite results to filter on. When specified, only suites with this result will be returned."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposGetOrgRuleSuites200Schema = ruleSuitesSchema.describe("Response")

/**
 * @description Resource not found
 */
export const reposGetOrgRuleSuites404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposGetOrgRuleSuites500Schema = basicErrorSchema.describe("Basic Error")

export const reposGetOrgRuleSuitesQueryResponseSchema = reposGetOrgRuleSuites200Schema

export const reposGetOrgRuleSuitePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"rule_suite_id": z.coerce.number().int().describe("The unique identifier of the rule suite result.\nTo get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)\nfor repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites)\nfor organizations.")
    })

/**
 * @description Response
 */
export const reposGetOrgRuleSuite200Schema = ruleSuiteSchema.describe("Response")

/**
 * @description Resource not found
 */
export const reposGetOrgRuleSuite404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposGetOrgRuleSuite500Schema = basicErrorSchema.describe("Basic Error")

export const reposGetOrgRuleSuiteQueryResponseSchema = reposGetOrgRuleSuite200Schema

export const reposGetOrgRulesetPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"ruleset_id": z.coerce.number().int().describe("The ID of the ruleset.")
    })

/**
 * @description Response
 */
export const reposGetOrgRuleset200Schema = repositoryRulesetSchema.describe("A set of rules to apply when specified conditions are met.")

/**
 * @description Resource not found
 */
export const reposGetOrgRuleset404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposGetOrgRuleset500Schema = basicErrorSchema.describe("Basic Error")

export const reposGetOrgRulesetQueryResponseSchema = reposGetOrgRuleset200Schema

export const reposUpdateOrgRulesetPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"ruleset_id": z.coerce.number().int().describe("The ID of the ruleset.")
    })

/**
 * @description Response
 */
export const reposUpdateOrgRuleset200Schema = repositoryRulesetSchema.describe("A set of rules to apply when specified conditions are met.")

/**
 * @description Resource not found
 */
export const reposUpdateOrgRuleset404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposUpdateOrgRuleset500Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Request body
 */
export const reposUpdateOrgRulesetMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("The name of the ruleset.")),
"target": z.optional(z.enum(["branch", "tag", "push", "repository"]).describe("The target of the ruleset")),
get "enforcement"(){
                return repositoryRuleEnforcementSchema.describe("The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).").optional()
              },
get "bypass_actors"(){
                return z.array(repositoryRulesetBypassActorSchema.describe("An actor that can bypass rules in a ruleset")).describe("The actors that can bypass the rules in this ruleset").optional()
              },
get "conditions"(){
                return orgRulesetConditionsSchema.describe("Conditions for an organization ruleset.\nThe branch and tag rulesets conditions object should contain both `repository_name` and `ref_name` properties, or both `repository_id` and `ref_name` properties, or both `repository_property` and `ref_name` properties.\nThe push rulesets conditions object does not require the `ref_name` property.\nFor repository policy rulesets, the conditions object should only contain the `repository_name`, the `repository_id`, or the `repository_property`.").optional()
              },
get "rules"(){
                return z.array(orgRulesSchema.describe("A repository rule.")).describe("An array of rules within the ruleset.").optional()
              }
    })

export const reposUpdateOrgRulesetMutationResponseSchema = reposUpdateOrgRuleset200Schema

export const reposDeleteOrgRulesetPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"ruleset_id": z.coerce.number().int().describe("The ID of the ruleset.")
    })

/**
 * @description Response
 */
export const reposDeleteOrgRuleset204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposDeleteOrgRuleset404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposDeleteOrgRuleset500Schema = basicErrorSchema.describe("Basic Error")

export const reposDeleteOrgRulesetMutationResponseSchema = reposDeleteOrgRuleset204Schema

export const orgsGetOrgRulesetHistoryPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"ruleset_id": z.coerce.number().int().describe("The ID of the ruleset.")
    })

export const orgsGetOrgRulesetHistoryQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const orgsGetOrgRulesetHistory200Schema = z.array(rulesetVersionSchema.describe("The historical version of a ruleset"))

/**
 * @description Resource not found
 */
export const orgsGetOrgRulesetHistory404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const orgsGetOrgRulesetHistory500Schema = basicErrorSchema.describe("Basic Error")

export const orgsGetOrgRulesetHistoryQueryResponseSchema = orgsGetOrgRulesetHistory200Schema

export const orgsGetOrgRulesetVersionPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"ruleset_id": z.coerce.number().int().describe("The ID of the ruleset."),
"version_id": z.coerce.number().int().describe("The ID of the version")
    })

/**
 * @description Response
 */
export const orgsGetOrgRulesetVersion200Schema = rulesetVersionWithStateSchema

/**
 * @description Resource not found
 */
export const orgsGetOrgRulesetVersion404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const orgsGetOrgRulesetVersion500Schema = basicErrorSchema.describe("Basic Error")

export const orgsGetOrgRulesetVersionQueryResponseSchema = orgsGetOrgRulesetVersion200Schema

export const secretScanningListAlertsForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const secretScanningListAlertsForOrgQueryParamsSchema = z.object({
    "state": z.optional(z.enum(["open", "resolved"]).describe("Set to `open` or `resolved` to only list secret scanning alerts in a specific state.")),
"secret_type": z.optional(z.string().describe("A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter. See \"[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)\" for a complete list of secret types.")),
"resolution": z.optional(z.string().describe("A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.")),
"sort": z.enum(["created", "updated"]).default("created").describe("The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved."),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty \"before\" query string.")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty \"after\" query string.")),
"validity": z.optional(z.string().describe("A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.")),
"is_publicly_leaked": z.boolean().default(false).describe("A boolean value representing whether or not to filter alerts by the publicly-leaked tag being present."),
"is_multi_repo": z.boolean().default(false).describe("A boolean value representing whether or not to filter alerts by the multi-repo tag being present."),
"hide_secret": z.boolean().default(false).describe("A boolean value representing whether or not to hide literal secrets in the results.")
    })

/**
 * @description Response
 */
export const secretScanningListAlertsForOrg200Schema = z.array(organizationSecretScanningAlertSchema)

/**
 * @description Resource not found
 */
export const secretScanningListAlertsForOrg404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const secretScanningListAlertsForOrg503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const secretScanningListAlertsForOrgQueryResponseSchema = secretScanningListAlertsForOrg200Schema

export const secretScanningListOrgPatternConfigsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const secretScanningListOrgPatternConfigs200Schema = secretScanningPatternConfigurationSchema.describe("A collection of secret scanning patterns and their settings related to push protection.")

/**
 * @description Forbidden
 */
export const secretScanningListOrgPatternConfigs403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const secretScanningListOrgPatternConfigs404Schema = basicErrorSchema.describe("Basic Error")

export const secretScanningListOrgPatternConfigsQueryResponseSchema = secretScanningListOrgPatternConfigs200Schema

export const secretScanningUpdateOrgPatternConfigsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const secretScanningUpdateOrgPatternConfigs200Schema = z.object({
    "pattern_config_version": z.optional(z.string().describe("The updated pattern configuration version."))
    })

/**
 * @description Bad Request
 */
export const secretScanningUpdateOrgPatternConfigs400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const secretScanningUpdateOrgPatternConfigs403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const secretScanningUpdateOrgPatternConfigs404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const secretScanningUpdateOrgPatternConfigs409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const secretScanningUpdateOrgPatternConfigs422Schema = validationErrorSchema.describe("Validation Error")

export const secretScanningUpdateOrgPatternConfigsMutationRequestSchema = z.object({
    get "pattern_config_version"(){
                return secretScanningRowVersionSchema.describe("The version of the entity. This is used to confirm you're updating the current version of the entity and mitigate unintentionally overriding someone else's update.").optional()
              },
"provider_pattern_settings": z.optional(z.array(z.object({
    "token_type": z.optional(z.string().describe("The ID of the pattern to configure.")),
"push_protection_setting": z.optional(z.enum(["not-set", "disabled", "enabled"]).describe("Push protection setting to set for the pattern."))
    })).describe("Pattern settings for provider patterns.")),
"custom_pattern_settings": z.optional(z.array(z.object({
    "token_type": z.optional(z.string().describe("The ID of the pattern to configure.")),
get "custom_pattern_version"(){
                return secretScanningRowVersionSchema.describe("The version of the entity. This is used to confirm you're updating the current version of the entity and mitigate unintentionally overriding someone else's update.").optional()
              },
"push_protection_setting": z.optional(z.enum(["disabled", "enabled"]).describe("Push protection setting to set for the pattern."))
    })).describe("Pattern settings for custom patterns."))
    })

export const secretScanningUpdateOrgPatternConfigsMutationResponseSchema = secretScanningUpdateOrgPatternConfigs200Schema

export const securityAdvisoriesListOrgRepositoryAdvisoriesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const securityAdvisoriesListOrgRepositoryAdvisoriesQueryParamsSchema = z.object({
    "direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"sort": z.enum(["created", "updated", "published"]).default("created").describe("The property to sort the results by."),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"per_page": z.coerce.number().int().min(1).max(100).default(30).describe("The number of advisories to return per page. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"state": z.optional(z.enum(["triage", "draft", "published", "closed"]).describe("Filter by the state of the repository advisories. Only advisories of this state will be returned."))
    })

/**
 * @description Response
 */
export const securityAdvisoriesListOrgRepositoryAdvisories200Schema = z.array(repositoryAdvisorySchema.describe("A repository security advisory."))

/**
 * @description Bad Request
 */
export const securityAdvisoriesListOrgRepositoryAdvisories400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const securityAdvisoriesListOrgRepositoryAdvisories404Schema = basicErrorSchema.describe("Basic Error")

export const securityAdvisoriesListOrgRepositoryAdvisoriesQueryResponseSchema = securityAdvisoriesListOrgRepositoryAdvisories200Schema

export const orgsListSecurityManagerTeamsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const orgsListSecurityManagerTeams200Schema = z.array(teamSimpleSchema.describe("Groups of organization members that gives permissions on specified repositories."))

export const orgsListSecurityManagerTeamsQueryResponseSchema = orgsListSecurityManagerTeams200Schema

export const orgsAddSecurityManagerTeamPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name.")
    })

/**
 * @description Response
 */
export const orgsAddSecurityManagerTeam204Schema = z.unknown()

export const orgsAddSecurityManagerTeamMutationResponseSchema = orgsAddSecurityManagerTeam204Schema

export const orgsRemoveSecurityManagerTeamPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name.")
    })

/**
 * @description Response
 */
export const orgsRemoveSecurityManagerTeam204Schema = z.unknown()

export const orgsRemoveSecurityManagerTeamMutationResponseSchema = orgsRemoveSecurityManagerTeam204Schema

export const billingGetGithubActionsBillingOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const billingGetGithubActionsBillingOrg200Schema = actionsBillingUsageSchema

export const billingGetGithubActionsBillingOrgQueryResponseSchema = billingGetGithubActionsBillingOrg200Schema

export const billingGetGithubPackagesBillingOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const billingGetGithubPackagesBillingOrg200Schema = packagesBillingUsageSchema

export const billingGetGithubPackagesBillingOrgQueryResponseSchema = billingGetGithubPackagesBillingOrg200Schema

export const billingGetSharedStorageBillingOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const billingGetSharedStorageBillingOrg200Schema = combinedBillingUsageSchema

export const billingGetSharedStorageBillingOrgQueryResponseSchema = billingGetSharedStorageBillingOrg200Schema

export const orgsGetImmutableReleasesSettingsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Immutable releases settings response
 */
export const orgsGetImmutableReleasesSettings200Schema = immutableReleasesOrganizationSettingsSchema.describe("Check immutable releases settings for an organization.")

export const orgsGetImmutableReleasesSettingsQueryResponseSchema = orgsGetImmutableReleasesSettings200Schema

export const orgsSetImmutableReleasesSettingsPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const orgsSetImmutableReleasesSettings204Schema = z.unknown()

export const orgsSetImmutableReleasesSettingsMutationRequestSchema = z.object({
    "enforced_repositories": z.enum(["all", "none", "selected"]).describe("The policy that controls how immutable releases are enforced in the organization."),
"selected_repository_ids": z.optional(z.array(z.int()).describe("An array of repository ids for which immutable releases enforcement should be applied. You can only provide a list of repository ids when the `enforced_repositories` is set to `selected`. You can add and remove individual repositories using the [Enable a selected repository for immutable releases in an organization](https://docs.github.com/rest/orgs/orgs#enable-a-selected-repository-for-immutable-releases-in-an-organization) and [Disable a selected repository for immutable releases in an organization](https://docs.github.com/rest/orgs/orgs#disable-a-selected-repository-for-immutable-releases-in-an-organization) endpoints."))
    })

export const orgsSetImmutableReleasesSettingsMutationResponseSchema = orgsSetImmutableReleasesSettings204Schema

export const orgsGetImmutableReleasesSettingsRepositoriesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const orgsGetImmutableReleasesSettingsRepositoriesQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const orgsGetImmutableReleasesSettingsRepositories200Schema = z.object({
    "total_count": z.int(),
get "repositories"(){
                return z.array(minimalRepositorySchema.describe("Minimal Repository"))
              }
    })

export const orgsGetImmutableReleasesSettingsRepositoriesQueryResponseSchema = orgsGetImmutableReleasesSettingsRepositories200Schema

export const orgsSetImmutableReleasesSettingsRepositoriesPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const orgsSetImmutableReleasesSettingsRepositories204Schema = z.unknown()

export const orgsSetImmutableReleasesSettingsRepositoriesMutationRequestSchema = z.object({
    "selected_repository_ids": z.array(z.int()).describe("An array of repository ids for which immutable releases enforcement should be applied. You can only provide a list of repository ids when the `enforced_repositories` is set to `selected`. You can add and remove individual repositories using the [Enable a selected repository for immutable releases in an organization](https://docs.github.com/rest/orgs/orgs#enable-a-selected-repository-for-immutable-releases-in-an-organization) and [Disable a selected repository for immutable releases in an organization](https://docs.github.com/rest/orgs/orgs#disable-a-selected-repository-for-immutable-releases-in-an-organization) endpoints.")
    })

export const orgsSetImmutableReleasesSettingsRepositoriesMutationResponseSchema = orgsSetImmutableReleasesSettingsRepositories204Schema

export const orgsEnableSelectedRepositoryImmutableReleasesOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"repository_id": z.coerce.number().int().describe("The unique identifier of the repository.")
    })

/**
 * @description Response
 */
export const orgsEnableSelectedRepositoryImmutableReleasesOrganization204Schema = z.unknown()

export const orgsEnableSelectedRepositoryImmutableReleasesOrganizationMutationResponseSchema = orgsEnableSelectedRepositoryImmutableReleasesOrganization204Schema

export const orgsDisableSelectedRepositoryImmutableReleasesOrganizationPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"repository_id": z.coerce.number().int().describe("The unique identifier of the repository.")
    })

/**
 * @description Response
 */
export const orgsDisableSelectedRepositoryImmutableReleasesOrganization204Schema = z.unknown()

export const orgsDisableSelectedRepositoryImmutableReleasesOrganizationMutationResponseSchema = orgsDisableSelectedRepositoryImmutableReleasesOrganization204Schema

export const hostedComputeListNetworkConfigurationsForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const hostedComputeListNetworkConfigurationsForOrgQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const hostedComputeListNetworkConfigurationsForOrg200Schema = z.object({
    "total_count": z.int(),
get "network_configurations"(){
                return z.array(networkConfigurationSchema.describe("A hosted compute network configuration."))
              }
    })

export const hostedComputeListNetworkConfigurationsForOrgQueryResponseSchema = hostedComputeListNetworkConfigurationsForOrg200Schema

export const hostedComputeCreateNetworkConfigurationForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const hostedComputeCreateNetworkConfigurationForOrg201Schema = networkConfigurationSchema.describe("A hosted compute network configuration.")

export const hostedComputeCreateNetworkConfigurationForOrgMutationRequestSchema = z.object({
    "name": z.string().describe("Name of the network configuration. Must be between 1 and 100 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'."),
"compute_service": z.optional(z.enum(["none", "actions"]).describe("The hosted compute service to use for the network configuration.")),
"network_settings_ids": z.array(z.string()).min(1).max(1).describe("The identifier of the network settings to use for the network configuration. Exactly one network settings must be specified.")
    })

export const hostedComputeCreateNetworkConfigurationForOrgMutationResponseSchema = hostedComputeCreateNetworkConfigurationForOrg201Schema

export const hostedComputeGetNetworkConfigurationForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"network_configuration_id": z.string().describe("Unique identifier of the hosted compute network configuration.")
    })

/**
 * @description Response
 */
export const hostedComputeGetNetworkConfigurationForOrg200Schema = networkConfigurationSchema.describe("A hosted compute network configuration.")

export const hostedComputeGetNetworkConfigurationForOrgQueryResponseSchema = hostedComputeGetNetworkConfigurationForOrg200Schema

export const hostedComputeUpdateNetworkConfigurationForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"network_configuration_id": z.string().describe("Unique identifier of the hosted compute network configuration.")
    })

/**
 * @description Response
 */
export const hostedComputeUpdateNetworkConfigurationForOrg200Schema = networkConfigurationSchema.describe("A hosted compute network configuration.")

export const hostedComputeUpdateNetworkConfigurationForOrgMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("Name of the network configuration. Must be between 1 and 100 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'.")),
"compute_service": z.optional(z.enum(["none", "actions"]).describe("The hosted compute service to use for the network configuration.")),
"network_settings_ids": z.optional(z.array(z.string()).min(0).max(1).describe("The identifier of the network settings to use for the network configuration. Exactly one network settings must be specified."))
    })

export const hostedComputeUpdateNetworkConfigurationForOrgMutationResponseSchema = hostedComputeUpdateNetworkConfigurationForOrg200Schema

export const hostedComputeDeleteNetworkConfigurationFromOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"network_configuration_id": z.string().describe("Unique identifier of the hosted compute network configuration.")
    })

/**
 * @description Response
 */
export const hostedComputeDeleteNetworkConfigurationFromOrg204Schema = z.unknown()

export const hostedComputeDeleteNetworkConfigurationFromOrgMutationResponseSchema = hostedComputeDeleteNetworkConfigurationFromOrg204Schema

export const hostedComputeGetNetworkSettingsForOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"network_settings_id": z.string().describe("Unique identifier of the hosted compute network settings.")
    })

/**
 * @description Response
 */
export const hostedComputeGetNetworkSettingsForOrg200Schema = networkSettingsSchema.describe("A hosted compute network settings resource.")

export const hostedComputeGetNetworkSettingsForOrgQueryResponseSchema = hostedComputeGetNetworkSettingsForOrg200Schema

export const copilotCopilotMetricsForTeamPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name.")
    })

export const copilotCopilotMetricsForTeamQueryParamsSchema = z.object({
    "since": z.optional(z.string().describe("Show usage metrics since this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`). Maximum value is 100 days ago.")),
"until": z.optional(z.string().describe("Show usage metrics until this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`) and should not preceed the `since` date if it is passed.")),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(100).describe("The number of days of metrics to display per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const copilotCopilotMetricsForTeam200Schema = z.array(copilotUsageMetricsDaySchema.describe("Copilot usage metrics for a given day."))

/**
 * @description Forbidden
 */
export const copilotCopilotMetricsForTeam403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const copilotCopilotMetricsForTeam404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Copilot Usage Merics API setting is disabled at the organization or enterprise level.
 */
export const copilotCopilotMetricsForTeam422Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const copilotCopilotMetricsForTeam500Schema = basicErrorSchema.describe("Basic Error")

export const copilotCopilotMetricsForTeamQueryResponseSchema = copilotCopilotMetricsForTeam200Schema

export const teamsListPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const teamsListQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const teamsList200Schema = z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories."))

/**
 * @description Forbidden
 */
export const teamsList403Schema = basicErrorSchema.describe("Basic Error")

export const teamsListQueryResponseSchema = teamsList200Schema

export const teamsCreatePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const teamsCreate201Schema = teamFullSchema.describe("Groups of organization members that gives permissions on specified repositories.")

/**
 * @description Forbidden
 */
export const teamsCreate403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const teamsCreate422Schema = validationErrorSchema.describe("Validation Error")

export const teamsCreateMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the team."),
"description": z.optional(z.string().describe("The description of the team.")),
"maintainers": z.optional(z.array(z.string()).describe("List GitHub usernames for organization members who will become team maintainers.")),
"repo_names": z.optional(z.array(z.string()).describe("The full name (e.g., \"organization-name/repository-name\") of repositories to add the team to.")),
"privacy": z.optional(z.enum(["secret", "closed"]).describe("The level of privacy this team should have. The options are:  \n**For a non-nested team:**  \n * `secret` - only visible to organization owners and members of this team.  \n * `closed` - visible to all members of this organization.  \nDefault: `secret`  \n**For a parent or child team:**  \n * `closed` - visible to all members of this organization.  \nDefault for child team: `closed`")),
"notification_setting": z.optional(z.enum(["notifications_enabled", "notifications_disabled"]).describe("The notification setting the team has chosen. The options are:  \n * `notifications_enabled` - team members receive notifications when the team is @mentioned.  \n * `notifications_disabled` - no one receives notifications.  \nDefault: `notifications_enabled`")),
"permission": z.optional(z.enum(["pull", "push"]).default("pull").describe("**Closing down notice**. The permission that new repositories will be added to the team with when none is specified.")),
"parent_team_id": z.optional(z.int().describe("The ID of a team to set as the parent team."))
    })

export const teamsCreateMutationResponseSchema = teamsCreate201Schema

export const teamsGetByNamePathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name.")
    })

/**
 * @description Response
 */
export const teamsGetByName200Schema = teamFullSchema.describe("Groups of organization members that gives permissions on specified repositories.")

/**
 * @description Resource not found
 */
export const teamsGetByName404Schema = basicErrorSchema.describe("Basic Error")

export const teamsGetByNameQueryResponseSchema = teamsGetByName200Schema

export const teamsUpdateInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name.")
    })

/**
 * @description Response when the updated information already exists
 */
export const teamsUpdateInOrg200Schema = teamFullSchema.describe("Groups of organization members that gives permissions on specified repositories.")

/**
 * @description Response
 */
export const teamsUpdateInOrg201Schema = teamFullSchema.describe("Groups of organization members that gives permissions on specified repositories.")

/**
 * @description Forbidden
 */
export const teamsUpdateInOrg403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const teamsUpdateInOrg404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const teamsUpdateInOrg422Schema = validationErrorSchema.describe("Validation Error")

export const teamsUpdateInOrgMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("The name of the team.")),
"description": z.optional(z.string().describe("The description of the team.")),
"privacy": z.optional(z.enum(["secret", "closed"]).describe("The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. When a team is nested, the `privacy` for parent teams cannot be `secret`. The options are:  \n**For a non-nested team:**  \n * `secret` - only visible to organization owners and members of this team.  \n * `closed` - visible to all members of this organization.  \n**For a parent or child team:**  \n * `closed` - visible to all members of this organization.")),
"notification_setting": z.optional(z.enum(["notifications_enabled", "notifications_disabled"]).describe("The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are: \n * `notifications_enabled` - team members receive notifications when the team is @mentioned.  \n * `notifications_disabled` - no one receives notifications.")),
"permission": z.optional(z.enum(["pull", "push", "admin"]).default("pull").describe("**Closing down notice**. The permission that new repositories will be added to the team with when none is specified.")),
"parent_team_id": z.int().describe("The ID of a team to set as the parent team.").nullish()
    })

export const teamsUpdateInOrgMutationResponseSchema = z.union([teamsUpdateInOrg200Schema, teamsUpdateInOrg201Schema])

export const teamsDeleteInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name.")
    })

/**
 * @description Response
 */
export const teamsDeleteInOrg204Schema = z.unknown()

export const teamsDeleteInOrgMutationResponseSchema = teamsDeleteInOrg204Schema

export const teamsListDiscussionsInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name.")
    })

export const teamsListDiscussionsInOrgQueryParamsSchema = z.object({
    "direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"pinned": z.optional(z.string().describe("Pinned discussions only filter"))
    })

/**
 * @description Response
 */
export const teamsListDiscussionsInOrg200Schema = z.array(teamDiscussionSchema.describe("A team discussion is a persistent record of a free-form conversation within a team."))

export const teamsListDiscussionsInOrgQueryResponseSchema = teamsListDiscussionsInOrg200Schema

export const teamsCreateDiscussionInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name.")
    })

/**
 * @description Response
 */
export const teamsCreateDiscussionInOrg201Schema = teamDiscussionSchema.describe("A team discussion is a persistent record of a free-form conversation within a team.")

export const teamsCreateDiscussionInOrgMutationRequestSchema = z.object({
    "title": z.string().describe("The discussion post's title."),
"body": z.string().describe("The discussion post's body text."),
"private": z.optional(z.boolean().default(false).describe("Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post."))
    })

export const teamsCreateDiscussionInOrgMutationResponseSchema = teamsCreateDiscussionInOrg201Schema

export const teamsGetDiscussionInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion.")
    })

/**
 * @description Response
 */
export const teamsGetDiscussionInOrg200Schema = teamDiscussionSchema.describe("A team discussion is a persistent record of a free-form conversation within a team.")

export const teamsGetDiscussionInOrgQueryResponseSchema = teamsGetDiscussionInOrg200Schema

export const teamsUpdateDiscussionInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion.")
    })

/**
 * @description Response
 */
export const teamsUpdateDiscussionInOrg200Schema = teamDiscussionSchema.describe("A team discussion is a persistent record of a free-form conversation within a team.")

export const teamsUpdateDiscussionInOrgMutationRequestSchema = z.object({
    "title": z.optional(z.string().describe("The discussion post's title.")),
"body": z.optional(z.string().describe("The discussion post's body text."))
    })

export const teamsUpdateDiscussionInOrgMutationResponseSchema = teamsUpdateDiscussionInOrg200Schema

export const teamsDeleteDiscussionInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion.")
    })

/**
 * @description Response
 */
export const teamsDeleteDiscussionInOrg204Schema = z.unknown()

export const teamsDeleteDiscussionInOrgMutationResponseSchema = teamsDeleteDiscussionInOrg204Schema

export const teamsListDiscussionCommentsInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion.")
    })

export const teamsListDiscussionCommentsInOrgQueryParamsSchema = z.object({
    "direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const teamsListDiscussionCommentsInOrg200Schema = z.array(teamDiscussionCommentSchema.describe("A reply to a discussion within a team."))

export const teamsListDiscussionCommentsInOrgQueryResponseSchema = teamsListDiscussionCommentsInOrg200Schema

export const teamsCreateDiscussionCommentInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion.")
    })

/**
 * @description Response
 */
export const teamsCreateDiscussionCommentInOrg201Schema = teamDiscussionCommentSchema.describe("A reply to a discussion within a team.")

export const teamsCreateDiscussionCommentInOrgMutationRequestSchema = z.object({
    "body": z.string().describe("The discussion comment's body text.")
    })

export const teamsCreateDiscussionCommentInOrgMutationResponseSchema = teamsCreateDiscussionCommentInOrg201Schema

export const teamsGetDiscussionCommentInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion."),
"comment_number": z.coerce.number().int().describe("The number that identifies the comment.")
    })

/**
 * @description Response
 */
export const teamsGetDiscussionCommentInOrg200Schema = teamDiscussionCommentSchema.describe("A reply to a discussion within a team.")

export const teamsGetDiscussionCommentInOrgQueryResponseSchema = teamsGetDiscussionCommentInOrg200Schema

export const teamsUpdateDiscussionCommentInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion."),
"comment_number": z.coerce.number().int().describe("The number that identifies the comment.")
    })

/**
 * @description Response
 */
export const teamsUpdateDiscussionCommentInOrg200Schema = teamDiscussionCommentSchema.describe("A reply to a discussion within a team.")

export const teamsUpdateDiscussionCommentInOrgMutationRequestSchema = z.object({
    "body": z.string().describe("The discussion comment's body text.")
    })

export const teamsUpdateDiscussionCommentInOrgMutationResponseSchema = teamsUpdateDiscussionCommentInOrg200Schema

export const teamsDeleteDiscussionCommentInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion."),
"comment_number": z.coerce.number().int().describe("The number that identifies the comment.")
    })

/**
 * @description Response
 */
export const teamsDeleteDiscussionCommentInOrg204Schema = z.unknown()

export const teamsDeleteDiscussionCommentInOrgMutationResponseSchema = teamsDeleteDiscussionCommentInOrg204Schema

export const reactionsListForTeamDiscussionCommentInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion."),
"comment_number": z.coerce.number().int().describe("The number that identifies the comment.")
    })

export const reactionsListForTeamDiscussionCommentInOrgQueryParamsSchema = z.object({
    "content": z.optional(z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion comment.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reactionsListForTeamDiscussionCommentInOrg200Schema = z.array(reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively."))

export const reactionsListForTeamDiscussionCommentInOrgQueryResponseSchema = reactionsListForTeamDiscussionCommentInOrg200Schema

export const reactionsCreateForTeamDiscussionCommentInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion."),
"comment_number": z.coerce.number().int().describe("The number that identifies the comment.")
    })

/**
 * @description Response when the reaction type has already been added to this team discussion comment
 */
export const reactionsCreateForTeamDiscussionCommentInOrg200Schema = reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

/**
 * @description Response
 */
export const reactionsCreateForTeamDiscussionCommentInOrg201Schema = reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

export const reactionsCreateForTeamDiscussionCommentInOrgMutationRequestSchema = z.object({
    "content": z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion comment.")
    })

export const reactionsCreateForTeamDiscussionCommentInOrgMutationResponseSchema = z.union([reactionsCreateForTeamDiscussionCommentInOrg200Schema, reactionsCreateForTeamDiscussionCommentInOrg201Schema])

export const reactionsDeleteForTeamDiscussionCommentPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion."),
"comment_number": z.coerce.number().int().describe("The number that identifies the comment."),
"reaction_id": z.coerce.number().int().describe("The unique identifier of the reaction.")
    })

/**
 * @description Response
 */
export const reactionsDeleteForTeamDiscussionComment204Schema = z.unknown()

export const reactionsDeleteForTeamDiscussionCommentMutationResponseSchema = reactionsDeleteForTeamDiscussionComment204Schema

export const reactionsListForTeamDiscussionInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion.")
    })

export const reactionsListForTeamDiscussionInOrgQueryParamsSchema = z.object({
    "content": z.optional(z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reactionsListForTeamDiscussionInOrg200Schema = z.array(reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively."))

export const reactionsListForTeamDiscussionInOrgQueryResponseSchema = reactionsListForTeamDiscussionInOrg200Schema

export const reactionsCreateForTeamDiscussionInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion.")
    })

/**
 * @description Response
 */
export const reactionsCreateForTeamDiscussionInOrg200Schema = reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

/**
 * @description Response
 */
export const reactionsCreateForTeamDiscussionInOrg201Schema = reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

export const reactionsCreateForTeamDiscussionInOrgMutationRequestSchema = z.object({
    "content": z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion.")
    })

export const reactionsCreateForTeamDiscussionInOrgMutationResponseSchema = z.union([reactionsCreateForTeamDiscussionInOrg200Schema, reactionsCreateForTeamDiscussionInOrg201Schema])

export const reactionsDeleteForTeamDiscussionPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion."),
"reaction_id": z.coerce.number().int().describe("The unique identifier of the reaction.")
    })

/**
 * @description Response
 */
export const reactionsDeleteForTeamDiscussion204Schema = z.unknown()

export const reactionsDeleteForTeamDiscussionMutationResponseSchema = reactionsDeleteForTeamDiscussion204Schema

export const teamsListPendingInvitationsInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name.")
    })

export const teamsListPendingInvitationsInOrgQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const teamsListPendingInvitationsInOrg200Schema = z.array(organizationInvitationSchema.describe("Organization Invitation"))

export const teamsListPendingInvitationsInOrgQueryResponseSchema = teamsListPendingInvitationsInOrg200Schema

export const teamsListMembersInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name.")
    })

export const teamsListMembersInOrgQueryParamsSchema = z.object({
    "role": z.enum(["member", "maintainer", "all"]).default("all").describe("Filters members returned by their role in the team."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const teamsListMembersInOrg200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

export const teamsListMembersInOrgQueryResponseSchema = teamsListMembersInOrg200Schema

export const teamsGetMembershipForUserInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const teamsGetMembershipForUserInOrg200Schema = teamMembershipSchema.describe("Team Membership")

/**
 * @description if user has no team membership
 */
export const teamsGetMembershipForUserInOrg404Schema = z.unknown()

export const teamsGetMembershipForUserInOrgQueryResponseSchema = teamsGetMembershipForUserInOrg200Schema

export const teamsAddOrUpdateMembershipForUserInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const teamsAddOrUpdateMembershipForUserInOrg200Schema = teamMembershipSchema.describe("Team Membership")

/**
 * @description Forbidden if team synchronization is set up
 */
export const teamsAddOrUpdateMembershipForUserInOrg403Schema = z.unknown()

/**
 * @description Unprocessable Entity if you attempt to add an organization to a team
 */
export const teamsAddOrUpdateMembershipForUserInOrg422Schema = z.unknown()

export const teamsAddOrUpdateMembershipForUserInOrgMutationRequestSchema = z.object({
    "role": z.optional(z.enum(["member", "maintainer"]).default("member").describe("The role that this user should have in the team."))
    })

export const teamsAddOrUpdateMembershipForUserInOrgMutationResponseSchema = teamsAddOrUpdateMembershipForUserInOrg200Schema

export const teamsRemoveMembershipForUserInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const teamsRemoveMembershipForUserInOrg204Schema = z.unknown()

/**
 * @description Forbidden if team synchronization is set up
 */
export const teamsRemoveMembershipForUserInOrg403Schema = z.unknown()

export const teamsRemoveMembershipForUserInOrgMutationResponseSchema = teamsRemoveMembershipForUserInOrg204Schema

export const teamsListProjectsInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name.")
    })

export const teamsListProjectsInOrgQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const teamsListProjectsInOrg200Schema = z.array(teamProjectSchema.describe("A team's access to a project."))

export const teamsListProjectsInOrgQueryResponseSchema = teamsListProjectsInOrg200Schema

export const teamsCheckPermissionsForProjectInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"project_id": z.coerce.number().int().describe("The unique identifier of the project.")
    })

/**
 * @description Response
 */
export const teamsCheckPermissionsForProjectInOrg200Schema = teamProjectSchema.describe("A team's access to a project.")

/**
 * @description Not Found if project is not managed by this team
 */
export const teamsCheckPermissionsForProjectInOrg404Schema = z.unknown()

export const teamsCheckPermissionsForProjectInOrgQueryResponseSchema = teamsCheckPermissionsForProjectInOrg200Schema

export const teamsAddOrUpdateProjectPermissionsInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"project_id": z.coerce.number().int().describe("The unique identifier of the project.")
    })

/**
 * @description Response
 */
export const teamsAddOrUpdateProjectPermissionsInOrg204Schema = z.unknown()

/**
 * @description Forbidden if the project is not owned by the organization
 */
export const teamsAddOrUpdateProjectPermissionsInOrg403Schema = z.object({
    "message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const teamsAddOrUpdateProjectPermissionsInOrgMutationRequestSchema = z.object({
    "permission": z.optional(z.enum(["read", "write", "admin"]).describe("The permission to grant to the team for this project. Default: the team's `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling this endpoint. For more information, see \"[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).\""))
    }).nullable()

export const teamsAddOrUpdateProjectPermissionsInOrgMutationResponseSchema = teamsAddOrUpdateProjectPermissionsInOrg204Schema

export const teamsRemoveProjectInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"project_id": z.coerce.number().int().describe("The unique identifier of the project.")
    })

/**
 * @description Response
 */
export const teamsRemoveProjectInOrg204Schema = z.unknown()

export const teamsRemoveProjectInOrgMutationResponseSchema = teamsRemoveProjectInOrg204Schema

export const teamsListReposInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name.")
    })

export const teamsListReposInOrgQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const teamsListReposInOrg200Schema = z.array(minimalRepositorySchema.describe("Minimal Repository"))

export const teamsListReposInOrgQueryResponseSchema = teamsListReposInOrg200Schema

export const teamsCheckPermissionsForRepoInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Alternative response with repository permissions
 */
export const teamsCheckPermissionsForRepoInOrg200Schema = teamRepositorySchema.describe("A team's access to a repository.")

/**
 * @description Response if team has permission for the repository. This is the response when the repository media type hasn\'t been provded in the Accept header.
 */
export const teamsCheckPermissionsForRepoInOrg204Schema = z.unknown()

/**
 * @description Not Found if team does not have permission for the repository
 */
export const teamsCheckPermissionsForRepoInOrg404Schema = z.unknown()

export const teamsCheckPermissionsForRepoInOrgQueryResponseSchema = z.union([teamsCheckPermissionsForRepoInOrg200Schema, teamsCheckPermissionsForRepoInOrg204Schema])

export const teamsAddOrUpdateRepoPermissionsInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const teamsAddOrUpdateRepoPermissionsInOrg204Schema = z.unknown()

export const teamsAddOrUpdateRepoPermissionsInOrgMutationRequestSchema = z.object({
    "permission": z.optional(z.string().describe("The permission to grant the team on this repository. We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository."))
    })

export const teamsAddOrUpdateRepoPermissionsInOrgMutationResponseSchema = teamsAddOrUpdateRepoPermissionsInOrg204Schema

export const teamsRemoveRepoInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name."),
"owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const teamsRemoveRepoInOrg204Schema = z.unknown()

export const teamsRemoveRepoInOrgMutationResponseSchema = teamsRemoveRepoInOrg204Schema

export const teamsListChildInOrgPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"team_slug": z.string().describe("The slug of the team name.")
    })

export const teamsListChildInOrgQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description if child teams exist
 */
export const teamsListChildInOrg200Schema = z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories."))

export const teamsListChildInOrgQueryResponseSchema = teamsListChildInOrg200Schema

export const orgsEnableOrDisableSecurityProductOnAllOrgReposPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive."),
"security_product": z.enum(["dependency_graph", "dependabot_alerts", "dependabot_security_updates", "advanced_security", "code_scanning_default_setup", "secret_scanning", "secret_scanning_push_protection"]).describe("The security feature to enable or disable."),
"enablement": z.enum(["enable_all", "disable_all"]).describe("The action to take.\n\n`enable_all` means to enable the specified security feature for all repositories in the organization.\n`disable_all` means to disable the specified security feature for all repositories in the organization.")
    })

/**
 * @description Action started
 */
export const orgsEnableOrDisableSecurityProductOnAllOrgRepos204Schema = z.unknown()

/**
 * @description The action could not be taken due to an in progress enablement, or a policy is preventing enablement
 */
export const orgsEnableOrDisableSecurityProductOnAllOrgRepos422Schema = z.unknown()

export const orgsEnableOrDisableSecurityProductOnAllOrgReposMutationRequestSchema = z.object({
    "query_suite": z.optional(z.enum(["default", "extended"]).describe("CodeQL query suite to be used. If you specify the `query_suite` parameter, the default setup will be configured with this query suite only on all repositories that didn't have default setup already configured. It will not change the query suite on repositories that already have default setup configured.\nIf you don't specify any `query_suite` in your request, the preferred query suite of the organization will be applied."))
    })

export const orgsEnableOrDisableSecurityProductOnAllOrgReposMutationResponseSchema = orgsEnableOrDisableSecurityProductOnAllOrgRepos204Schema

export const projectsClassicGetColumnPathParamsSchema = z.object({
    "column_id": z.coerce.number().int().describe("The unique identifier of the column.")
    })

/**
 * @description Response
 */
export const projectsClassicGetColumn200Schema = projectColumnSchema.describe("Project columns contain cards of work.")

/**
 * @description Not modified
 */
export const projectsClassicGetColumn304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsClassicGetColumn401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicGetColumn403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const projectsClassicGetColumn404Schema = basicErrorSchema.describe("Basic Error")

export const projectsClassicGetColumnQueryResponseSchema = projectsClassicGetColumn200Schema

export const projectsClassicUpdateColumnPathParamsSchema = z.object({
    "column_id": z.coerce.number().int().describe("The unique identifier of the column.")
    })

/**
 * @description Response
 */
export const projectsClassicUpdateColumn200Schema = projectColumnSchema.describe("Project columns contain cards of work.")

/**
 * @description Not modified
 */
export const projectsClassicUpdateColumn304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsClassicUpdateColumn401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicUpdateColumn403Schema = basicErrorSchema.describe("Basic Error")

export const projectsClassicUpdateColumnMutationRequestSchema = z.object({
    "name": z.string().describe("Name of the project column")
    })

export const projectsClassicUpdateColumnMutationResponseSchema = projectsClassicUpdateColumn200Schema

export const projectsClassicDeleteColumnPathParamsSchema = z.object({
    "column_id": z.coerce.number().int().describe("The unique identifier of the column.")
    })

/**
 * @description Response
 */
export const projectsClassicDeleteColumn204Schema = z.unknown()

/**
 * @description Not modified
 */
export const projectsClassicDeleteColumn304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsClassicDeleteColumn401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicDeleteColumn403Schema = basicErrorSchema.describe("Basic Error")

export const projectsClassicDeleteColumnMutationResponseSchema = projectsClassicDeleteColumn204Schema

export const projectsClassicMoveColumnPathParamsSchema = z.object({
    "column_id": z.coerce.number().int().describe("The unique identifier of the column.")
    })

/**
 * @description Response
 */
export const projectsClassicMoveColumn201Schema = z.object({
    
    })

/**
 * @description Not modified
 */
export const projectsClassicMoveColumn304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsClassicMoveColumn401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicMoveColumn403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const projectsClassicMoveColumn422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const projectsClassicMoveColumnMutationRequestSchema = z.object({
    "position": z.string().regex(/^(?:first|last|after:\d+)$/).describe("The position of the column in a project. Can be one of: `first`, `last`, or `after:<column_id>` to place after the specified column.")
    })

export const projectsClassicMoveColumnMutationResponseSchema = projectsClassicMoveColumn201Schema

export const projectsClassicGetPathParamsSchema = z.object({
    "project_id": z.coerce.number().int().describe("The unique identifier of the project.")
    })

/**
 * @description Response
 */
export const projectsClassicGet200Schema = projectSchema.describe("Projects are a way to organize columns and cards of work.")

/**
 * @description Not modified
 */
export const projectsClassicGet304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsClassicGet401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicGet403Schema = basicErrorSchema.describe("Basic Error")

export const projectsClassicGetQueryResponseSchema = projectsClassicGet200Schema

export const projectsClassicUpdatePathParamsSchema = z.object({
    "project_id": z.coerce.number().int().describe("The unique identifier of the project.")
    })

/**
 * @description Response
 */
export const projectsClassicUpdate200Schema = projectSchema.describe("Projects are a way to organize columns and cards of work.")

/**
 * @description Not modified
 */
export const projectsClassicUpdate304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsClassicUpdate401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicUpdate403Schema = z.object({
    "message": z.optional(z.string()),
"documentation_url": z.optional(z.string()),
"errors": z.optional(z.array(z.string()))
    })

/**
 * @description Not Found if the authenticated user does not have access to the project
 */
export const projectsClassicUpdate404Schema = z.unknown()

/**
 * @description Gone
 */
export const projectsClassicUpdate410Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const projectsClassicUpdate422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const projectsClassicUpdateMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("Name of the project")),
"body": z.string().describe("Body of the project").nullish(),
"state": z.optional(z.string().describe("State of the project; either 'open' or 'closed'")),
"organization_permission": z.optional(z.enum(["read", "write", "admin", "none"]).describe("The baseline permission that all organization members have on this project")),
"private": z.optional(z.boolean().describe("Whether or not this project can be seen by everyone."))
    })

export const projectsClassicUpdateMutationResponseSchema = projectsClassicUpdate200Schema

export const projectsClassicDeletePathParamsSchema = z.object({
    "project_id": z.coerce.number().int().describe("The unique identifier of the project.")
    })

/**
 * @description Delete Success
 */
export const projectsClassicDelete204Schema = z.unknown()

/**
 * @description Not modified
 */
export const projectsClassicDelete304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsClassicDelete401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicDelete403Schema = z.object({
    "message": z.optional(z.string()),
"documentation_url": z.optional(z.string()),
"errors": z.optional(z.array(z.string()))
    })

/**
 * @description Resource not found
 */
export const projectsClassicDelete404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const projectsClassicDelete410Schema = basicErrorSchema.describe("Basic Error")

export const projectsClassicDeleteMutationResponseSchema = projectsClassicDelete204Schema

export const projectsClassicListCollaboratorsPathParamsSchema = z.object({
    "project_id": z.coerce.number().int().describe("The unique identifier of the project.")
    })

export const projectsClassicListCollaboratorsQueryParamsSchema = z.object({
    "affiliation": z.enum(["outside", "direct", "all"]).default("all").describe("Filters the collaborators by their affiliation. `outside` means outside collaborators of a project that are not a member of the project's organization. `direct` means collaborators with permissions to a project, regardless of organization membership status. `all` means all collaborators the authenticated user can see."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const projectsClassicListCollaborators200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

/**
 * @description Not modified
 */
export const projectsClassicListCollaborators304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsClassicListCollaborators401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicListCollaborators403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const projectsClassicListCollaborators404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const projectsClassicListCollaborators422Schema = validationErrorSchema.describe("Validation Error")

export const projectsClassicListCollaboratorsQueryResponseSchema = projectsClassicListCollaborators200Schema

export const projectsClassicAddCollaboratorPathParamsSchema = z.object({
    "project_id": z.coerce.number().int().describe("The unique identifier of the project."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const projectsClassicAddCollaborator204Schema = z.unknown()

/**
 * @description Not modified
 */
export const projectsClassicAddCollaborator304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsClassicAddCollaborator401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicAddCollaborator403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const projectsClassicAddCollaborator404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const projectsClassicAddCollaborator422Schema = validationErrorSchema.describe("Validation Error")

export const projectsClassicAddCollaboratorMutationRequestSchema = z.object({
    "permission": z.optional(z.enum(["read", "write", "admin"]).default("write").describe("The permission to grant the collaborator."))
    }).nullable()

export const projectsClassicAddCollaboratorMutationResponseSchema = projectsClassicAddCollaborator204Schema

export const projectsClassicRemoveCollaboratorPathParamsSchema = z.object({
    "project_id": z.coerce.number().int().describe("The unique identifier of the project."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const projectsClassicRemoveCollaborator204Schema = z.unknown()

/**
 * @description Not modified
 */
export const projectsClassicRemoveCollaborator304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsClassicRemoveCollaborator401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicRemoveCollaborator403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const projectsClassicRemoveCollaborator404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const projectsClassicRemoveCollaborator422Schema = validationErrorSchema.describe("Validation Error")

export const projectsClassicRemoveCollaboratorMutationResponseSchema = projectsClassicRemoveCollaborator204Schema

export const projectsClassicGetPermissionForUserPathParamsSchema = z.object({
    "project_id": z.coerce.number().int().describe("The unique identifier of the project."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const projectsClassicGetPermissionForUser200Schema = projectCollaboratorPermissionSchema.describe("Project Collaborator Permission")

/**
 * @description Not modified
 */
export const projectsClassicGetPermissionForUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsClassicGetPermissionForUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicGetPermissionForUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const projectsClassicGetPermissionForUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const projectsClassicGetPermissionForUser422Schema = validationErrorSchema.describe("Validation Error")

export const projectsClassicGetPermissionForUserQueryResponseSchema = projectsClassicGetPermissionForUser200Schema

export const projectsClassicListColumnsPathParamsSchema = z.object({
    "project_id": z.coerce.number().int().describe("The unique identifier of the project.")
    })

export const projectsClassicListColumnsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const projectsClassicListColumns200Schema = z.array(projectColumnSchema.describe("Project columns contain cards of work."))

/**
 * @description Not modified
 */
export const projectsClassicListColumns304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsClassicListColumns401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicListColumns403Schema = basicErrorSchema.describe("Basic Error")

export const projectsClassicListColumnsQueryResponseSchema = projectsClassicListColumns200Schema

export const projectsClassicCreateColumnPathParamsSchema = z.object({
    "project_id": z.coerce.number().int().describe("The unique identifier of the project.")
    })

/**
 * @description Response
 */
export const projectsClassicCreateColumn201Schema = projectColumnSchema.describe("Project columns contain cards of work.")

/**
 * @description Not modified
 */
export const projectsClassicCreateColumn304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsClassicCreateColumn401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicCreateColumn403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const projectsClassicCreateColumn422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const projectsClassicCreateColumnMutationRequestSchema = z.object({
    "name": z.string().describe("Name of the project column")
    })

export const projectsClassicCreateColumnMutationResponseSchema = projectsClassicCreateColumn201Schema

/**
 * @description Response
 */
export const rateLimitGet200Schema = rateLimitOverviewSchema.describe("Rate Limit Overview")

/**
 * @description Not modified
 */
export const rateLimitGet304Schema = z.unknown()

/**
 * @description Resource not found
 */
export const rateLimitGet404Schema = basicErrorSchema.describe("Basic Error")

export const rateLimitGetQueryResponseSchema = rateLimitGet200Schema

export const reposGetPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposGet200Schema = fullRepositorySchema.describe("Full Repository")

/**
 * @description Moved permanently
 */
export const reposGet301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const reposGet403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposGet404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetQueryResponseSchema = reposGet200Schema

export const reposUpdatePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposUpdate200Schema = fullRepositorySchema.describe("Full Repository")

/**
 * @description Temporary Redirect
 */
export const reposUpdate307Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const reposUpdate403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposUpdate404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposUpdate422Schema = validationErrorSchema.describe("Validation Error")

export const reposUpdateMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("The name of the repository.")),
"description": z.optional(z.string().describe("A short description of the repository.")),
"homepage": z.optional(z.string().describe("A URL with more information about the repository.")),
"private": z.optional(z.boolean().default(false).describe("Either `true` to make the repository private or `false` to make it public. Default: `false`.  \n**Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://docs.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private.")),
"visibility": z.optional(z.enum(["public", "private"]).describe("The visibility of the repository.")),
"security_and_analysis": z.object({
    "advanced_security": z.optional(z.object({
    "status": z.optional(z.string().describe("Can be `enabled` or `disabled`."))
    }).describe("Use the `status` property to enable or disable GitHub Advanced Security for this repository.\nFor more information, see \"[About GitHub Advanced\nSecurity](/github/getting-started-with-github/learning-about-github/about-github-advanced-security).\"\n\nFor standalone Code Scanning or Secret Protection products, this parameter cannot be used.")),
"code_security": z.optional(z.object({
    "status": z.optional(z.string().describe("Can be `enabled` or `disabled`."))
    }).describe("Use the `status` property to enable or disable GitHub Code Security for this repository.")),
"secret_scanning": z.optional(z.object({
    "status": z.optional(z.string().describe("Can be `enabled` or `disabled`."))
    }).describe("Use the `status` property to enable or disable secret scanning for this repository. For more information, see \"[About secret scanning](/code-security/secret-security/about-secret-scanning).\"")),
"secret_scanning_push_protection": z.optional(z.object({
    "status": z.optional(z.string().describe("Can be `enabled` or `disabled`."))
    }).describe("Use the `status` property to enable or disable secret scanning push protection for this repository. For more information, see \"[Protecting pushes with secret scanning](/code-security/secret-scanning/protecting-pushes-with-secret-scanning).\"")),
"secret_scanning_ai_detection": z.optional(z.object({
    "status": z.optional(z.string().describe("Can be `enabled` or `disabled`."))
    }).describe("Use the `status` property to enable or disable secret scanning AI detection for this repository. For more information, see \"[Responsible detection of generic secrets with AI](https://docs.github.com/code-security/secret-scanning/using-advanced-secret-scanning-and-push-protection-features/generic-secret-detection/responsible-ai-generic-secrets).\"")),
"secret_scanning_non_provider_patterns": z.optional(z.object({
    "status": z.optional(z.string().describe("Can be `enabled` or `disabled`."))
    }).describe("Use the `status` property to enable or disable secret scanning non-provider patterns for this repository. For more information, see \"[Supported secret scanning patterns](/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets).\""))
    }).describe("Specify which security and analysis features to enable or disable for the repository.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"\n\nFor example, to enable GitHub Advanced Security, use this data in the body of the `PATCH` request:\n`{ \"security_and_analysis\": {\"advanced_security\": { \"status\": \"enabled\" } } }`.\n\nYou can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request.").nullish(),
"has_issues": z.optional(z.boolean().default(true).describe("Either `true` to enable issues for this repository or `false` to disable them.")),
"has_projects": z.optional(z.boolean().default(true).describe("Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.")),
"has_wiki": z.optional(z.boolean().default(true).describe("Either `true` to enable the wiki for this repository or `false` to disable it.")),
"is_template": z.optional(z.boolean().default(false).describe("Either `true` to make this repo available as a template repository or `false` to prevent it.")),
"default_branch": z.optional(z.string().describe("Updates the default branch for this repository.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.")),
"allow_auto_merge": z.optional(z.boolean().default(false).describe("Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.")),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.")),
"allow_update_branch": z.optional(z.boolean().default(false).describe("Either `true` to always allow a pull request head branch that is behind its base branch to be updated even if it is not required to be up to date before merging, or false otherwise.")),
"use_squash_pr_title_as_default": z.optional(z.boolean().default(false).describe("Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead.")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("Required when using `squash_merge_commit_message`.\n\nThe default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("Required when using `merge_commit_message`.\n\nThe default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"archived": z.optional(z.boolean().default(false).describe("Whether to archive this repository. `false` will unarchive a previously archived repository.")),
"allow_forking": z.optional(z.boolean().default(false).describe("Either `true` to allow private forks, or `false` to prevent private forks.")),
"web_commit_signoff_required": z.optional(z.boolean().default(false).describe("Either `true` to require contributors to sign off on web-based commits, or `false` to not require contributors to sign off on web-based commits."))
    })

export const reposUpdateMutationResponseSchema = reposUpdate200Schema

export const reposDeletePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposDelete204Schema = z.unknown()

/**
 * @description Temporary Redirect
 */
export const reposDelete307Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description If an organization owner has configured the organization to prevent members from deleting organization-owned repositories, a member will get this response:
 */
export const reposDelete403Schema = z.object({
    "message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

/**
 * @description Resource not found
 */
export const reposDelete404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const reposDelete409Schema = basicErrorSchema.describe("Basic Error")

export const reposDeleteMutationResponseSchema = reposDelete204Schema

export const actionsListArtifactsForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const actionsListArtifactsForRepoQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"name": z.optional(z.string().describe("The name field of an artifact. When specified, only artifacts with this name will be returned."))
    })

/**
 * @description Response
 */
export const actionsListArtifactsForRepo200Schema = z.object({
    "total_count": z.int(),
get "artifacts"(){
                return z.array(artifactSchema.describe("An artifact"))
              }
    })

export const actionsListArtifactsForRepoQueryResponseSchema = actionsListArtifactsForRepo200Schema

export const actionsGetArtifactPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"artifact_id": z.coerce.number().int().describe("The unique identifier of the artifact.")
    })

/**
 * @description Response
 */
export const actionsGetArtifact200Schema = artifactSchema.describe("An artifact")

export const actionsGetArtifactQueryResponseSchema = actionsGetArtifact200Schema

export const actionsDeleteArtifactPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"artifact_id": z.coerce.number().int().describe("The unique identifier of the artifact.")
    })

/**
 * @description Response
 */
export const actionsDeleteArtifact204Schema = z.unknown()

export const actionsDeleteArtifactMutationResponseSchema = actionsDeleteArtifact204Schema

export const actionsDownloadArtifactPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"artifact_id": z.coerce.number().int().describe("The unique identifier of the artifact."),
"archive_format": z.string()
    })

/**
 * @description Response
 */
export const actionsDownloadArtifact302Schema = z.unknown()

/**
 * @description Gone
 */
export const actionsDownloadArtifact410Schema = basicErrorSchema.describe("Basic Error")

export const actionsDownloadArtifactQueryResponseSchema = z.unknown()

export const actionsGetActionsCacheUsagePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetActionsCacheUsage200Schema = actionsCacheUsageByRepositorySchema.describe("GitHub Actions Cache Usage by repository.")

export const actionsGetActionsCacheUsageQueryResponseSchema = actionsGetActionsCacheUsage200Schema

export const actionsGetActionsCacheListPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const actionsGetActionsCacheListQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"ref": z.optional(z.string().describe("The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.")),
"key": z.optional(z.string().describe("An explicit key or prefix for identifying the cache")),
"sort": z.enum(["created_at", "last_accessed_at", "size_in_bytes"]).default("last_accessed_at").describe("The property to sort the results by. `created_at` means when the cache was created. `last_accessed_at` means when the cache was last accessed. `size_in_bytes` is the size of the cache in bytes."),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by.")
    })

/**
 * @description Response
 */
export const actionsGetActionsCacheList200Schema = actionsCacheListSchema.describe("Repository actions caches")

export const actionsGetActionsCacheListQueryResponseSchema = actionsGetActionsCacheList200Schema

export const actionsDeleteActionsCacheByKeyPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const actionsDeleteActionsCacheByKeyQueryParamsSchema = z.object({
    "key": z.string().describe("A key for identifying the cache."),
"ref": z.optional(z.string().describe("The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`."))
    })

/**
 * @description Response
 */
export const actionsDeleteActionsCacheByKey200Schema = actionsCacheListSchema.describe("Repository actions caches")

export const actionsDeleteActionsCacheByKeyMutationResponseSchema = actionsDeleteActionsCacheByKey200Schema

export const actionsDeleteActionsCacheByIdPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"cache_id": z.coerce.number().int().describe("The unique identifier of the GitHub Actions cache.")
    })

/**
 * @description Response
 */
export const actionsDeleteActionsCacheById204Schema = z.unknown()

export const actionsDeleteActionsCacheByIdMutationResponseSchema = actionsDeleteActionsCacheById204Schema

export const actionsGetJobForWorkflowRunPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"job_id": z.coerce.number().int().describe("The unique identifier of the job.")
    })

/**
 * @description Response
 */
export const actionsGetJobForWorkflowRun200Schema = jobSchema.describe("Information of a job execution in a workflow run")

export const actionsGetJobForWorkflowRunQueryResponseSchema = actionsGetJobForWorkflowRun200Schema

export const actionsDownloadJobLogsForWorkflowRunPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"job_id": z.coerce.number().int().describe("The unique identifier of the job.")
    })

/**
 * @description Response
 */
export const actionsDownloadJobLogsForWorkflowRun302Schema = z.unknown()

export const actionsDownloadJobLogsForWorkflowRunQueryResponseSchema = z.unknown()

export const actionsReRunJobForWorkflowRunPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"job_id": z.coerce.number().int().describe("The unique identifier of the job.")
    })

/**
 * @description Response
 */
export const actionsReRunJobForWorkflowRun201Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Forbidden
 */
export const actionsReRunJobForWorkflowRun403Schema = basicErrorSchema.describe("Basic Error")

export const actionsReRunJobForWorkflowRunMutationRequestSchema = z.object({
    "enable_debug_logging": z.optional(z.boolean().default(false).describe("Whether to enable debug logging for the re-run."))
    }).nullable()

export const actionsReRunJobForWorkflowRunMutationResponseSchema = actionsReRunJobForWorkflowRun201Schema

export const actionsGetCustomOidcSubClaimForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Status response
 */
export const actionsGetCustomOidcSubClaimForRepo200Schema = oidcCustomSubRepoSchema.describe("Actions OIDC subject customization for a repository")

/**
 * @description Bad Request
 */
export const actionsGetCustomOidcSubClaimForRepo400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const actionsGetCustomOidcSubClaimForRepo404Schema = basicErrorSchema.describe("Basic Error")

export const actionsGetCustomOidcSubClaimForRepoQueryResponseSchema = actionsGetCustomOidcSubClaimForRepo200Schema

export const actionsSetCustomOidcSubClaimForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Empty response
 */
export const actionsSetCustomOidcSubClaimForRepo201Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Bad Request
 */
export const actionsSetCustomOidcSubClaimForRepo400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const actionsSetCustomOidcSubClaimForRepo404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsSetCustomOidcSubClaimForRepo422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const actionsSetCustomOidcSubClaimForRepoMutationRequestSchema = z.object({
    "use_default": z.boolean().describe("Whether to use the default template or not. If `true`, the `include_claim_keys` field is ignored."),
"include_claim_keys": z.optional(z.array(z.string()).describe("Array of unique strings. Each claim key can only contain alphanumeric characters and underscores."))
    }).describe("Actions OIDC subject customization for a repository")

export const actionsSetCustomOidcSubClaimForRepoMutationResponseSchema = actionsSetCustomOidcSubClaimForRepo201Schema

export const actionsListRepoOrganizationSecretsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const actionsListRepoOrganizationSecretsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListRepoOrganizationSecrets200Schema = z.object({
    "total_count": z.int(),
get "secrets"(){
                return z.array(actionsSecretSchema.describe("Set secrets for GitHub Actions."))
              }
    })

export const actionsListRepoOrganizationSecretsQueryResponseSchema = actionsListRepoOrganizationSecrets200Schema

export const actionsListRepoOrganizationVariablesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const actionsListRepoOrganizationVariablesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(10).describe("The number of results per page (max 30). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListRepoOrganizationVariables200Schema = z.object({
    "total_count": z.int(),
get "variables"(){
                return z.array(actionsVariableSchema)
              }
    })

export const actionsListRepoOrganizationVariablesQueryResponseSchema = actionsListRepoOrganizationVariables200Schema

export const actionsGetGithubActionsPermissionsRepositoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetGithubActionsPermissionsRepository200Schema = actionsRepositoryPermissionsSchema

export const actionsGetGithubActionsPermissionsRepositoryQueryResponseSchema = actionsGetGithubActionsPermissionsRepository200Schema

export const actionsSetGithubActionsPermissionsRepositoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsSetGithubActionsPermissionsRepository204Schema = z.unknown()

export const actionsSetGithubActionsPermissionsRepositoryMutationRequestSchema = z.object({
    get "enabled"(){
                return actionsEnabledSchema.describe("Whether GitHub Actions is enabled on the repository.")
              },
get "allowed_actions"(){
                return allowedActionsSchema.describe("The permissions policy that controls the actions and reusable workflows that are allowed to run.").optional()
              },
get "sha_pinning_required"(){
                return shaPinningRequiredSchema.describe("Whether actions must be pinned to a full-length commit SHA.").optional()
              }
    })

export const actionsSetGithubActionsPermissionsRepositoryMutationResponseSchema = actionsSetGithubActionsPermissionsRepository204Schema

export const actionsGetWorkflowAccessToRepositoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetWorkflowAccessToRepository200Schema = actionsWorkflowAccessToRepositorySchema

export const actionsGetWorkflowAccessToRepositoryQueryResponseSchema = actionsGetWorkflowAccessToRepository200Schema

export const actionsSetWorkflowAccessToRepositoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsSetWorkflowAccessToRepository204Schema = z.unknown()

export const actionsSetWorkflowAccessToRepositoryMutationRequestSchema = actionsWorkflowAccessToRepositorySchema

export const actionsSetWorkflowAccessToRepositoryMutationResponseSchema = actionsSetWorkflowAccessToRepository204Schema

export const actionsGetArtifactAndLogRetentionSettingsRepositoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetArtifactAndLogRetentionSettingsRepository200Schema = actionsArtifactAndLogRetentionResponseSchema

/**
 * @description Resource not found
 */
export const actionsGetArtifactAndLogRetentionSettingsRepository404Schema = basicErrorSchema.describe("Basic Error")

export const actionsGetArtifactAndLogRetentionSettingsRepositoryQueryResponseSchema = actionsGetArtifactAndLogRetentionSettingsRepository200Schema

export const actionsSetArtifactAndLogRetentionSettingsRepositoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Empty response for successful settings update
 */
export const actionsSetArtifactAndLogRetentionSettingsRepository204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const actionsSetArtifactAndLogRetentionSettingsRepository404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsSetArtifactAndLogRetentionSettingsRepository422Schema = validationErrorSchema.describe("Validation Error")

export const actionsSetArtifactAndLogRetentionSettingsRepositoryMutationRequestSchema = actionsArtifactAndLogRetentionSchema

export const actionsSetArtifactAndLogRetentionSettingsRepositoryMutationResponseSchema = actionsSetArtifactAndLogRetentionSettingsRepository204Schema

export const actionsGetForkPrContributorApprovalPermissionsRepositoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetForkPrContributorApprovalPermissionsRepository200Schema = actionsForkPrContributorApprovalSchema

/**
 * @description Resource not found
 */
export const actionsGetForkPrContributorApprovalPermissionsRepository404Schema = basicErrorSchema.describe("Basic Error")

export const actionsGetForkPrContributorApprovalPermissionsRepositoryQueryResponseSchema = actionsGetForkPrContributorApprovalPermissionsRepository200Schema

export const actionsSetForkPrContributorApprovalPermissionsRepositoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsSetForkPrContributorApprovalPermissionsRepository204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const actionsSetForkPrContributorApprovalPermissionsRepository404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsSetForkPrContributorApprovalPermissionsRepository422Schema = validationErrorSchema.describe("Validation Error")

export const actionsSetForkPrContributorApprovalPermissionsRepositoryMutationRequestSchema = actionsForkPrContributorApprovalSchema

export const actionsSetForkPrContributorApprovalPermissionsRepositoryMutationResponseSchema = actionsSetForkPrContributorApprovalPermissionsRepository204Schema

export const actionsGetPrivateRepoForkPrWorkflowsSettingsRepositoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetPrivateRepoForkPrWorkflowsSettingsRepository200Schema = actionsForkPrWorkflowsPrivateReposSchema

/**
 * @description Forbidden
 */
export const actionsGetPrivateRepoForkPrWorkflowsSettingsRepository403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const actionsGetPrivateRepoForkPrWorkflowsSettingsRepository404Schema = basicErrorSchema.describe("Basic Error")

export const actionsGetPrivateRepoForkPrWorkflowsSettingsRepositoryQueryResponseSchema = actionsGetPrivateRepoForkPrWorkflowsSettingsRepository200Schema

export const actionsSetPrivateRepoForkPrWorkflowsSettingsRepositoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Empty response for successful settings update
 */
export const actionsSetPrivateRepoForkPrWorkflowsSettingsRepository204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const actionsSetPrivateRepoForkPrWorkflowsSettingsRepository404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsSetPrivateRepoForkPrWorkflowsSettingsRepository422Schema = validationErrorSchema.describe("Validation Error")

export const actionsSetPrivateRepoForkPrWorkflowsSettingsRepositoryMutationRequestSchema = actionsForkPrWorkflowsPrivateReposRequestSchema

export const actionsSetPrivateRepoForkPrWorkflowsSettingsRepositoryMutationResponseSchema = actionsSetPrivateRepoForkPrWorkflowsSettingsRepository204Schema

export const actionsGetAllowedActionsRepositoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetAllowedActionsRepository200Schema = selectedActionsSchema

export const actionsGetAllowedActionsRepositoryQueryResponseSchema = actionsGetAllowedActionsRepository200Schema

export const actionsSetAllowedActionsRepositoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsSetAllowedActionsRepository204Schema = z.unknown()

export const actionsSetAllowedActionsRepositoryMutationRequestSchema = selectedActionsSchema

export const actionsSetAllowedActionsRepositoryMutationResponseSchema = actionsSetAllowedActionsRepository204Schema

export const actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetGithubActionsDefaultWorkflowPermissionsRepository200Schema = actionsGetDefaultWorkflowPermissionsSchema

export const actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryQueryResponseSchema = actionsGetGithubActionsDefaultWorkflowPermissionsRepository200Schema

export const actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Success response
 */
export const actionsSetGithubActionsDefaultWorkflowPermissionsRepository204Schema = z.unknown()

/**
 * @description Conflict response when changing a setting is prevented by the owning organization
 */
export const actionsSetGithubActionsDefaultWorkflowPermissionsRepository409Schema = z.unknown()

export const actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryMutationRequestSchema = actionsSetDefaultWorkflowPermissionsSchema

export const actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryMutationResponseSchema = actionsSetGithubActionsDefaultWorkflowPermissionsRepository204Schema

export const actionsListSelfHostedRunnersForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const actionsListSelfHostedRunnersForRepoQueryParamsSchema = z.object({
    "name": z.optional(z.string().describe("The name of a self-hosted runner.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListSelfHostedRunnersForRepo200Schema = z.object({
    "total_count": z.int(),
get "runners"(){
                return z.array(runnerSchema.describe("A self hosted runner"))
              }
    })

export const actionsListSelfHostedRunnersForRepoQueryResponseSchema = actionsListSelfHostedRunnersForRepo200Schema

export const actionsListRunnerApplicationsForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsListRunnerApplicationsForRepo200Schema = z.array(runnerApplicationSchema.describe("Runner Application"))

export const actionsListRunnerApplicationsForRepoQueryResponseSchema = actionsListRunnerApplicationsForRepo200Schema

export const actionsGenerateRunnerJitconfigForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGenerateRunnerJitconfigForRepo201Schema = z.object({
    get "runner"(){
                return runnerSchema.describe("A self hosted runner")
              },
"encoded_jit_config": z.string().describe("The base64 encoded runner configuration.")
    })

/**
 * @description Resource not found
 */
export const actionsGenerateRunnerJitconfigForRepo404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const actionsGenerateRunnerJitconfigForRepo409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsGenerateRunnerJitconfigForRepo422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const actionsGenerateRunnerJitconfigForRepoMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the new runner."),
"runner_group_id": z.int().describe("The ID of the runner group to register the runner to."),
"labels": z.array(z.string()).min(1).max(100).describe("The names of the custom labels to add to the runner. **Minimum items**: 1. **Maximum items**: 100."),
"work_folder": z.optional(z.string().default("_work").describe("The working directory to be used for job execution, relative to the runner install directory."))
    })

export const actionsGenerateRunnerJitconfigForRepoMutationResponseSchema = actionsGenerateRunnerJitconfigForRepo201Schema

export const actionsCreateRegistrationTokenForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsCreateRegistrationTokenForRepo201Schema = authenticationTokenSchema.describe("Authentication Token")

export const actionsCreateRegistrationTokenForRepoMutationResponseSchema = actionsCreateRegistrationTokenForRepo201Schema

export const actionsCreateRemoveTokenForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsCreateRemoveTokenForRepo201Schema = authenticationTokenSchema.describe("Authentication Token")

export const actionsCreateRemoveTokenForRepoMutationResponseSchema = actionsCreateRemoveTokenForRepo201Schema

export const actionsGetSelfHostedRunnerForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"runner_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsGetSelfHostedRunnerForRepo200Schema = runnerSchema.describe("A self hosted runner")

export const actionsGetSelfHostedRunnerForRepoQueryResponseSchema = actionsGetSelfHostedRunnerForRepo200Schema

export const actionsDeleteSelfHostedRunnerFromRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"runner_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsDeleteSelfHostedRunnerFromRepo204Schema = z.unknown()

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsDeleteSelfHostedRunnerFromRepo422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const actionsDeleteSelfHostedRunnerFromRepoMutationResponseSchema = actionsDeleteSelfHostedRunnerFromRepo204Schema

export const actionsListLabelsForSelfHostedRunnerForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"runner_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsListLabelsForSelfHostedRunnerForRepo200Schema = z.object({
    "total_count": z.int(),
get "labels"(){
                return z.array(runnerLabelSchema.describe("A label for a self hosted runner"))
              }
    })

/**
 * @description Resource not found
 */
export const actionsListLabelsForSelfHostedRunnerForRepo404Schema = basicErrorSchema.describe("Basic Error")

export const actionsListLabelsForSelfHostedRunnerForRepoQueryResponseSchema = actionsListLabelsForSelfHostedRunnerForRepo200Schema

export const actionsAddCustomLabelsToSelfHostedRunnerForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"runner_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsAddCustomLabelsToSelfHostedRunnerForRepo200Schema = z.object({
    "total_count": z.int(),
get "labels"(){
                return z.array(runnerLabelSchema.describe("A label for a self hosted runner"))
              }
    })

/**
 * @description Resource not found
 */
export const actionsAddCustomLabelsToSelfHostedRunnerForRepo404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsAddCustomLabelsToSelfHostedRunnerForRepo422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const actionsAddCustomLabelsToSelfHostedRunnerForRepoMutationRequestSchema = z.object({
    "labels": z.array(z.string()).min(1).max(100).describe("The names of the custom labels to add to the runner.")
    })

export const actionsAddCustomLabelsToSelfHostedRunnerForRepoMutationResponseSchema = actionsAddCustomLabelsToSelfHostedRunnerForRepo200Schema

export const actionsSetCustomLabelsForSelfHostedRunnerForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"runner_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsSetCustomLabelsForSelfHostedRunnerForRepo200Schema = z.object({
    "total_count": z.int(),
get "labels"(){
                return z.array(runnerLabelSchema.describe("A label for a self hosted runner"))
              }
    })

/**
 * @description Resource not found
 */
export const actionsSetCustomLabelsForSelfHostedRunnerForRepo404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsSetCustomLabelsForSelfHostedRunnerForRepo422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const actionsSetCustomLabelsForSelfHostedRunnerForRepoMutationRequestSchema = z.object({
    "labels": z.array(z.string()).min(0).max(100).describe("The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.")
    })

export const actionsSetCustomLabelsForSelfHostedRunnerForRepoMutationResponseSchema = actionsSetCustomLabelsForSelfHostedRunnerForRepo200Schema

export const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"runner_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner.")
    })

/**
 * @description Response
 */
export const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo200Schema = z.object({
    "total_count": z.int(),
get "labels"(){
                return z.array(runnerLabelSchema.describe("A label for a self hosted runner"))
              }
    })

/**
 * @description Resource not found
 */
export const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo404Schema = basicErrorSchema.describe("Basic Error")

export const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoMutationResponseSchema = actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo200Schema

export const actionsRemoveCustomLabelFromSelfHostedRunnerForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"runner_id": z.coerce.number().int().describe("Unique identifier of the self-hosted runner."),
"name": z.string().describe("The name of a self-hosted runner's custom label.")
    })

/**
 * @description Response
 */
export const actionsRemoveCustomLabelFromSelfHostedRunnerForRepo200Schema = z.object({
    "total_count": z.int(),
get "labels"(){
                return z.array(runnerLabelSchema.describe("A label for a self hosted runner"))
              }
    })

/**
 * @description Resource not found
 */
export const actionsRemoveCustomLabelFromSelfHostedRunnerForRepo404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const actionsRemoveCustomLabelFromSelfHostedRunnerForRepo422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const actionsRemoveCustomLabelFromSelfHostedRunnerForRepoMutationResponseSchema = actionsRemoveCustomLabelFromSelfHostedRunnerForRepo200Schema

export const actionsListWorkflowRunsForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const actionsListWorkflowRunsForRepoQueryParamsSchema = z.object({
    "actor": z.optional(z.string().describe("Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run.")),
"branch": z.optional(z.string().describe("Returns workflow runs associated with a branch. Use the name of the branch of the `push`.")),
"event": z.optional(z.string().describe("Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see \"[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\"")),
"status": z.optional(z.enum(["completed", "action_required", "cancelled", "failure", "neutral", "skipped", "stale", "success", "timed_out", "in_progress", "queued", "requested", "waiting", "pending"]).describe("Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"created": z.optional(z.iso.datetime({ offset: true }).describe("Returns workflow runs created within the given date-time range. For more information on the syntax, see \"[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\"")),
"exclude_pull_requests": z.boolean().default(false).describe("If `true` pull requests are omitted from the response (empty array)."),
"check_suite_id": z.optional(z.coerce.number().int().describe("Returns workflow runs with the `check_suite_id` that you specify.")),
"head_sha": z.optional(z.string().describe("Only returns workflow runs that are associated with the specified `head_sha`."))
    })

/**
 * @description Response
 */
export const actionsListWorkflowRunsForRepo200Schema = z.object({
    "total_count": z.int(),
get "workflow_runs"(){
                return z.array(workflowRunSchema.describe("An invocation of a workflow"))
              }
    })

export const actionsListWorkflowRunsForRepoQueryResponseSchema = actionsListWorkflowRunsForRepo200Schema

export const actionsGetWorkflowRunPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run.")
    })

export const actionsGetWorkflowRunQueryParamsSchema = z.object({
    "exclude_pull_requests": z.boolean().default(false).describe("If `true` pull requests are omitted from the response (empty array).")
    })

/**
 * @description Response
 */
export const actionsGetWorkflowRun200Schema = workflowRunSchema.describe("An invocation of a workflow")

export const actionsGetWorkflowRunQueryResponseSchema = actionsGetWorkflowRun200Schema

export const actionsDeleteWorkflowRunPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run.")
    })

/**
 * @description Response
 */
export const actionsDeleteWorkflowRun204Schema = z.unknown()

export const actionsDeleteWorkflowRunMutationResponseSchema = actionsDeleteWorkflowRun204Schema

export const actionsGetReviewsForRunPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run.")
    })

/**
 * @description Response
 */
export const actionsGetReviewsForRun200Schema = z.array(environmentApprovalsSchema.describe("An entry in the reviews log for environment deployments"))

export const actionsGetReviewsForRunQueryResponseSchema = actionsGetReviewsForRun200Schema

export const actionsApproveWorkflowRunPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run.")
    })

/**
 * @description Response
 */
export const actionsApproveWorkflowRun201Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Forbidden
 */
export const actionsApproveWorkflowRun403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const actionsApproveWorkflowRun404Schema = basicErrorSchema.describe("Basic Error")

export const actionsApproveWorkflowRunMutationResponseSchema = actionsApproveWorkflowRun201Schema

export const actionsListWorkflowRunArtifactsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run.")
    })

export const actionsListWorkflowRunArtifactsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"name": z.optional(z.string().describe("The name field of an artifact. When specified, only artifacts with this name will be returned."))
    })

/**
 * @description Response
 */
export const actionsListWorkflowRunArtifacts200Schema = z.object({
    "total_count": z.int(),
get "artifacts"(){
                return z.array(artifactSchema.describe("An artifact"))
              }
    })

export const actionsListWorkflowRunArtifactsQueryResponseSchema = actionsListWorkflowRunArtifacts200Schema

export const actionsGetWorkflowRunAttemptPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run."),
"attempt_number": z.coerce.number().int().describe("The attempt number of the workflow run.")
    })

export const actionsGetWorkflowRunAttemptQueryParamsSchema = z.object({
    "exclude_pull_requests": z.boolean().default(false).describe("If `true` pull requests are omitted from the response (empty array).")
    })

/**
 * @description Response
 */
export const actionsGetWorkflowRunAttempt200Schema = workflowRunSchema.describe("An invocation of a workflow")

export const actionsGetWorkflowRunAttemptQueryResponseSchema = actionsGetWorkflowRunAttempt200Schema

export const actionsListJobsForWorkflowRunAttemptPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run."),
"attempt_number": z.coerce.number().int().describe("The attempt number of the workflow run.")
    })

export const actionsListJobsForWorkflowRunAttemptQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListJobsForWorkflowRunAttempt200Schema = z.object({
    "total_count": z.int(),
get "jobs"(){
                return z.array(jobSchema.describe("Information of a job execution in a workflow run"))
              }
    })

/**
 * @description Resource not found
 */
export const actionsListJobsForWorkflowRunAttempt404Schema = basicErrorSchema.describe("Basic Error")

export const actionsListJobsForWorkflowRunAttemptQueryResponseSchema = actionsListJobsForWorkflowRunAttempt200Schema

export const actionsDownloadWorkflowRunAttemptLogsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run."),
"attempt_number": z.coerce.number().int().describe("The attempt number of the workflow run.")
    })

/**
 * @description Response
 */
export const actionsDownloadWorkflowRunAttemptLogs302Schema = z.unknown()

export const actionsDownloadWorkflowRunAttemptLogsQueryResponseSchema = z.unknown()

export const actionsCancelWorkflowRunPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run.")
    })

/**
 * @description Response
 */
export const actionsCancelWorkflowRun202Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Conflict
 */
export const actionsCancelWorkflowRun409Schema = basicErrorSchema.describe("Basic Error")

export const actionsCancelWorkflowRunMutationResponseSchema = actionsCancelWorkflowRun202Schema

export const actionsReviewCustomGatesForRunPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run.")
    })

/**
 * @description Response
 */
export const actionsReviewCustomGatesForRun204Schema = z.unknown()

export const actionsReviewCustomGatesForRunMutationRequestSchema = z.union([reviewCustomGatesCommentRequiredSchema, reviewCustomGatesStateRequiredSchema])

export const actionsReviewCustomGatesForRunMutationResponseSchema = actionsReviewCustomGatesForRun204Schema

export const actionsForceCancelWorkflowRunPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run.")
    })

/**
 * @description Response
 */
export const actionsForceCancelWorkflowRun202Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Conflict
 */
export const actionsForceCancelWorkflowRun409Schema = basicErrorSchema.describe("Basic Error")

export const actionsForceCancelWorkflowRunMutationResponseSchema = actionsForceCancelWorkflowRun202Schema

export const actionsListJobsForWorkflowRunPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run.")
    })

export const actionsListJobsForWorkflowRunQueryParamsSchema = z.object({
    "filter": z.enum(["latest", "all"]).default("latest").describe("Filters jobs by their `completed_at` timestamp. `latest` returns jobs from the most recent execution of the workflow run. `all` returns all jobs for a workflow run, including from old executions of the workflow run."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListJobsForWorkflowRun200Schema = z.object({
    "total_count": z.int(),
get "jobs"(){
                return z.array(jobSchema.describe("Information of a job execution in a workflow run"))
              }
    })

export const actionsListJobsForWorkflowRunQueryResponseSchema = actionsListJobsForWorkflowRun200Schema

export const actionsDownloadWorkflowRunLogsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run.")
    })

/**
 * @description Response
 */
export const actionsDownloadWorkflowRunLogs302Schema = z.unknown()

export const actionsDownloadWorkflowRunLogsQueryResponseSchema = z.unknown()

export const actionsDeleteWorkflowRunLogsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run.")
    })

/**
 * @description Response
 */
export const actionsDeleteWorkflowRunLogs204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const actionsDeleteWorkflowRunLogs403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const actionsDeleteWorkflowRunLogs500Schema = basicErrorSchema.describe("Basic Error")

export const actionsDeleteWorkflowRunLogsMutationResponseSchema = actionsDeleteWorkflowRunLogs204Schema

export const actionsGetPendingDeploymentsForRunPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run.")
    })

/**
 * @description Response
 */
export const actionsGetPendingDeploymentsForRun200Schema = z.array(pendingDeploymentSchema.describe("Details of a deployment that is waiting for protection rules to pass"))

export const actionsGetPendingDeploymentsForRunQueryResponseSchema = actionsGetPendingDeploymentsForRun200Schema

export const actionsReviewPendingDeploymentsForRunPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run.")
    })

/**
 * @description Response
 */
export const actionsReviewPendingDeploymentsForRun200Schema = z.array(deploymentSchema.describe("A request for a specific ref(branch,sha,tag) to be deployed"))

export const actionsReviewPendingDeploymentsForRunMutationRequestSchema = z.object({
    "environment_ids": z.array(z.int()).describe("The list of environment ids to approve or reject"),
"state": z.enum(["approved", "rejected"]).describe("Whether to approve or reject deployment to the specified environments."),
"comment": z.string().describe("A comment to accompany the deployment review")
    })

export const actionsReviewPendingDeploymentsForRunMutationResponseSchema = actionsReviewPendingDeploymentsForRun200Schema

export const actionsReRunWorkflowPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run.")
    })

/**
 * @description Response
 */
export const actionsReRunWorkflow201Schema = emptyObjectSchema.describe("An object without any properties.")

export const actionsReRunWorkflowMutationRequestSchema = z.object({
    "enable_debug_logging": z.optional(z.boolean().default(false).describe("Whether to enable debug logging for the re-run."))
    }).nullable()

export const actionsReRunWorkflowMutationResponseSchema = actionsReRunWorkflow201Schema

export const actionsReRunWorkflowFailedJobsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run.")
    })

/**
 * @description Response
 */
export const actionsReRunWorkflowFailedJobs201Schema = emptyObjectSchema.describe("An object without any properties.")

export const actionsReRunWorkflowFailedJobsMutationRequestSchema = z.object({
    "enable_debug_logging": z.optional(z.boolean().default(false).describe("Whether to enable debug logging for the re-run."))
    }).nullable()

export const actionsReRunWorkflowFailedJobsMutationResponseSchema = actionsReRunWorkflowFailedJobs201Schema

export const actionsGetWorkflowRunUsagePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"run_id": z.coerce.number().int().describe("The unique identifier of the workflow run.")
    })

/**
 * @description Response
 */
export const actionsGetWorkflowRunUsage200Schema = workflowRunUsageSchema.describe("Workflow Run Usage")

export const actionsGetWorkflowRunUsageQueryResponseSchema = actionsGetWorkflowRunUsage200Schema

export const actionsListRepoSecretsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const actionsListRepoSecretsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListRepoSecrets200Schema = z.object({
    "total_count": z.int(),
get "secrets"(){
                return z.array(actionsSecretSchema.describe("Set secrets for GitHub Actions."))
              }
    })

export const actionsListRepoSecretsQueryResponseSchema = actionsListRepoSecrets200Schema

export const actionsGetRepoPublicKeyPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsGetRepoPublicKey200Schema = actionsPublicKeySchema.describe("The public key used for setting Actions Secrets.")

export const actionsGetRepoPublicKeyQueryResponseSchema = actionsGetRepoPublicKey200Schema

export const actionsGetRepoSecretPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const actionsGetRepoSecret200Schema = actionsSecretSchema.describe("Set secrets for GitHub Actions.")

export const actionsGetRepoSecretQueryResponseSchema = actionsGetRepoSecret200Schema

export const actionsCreateOrUpdateRepoSecretPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response when creating a secret
 */
export const actionsCreateOrUpdateRepoSecret201Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Response when updating a secret
 */
export const actionsCreateOrUpdateRepoSecret204Schema = z.unknown()

export const actionsCreateOrUpdateRepoSecretMutationRequestSchema = z.object({
    "encrypted_value": z.string().regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$/).describe("Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/actions/secrets#get-a-repository-public-key) endpoint."),
"key_id": z.string().describe("ID of the key you used to encrypt the secret.")
    })

export const actionsCreateOrUpdateRepoSecretMutationResponseSchema = z.union([actionsCreateOrUpdateRepoSecret201Schema, actionsCreateOrUpdateRepoSecret204Schema])

export const actionsDeleteRepoSecretPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const actionsDeleteRepoSecret204Schema = z.unknown()

export const actionsDeleteRepoSecretMutationResponseSchema = actionsDeleteRepoSecret204Schema

export const actionsListRepoVariablesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const actionsListRepoVariablesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(10).describe("The number of results per page (max 30). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListRepoVariables200Schema = z.object({
    "total_count": z.int(),
get "variables"(){
                return z.array(actionsVariableSchema)
              }
    })

export const actionsListRepoVariablesQueryResponseSchema = actionsListRepoVariables200Schema

export const actionsCreateRepoVariablePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const actionsCreateRepoVariable201Schema = emptyObjectSchema.describe("An object without any properties.")

export const actionsCreateRepoVariableMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the variable."),
"value": z.string().describe("The value of the variable.")
    })

export const actionsCreateRepoVariableMutationResponseSchema = actionsCreateRepoVariable201Schema

export const actionsGetRepoVariablePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"name": z.string().describe("The name of the variable.")
    })

/**
 * @description Response
 */
export const actionsGetRepoVariable200Schema = actionsVariableSchema

export const actionsGetRepoVariableQueryResponseSchema = actionsGetRepoVariable200Schema

export const actionsUpdateRepoVariablePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"name": z.string().describe("The name of the variable.")
    })

/**
 * @description Response
 */
export const actionsUpdateRepoVariable204Schema = z.unknown()

export const actionsUpdateRepoVariableMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("The name of the variable.")),
"value": z.optional(z.string().describe("The value of the variable."))
    })

export const actionsUpdateRepoVariableMutationResponseSchema = actionsUpdateRepoVariable204Schema

export const actionsDeleteRepoVariablePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"name": z.string().describe("The name of the variable.")
    })

/**
 * @description Response
 */
export const actionsDeleteRepoVariable204Schema = z.unknown()

export const actionsDeleteRepoVariableMutationResponseSchema = actionsDeleteRepoVariable204Schema

export const actionsListRepoWorkflowsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const actionsListRepoWorkflowsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListRepoWorkflows200Schema = z.object({
    "total_count": z.int(),
get "workflows"(){
                return z.array(workflowSchema.describe("A GitHub Actions workflow"))
              }
    })

export const actionsListRepoWorkflowsQueryResponseSchema = actionsListRepoWorkflows200Schema

export const actionsGetWorkflowPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"workflow_id": z.union([z.coerce.number().int(), z.string()]).describe("The ID of the workflow. You can also pass the workflow file name as a string.")
    })

/**
 * @description Response
 */
export const actionsGetWorkflow200Schema = workflowSchema.describe("A GitHub Actions workflow")

export const actionsGetWorkflowQueryResponseSchema = actionsGetWorkflow200Schema

export const actionsDisableWorkflowPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"workflow_id": z.union([z.coerce.number().int(), z.string()]).describe("The ID of the workflow. You can also pass the workflow file name as a string.")
    })

/**
 * @description Response
 */
export const actionsDisableWorkflow204Schema = z.unknown()

export const actionsDisableWorkflowMutationResponseSchema = actionsDisableWorkflow204Schema

export const actionsCreateWorkflowDispatchPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"workflow_id": z.union([z.coerce.number().int(), z.string()]).describe("The ID of the workflow. You can also pass the workflow file name as a string.")
    })

/**
 * @description Response
 */
export const actionsCreateWorkflowDispatch204Schema = z.unknown()

export const actionsCreateWorkflowDispatchMutationRequestSchema = z.object({
    "ref": z.string().describe("The git reference for the workflow. The reference can be a branch or tag name."),
"inputs": z.optional(z.object({
    
    }).catchall(z.unknown()).describe("Input keys and values configured in the workflow file. The maximum number of properties is 10. Any default properties configured in the workflow file will be used when `inputs` are omitted."))
    })

export const actionsCreateWorkflowDispatchMutationResponseSchema = actionsCreateWorkflowDispatch204Schema

export const actionsEnableWorkflowPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"workflow_id": z.union([z.coerce.number().int(), z.string()]).describe("The ID of the workflow. You can also pass the workflow file name as a string.")
    })

/**
 * @description Response
 */
export const actionsEnableWorkflow204Schema = z.unknown()

export const actionsEnableWorkflowMutationResponseSchema = actionsEnableWorkflow204Schema

export const actionsListWorkflowRunsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"workflow_id": z.union([z.coerce.number().int(), z.string()]).describe("The ID of the workflow. You can also pass the workflow file name as a string.")
    })

export const actionsListWorkflowRunsQueryParamsSchema = z.object({
    "actor": z.optional(z.string().describe("Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run.")),
"branch": z.optional(z.string().describe("Returns workflow runs associated with a branch. Use the name of the branch of the `push`.")),
"event": z.optional(z.string().describe("Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see \"[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\"")),
"status": z.optional(z.enum(["completed", "action_required", "cancelled", "failure", "neutral", "skipped", "stale", "success", "timed_out", "in_progress", "queued", "requested", "waiting", "pending"]).describe("Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"created": z.optional(z.iso.datetime({ offset: true }).describe("Returns workflow runs created within the given date-time range. For more information on the syntax, see \"[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\"")),
"exclude_pull_requests": z.boolean().default(false).describe("If `true` pull requests are omitted from the response (empty array)."),
"check_suite_id": z.optional(z.coerce.number().int().describe("Returns workflow runs with the `check_suite_id` that you specify.")),
"head_sha": z.optional(z.string().describe("Only returns workflow runs that are associated with the specified `head_sha`."))
    })

/**
 * @description Response
 */
export const actionsListWorkflowRuns200Schema = z.object({
    "total_count": z.int(),
get "workflow_runs"(){
                return z.array(workflowRunSchema.describe("An invocation of a workflow"))
              }
    })

export const actionsListWorkflowRunsQueryResponseSchema = actionsListWorkflowRuns200Schema

export const actionsGetWorkflowUsagePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"workflow_id": z.union([z.coerce.number().int(), z.string()]).describe("The ID of the workflow. You can also pass the workflow file name as a string.")
    })

/**
 * @description Response
 */
export const actionsGetWorkflowUsage200Schema = workflowUsageSchema.describe("Workflow Usage")

export const actionsGetWorkflowUsageQueryResponseSchema = actionsGetWorkflowUsage200Schema

export const reposListActivitiesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposListActivitiesQueryParamsSchema = z.object({
    "direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"ref": z.optional(z.string().describe("The Git reference for the activities you want to list.\n\nThe `ref` for a branch can be formatted either as `refs/heads/BRANCH_NAME` or `BRANCH_NAME`, where `BRANCH_NAME` is the name of your branch.")),
"actor": z.optional(z.string().describe("The GitHub username to use to filter by the actor who performed the activity.")),
"time_period": z.optional(z.enum(["day", "week", "month", "quarter", "year"]).describe("The time period to filter by.\n\nFor example, `day` will filter for activity that occurred in the past 24 hours, and `week` will filter for activity that occurred in the past 7 days (168 hours).")),
"activity_type": z.optional(z.enum(["push", "force_push", "branch_creation", "branch_deletion", "pr_merge", "merge_queue_merge"]).describe("The activity type to filter by.\n\nFor example, you can choose to filter by \"force_push\", to see all force pushes to the repository."))
    })

/**
 * @description Response
 */
export const reposListActivities200Schema = z.array(activitySchema.describe("Activity"))

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposListActivities422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const reposListActivitiesQueryResponseSchema = reposListActivities200Schema

export const issuesListAssigneesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const issuesListAssigneesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesListAssignees200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

/**
 * @description Resource not found
 */
export const issuesListAssignees404Schema = basicErrorSchema.describe("Basic Error")

export const issuesListAssigneesQueryResponseSchema = issuesListAssignees200Schema

export const issuesCheckUserCanBeAssignedPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"assignee": z.string()
    })

/**
 * @description If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.
 */
export const issuesCheckUserCanBeAssigned204Schema = z.unknown()

/**
 * @description Otherwise a `404` status code is returned.
 */
export const issuesCheckUserCanBeAssigned404Schema = basicErrorSchema.describe("Basic Error")

export const issuesCheckUserCanBeAssignedQueryResponseSchema = issuesCheckUserCanBeAssigned204Schema

export const reposCreateAttestationPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description response
 */
export const reposCreateAttestation201Schema = z.object({
    "id": z.optional(z.int().describe("The ID of the attestation."))
    })

/**
 * @description Forbidden
 */
export const reposCreateAttestation403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposCreateAttestation422Schema = validationErrorSchema.describe("Validation Error")

export const reposCreateAttestationMutationRequestSchema = z.object({
    "bundle": z.object({
    "mediaType": z.optional(z.string()),
"verificationMaterial": z.optional(z.object({
    
    }).catchall(z.unknown())),
"dsseEnvelope": z.optional(z.object({
    
    }).catchall(z.unknown()))
    }).describe("The attestation's Sigstore Bundle.\nRefer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information.")
    })

export const reposCreateAttestationMutationResponseSchema = reposCreateAttestation201Schema

export const reposListAttestationsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"subject_digest": z.string().describe("The parameter should be set to the attestation's subject's SHA256 digest, in the form `sha256:HEX_DIGEST`.")
    })

export const reposListAttestationsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"predicate_type": z.optional(z.string().describe("Optional filter for fetching attestations with a given predicate type.\nThis option accepts `provenance`, `sbom`, `release`, or freeform text\nfor custom predicate types."))
    })

/**
 * @description Response
 */
export const reposListAttestations200Schema = z.object({
    "attestations": z.optional(z.array(z.object({
    "bundle": z.optional(z.object({
    "mediaType": z.optional(z.string()),
"verificationMaterial": z.optional(z.object({
    
    }).catchall(z.unknown())),
"dsseEnvelope": z.optional(z.object({
    
    }).catchall(z.unknown()))
    }).describe("The attestation's Sigstore Bundle.\nRefer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information.")),
"repository_id": z.optional(z.int()),
"bundle_url": z.optional(z.string()),
"initiator": z.optional(z.string())
    })))
    })

export const reposListAttestationsQueryResponseSchema = reposListAttestations200Schema

export const reposListAutolinksPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposListAutolinks200Schema = z.array(autolinkSchema.describe("An autolink reference."))

export const reposListAutolinksQueryResponseSchema = reposListAutolinks200Schema

export const reposCreateAutolinkPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description response
 */
export const reposCreateAutolink201Schema = autolinkSchema.describe("An autolink reference.")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposCreateAutolink422Schema = validationErrorSchema.describe("Validation Error")

export const reposCreateAutolinkMutationRequestSchema = z.object({
    "key_prefix": z.string().describe("This prefix appended by certain characters will generate a link any time it is found in an issue, pull request, or commit."),
"url_template": z.string().describe("The URL must contain `<num>` for the reference number. `<num>` matches different characters depending on the value of `is_alphanumeric`."),
"is_alphanumeric": z.optional(z.boolean().default(true).describe("Whether this autolink reference matches alphanumeric characters. If true, the `<num>` parameter of the `url_template` matches alphanumeric characters `A-Z` (case insensitive), `0-9`, and `-`. If false, this autolink reference only matches numeric characters."))
    })

export const reposCreateAutolinkMutationResponseSchema = reposCreateAutolink201Schema

export const reposGetAutolinkPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"autolink_id": z.coerce.number().int().describe("The unique identifier of the autolink.")
    })

/**
 * @description Response
 */
export const reposGetAutolink200Schema = autolinkSchema.describe("An autolink reference.")

/**
 * @description Resource not found
 */
export const reposGetAutolink404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetAutolinkQueryResponseSchema = reposGetAutolink200Schema

export const reposDeleteAutolinkPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"autolink_id": z.coerce.number().int().describe("The unique identifier of the autolink.")
    })

/**
 * @description Response
 */
export const reposDeleteAutolink204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposDeleteAutolink404Schema = basicErrorSchema.describe("Basic Error")

export const reposDeleteAutolinkMutationResponseSchema = reposDeleteAutolink204Schema

export const reposCheckAutomatedSecurityFixesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response if Dependabot is enabled
 */
export const reposCheckAutomatedSecurityFixes200Schema = checkAutomatedSecurityFixesSchema.describe("Check Dependabot security updates")

/**
 * @description Not Found if Dependabot is not enabled for the repository
 */
export const reposCheckAutomatedSecurityFixes404Schema = z.unknown()

export const reposCheckAutomatedSecurityFixesQueryResponseSchema = reposCheckAutomatedSecurityFixes200Schema

export const reposEnableAutomatedSecurityFixesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposEnableAutomatedSecurityFixes204Schema = z.unknown()

export const reposEnableAutomatedSecurityFixesMutationResponseSchema = reposEnableAutomatedSecurityFixes204Schema

export const reposDisableAutomatedSecurityFixesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposDisableAutomatedSecurityFixes204Schema = z.unknown()

export const reposDisableAutomatedSecurityFixesMutationResponseSchema = reposDisableAutomatedSecurityFixes204Schema

export const reposListBranchesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposListBranchesQueryParamsSchema = z.object({
    "protected": z.optional(z.boolean().describe("Setting to `true` returns only branches protected by branch protections or rulesets. When set to `false`, only unprotected branches are returned. Omitting this parameter returns all branches.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListBranches200Schema = z.array(shortBranchSchema.describe("Short Branch"))

/**
 * @description Resource not found
 */
export const reposListBranches404Schema = basicErrorSchema.describe("Basic Error")

export const reposListBranchesQueryResponseSchema = reposListBranches200Schema

export const reposGetBranchPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposGetBranch200Schema = branchWithProtectionSchema.describe("Branch With Protection")

/**
 * @description Moved permanently
 */
export const reposGetBranch301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposGetBranch404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetBranchQueryResponseSchema = reposGetBranch200Schema

export const reposGetBranchProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposGetBranchProtection200Schema = branchProtectionSchema.describe("Branch Protection")

/**
 * @description Resource not found
 */
export const reposGetBranchProtection404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetBranchProtectionQueryResponseSchema = reposGetBranchProtection200Schema

export const reposUpdateBranchProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposUpdateBranchProtection200Schema = protectedBranchSchema.describe("Branch protections protect branches")

/**
 * @description Forbidden
 */
export const reposUpdateBranchProtection403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposUpdateBranchProtection404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposUpdateBranchProtection422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const reposUpdateBranchProtectionMutationRequestSchema = z.object({
    "required_status_checks": z.nullable(z.object({
    "strict": z.boolean().describe("Require branches to be up to date before merging."),
"contexts": z.array(z.string()).describe("**Closing down notice**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control."),
"checks": z.optional(z.array(z.object({
    "context": z.string().describe("The name of the required check"),
"app_id": z.optional(z.int().describe("The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status."))
    })).describe("The list of status checks to require in order to merge into this branch."))
    }).describe("Require status checks to pass before merging. Set to `null` to disable.")),
"enforce_admins": z.nullable(z.boolean().describe("Enforce all configured restrictions for administrators. Set to `true` to enforce required status checks for repository administrators. Set to `null` to disable.")),
"required_pull_request_reviews": z.nullable(z.object({
    "dismissal_restrictions": z.optional(z.object({
    "users": z.optional(z.array(z.string()).describe("The list of user `login`s with dismissal access")),
"teams": z.optional(z.array(z.string()).describe("The list of team `slug`s with dismissal access")),
"apps": z.optional(z.array(z.string()).describe("The list of app `slug`s with dismissal access"))
    }).describe("Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.")),
"dismiss_stale_reviews": z.optional(z.boolean().describe("Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.")),
"require_code_owner_reviews": z.optional(z.boolean().describe("Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) review them.")),
"required_approving_review_count": z.optional(z.int().describe("Specify the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.")),
"require_last_push_approval": z.optional(z.boolean().default(false).describe("Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`.")),
"bypass_pull_request_allowances": z.optional(z.object({
    "users": z.optional(z.array(z.string()).describe("The list of user `login`s allowed to bypass pull request requirements.")),
"teams": z.optional(z.array(z.string()).describe("The list of team `slug`s allowed to bypass pull request requirements.")),
"apps": z.optional(z.array(z.string()).describe("The list of app `slug`s allowed to bypass pull request requirements."))
    }).describe("Allow specific users, teams, or apps to bypass pull request requirements."))
    }).describe("Require at least one approving review on a pull request, before merging. Set to `null` to disable.")),
"restrictions": z.nullable(z.object({
    "users": z.array(z.string()).describe("The list of user `login`s with push access"),
"teams": z.array(z.string()).describe("The list of team `slug`s with push access"),
"apps": z.optional(z.array(z.string()).describe("The list of app `slug`s with push access"))
    }).describe("Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.")),
"required_linear_history": z.optional(z.boolean().describe("Enforces a linear commit Git history, which prevents anyone from pushing merge commits to a branch. Set to `true` to enforce a linear commit history. Set to `false` to disable a linear commit Git history. Your repository must allow squash merging or rebase merging before you can enable a linear commit history. Default: `false`. For more information, see \"[Requiring a linear commit history](https://docs.github.com/github/administering-a-repository/requiring-a-linear-commit-history)\" in the GitHub Help documentation.")),
"allow_force_pushes": z.boolean().describe("Permits force pushes to the protected branch by anyone with write access to the repository. Set to `true` to allow force pushes. Set to `false` or `null` to block force pushes. Default: `false`. For more information, see \"[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)\" in the GitHub Help documentation.\"").nullish(),
"allow_deletions": z.optional(z.boolean().describe("Allows deletion of the protected branch by anyone with write access to the repository. Set to `false` to prevent deletion of the protected branch. Default: `false`. For more information, see \"[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)\" in the GitHub Help documentation.")),
"block_creations": z.optional(z.boolean().describe("If set to `true`, the `restrictions` branch protection settings which limits who can push will also block pushes which create new branches, unless the push is initiated by a user, team, or app which has the ability to push. Set to `true` to restrict new branch creation. Default: `false`.")),
"required_conversation_resolution": z.optional(z.boolean().describe("Requires all conversations on code to be resolved before a pull request can be merged into a branch that matches this rule. Set to `false` to disable. Default: `false`.")),
"lock_branch": z.optional(z.boolean().default(false).describe("Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. Default: `false`.")),
"allow_fork_syncing": z.optional(z.boolean().default(false).describe("Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing. Default: `false`."))
    })

export const reposUpdateBranchProtectionMutationResponseSchema = reposUpdateBranchProtection200Schema

export const reposDeleteBranchProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposDeleteBranchProtection204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const reposDeleteBranchProtection403Schema = basicErrorSchema.describe("Basic Error")

export const reposDeleteBranchProtectionMutationResponseSchema = reposDeleteBranchProtection204Schema

export const reposGetAdminBranchProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposGetAdminBranchProtection200Schema = protectedBranchAdminEnforcedSchema.describe("Protected Branch Admin Enforced")

export const reposGetAdminBranchProtectionQueryResponseSchema = reposGetAdminBranchProtection200Schema

export const reposSetAdminBranchProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposSetAdminBranchProtection200Schema = protectedBranchAdminEnforcedSchema.describe("Protected Branch Admin Enforced")

export const reposSetAdminBranchProtectionMutationResponseSchema = reposSetAdminBranchProtection200Schema

export const reposDeleteAdminBranchProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposDeleteAdminBranchProtection204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposDeleteAdminBranchProtection404Schema = basicErrorSchema.describe("Basic Error")

export const reposDeleteAdminBranchProtectionMutationResponseSchema = reposDeleteAdminBranchProtection204Schema

export const reposGetPullRequestReviewProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposGetPullRequestReviewProtection200Schema = protectedBranchPullRequestReviewSchema.describe("Protected Branch Pull Request Review")

export const reposGetPullRequestReviewProtectionQueryResponseSchema = reposGetPullRequestReviewProtection200Schema

export const reposUpdatePullRequestReviewProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposUpdatePullRequestReviewProtection200Schema = protectedBranchPullRequestReviewSchema.describe("Protected Branch Pull Request Review")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposUpdatePullRequestReviewProtection422Schema = validationErrorSchema.describe("Validation Error")

export const reposUpdatePullRequestReviewProtectionMutationRequestSchema = z.object({
    "dismissal_restrictions": z.optional(z.object({
    "users": z.optional(z.array(z.string()).describe("The list of user `login`s with dismissal access")),
"teams": z.optional(z.array(z.string()).describe("The list of team `slug`s with dismissal access")),
"apps": z.optional(z.array(z.string()).describe("The list of app `slug`s with dismissal access"))
    }).describe("Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.")),
"dismiss_stale_reviews": z.optional(z.boolean().describe("Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.")),
"require_code_owner_reviews": z.optional(z.boolean().describe("Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) have reviewed.")),
"required_approving_review_count": z.optional(z.int().describe("Specifies the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.")),
"require_last_push_approval": z.optional(z.boolean().default(false).describe("Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`")),
"bypass_pull_request_allowances": z.optional(z.object({
    "users": z.optional(z.array(z.string()).describe("The list of user `login`s allowed to bypass pull request requirements.")),
"teams": z.optional(z.array(z.string()).describe("The list of team `slug`s allowed to bypass pull request requirements.")),
"apps": z.optional(z.array(z.string()).describe("The list of app `slug`s allowed to bypass pull request requirements."))
    }).describe("Allow specific users, teams, or apps to bypass pull request requirements."))
    })

export const reposUpdatePullRequestReviewProtectionMutationResponseSchema = reposUpdatePullRequestReviewProtection200Schema

export const reposDeletePullRequestReviewProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposDeletePullRequestReviewProtection204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposDeletePullRequestReviewProtection404Schema = basicErrorSchema.describe("Basic Error")

export const reposDeletePullRequestReviewProtectionMutationResponseSchema = reposDeletePullRequestReviewProtection204Schema

export const reposGetCommitSignatureProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposGetCommitSignatureProtection200Schema = protectedBranchAdminEnforcedSchema.describe("Protected Branch Admin Enforced")

/**
 * @description Resource not found
 */
export const reposGetCommitSignatureProtection404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetCommitSignatureProtectionQueryResponseSchema = reposGetCommitSignatureProtection200Schema

export const reposCreateCommitSignatureProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposCreateCommitSignatureProtection200Schema = protectedBranchAdminEnforcedSchema.describe("Protected Branch Admin Enforced")

/**
 * @description Resource not found
 */
export const reposCreateCommitSignatureProtection404Schema = basicErrorSchema.describe("Basic Error")

export const reposCreateCommitSignatureProtectionMutationResponseSchema = reposCreateCommitSignatureProtection200Schema

export const reposDeleteCommitSignatureProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposDeleteCommitSignatureProtection204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposDeleteCommitSignatureProtection404Schema = basicErrorSchema.describe("Basic Error")

export const reposDeleteCommitSignatureProtectionMutationResponseSchema = reposDeleteCommitSignatureProtection204Schema

export const reposGetStatusChecksProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposGetStatusChecksProtection200Schema = statusCheckPolicySchema.describe("Status Check Policy")

/**
 * @description Resource not found
 */
export const reposGetStatusChecksProtection404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetStatusChecksProtectionQueryResponseSchema = reposGetStatusChecksProtection200Schema

export const reposUpdateStatusCheckProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposUpdateStatusCheckProtection200Schema = statusCheckPolicySchema.describe("Status Check Policy")

/**
 * @description Resource not found
 */
export const reposUpdateStatusCheckProtection404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposUpdateStatusCheckProtection422Schema = validationErrorSchema.describe("Validation Error")

export const reposUpdateStatusCheckProtectionMutationRequestSchema = z.object({
    "strict": z.optional(z.boolean().describe("Require branches to be up to date before merging.")),
"contexts": z.optional(z.array(z.string()).describe("**Closing down notice**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.")),
"checks": z.optional(z.array(z.object({
    "context": z.string().describe("The name of the required check"),
"app_id": z.optional(z.int().describe("The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status."))
    })).describe("The list of status checks to require in order to merge into this branch."))
    })

export const reposUpdateStatusCheckProtectionMutationResponseSchema = reposUpdateStatusCheckProtection200Schema

export const reposRemoveStatusCheckProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposRemoveStatusCheckProtection204Schema = z.unknown()

export const reposRemoveStatusCheckProtectionMutationResponseSchema = reposRemoveStatusCheckProtection204Schema

export const reposGetAllStatusCheckContextsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposGetAllStatusCheckContexts200Schema = z.array(z.string())

/**
 * @description Resource not found
 */
export const reposGetAllStatusCheckContexts404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetAllStatusCheckContextsQueryResponseSchema = reposGetAllStatusCheckContexts200Schema

export const reposAddStatusCheckContextsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposAddStatusCheckContexts200Schema = z.array(z.string())

/**
 * @description Forbidden
 */
export const reposAddStatusCheckContexts403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposAddStatusCheckContexts404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposAddStatusCheckContexts422Schema = validationErrorSchema.describe("Validation Error")

export const reposAddStatusCheckContextsMutationRequestSchema = z.union([z.array(z.string()), z.object({
    "contexts": z.array(z.string()).describe("The name of the status checks")
    })])

export const reposAddStatusCheckContextsMutationResponseSchema = reposAddStatusCheckContexts200Schema

export const reposSetStatusCheckContextsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposSetStatusCheckContexts200Schema = z.array(z.string())

/**
 * @description Resource not found
 */
export const reposSetStatusCheckContexts404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposSetStatusCheckContexts422Schema = validationErrorSchema.describe("Validation Error")

export const reposSetStatusCheckContextsMutationRequestSchema = z.union([z.array(z.string()), z.object({
    "contexts": z.array(z.string()).describe("The name of the status checks")
    })])

export const reposSetStatusCheckContextsMutationResponseSchema = reposSetStatusCheckContexts200Schema

export const reposRemoveStatusCheckContextsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposRemoveStatusCheckContexts200Schema = z.array(z.string())

/**
 * @description Resource not found
 */
export const reposRemoveStatusCheckContexts404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposRemoveStatusCheckContexts422Schema = validationErrorSchema.describe("Validation Error")

export const reposRemoveStatusCheckContextsMutationRequestSchema = z.union([z.array(z.string()), z.object({
    "contexts": z.array(z.string()).describe("The name of the status checks")
    })])

export const reposRemoveStatusCheckContextsMutationResponseSchema = reposRemoveStatusCheckContexts200Schema

export const reposGetAccessRestrictionsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposGetAccessRestrictions200Schema = branchRestrictionPolicySchema.describe("Branch Restriction Policy")

/**
 * @description Resource not found
 */
export const reposGetAccessRestrictions404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetAccessRestrictionsQueryResponseSchema = reposGetAccessRestrictions200Schema

export const reposDeleteAccessRestrictionsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposDeleteAccessRestrictions204Schema = z.unknown()

export const reposDeleteAccessRestrictionsMutationResponseSchema = reposDeleteAccessRestrictions204Schema

export const reposGetAppsWithAccessToProtectedBranchPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposGetAppsWithAccessToProtectedBranch200Schema = z.array(integrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable())

/**
 * @description Resource not found
 */
export const reposGetAppsWithAccessToProtectedBranch404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetAppsWithAccessToProtectedBranchQueryResponseSchema = reposGetAppsWithAccessToProtectedBranch200Schema

export const reposAddAppAccessRestrictionsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposAddAppAccessRestrictions200Schema = z.array(integrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable())

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposAddAppAccessRestrictions422Schema = validationErrorSchema.describe("Validation Error")

export const reposAddAppAccessRestrictionsMutationRequestSchema = z.object({
    "apps": z.array(z.string()).describe("The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.")
    })

export const reposAddAppAccessRestrictionsMutationResponseSchema = reposAddAppAccessRestrictions200Schema

export const reposSetAppAccessRestrictionsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposSetAppAccessRestrictions200Schema = z.array(integrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable())

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposSetAppAccessRestrictions422Schema = validationErrorSchema.describe("Validation Error")

export const reposSetAppAccessRestrictionsMutationRequestSchema = z.object({
    "apps": z.array(z.string()).describe("The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.")
    })

export const reposSetAppAccessRestrictionsMutationResponseSchema = reposSetAppAccessRestrictions200Schema

export const reposRemoveAppAccessRestrictionsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposRemoveAppAccessRestrictions200Schema = z.array(integrationSchema.describe("GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.").nullable())

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposRemoveAppAccessRestrictions422Schema = validationErrorSchema.describe("Validation Error")

export const reposRemoveAppAccessRestrictionsMutationRequestSchema = z.object({
    "apps": z.array(z.string()).describe("The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.")
    })

export const reposRemoveAppAccessRestrictionsMutationResponseSchema = reposRemoveAppAccessRestrictions200Schema

export const reposGetTeamsWithAccessToProtectedBranchPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposGetTeamsWithAccessToProtectedBranch200Schema = z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories."))

/**
 * @description Resource not found
 */
export const reposGetTeamsWithAccessToProtectedBranch404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetTeamsWithAccessToProtectedBranchQueryResponseSchema = reposGetTeamsWithAccessToProtectedBranch200Schema

export const reposAddTeamAccessRestrictionsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposAddTeamAccessRestrictions200Schema = z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories."))

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposAddTeamAccessRestrictions422Schema = validationErrorSchema.describe("Validation Error")

export const reposAddTeamAccessRestrictionsMutationRequestSchema = z.union([z.array(z.string()), z.object({
    "teams": z.array(z.string()).describe("The slug values for teams")
    })])

export const reposAddTeamAccessRestrictionsMutationResponseSchema = reposAddTeamAccessRestrictions200Schema

export const reposSetTeamAccessRestrictionsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposSetTeamAccessRestrictions200Schema = z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories."))

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposSetTeamAccessRestrictions422Schema = validationErrorSchema.describe("Validation Error")

export const reposSetTeamAccessRestrictionsMutationRequestSchema = z.union([z.array(z.string()), z.object({
    "teams": z.array(z.string()).describe("The slug values for teams")
    })])

export const reposSetTeamAccessRestrictionsMutationResponseSchema = reposSetTeamAccessRestrictions200Schema

export const reposRemoveTeamAccessRestrictionsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposRemoveTeamAccessRestrictions200Schema = z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories."))

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposRemoveTeamAccessRestrictions422Schema = validationErrorSchema.describe("Validation Error")

export const reposRemoveTeamAccessRestrictionsMutationRequestSchema = z.union([z.array(z.string()), z.object({
    "teams": z.array(z.string()).describe("The slug values for teams")
    })])

export const reposRemoveTeamAccessRestrictionsMutationResponseSchema = reposRemoveTeamAccessRestrictions200Schema

export const reposGetUsersWithAccessToProtectedBranchPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposGetUsersWithAccessToProtectedBranch200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

/**
 * @description Resource not found
 */
export const reposGetUsersWithAccessToProtectedBranch404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetUsersWithAccessToProtectedBranchQueryResponseSchema = reposGetUsersWithAccessToProtectedBranch200Schema

export const reposAddUserAccessRestrictionsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposAddUserAccessRestrictions200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposAddUserAccessRestrictions422Schema = validationErrorSchema.describe("Validation Error")

export const reposAddUserAccessRestrictionsMutationRequestSchema = z.object({
    "users": z.array(z.string()).describe("The username for users")
    })

export const reposAddUserAccessRestrictionsMutationResponseSchema = reposAddUserAccessRestrictions200Schema

export const reposSetUserAccessRestrictionsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposSetUserAccessRestrictions200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposSetUserAccessRestrictions422Schema = validationErrorSchema.describe("Validation Error")

export const reposSetUserAccessRestrictionsMutationRequestSchema = z.object({
    "users": z.array(z.string()).describe("The username for users")
    })

export const reposSetUserAccessRestrictionsMutationResponseSchema = reposSetUserAccessRestrictions200Schema

export const reposRemoveUserAccessRestrictionsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposRemoveUserAccessRestrictions200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposRemoveUserAccessRestrictions422Schema = validationErrorSchema.describe("Validation Error")

export const reposRemoveUserAccessRestrictionsMutationRequestSchema = z.object({
    "users": z.array(z.string()).describe("The username for users")
    })

export const reposRemoveUserAccessRestrictionsMutationResponseSchema = reposRemoveUserAccessRestrictions200Schema

export const reposRenameBranchPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

/**
 * @description Response
 */
export const reposRenameBranch201Schema = branchWithProtectionSchema.describe("Branch With Protection")

/**
 * @description Forbidden
 */
export const reposRenameBranch403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposRenameBranch404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposRenameBranch422Schema = validationErrorSchema.describe("Validation Error")

export const reposRenameBranchMutationRequestSchema = z.object({
    "new_name": z.string().describe("The new name of the branch.")
    })

export const reposRenameBranchMutationResponseSchema = reposRenameBranch201Schema

export const checksCreatePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const checksCreate201Schema = checkRunSchema.describe("A check performed on the code of a given code change")

export const checksCreateMutationRequestSchema = z.unknown()

export const checksCreateMutationResponseSchema = checksCreate201Schema

export const checksGetPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"check_run_id": z.coerce.number().int().describe("The unique identifier of the check run.")
    })

/**
 * @description Response
 */
export const checksGet200Schema = checkRunSchema.describe("A check performed on the code of a given code change")

export const checksGetQueryResponseSchema = checksGet200Schema

export const checksUpdatePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"check_run_id": z.coerce.number().int().describe("The unique identifier of the check run.")
    })

/**
 * @description Response
 */
export const checksUpdate200Schema = checkRunSchema.describe("A check performed on the code of a given code change")

export const checksUpdateMutationRequestSchema = z.union([z.object({
    "status": z.optional(z.enum(["completed"]))
    }).catchall(z.unknown()).and(z.object({
    "name": z.optional(z.string().describe("The name of the check. For example, \"code-coverage\".")),
"details_url": z.optional(z.string().describe("The URL of the integrator's site that has the full details of the check.")),
"external_id": z.optional(z.string().describe("A reference for the run on the integrator's system.")),
"started_at": z.optional(z.iso.datetime({ offset: true }).describe("This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"status": z.optional(z.enum(["queued", "in_progress", "completed", "waiting", "requested", "pending"]).describe("The current status of the check run. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.")),
"conclusion": z.optional(z.enum(["action_required", "cancelled", "failure", "neutral", "success", "skipped", "stale", "timed_out"]).describe("**Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. \n**Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.")),
"completed_at": z.optional(z.iso.datetime({ offset: true }).describe("The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"output": z.optional(z.object({
    "title": z.optional(z.string().describe("**Required**.")),
"summary": z.string().max(65535).describe("Can contain Markdown."),
"text": z.optional(z.string().max(65535).describe("Can contain Markdown.")),
"annotations": z.optional(z.array(z.object({
    "path": z.string().describe("The path of the file to add an annotation to. For example, `assets/css/main.css`."),
"start_line": z.int().describe("The start line of the annotation. Line numbers start at 1."),
"end_line": z.int().describe("The end line of the annotation."),
"start_column": z.optional(z.int().describe("The start column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values. Column numbers start at 1.")),
"end_column": z.optional(z.int().describe("The end column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values.")),
"annotation_level": z.enum(["notice", "warning", "failure"]).describe("The level of the annotation."),
"message": z.string().describe("A short description of the feedback for these lines of code. The maximum size is 64 KB."),
"title": z.optional(z.string().describe("The title that represents the annotation. The maximum size is 255 characters.")),
"raw_details": z.optional(z.string().describe("Details about this annotation. The maximum size is 64 KB."))
    })).max(50).describe("Adds information from your analysis to specific lines of code. Annotations are visible in GitHub's pull request UI. Annotations are visible in GitHub's pull request UI. The Checks API limits the number of annotations to a maximum of 50 per API request. To create more than 50 annotations, you have to make multiple requests to the [Update a check run](https://docs.github.com/rest/checks/runs#update-a-check-run) endpoint. Each time you update the check run, annotations are appended to the list of annotations that already exist for the check run. GitHub Actions are limited to 10 warning annotations and 10 error annotations per step. For details about annotations in the UI, see \"[About status checks](https://docs.github.com/articles/about-status-checks#checks)\".")),
"images": z.optional(z.array(z.object({
    "alt": z.string().describe("The alternative text for the image."),
"image_url": z.string().describe("The full URL of the image."),
"caption": z.optional(z.string().describe("A short image description."))
    })).describe("Adds images to the output displayed in the GitHub pull request UI."))
    }).describe("Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run.")),
"actions": z.optional(z.array(z.object({
    "label": z.string().max(20).describe("The text to be displayed on a button in the web UI. The maximum size is 20 characters."),
"description": z.string().max(40).describe("A short explanation of what this action would do. The maximum size is 40 characters."),
"identifier": z.string().max(20).describe("A reference for the action on the integrator's system. The maximum size is 20 characters.")
    })).max(3).describe("Possible further actions the integrator can perform, which a user may trigger. Each action includes a `label`, `identifier` and `description`. A maximum of three actions are accepted. To learn more about check runs and requested actions, see \"[Check runs and requested actions](https://docs.github.com/rest/guides/using-the-rest-api-to-interact-with-checks#check-runs-and-requested-actions).\""))
    })), z.object({
    "status": z.optional(z.enum(["queued", "in_progress"]))
    }).catchall(z.unknown()).and(z.object({
    "name": z.optional(z.string().describe("The name of the check. For example, \"code-coverage\".")),
"details_url": z.optional(z.string().describe("The URL of the integrator's site that has the full details of the check.")),
"external_id": z.optional(z.string().describe("A reference for the run on the integrator's system.")),
"started_at": z.optional(z.iso.datetime({ offset: true }).describe("This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"status": z.optional(z.enum(["queued", "in_progress", "completed", "waiting", "requested", "pending"]).describe("The current status of the check run. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.")),
"conclusion": z.optional(z.enum(["action_required", "cancelled", "failure", "neutral", "success", "skipped", "stale", "timed_out"]).describe("**Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. \n**Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.")),
"completed_at": z.optional(z.iso.datetime({ offset: true }).describe("The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"output": z.optional(z.object({
    "title": z.optional(z.string().describe("**Required**.")),
"summary": z.string().max(65535).describe("Can contain Markdown."),
"text": z.optional(z.string().max(65535).describe("Can contain Markdown.")),
"annotations": z.optional(z.array(z.object({
    "path": z.string().describe("The path of the file to add an annotation to. For example, `assets/css/main.css`."),
"start_line": z.int().describe("The start line of the annotation. Line numbers start at 1."),
"end_line": z.int().describe("The end line of the annotation."),
"start_column": z.optional(z.int().describe("The start column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values. Column numbers start at 1.")),
"end_column": z.optional(z.int().describe("The end column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values.")),
"annotation_level": z.enum(["notice", "warning", "failure"]).describe("The level of the annotation."),
"message": z.string().describe("A short description of the feedback for these lines of code. The maximum size is 64 KB."),
"title": z.optional(z.string().describe("The title that represents the annotation. The maximum size is 255 characters.")),
"raw_details": z.optional(z.string().describe("Details about this annotation. The maximum size is 64 KB."))
    })).max(50).describe("Adds information from your analysis to specific lines of code. Annotations are visible in GitHub's pull request UI. Annotations are visible in GitHub's pull request UI. The Checks API limits the number of annotations to a maximum of 50 per API request. To create more than 50 annotations, you have to make multiple requests to the [Update a check run](https://docs.github.com/rest/checks/runs#update-a-check-run) endpoint. Each time you update the check run, annotations are appended to the list of annotations that already exist for the check run. GitHub Actions are limited to 10 warning annotations and 10 error annotations per step. For details about annotations in the UI, see \"[About status checks](https://docs.github.com/articles/about-status-checks#checks)\".")),
"images": z.optional(z.array(z.object({
    "alt": z.string().describe("The alternative text for the image."),
"image_url": z.string().describe("The full URL of the image."),
"caption": z.optional(z.string().describe("A short image description."))
    })).describe("Adds images to the output displayed in the GitHub pull request UI."))
    }).describe("Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run.")),
"actions": z.optional(z.array(z.object({
    "label": z.string().max(20).describe("The text to be displayed on a button in the web UI. The maximum size is 20 characters."),
"description": z.string().max(40).describe("A short explanation of what this action would do. The maximum size is 40 characters."),
"identifier": z.string().max(20).describe("A reference for the action on the integrator's system. The maximum size is 20 characters.")
    })).max(3).describe("Possible further actions the integrator can perform, which a user may trigger. Each action includes a `label`, `identifier` and `description`. A maximum of three actions are accepted. To learn more about check runs and requested actions, see \"[Check runs and requested actions](https://docs.github.com/rest/guides/using-the-rest-api-to-interact-with-checks#check-runs-and-requested-actions).\""))
    }))])

export const checksUpdateMutationResponseSchema = checksUpdate200Schema

export const checksListAnnotationsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"check_run_id": z.coerce.number().int().describe("The unique identifier of the check run.")
    })

export const checksListAnnotationsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const checksListAnnotations200Schema = z.array(checkAnnotationSchema.describe("Check Annotation"))

export const checksListAnnotationsQueryResponseSchema = checksListAnnotations200Schema

export const checksRerequestRunPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"check_run_id": z.coerce.number().int().describe("The unique identifier of the check run.")
    })

/**
 * @description Response
 */
export const checksRerequestRun201Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Forbidden if the check run is not rerequestable or doesn\'t belong to the authenticated GitHub App
 */
export const checksRerequestRun403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const checksRerequestRun404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation error if the check run is not rerequestable
 */
export const checksRerequestRun422Schema = basicErrorSchema.describe("Basic Error")

export const checksRerequestRunMutationResponseSchema = checksRerequestRun201Schema

export const checksCreateSuitePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response when the suite already exists
 */
export const checksCreateSuite200Schema = checkSuiteSchema.describe("A suite of checks performed on the code of a given code change")

/**
 * @description Response when the suite was created
 */
export const checksCreateSuite201Schema = checkSuiteSchema.describe("A suite of checks performed on the code of a given code change")

export const checksCreateSuiteMutationRequestSchema = z.object({
    "head_sha": z.string().describe("The sha of the head commit.")
    })

export const checksCreateSuiteMutationResponseSchema = z.union([checksCreateSuite200Schema, checksCreateSuite201Schema])

export const checksSetSuitesPreferencesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const checksSetSuitesPreferences200Schema = checkSuitePreferenceSchema.describe("Check suite configuration preferences for a repository.")

export const checksSetSuitesPreferencesMutationRequestSchema = z.object({
    "auto_trigger_checks": z.optional(z.array(z.object({
    "app_id": z.int().describe("The `id` of the GitHub App."),
"setting": z.boolean().default(true).describe("Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository, or `false` to disable them.")
    })).describe("Enables or disables automatic creation of CheckSuite events upon pushes to the repository. Enabled by default."))
    })

export const checksSetSuitesPreferencesMutationResponseSchema = checksSetSuitesPreferences200Schema

export const checksGetSuitePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"check_suite_id": z.coerce.number().int().describe("The unique identifier of the check suite.")
    })

/**
 * @description Response
 */
export const checksGetSuite200Schema = checkSuiteSchema.describe("A suite of checks performed on the code of a given code change")

export const checksGetSuiteQueryResponseSchema = checksGetSuite200Schema

export const checksListForSuitePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"check_suite_id": z.coerce.number().int().describe("The unique identifier of the check suite.")
    })

export const checksListForSuiteQueryParamsSchema = z.object({
    "check_name": z.optional(z.string().describe("Returns check runs with the specified `name`.")),
"status": z.optional(z.enum(["queued", "in_progress", "completed"]).describe("Returns check runs with the specified `status`.")),
"filter": z.enum(["latest", "all"]).default("latest").describe("Filters check runs by their `completed_at` timestamp. `latest` returns the most recent check runs."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const checksListForSuite200Schema = z.object({
    "total_count": z.int(),
get "check_runs"(){
                return z.array(checkRunSchema.describe("A check performed on the code of a given code change"))
              }
    })

export const checksListForSuiteQueryResponseSchema = checksListForSuite200Schema

export const checksRerequestSuitePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"check_suite_id": z.coerce.number().int().describe("The unique identifier of the check suite.")
    })

/**
 * @description Response
 */
export const checksRerequestSuite201Schema = emptyObjectSchema.describe("An object without any properties.")

export const checksRerequestSuiteMutationResponseSchema = checksRerequestSuite201Schema

export const codeScanningListAlertsForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const codeScanningListAlertsForRepoQueryParamsSchema = z.object({
    get "tool_name"(){
                return codeScanningAnalysisToolNameSchema.describe("The name of the tool used to generate the code scanning analysis.").optional()
              },
get "tool_guid"(){
                return codeScanningAnalysisToolGuidSchema.describe("The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.").optional()
              },
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
get "ref"(){
                return codeScanningRefSchema.describe("The Git reference, formatted as `refs/pull/<number>/merge`, `refs/pull/<number>/head`,\n`refs/heads/<branch name>` or simply `<branch name>`.").optional()
              },
"pr": z.optional(z.coerce.number().int().describe("The number of the pull request for the results you want to list.")),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"sort": z.enum(["created", "updated"]).default("created").describe("The property by which to sort the results."),
get "state"(){
                return codeScanningAlertStateQuerySchema.describe("State of a code scanning alert.").optional()
              },
get "severity"(){
                return codeScanningAlertSeveritySchema.describe("Severity of a code scanning alert.").optional()
              }
    })

/**
 * @description Response
 */
export const codeScanningListAlertsForRepo200Schema = z.array(codeScanningAlertItemsSchema)

/**
 * @description Not modified
 */
export const codeScanningListAlertsForRepo304Schema = z.unknown()

/**
 * @description Response if GitHub Advanced Security is not enabled for this repository
 */
export const codeScanningListAlertsForRepo403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeScanningListAlertsForRepo404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningListAlertsForRepo503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningListAlertsForRepoQueryResponseSchema = codeScanningListAlertsForRepo200Schema

export const codeScanningGetAlertPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
get "alert_number"(){
                return alertNumberSchema.describe("The security alert number.")
              }
    })

/**
 * @description Response
 */
export const codeScanningGetAlert200Schema = codeScanningAlertSchema

/**
 * @description Not modified
 */
export const codeScanningGetAlert304Schema = z.unknown()

/**
 * @description Response if GitHub Advanced Security is not enabled for this repository
 */
export const codeScanningGetAlert403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeScanningGetAlert404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningGetAlert503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningGetAlertQueryResponseSchema = codeScanningGetAlert200Schema

export const codeScanningUpdateAlertPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
get "alert_number"(){
                return alertNumberSchema.describe("The security alert number.")
              }
    })

/**
 * @description Response
 */
export const codeScanningUpdateAlert200Schema = codeScanningAlertSchema

/**
 * @description Bad Request
 */
export const codeScanningUpdateAlert400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Response if the repository is archived or if GitHub Advanced Security is not enabled for this repository
 */
export const codeScanningUpdateAlert403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeScanningUpdateAlert404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningUpdateAlert503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningUpdateAlertMutationRequestSchema = z.object({
    get "state"(){
                return codeScanningAlertSetStateSchema.describe("Sets the state of the code scanning alert. You must provide `dismissed_reason` when you set the state to `dismissed`.")
              },
get "dismissed_reason"(){
                return codeScanningAlertDismissedReasonSchema.describe("**Required when the state is dismissed.** The reason for dismissing or closing the alert.").optional()
              },
get "dismissed_comment"(){
                return codeScanningAlertDismissedCommentSchema.describe("The dismissal comment associated with the dismissal of the alert.").optional()
              },
get "create_request"(){
                return codeScanningAlertCreateRequestSchema.describe("If `true`, attempt to create an alert dismissal request.").optional()
              }
    })

export const codeScanningUpdateAlertMutationResponseSchema = codeScanningUpdateAlert200Schema

export const codeScanningGetAutofixPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
get "alert_number"(){
                return alertNumberSchema.describe("The security alert number.")
              }
    })

/**
 * @description Response
 */
export const codeScanningGetAutofix200Schema = codeScanningAutofixSchema

/**
 * @description Bad Request
 */
export const codeScanningGetAutofix400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Response if GitHub Advanced Security is not enabled for this repository
 */
export const codeScanningGetAutofix403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeScanningGetAutofix404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningGetAutofix503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningGetAutofixQueryResponseSchema = codeScanningGetAutofix200Schema

export const codeScanningCreateAutofixPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
get "alert_number"(){
                return alertNumberSchema.describe("The security alert number.")
              }
    })

/**
 * @description OK
 */
export const codeScanningCreateAutofix200Schema = codeScanningAutofixSchema

/**
 * @description Accepted
 */
export const codeScanningCreateAutofix202Schema = codeScanningAutofixSchema

/**
 * @description Bad Request
 */
export const codeScanningCreateAutofix400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Response if the repository is archived, if GitHub Advanced Security is not enabled for this repository or if rate limit is exceeded
 */
export const codeScanningCreateAutofix403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeScanningCreateAutofix404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Unprocessable Entity
 */
export const codeScanningCreateAutofix422Schema = z.unknown()

/**
 * @description Service unavailable
 */
export const codeScanningCreateAutofix503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningCreateAutofixMutationResponseSchema = z.union([codeScanningCreateAutofix200Schema, codeScanningCreateAutofix202Schema])

export const codeScanningCommitAutofixPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
get "alert_number"(){
                return alertNumberSchema.describe("The security alert number.")
              }
    })

/**
 * @description Created
 */
export const codeScanningCommitAutofix201Schema = codeScanningAutofixCommitsResponseSchema

/**
 * @description Bad Request
 */
export const codeScanningCommitAutofix400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Response if the repository is archived or if GitHub Advanced Security is not enabled for this repository
 */
export const codeScanningCommitAutofix403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeScanningCommitAutofix404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Unprocessable Entity
 */
export const codeScanningCommitAutofix422Schema = z.unknown()

/**
 * @description Service unavailable
 */
export const codeScanningCommitAutofix503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningCommitAutofixMutationRequestSchema = codeScanningAutofixCommitsSchema.describe("Commit an autofix for a code scanning alert").nullable()

export const codeScanningCommitAutofixMutationResponseSchema = codeScanningCommitAutofix201Schema

export const codeScanningListAlertInstancesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
get "alert_number"(){
                return alertNumberSchema.describe("The security alert number.")
              }
    })

export const codeScanningListAlertInstancesQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
get "ref"(){
                return codeScanningRefSchema.describe("The Git reference, formatted as `refs/pull/<number>/merge`, `refs/pull/<number>/head`,\n`refs/heads/<branch name>` or simply `<branch name>`.").optional()
              },
"pr": z.optional(z.coerce.number().int().describe("The number of the pull request for the results you want to list."))
    })

/**
 * @description Response
 */
export const codeScanningListAlertInstances200Schema = z.array(codeScanningAlertInstanceSchema)

/**
 * @description Response if GitHub Advanced Security is not enabled for this repository
 */
export const codeScanningListAlertInstances403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeScanningListAlertInstances404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningListAlertInstances503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningListAlertInstancesQueryResponseSchema = codeScanningListAlertInstances200Schema

export const codeScanningListRecentAnalysesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const codeScanningListRecentAnalysesQueryParamsSchema = z.object({
    get "tool_name"(){
                return codeScanningAnalysisToolNameSchema.describe("The name of the tool used to generate the code scanning analysis.").optional()
              },
get "tool_guid"(){
                return codeScanningAnalysisToolGuidSchema.describe("The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.").optional()
              },
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"pr": z.optional(z.coerce.number().int().describe("The number of the pull request for the results you want to list.")),
get "ref"(){
                return codeScanningRefSchema.describe("The Git reference, formatted as `refs/pull/<number>/merge`, `refs/pull/<number>/head`,\n`refs/heads/<branch name>` or simply `<branch name>`.").optional()
              },
get "sarif_id"(){
                return codeScanningAnalysisSarifIdSchema.describe("An identifier for the upload.").optional()
              },
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"sort": z.enum(["created"]).default("created").describe("The property by which to sort the results.")
    })

/**
 * @description Response
 */
export const codeScanningListRecentAnalyses200Schema = z.array(codeScanningAnalysisSchema)

/**
 * @description Response if GitHub Advanced Security is not enabled for this repository
 */
export const codeScanningListRecentAnalyses403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeScanningListRecentAnalyses404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningListRecentAnalyses503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningListRecentAnalysesQueryResponseSchema = codeScanningListRecentAnalyses200Schema

export const codeScanningGetAnalysisPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"analysis_id": z.coerce.number().int().describe("The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses` operation.")
    })

/**
 * @description Response
 */
export const codeScanningGetAnalysis200Schema = codeScanningAnalysisSchema

/**
 * @description Response if GitHub Advanced Security is not enabled for this repository
 */
export const codeScanningGetAnalysis403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeScanningGetAnalysis404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Response if analysis could not be processed
 */
export const codeScanningGetAnalysis422Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningGetAnalysis503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningGetAnalysisQueryResponseSchema = codeScanningGetAnalysis200Schema

export const codeScanningDeleteAnalysisPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"analysis_id": z.coerce.number().int().describe("The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses` operation.")
    })

export const codeScanningDeleteAnalysisQueryParamsSchema = z.object({
    "confirm_delete": z.string().describe("Allow deletion if the specified analysis is the last in a set. If you attempt to delete the final analysis in a set without setting this parameter to `true`, you'll get a 400 response with the message: `Analysis is last of its type and deletion may result in the loss of historical alert data. Please specify confirm_delete.`").nullish()
    }).optional()

/**
 * @description Response
 */
export const codeScanningDeleteAnalysis200Schema = codeScanningAnalysisDeletionSchema.describe("Successful deletion of a code scanning analysis")

/**
 * @description Bad Request
 */
export const codeScanningDeleteAnalysis400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Response if the repository is archived or if GitHub Advanced Security is not enabled for this repository
 */
export const codeScanningDeleteAnalysis403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeScanningDeleteAnalysis404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningDeleteAnalysis503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningDeleteAnalysisMutationResponseSchema = codeScanningDeleteAnalysis200Schema

export const codeScanningListCodeqlDatabasesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const codeScanningListCodeqlDatabases200Schema = z.array(codeScanningCodeqlDatabaseSchema.describe("A CodeQL database."))

/**
 * @description Response if GitHub Advanced Security is not enabled for this repository
 */
export const codeScanningListCodeqlDatabases403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeScanningListCodeqlDatabases404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningListCodeqlDatabases503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningListCodeqlDatabasesQueryResponseSchema = codeScanningListCodeqlDatabases200Schema

export const codeScanningGetCodeqlDatabasePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"language": z.string().describe("The language of the CodeQL database.")
    })

/**
 * @description Response
 */
export const codeScanningGetCodeqlDatabase200Schema = codeScanningCodeqlDatabaseSchema.describe("A CodeQL database.")

/**
 * @description Found
 */
export const codeScanningGetCodeqlDatabase302Schema = z.unknown()

/**
 * @description Response if GitHub Advanced Security is not enabled for this repository
 */
export const codeScanningGetCodeqlDatabase403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeScanningGetCodeqlDatabase404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningGetCodeqlDatabase503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningGetCodeqlDatabaseQueryResponseSchema = codeScanningGetCodeqlDatabase200Schema

export const codeScanningDeleteCodeqlDatabasePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"language": z.string().describe("The language of the CodeQL database.")
    })

/**
 * @description Response
 */
export const codeScanningDeleteCodeqlDatabase204Schema = z.unknown()

/**
 * @description Response if the repository is archived or if GitHub Advanced Security is not enabled for this repository
 */
export const codeScanningDeleteCodeqlDatabase403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeScanningDeleteCodeqlDatabase404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningDeleteCodeqlDatabase503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningDeleteCodeqlDatabaseMutationResponseSchema = codeScanningDeleteCodeqlDatabase204Schema

export const codeScanningCreateVariantAnalysisPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Variant analysis submitted for processing
 */
export const codeScanningCreateVariantAnalysis201Schema = codeScanningVariantAnalysisSchema.describe("A run of a CodeQL query against one or more repositories.")

/**
 * @description Resource not found
 */
export const codeScanningCreateVariantAnalysis404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Unable to process variant analysis submission
 */
export const codeScanningCreateVariantAnalysis422Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningCreateVariantAnalysis503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningCreateVariantAnalysisMutationRequestSchema = z.unknown()

export const codeScanningCreateVariantAnalysisMutationResponseSchema = codeScanningCreateVariantAnalysis201Schema

export const codeScanningGetVariantAnalysisPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"codeql_variant_analysis_id": z.coerce.number().int().describe("The unique identifier of the variant analysis.")
    })

/**
 * @description Response
 */
export const codeScanningGetVariantAnalysis200Schema = codeScanningVariantAnalysisSchema.describe("A run of a CodeQL query against one or more repositories.")

/**
 * @description Resource not found
 */
export const codeScanningGetVariantAnalysis404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningGetVariantAnalysis503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningGetVariantAnalysisQueryResponseSchema = codeScanningGetVariantAnalysis200Schema

export const codeScanningGetVariantAnalysisRepoTaskPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the controller repository."),
"codeql_variant_analysis_id": z.coerce.number().int().describe("The ID of the variant analysis."),
"repo_owner": z.string().describe("The account owner of the variant analysis repository. The name is not case sensitive."),
"repo_name": z.string().describe("The name of the variant analysis repository.")
    })

/**
 * @description Response
 */
export const codeScanningGetVariantAnalysisRepoTask200Schema = codeScanningVariantAnalysisRepoTaskSchema

/**
 * @description Resource not found
 */
export const codeScanningGetVariantAnalysisRepoTask404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningGetVariantAnalysisRepoTask503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningGetVariantAnalysisRepoTaskQueryResponseSchema = codeScanningGetVariantAnalysisRepoTask200Schema

export const codeScanningGetDefaultSetupPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const codeScanningGetDefaultSetup200Schema = codeScanningDefaultSetupSchema.describe("Configuration for code scanning default setup.")

/**
 * @description Response if GitHub Advanced Security is not enabled for this repository
 */
export const codeScanningGetDefaultSetup403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeScanningGetDefaultSetup404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningGetDefaultSetup503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningGetDefaultSetupQueryResponseSchema = codeScanningGetDefaultSetup200Schema

export const codeScanningUpdateDefaultSetupPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const codeScanningUpdateDefaultSetup200Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Response
 */
export const codeScanningUpdateDefaultSetup202Schema = codeScanningDefaultSetupUpdateResponseSchema.describe("You can use `run_url` to track the status of the run. This includes a property status and conclusion.\nYou should not rely on this always being an actions workflow run object.")

/**
 * @description Response if the repository is archived or if GitHub Advanced Security is not enabled for this repository
 */
export const codeScanningUpdateDefaultSetup403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeScanningUpdateDefaultSetup404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Response if there is already a validation run in progress with a different default setup configuration
 */
export const codeScanningUpdateDefaultSetup409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Response if the configuration change cannot be made because the repository is not in the required state
 */
export const codeScanningUpdateDefaultSetup422Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codeScanningUpdateDefaultSetup503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningUpdateDefaultSetupMutationRequestSchema = codeScanningDefaultSetupUpdateSchema.describe("Configuration for code scanning default setup.")

export const codeScanningUpdateDefaultSetupMutationResponseSchema = z.union([codeScanningUpdateDefaultSetup200Schema, codeScanningUpdateDefaultSetup202Schema])

export const codeScanningUploadSarifPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const codeScanningUploadSarif202Schema = codeScanningSarifsReceiptSchema

/**
 * @description Bad Request if the sarif field is invalid
 */
export const codeScanningUploadSarif400Schema = z.unknown()

/**
 * @description Response if the repository is archived or if GitHub Advanced Security is not enabled for this repository
 */
export const codeScanningUploadSarif403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeScanningUploadSarif404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Payload Too Large if the sarif field is too large
 */
export const codeScanningUploadSarif413Schema = z.unknown()

/**
 * @description Service unavailable
 */
export const codeScanningUploadSarif503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningUploadSarifMutationRequestSchema = z.object({
    get "commit_sha"(){
                return codeScanningAnalysisCommitShaSchema.describe("The SHA of the commit to which the analysis you are uploading relates.")
              },
get "ref"(){
                return codeScanningRefFullSchema.describe("The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/tags/<tag>`, `refs/pull/<number>/merge`, or `refs/pull/<number>/head`.")
              },
get "sarif"(){
                return codeScanningAnalysisSarifFileSchema.describe("A Base64 string representing the SARIF file to upload. You must first compress your SARIF file using [`gzip`](http://www.gnu.org/software/gzip/manual/gzip.html) and then translate the contents of the file into a Base64 encoding string. For more information, see \"[SARIF support for code scanning](https://docs.github.com/code-security/secure-coding/sarif-support-for-code-scanning).\"")
              },
"checkout_uri": z.optional(z.url().describe("The base directory used in the analysis, as it appears in the SARIF file.\nThis property is used to convert file paths from absolute to relative, so that alerts can be mapped to their correct location in the repository.")),
"started_at": z.optional(z.iso.datetime({ offset: true }).describe("The time that the analysis run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"tool_name": z.optional(z.string().describe("The name of the tool used to generate the code scanning analysis. If this parameter is not used, the tool name defaults to \"API\". If the uploaded SARIF contains a tool GUID, this will be available for filtering using the `tool_guid` parameter of operations such as `GET /repos/{owner}/{repo}/code-scanning/alerts`.")),
"validate": z.optional(z.boolean().describe("Whether the SARIF file will be validated according to the code scanning specifications.\nThis parameter is intended to help integrators ensure that the uploaded SARIF files are correctly rendered by code scanning."))
    })

export const codeScanningUploadSarifMutationResponseSchema = codeScanningUploadSarif202Schema

export const codeScanningGetSarifPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"sarif_id": z.string().describe("The SARIF ID obtained after uploading.")
    })

/**
 * @description Response
 */
export const codeScanningGetSarif200Schema = codeScanningSarifsStatusSchema

/**
 * @description Response if GitHub Advanced Security is not enabled for this repository
 */
export const codeScanningGetSarif403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Not Found if the sarif id does not match any upload
 */
export const codeScanningGetSarif404Schema = z.unknown()

/**
 * @description Service unavailable
 */
export const codeScanningGetSarif503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codeScanningGetSarifQueryResponseSchema = codeScanningGetSarif200Schema

export const codeSecurityGetConfigurationForRepositoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const codeSecurityGetConfigurationForRepository200Schema = codeSecurityConfigurationForRepositorySchema.describe("Code security configuration associated with a repository and attachment status")

/**
 * @description A header with no content is returned.
 */
export const codeSecurityGetConfigurationForRepository204Schema = z.unknown()

/**
 * @description Not modified
 */
export const codeSecurityGetConfigurationForRepository304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const codeSecurityGetConfigurationForRepository403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codeSecurityGetConfigurationForRepository404Schema = basicErrorSchema.describe("Basic Error")

export const codeSecurityGetConfigurationForRepositoryQueryResponseSchema = z.union([codeSecurityGetConfigurationForRepository200Schema, codeSecurityGetConfigurationForRepository204Schema])

export const reposCodeownersErrorsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposCodeownersErrorsQueryParamsSchema = z.object({
    "ref": z.optional(z.string().describe("A branch, tag or commit name used to determine which version of the CODEOWNERS file to use. Default: the repository's default branch (e.g. `main`)"))
    }).optional()

/**
 * @description Response
 */
export const reposCodeownersErrors200Schema = codeownersErrorsSchema.describe("A list of errors found in a repo's CODEOWNERS file")

/**
 * @description Resource not found
 */
export const reposCodeownersErrors404Schema = z.unknown()

export const reposCodeownersErrorsQueryResponseSchema = reposCodeownersErrors200Schema

export const codespacesListInRepositoryForAuthenticatedUserPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const codespacesListInRepositoryForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const codespacesListInRepositoryForAuthenticatedUser200Schema = z.object({
    "total_count": z.int(),
get "codespaces"(){
                return z.array(codespaceSchema.describe("A codespace."))
              }
    })

/**
 * @description Requires authentication
 */
export const codespacesListInRepositoryForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesListInRepositoryForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesListInRepositoryForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesListInRepositoryForAuthenticatedUser500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesListInRepositoryForAuthenticatedUserQueryResponseSchema = codespacesListInRepositoryForAuthenticatedUser200Schema

export const codespacesCreateWithRepoForAuthenticatedUserPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response when the codespace was successfully created
 */
export const codespacesCreateWithRepoForAuthenticatedUser201Schema = codespaceSchema.describe("A codespace.")

/**
 * @description Response when the codespace creation partially failed but is being retried in the background
 */
export const codespacesCreateWithRepoForAuthenticatedUser202Schema = codespaceSchema.describe("A codespace.")

/**
 * @description Bad Request
 */
export const codespacesCreateWithRepoForAuthenticatedUser400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Requires authentication
 */
export const codespacesCreateWithRepoForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesCreateWithRepoForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesCreateWithRepoForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codespacesCreateWithRepoForAuthenticatedUser503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codespacesCreateWithRepoForAuthenticatedUserMutationRequestSchema = z.object({
    "ref": z.optional(z.string().describe("Git ref (typically a branch name) for this codespace")),
"location": z.optional(z.string().describe("The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.")),
"geo": z.optional(z.enum(["EuropeWest", "SoutheastAsia", "UsEast", "UsWest"]).describe("The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down.")),
"client_ip": z.optional(z.string().describe("IP for location auto-detection when proxying a request")),
"machine": z.optional(z.string().describe("Machine type to use for this codespace")),
"devcontainer_path": z.optional(z.string().describe("Path to devcontainer.json config to use for this codespace")),
"multi_repo_permissions_opt_out": z.optional(z.boolean().describe("Whether to authorize requested permissions from devcontainer.json")),
"working_directory": z.optional(z.string().describe("Working directory for this codespace")),
"idle_timeout_minutes": z.optional(z.int().describe("Time in minutes before codespace stops from inactivity")),
"display_name": z.optional(z.string().describe("Display name for this codespace")),
"retention_period_minutes": z.optional(z.int().describe("Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days)."))
    }).nullable()

export const codespacesCreateWithRepoForAuthenticatedUserMutationResponseSchema = z.union([codespacesCreateWithRepoForAuthenticatedUser201Schema, codespacesCreateWithRepoForAuthenticatedUser202Schema])

export const codespacesListDevcontainersInRepositoryForAuthenticatedUserPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const codespacesListDevcontainersInRepositoryForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const codespacesListDevcontainersInRepositoryForAuthenticatedUser200Schema = z.object({
    "total_count": z.int(),
"devcontainers": z.array(z.object({
    "path": z.string(),
"name": z.optional(z.string()),
"display_name": z.optional(z.string())
    }))
    })

/**
 * @description Bad Request
 */
export const codespacesListDevcontainersInRepositoryForAuthenticatedUser400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Requires authentication
 */
export const codespacesListDevcontainersInRepositoryForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesListDevcontainersInRepositoryForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesListDevcontainersInRepositoryForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesListDevcontainersInRepositoryForAuthenticatedUser500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesListDevcontainersInRepositoryForAuthenticatedUserQueryResponseSchema = codespacesListDevcontainersInRepositoryForAuthenticatedUser200Schema

export const codespacesRepoMachinesForAuthenticatedUserPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const codespacesRepoMachinesForAuthenticatedUserQueryParamsSchema = z.object({
    "location": z.optional(z.string().describe("The location to check for available machines. Assigned by IP if not provided.")),
"client_ip": z.optional(z.string().describe("IP for location auto-detection when proxying a request")),
"ref": z.optional(z.string().describe("The branch or commit to check for prebuild availability and devcontainer restrictions."))
    }).optional()

/**
 * @description Response
 */
export const codespacesRepoMachinesForAuthenticatedUser200Schema = z.object({
    "total_count": z.int(),
get "machines"(){
                return z.array(codespaceMachineSchema.describe("A description of the machine powering a codespace."))
              }
    })

/**
 * @description Not modified
 */
export const codespacesRepoMachinesForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const codespacesRepoMachinesForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesRepoMachinesForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesRepoMachinesForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesRepoMachinesForAuthenticatedUser500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesRepoMachinesForAuthenticatedUserQueryResponseSchema = codespacesRepoMachinesForAuthenticatedUser200Schema

export const codespacesPreFlightWithRepoForAuthenticatedUserPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const codespacesPreFlightWithRepoForAuthenticatedUserQueryParamsSchema = z.object({
    "ref": z.optional(z.string().describe("The branch or commit to check for a default devcontainer path. If not specified, the default branch will be checked.")),
"client_ip": z.optional(z.string().describe("An alternative IP for default location auto-detection, such as when proxying a request."))
    }).optional()

/**
 * @description Response when a user is able to create codespaces from the repository.
 */
export const codespacesPreFlightWithRepoForAuthenticatedUser200Schema = z.object({
    get "billable_owner"(){
                return simpleUserSchema.describe("A GitHub user.").optional()
              },
"defaults": z.optional(z.object({
    "location": z.string(),
"devcontainer_path": z.nullable(z.string())
    }))
    })

/**
 * @description Requires authentication
 */
export const codespacesPreFlightWithRepoForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesPreFlightWithRepoForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesPreFlightWithRepoForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const codespacesPreFlightWithRepoForAuthenticatedUserQueryResponseSchema = codespacesPreFlightWithRepoForAuthenticatedUser200Schema

export const codespacesCheckPermissionsForDevcontainerPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const codespacesCheckPermissionsForDevcontainerQueryParamsSchema = z.object({
    "ref": z.string().describe("The git reference that points to the location of the devcontainer configuration to use for the permission check. The value of `ref` will typically be a branch name (`heads/BRANCH_NAME`). For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation."),
"devcontainer_path": z.string().describe("Path to the devcontainer.json configuration to use for the permission check.")
    })

/**
 * @description Response when the permission check is successful
 */
export const codespacesCheckPermissionsForDevcontainer200Schema = codespacesPermissionsCheckForDevcontainerSchema.describe("Permission check result for a given devcontainer config.")

/**
 * @description Requires authentication
 */
export const codespacesCheckPermissionsForDevcontainer401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesCheckPermissionsForDevcontainer403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesCheckPermissionsForDevcontainer404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const codespacesCheckPermissionsForDevcontainer422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Service unavailable
 */
export const codespacesCheckPermissionsForDevcontainer503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codespacesCheckPermissionsForDevcontainerQueryResponseSchema = codespacesCheckPermissionsForDevcontainer200Schema

export const codespacesListRepoSecretsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const codespacesListRepoSecretsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const codespacesListRepoSecrets200Schema = z.object({
    "total_count": z.int(),
get "secrets"(){
                return z.array(repoCodespacesSecretSchema.describe("Set repository secrets for GitHub Codespaces."))
              }
    })

export const codespacesListRepoSecretsQueryResponseSchema = codespacesListRepoSecrets200Schema

export const codespacesGetRepoPublicKeyPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const codespacesGetRepoPublicKey200Schema = codespacesPublicKeySchema.describe("The public key used for setting Codespaces secrets.")

export const codespacesGetRepoPublicKeyQueryResponseSchema = codespacesGetRepoPublicKey200Schema

export const codespacesGetRepoSecretPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const codespacesGetRepoSecret200Schema = repoCodespacesSecretSchema.describe("Set repository secrets for GitHub Codespaces.")

export const codespacesGetRepoSecretQueryResponseSchema = codespacesGetRepoSecret200Schema

export const codespacesCreateOrUpdateRepoSecretPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response when creating a secret
 */
export const codespacesCreateOrUpdateRepoSecret201Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Response when updating a secret
 */
export const codespacesCreateOrUpdateRepoSecret204Schema = z.unknown()

export const codespacesCreateOrUpdateRepoSecretMutationRequestSchema = z.object({
    "encrypted_value": z.optional(z.string().regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$/).describe("Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/codespaces/repository-secrets#get-a-repository-public-key) endpoint.")),
"key_id": z.optional(z.string().describe("ID of the key you used to encrypt the secret."))
    })

export const codespacesCreateOrUpdateRepoSecretMutationResponseSchema = z.union([codespacesCreateOrUpdateRepoSecret201Schema, codespacesCreateOrUpdateRepoSecret204Schema])

export const codespacesDeleteRepoSecretPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const codespacesDeleteRepoSecret204Schema = z.unknown()

export const codespacesDeleteRepoSecretMutationResponseSchema = codespacesDeleteRepoSecret204Schema

export const reposListCollaboratorsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposListCollaboratorsQueryParamsSchema = z.object({
    "affiliation": z.enum(["outside", "direct", "all"]).default("all").describe("Filter collaborators returned by their affiliation. `outside` means all outside collaborators of an organization-owned repository. `direct` means all collaborators with permissions to an organization-owned repository, regardless of organization membership status. `all` means all collaborators the authenticated user can see."),
"permission": z.optional(z.enum(["pull", "triage", "push", "maintain", "admin"]).describe("Filter collaborators by the permissions they have on the repository. If not specified, all collaborators will be returned.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListCollaborators200Schema = z.array(collaboratorSchema.describe("Collaborator"))

/**
 * @description Resource not found
 */
export const reposListCollaborators404Schema = basicErrorSchema.describe("Basic Error")

export const reposListCollaboratorsQueryResponseSchema = reposListCollaborators200Schema

export const reposCheckCollaboratorPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response if user is a collaborator
 */
export const reposCheckCollaborator204Schema = z.unknown()

/**
 * @description Not Found if user is not a collaborator
 */
export const reposCheckCollaborator404Schema = z.unknown()

export const reposCheckCollaboratorQueryResponseSchema = reposCheckCollaborator204Schema

export const reposAddCollaboratorPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response when a new invitation is created
 */
export const reposAddCollaborator201Schema = repositoryInvitationSchema.describe("Repository invitations let you manage who you collaborate with.")

/**
 * @description Response when:\n- an existing collaborator is added as a collaborator\n- an organization member is added as an individual collaborator\n- an existing team member (whose team is also a repository collaborator) is added as an individual collaborator
 */
export const reposAddCollaborator204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const reposAddCollaborator403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Response when:\n- validation failed, or the endpoint has been spammed\n- an Enterprise Managed User (EMU) account was invited to a repository in an enterprise with personal user accounts
 */
export const reposAddCollaborator422Schema = validationErrorSchema.describe("Validation Error")

export const reposAddCollaboratorMutationRequestSchema = z.object({
    "permission": z.optional(z.string().default("push").describe("The permission to grant the collaborator. **Only valid on organization-owned repositories.** We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any."))
    })

export const reposAddCollaboratorMutationResponseSchema = z.union([reposAddCollaborator201Schema, reposAddCollaborator204Schema])

export const reposRemoveCollaboratorPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description No Content when collaborator was removed from the repository.
 */
export const reposRemoveCollaborator204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const reposRemoveCollaborator403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposRemoveCollaborator422Schema = validationErrorSchema.describe("Validation Error")

export const reposRemoveCollaboratorMutationResponseSchema = reposRemoveCollaborator204Schema

export const reposGetCollaboratorPermissionLevelPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description if user has admin permissions
 */
export const reposGetCollaboratorPermissionLevel200Schema = repositoryCollaboratorPermissionSchema.describe("Repository Collaborator Permission")

/**
 * @description Resource not found
 */
export const reposGetCollaboratorPermissionLevel404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetCollaboratorPermissionLevelQueryResponseSchema = reposGetCollaboratorPermissionLevel200Schema

export const reposListCommitCommentsForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposListCommitCommentsForRepoQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListCommitCommentsForRepo200Schema = z.array(commitCommentSchema.describe("Commit Comment"))

export const reposListCommitCommentsForRepoQueryResponseSchema = reposListCommitCommentsForRepo200Schema

export const reposGetCommitCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

/**
 * @description Response
 */
export const reposGetCommitComment200Schema = commitCommentSchema.describe("Commit Comment")

/**
 * @description Resource not found
 */
export const reposGetCommitComment404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetCommitCommentQueryResponseSchema = reposGetCommitComment200Schema

export const reposUpdateCommitCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

/**
 * @description Response
 */
export const reposUpdateCommitComment200Schema = commitCommentSchema.describe("Commit Comment")

/**
 * @description Resource not found
 */
export const reposUpdateCommitComment404Schema = basicErrorSchema.describe("Basic Error")

export const reposUpdateCommitCommentMutationRequestSchema = z.object({
    "body": z.string().describe("The contents of the comment")
    })

export const reposUpdateCommitCommentMutationResponseSchema = reposUpdateCommitComment200Schema

export const reposDeleteCommitCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

/**
 * @description Response
 */
export const reposDeleteCommitComment204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposDeleteCommitComment404Schema = basicErrorSchema.describe("Basic Error")

export const reposDeleteCommitCommentMutationResponseSchema = reposDeleteCommitComment204Schema

export const reactionsListForCommitCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

export const reactionsListForCommitCommentQueryParamsSchema = z.object({
    "content": z.optional(z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a commit comment.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reactionsListForCommitComment200Schema = z.array(reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively."))

/**
 * @description Resource not found
 */
export const reactionsListForCommitComment404Schema = basicErrorSchema.describe("Basic Error")

export const reactionsListForCommitCommentQueryResponseSchema = reactionsListForCommitComment200Schema

export const reactionsCreateForCommitCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

/**
 * @description Reaction exists
 */
export const reactionsCreateForCommitComment200Schema = reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

/**
 * @description Reaction created
 */
export const reactionsCreateForCommitComment201Schema = reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reactionsCreateForCommitComment422Schema = validationErrorSchema.describe("Validation Error")

export const reactionsCreateForCommitCommentMutationRequestSchema = z.object({
    "content": z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the commit comment.")
    })

export const reactionsCreateForCommitCommentMutationResponseSchema = z.union([reactionsCreateForCommitComment200Schema, reactionsCreateForCommitComment201Schema])

export const reactionsDeleteForCommitCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment."),
"reaction_id": z.coerce.number().int().describe("The unique identifier of the reaction.")
    })

/**
 * @description Response
 */
export const reactionsDeleteForCommitComment204Schema = z.unknown()

export const reactionsDeleteForCommitCommentMutationResponseSchema = reactionsDeleteForCommitComment204Schema

export const reposListCommitsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposListCommitsQueryParamsSchema = z.object({
    "sha": z.optional(z.string().describe("SHA or branch to start listing commits from. Default: the repositorys default branch (usually `main`).")),
"path": z.optional(z.string().describe("Only commits containing this file path will be returned.")),
"author": z.optional(z.string().describe("GitHub username or email address to use to filter by commit author.")),
"committer": z.optional(z.string().describe("GitHub username or email address to use to filter by commit committer.")),
"since": z.optional(z.iso.datetime({ offset: true }).describe("Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned.")),
"until": z.optional(z.iso.datetime({ offset: true }).describe("Only commits before this date will be returned. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListCommits200Schema = z.array(commitSchema.describe("Commit"))

/**
 * @description Bad Request
 */
export const reposListCommits400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposListCommits404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const reposListCommits409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposListCommits500Schema = basicErrorSchema.describe("Basic Error")

export const reposListCommitsQueryResponseSchema = reposListCommits200Schema

export const reposListBranchesForHeadCommitPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"commit_sha": z.string().describe("The SHA of the commit.")
    })

/**
 * @description Response
 */
export const reposListBranchesForHeadCommit200Schema = z.array(branchShortSchema.describe("Branch Short"))

/**
 * @description Conflict
 */
export const reposListBranchesForHeadCommit409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposListBranchesForHeadCommit422Schema = validationErrorSchema.describe("Validation Error")

export const reposListBranchesForHeadCommitQueryResponseSchema = reposListBranchesForHeadCommit200Schema

export const reposListCommentsForCommitPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"commit_sha": z.string().describe("The SHA of the commit.")
    })

export const reposListCommentsForCommitQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListCommentsForCommit200Schema = z.array(commitCommentSchema.describe("Commit Comment"))

export const reposListCommentsForCommitQueryResponseSchema = reposListCommentsForCommit200Schema

export const reposCreateCommitCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"commit_sha": z.string().describe("The SHA of the commit.")
    })

/**
 * @description Response
 */
export const reposCreateCommitComment201Schema = commitCommentSchema.describe("Commit Comment")

/**
 * @description Forbidden
 */
export const reposCreateCommitComment403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposCreateCommitComment422Schema = validationErrorSchema.describe("Validation Error")

export const reposCreateCommitCommentMutationRequestSchema = z.object({
    "body": z.string().describe("The contents of the comment."),
"path": z.optional(z.string().describe("Relative path of the file to comment on.")),
"position": z.optional(z.int().describe("Line index in the diff to comment on.")),
"line": z.optional(z.int().describe("**Closing down notice**. Use **position** parameter instead. Line number in the file to comment on."))
    })

export const reposCreateCommitCommentMutationResponseSchema = reposCreateCommitComment201Schema

export const reposListPullRequestsAssociatedWithCommitPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"commit_sha": z.string().describe("The SHA of the commit.")
    })

export const reposListPullRequestsAssociatedWithCommitQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListPullRequestsAssociatedWithCommit200Schema = z.array(pullRequestSimpleSchema.describe("Pull Request Simple"))

/**
 * @description Conflict
 */
export const reposListPullRequestsAssociatedWithCommit409Schema = basicErrorSchema.describe("Basic Error")

export const reposListPullRequestsAssociatedWithCommitQueryResponseSchema = reposListPullRequestsAssociatedWithCommit200Schema

export const reposGetCommitPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ref": z.string().describe("The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.")
    })

export const reposGetCommitQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposGetCommit200Schema = commitSchema.describe("Commit")

/**
 * @description Resource not found
 */
export const reposGetCommit404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const reposGetCommit409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposGetCommit422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Internal Error
 */
export const reposGetCommit500Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const reposGetCommit503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const reposGetCommitQueryResponseSchema = reposGetCommit200Schema

export const checksListForRefPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ref": z.string().describe("The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.")
    })

export const checksListForRefQueryParamsSchema = z.object({
    "check_name": z.optional(z.string().describe("Returns check runs with the specified `name`.")),
"status": z.optional(z.enum(["queued", "in_progress", "completed"]).describe("Returns check runs with the specified `status`.")),
"filter": z.enum(["latest", "all"]).default("latest").describe("Filters check runs by their `completed_at` timestamp. `latest` returns the most recent check runs."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"app_id": z.optional(z.coerce.number().int())
    })

/**
 * @description Response
 */
export const checksListForRef200Schema = z.object({
    "total_count": z.int(),
get "check_runs"(){
                return z.array(checkRunSchema.describe("A check performed on the code of a given code change"))
              }
    })

export const checksListForRefQueryResponseSchema = checksListForRef200Schema

export const checksListSuitesForRefPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ref": z.string().describe("The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.")
    })

export const checksListSuitesForRefQueryParamsSchema = z.object({
    "app_id": z.optional(z.coerce.number().int().describe("Filters check suites by GitHub App `id`.")),
"check_name": z.optional(z.string().describe("Returns check runs with the specified `name`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const checksListSuitesForRef200Schema = z.object({
    "total_count": z.int(),
get "check_suites"(){
                return z.array(checkSuiteSchema.describe("A suite of checks performed on the code of a given code change"))
              }
    })

export const checksListSuitesForRefQueryResponseSchema = checksListSuitesForRef200Schema

export const reposGetCombinedStatusForRefPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ref": z.string().describe("The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.")
    })

export const reposGetCombinedStatusForRefQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposGetCombinedStatusForRef200Schema = combinedCommitStatusSchema.describe("Combined Commit Status")

/**
 * @description Resource not found
 */
export const reposGetCombinedStatusForRef404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetCombinedStatusForRefQueryResponseSchema = reposGetCombinedStatusForRef200Schema

export const reposListCommitStatusesForRefPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ref": z.string().describe("The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.")
    })

export const reposListCommitStatusesForRefQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListCommitStatusesForRef200Schema = z.array(statusSchema.describe("The status of a commit."))

/**
 * @description Moved permanently
 */
export const reposListCommitStatusesForRef301Schema = basicErrorSchema.describe("Basic Error")

export const reposListCommitStatusesForRefQueryResponseSchema = reposListCommitStatusesForRef200Schema

export const reposGetCommunityProfileMetricsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposGetCommunityProfileMetrics200Schema = communityProfileSchema.describe("Community Profile")

export const reposGetCommunityProfileMetricsQueryResponseSchema = reposGetCommunityProfileMetrics200Schema

export const reposCompareCommitsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"basehead": z.string().describe("The base branch and head branch to compare. This parameter expects the format `BASE...HEAD`. Both must be branch names in `repo`. To compare with a branch that exists in a different repository in the same network as `repo`, the `basehead` parameter expects the format `USERNAME:BASE...USERNAME:HEAD`.")
    })

export const reposCompareCommitsQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposCompareCommits200Schema = commitComparisonSchema.describe("Commit Comparison")

/**
 * @description Resource not found
 */
export const reposCompareCommits404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposCompareCommits500Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const reposCompareCommits503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const reposCompareCommitsQueryResponseSchema = reposCompareCommits200Schema

export const reposGetContentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"path": z.string().describe("path parameter")
    })

export const reposGetContentQueryParamsSchema = z.object({
    "ref": z.optional(z.string().describe("The name of the commit/branch/tag. Default: the repositorys default branch."))
    }).optional()

/**
 * @description Response
 */
export const reposGetContent200Schema = z.union([contentDirectorySchema.and(z.object({
    "type": z.literal("array")
    })), contentFileSchema.and(z.object({
    "type": z.literal("file")
    })), contentSymlinkSchema.and(z.object({
    "type": z.literal("symlink")
    })), contentSubmoduleSchema.and(z.object({
    "type": z.literal("submodule")
    }))])

/**
 * @description Found
 */
export const reposGetContent302Schema = z.unknown()

/**
 * @description Not modified
 */
export const reposGetContent304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const reposGetContent403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposGetContent404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetContentQueryResponseSchema = reposGetContent200Schema

export const reposCreateOrUpdateFileContentsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"path": z.string().describe("path parameter")
    })

/**
 * @description Response
 */
export const reposCreateOrUpdateFileContents200Schema = fileCommitSchema.describe("File Commit")

/**
 * @description Response
 */
export const reposCreateOrUpdateFileContents201Schema = fileCommitSchema.describe("File Commit")

/**
 * @description Resource not found
 */
export const reposCreateOrUpdateFileContents404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const reposCreateOrUpdateFileContents409Schema = z.union([basicErrorSchema, repositoryRuleViolationErrorSchema])

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposCreateOrUpdateFileContents422Schema = validationErrorSchema.describe("Validation Error")

export const reposCreateOrUpdateFileContentsMutationRequestSchema = z.object({
    "message": z.string().describe("The commit message."),
"content": z.string().describe("The new file content, using Base64 encoding."),
"sha": z.optional(z.string().describe("**Required if you are updating a file**. The blob SHA of the file being replaced.")),
"branch": z.optional(z.string().describe("The branch name. Default: the repositorys default branch.")),
"committer": z.optional(z.object({
    "name": z.string().describe("The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted."),
"email": z.string().describe("The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted."),
"date": z.optional(z.string())
    }).describe("The person that committed the file. Default: the authenticated user.")),
"author": z.optional(z.object({
    "name": z.string().describe("The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted."),
"email": z.string().describe("The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted."),
"date": z.optional(z.string())
    }).describe("The author of the file. Default: The `committer` or the authenticated user if you omit `committer`."))
    })

export const reposCreateOrUpdateFileContentsMutationResponseSchema = z.union([reposCreateOrUpdateFileContents200Schema, reposCreateOrUpdateFileContents201Schema])

export const reposDeleteFilePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"path": z.string().describe("path parameter")
    })

/**
 * @description Response
 */
export const reposDeleteFile200Schema = fileCommitSchema.describe("File Commit")

/**
 * @description Resource not found
 */
export const reposDeleteFile404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const reposDeleteFile409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposDeleteFile422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Service unavailable
 */
export const reposDeleteFile503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const reposDeleteFileMutationRequestSchema = z.object({
    "message": z.string().describe("The commit message."),
"sha": z.string().describe("The blob SHA of the file being deleted."),
"branch": z.optional(z.string().describe("The branch name. Default: the repositorys default branch")),
"committer": z.optional(z.object({
    "name": z.optional(z.string().describe("The name of the author (or committer) of the commit")),
"email": z.optional(z.string().describe("The email of the author (or committer) of the commit"))
    }).describe("object containing information about the committer.")),
"author": z.optional(z.object({
    "name": z.optional(z.string().describe("The name of the author (or committer) of the commit")),
"email": z.optional(z.string().describe("The email of the author (or committer) of the commit"))
    }).describe("object containing information about the author."))
    })

export const reposDeleteFileMutationResponseSchema = reposDeleteFile200Schema

export const reposListContributorsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposListContributorsQueryParamsSchema = z.object({
    "anon": z.optional(z.string().describe("Set to `1` or `true` to include anonymous contributors in results.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description If repository contains content
 */
export const reposListContributors200Schema = z.array(contributorSchema.describe("Contributor"))

/**
 * @description Response if repository is empty
 */
export const reposListContributors204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const reposListContributors403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposListContributors404Schema = basicErrorSchema.describe("Basic Error")

export const reposListContributorsQueryResponseSchema = z.union([reposListContributors200Schema, reposListContributors204Schema])

export const dependabotListAlertsForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const dependabotListAlertsForRepoQueryParamsSchema = z.object({
    "state": z.optional(z.string().describe("A comma-separated list of states. If specified, only alerts with these states will be returned.\n\nCan be: `auto_dismissed`, `dismissed`, `fixed`, `open`")),
"severity": z.optional(z.string().describe("A comma-separated list of severities. If specified, only alerts with these severities will be returned.\n\nCan be: `low`, `medium`, `high`, `critical`")),
"ecosystem": z.optional(z.string().describe("A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.\n\nCan be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`")),
"package": z.optional(z.string().describe("A comma-separated list of package names. If specified, only alerts for these packages will be returned.")),
"manifest": z.optional(z.string().describe("A comma-separated list of full manifest paths. If specified, only alerts for these manifests will be returned.")),
"epss_percentage": z.optional(z.string().describe("CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as:\n- An exact number (`n`)\n- Comparators such as `>n`, `<n`, `>=n`, `<=n`\n- A range like `n..n`, where `n` is a number from 0.0 to 1.0\n\nFilters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned.")),
"has": z.optional(z.union([z.array(z.enum(["patch"])), z.string()]).describe("Filters the list of alerts based on whether the alert has the given value. If specified, only alerts meeting this criterion will be returned.\nMultiple `has` filters can be passed to filter for alerts that have all of the values. Currently, only `patch` is supported.")),
"scope": z.optional(z.enum(["development", "runtime"]).describe("The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.")),
"sort": z.enum(["created", "updated", "epss_percentage"]).default("created").describe("The property by which to sort the results.\n`created` means when the alert was created.\n`updated` means when the alert's state last changed.\n`epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage."),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""))
    })

/**
 * @description Response
 */
export const dependabotListAlertsForRepo200Schema = z.array(dependabotAlertSchema.describe("A Dependabot alert."))

/**
 * @description Not modified
 */
export const dependabotListAlertsForRepo304Schema = z.unknown()

/**
 * @description Bad Request
 */
export const dependabotListAlertsForRepo400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const dependabotListAlertsForRepo403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const dependabotListAlertsForRepo404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const dependabotListAlertsForRepo422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const dependabotListAlertsForRepoQueryResponseSchema = dependabotListAlertsForRepo200Schema

export const dependabotGetAlertPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
get "alert_number"(){
                return alertNumberSchema.describe("The security alert number.")
              }
    })

/**
 * @description Response
 */
export const dependabotGetAlert200Schema = dependabotAlertSchema.describe("A Dependabot alert.")

/**
 * @description Not modified
 */
export const dependabotGetAlert304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const dependabotGetAlert403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const dependabotGetAlert404Schema = basicErrorSchema.describe("Basic Error")

export const dependabotGetAlertQueryResponseSchema = dependabotGetAlert200Schema

export const dependabotUpdateAlertPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
get "alert_number"(){
                return alertNumberSchema.describe("The security alert number.")
              }
    })

/**
 * @description Response
 */
export const dependabotUpdateAlert200Schema = dependabotAlertSchema.describe("A Dependabot alert.")

/**
 * @description Bad Request
 */
export const dependabotUpdateAlert400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const dependabotUpdateAlert403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const dependabotUpdateAlert404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const dependabotUpdateAlert409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const dependabotUpdateAlert422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const dependabotUpdateAlertMutationRequestSchema = z.object({
    "state": z.enum(["dismissed", "open"]).describe("The state of the Dependabot alert.\nA `dismissed_reason` must be provided when setting the state to `dismissed`."),
"dismissed_reason": z.optional(z.enum(["fix_started", "inaccurate", "no_bandwidth", "not_used", "tolerable_risk"]).describe("**Required when `state` is `dismissed`.** A reason for dismissing the alert.")),
"dismissed_comment": z.optional(z.string().max(280).describe("An optional comment associated with dismissing the alert."))
    })

export const dependabotUpdateAlertMutationResponseSchema = dependabotUpdateAlert200Schema

export const dependabotListRepoSecretsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const dependabotListRepoSecretsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const dependabotListRepoSecrets200Schema = z.object({
    "total_count": z.int(),
get "secrets"(){
                return z.array(dependabotSecretSchema.describe("Set secrets for Dependabot."))
              }
    })

export const dependabotListRepoSecretsQueryResponseSchema = dependabotListRepoSecrets200Schema

export const dependabotGetRepoPublicKeyPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const dependabotGetRepoPublicKey200Schema = dependabotPublicKeySchema.describe("The public key used for setting Dependabot Secrets.")

export const dependabotGetRepoPublicKeyQueryResponseSchema = dependabotGetRepoPublicKey200Schema

export const dependabotGetRepoSecretPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const dependabotGetRepoSecret200Schema = dependabotSecretSchema.describe("Set secrets for Dependabot.")

export const dependabotGetRepoSecretQueryResponseSchema = dependabotGetRepoSecret200Schema

export const dependabotCreateOrUpdateRepoSecretPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response when creating a secret
 */
export const dependabotCreateOrUpdateRepoSecret201Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Response when updating a secret
 */
export const dependabotCreateOrUpdateRepoSecret204Schema = z.unknown()

export const dependabotCreateOrUpdateRepoSecretMutationRequestSchema = z.object({
    "encrypted_value": z.optional(z.string().regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$/).describe("Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/dependabot/secrets#get-a-repository-public-key) endpoint.")),
"key_id": z.optional(z.string().describe("ID of the key you used to encrypt the secret."))
    })

export const dependabotCreateOrUpdateRepoSecretMutationResponseSchema = z.union([dependabotCreateOrUpdateRepoSecret201Schema, dependabotCreateOrUpdateRepoSecret204Schema])

export const dependabotDeleteRepoSecretPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const dependabotDeleteRepoSecret204Schema = z.unknown()

export const dependabotDeleteRepoSecretMutationResponseSchema = dependabotDeleteRepoSecret204Schema

export const dependencyGraphDiffRangePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"basehead": z.string().describe("The base and head Git revisions to compare. The Git revisions will be resolved to commit SHAs. Named revisions will be resolved to their corresponding HEAD commits, and an appropriate merge base will be determined. This parameter expects the format `{base}...{head}`.")
    })

export const dependencyGraphDiffRangeQueryParamsSchema = z.object({
    "name": z.optional(z.string().describe("The full path, relative to the repository root, of the dependency manifest file."))
    }).optional()

/**
 * @description Response
 */
export const dependencyGraphDiffRange200Schema = dependencyGraphDiffSchema.describe("A diff of the dependencies between two commits.")

/**
 * @description Response for a private repository when GitHub Advanced Security is not enabled, or if used against a fork
 */
export const dependencyGraphDiffRange403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const dependencyGraphDiffRange404Schema = basicErrorSchema.describe("Basic Error")

export const dependencyGraphDiffRangeQueryResponseSchema = dependencyGraphDiffRange200Schema

export const dependencyGraphExportSbomPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const dependencyGraphExportSbom200Schema = dependencyGraphSpdxSbomSchema.describe("A schema for the SPDX JSON format returned by the Dependency Graph.")

/**
 * @description Forbidden
 */
export const dependencyGraphExportSbom403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const dependencyGraphExportSbom404Schema = basicErrorSchema.describe("Basic Error")

export const dependencyGraphExportSbomQueryResponseSchema = dependencyGraphExportSbom200Schema

export const dependencyGraphCreateRepositorySnapshotPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const dependencyGraphCreateRepositorySnapshot201Schema = z.object({
    "id": z.int().describe("ID of the created snapshot."),
"created_at": z.string().describe("The time at which the snapshot was created."),
"result": z.string().describe("Either \"SUCCESS\", \"ACCEPTED\", or \"INVALID\". \"SUCCESS\" indicates that the snapshot was successfully created and the repository's dependencies were updated. \"ACCEPTED\" indicates that the snapshot was successfully created, but the repository's dependencies were not updated. \"INVALID\" indicates that the snapshot was malformed."),
"message": z.string().describe("A message providing further details about the result, such as why the dependencies were not updated.")
    })

export const dependencyGraphCreateRepositorySnapshotMutationRequestSchema = snapshotSchema.describe("Create a new snapshot of a repository's dependencies.")

export const dependencyGraphCreateRepositorySnapshotMutationResponseSchema = dependencyGraphCreateRepositorySnapshot201Schema

export const reposListDeploymentsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposListDeploymentsQueryParamsSchema = z.object({
    "sha": z.string().default("none").describe("The SHA recorded at creation time."),
"ref": z.string().default("none").describe("The name of the ref. This can be a branch, tag, or SHA."),
"task": z.string().default("none").describe("The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`)."),
"environment": z.nullable(z.string().default("none").describe("The name of the environment that was deployed to (e.g., `staging` or `production`).")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListDeployments200Schema = z.array(deploymentSchema.describe("A request for a specific ref(branch,sha,tag) to be deployed"))

export const reposListDeploymentsQueryResponseSchema = reposListDeployments200Schema

export const reposCreateDeploymentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposCreateDeployment201Schema = deploymentSchema.describe("A request for a specific ref(branch,sha,tag) to be deployed")

/**
 * @description Merged branch response
 */
export const reposCreateDeployment202Schema = z.object({
    "message": z.optional(z.string())
    })

/**
 * @description Conflict when there is a merge conflict or the commit\'s status checks failed
 */
export const reposCreateDeployment409Schema = z.unknown()

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposCreateDeployment422Schema = validationErrorSchema.describe("Validation Error")

export const reposCreateDeploymentMutationRequestSchema = z.object({
    "ref": z.string().describe("The ref to deploy. This can be a branch, tag, or SHA."),
"task": z.optional(z.string().default("deploy").describe("Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).")),
"auto_merge": z.optional(z.boolean().default(true).describe("Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch.")),
"required_contexts": z.optional(z.array(z.string()).describe("The [status](https://docs.github.com/rest/commits/statuses) contexts to verify against commit status checks. If you omit this parameter, GitHub verifies all unique contexts before creating a deployment. To bypass checking entirely, pass an empty array. Defaults to all unique contexts.")),
"payload": z.optional(z.union([z.string(), z.object({
    
    }).catchall(z.unknown())])),
"environment": z.optional(z.string().default("production").describe("Name for the target deployment environment (e.g., `production`, `staging`, `qa`).")),
"description": z.string().default("").describe("Short description of the deployment.").nullish(),
"transient_environment": z.optional(z.boolean().default(false).describe("Specifies if the given environment is specific to the deployment and will no longer exist at some point in the future. Default: `false`")),
"production_environment": z.optional(z.boolean().describe("Specifies if the given environment is one that end-users directly interact with. Default: `true` when `environment` is `production` and `false` otherwise."))
    })

export const reposCreateDeploymentMutationResponseSchema = z.union([reposCreateDeployment201Schema, reposCreateDeployment202Schema])

export const reposGetDeploymentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"deployment_id": z.coerce.number().int().describe("deployment_id parameter")
    })

/**
 * @description Response
 */
export const reposGetDeployment200Schema = deploymentSchema.describe("A request for a specific ref(branch,sha,tag) to be deployed")

/**
 * @description Resource not found
 */
export const reposGetDeployment404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetDeploymentQueryResponseSchema = reposGetDeployment200Schema

export const reposDeleteDeploymentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"deployment_id": z.coerce.number().int().describe("deployment_id parameter")
    })

/**
 * @description Response
 */
export const reposDeleteDeployment204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposDeleteDeployment404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposDeleteDeployment422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const reposDeleteDeploymentMutationResponseSchema = reposDeleteDeployment204Schema

export const reposListDeploymentStatusesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"deployment_id": z.coerce.number().int().describe("deployment_id parameter")
    })

export const reposListDeploymentStatusesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListDeploymentStatuses200Schema = z.array(deploymentStatusSchema.describe("The status of a deployment."))

/**
 * @description Resource not found
 */
export const reposListDeploymentStatuses404Schema = basicErrorSchema.describe("Basic Error")

export const reposListDeploymentStatusesQueryResponseSchema = reposListDeploymentStatuses200Schema

export const reposCreateDeploymentStatusPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"deployment_id": z.coerce.number().int().describe("deployment_id parameter")
    })

/**
 * @description Response
 */
export const reposCreateDeploymentStatus201Schema = deploymentStatusSchema.describe("The status of a deployment.")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposCreateDeploymentStatus422Schema = validationErrorSchema.describe("Validation Error")

export const reposCreateDeploymentStatusMutationRequestSchema = z.object({
    "state": z.enum(["error", "failure", "inactive", "in_progress", "queued", "pending", "success"]).describe("The state of the status. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub."),
"target_url": z.optional(z.string().default("").describe("The target URL to associate with this status. This URL should contain output to keep the user updated while the task is running or serve as historical information for what happened in the deployment.\n\n> [!NOTE]\n> It's recommended to use the `log_url` parameter, which replaces `target_url`.")),
"log_url": z.optional(z.string().default("").describe("The full URL of the deployment's output. This parameter replaces `target_url`. We will continue to accept `target_url` to support legacy uses, but we recommend replacing `target_url` with `log_url`. Setting `log_url` will automatically set `target_url` to the same value. Default: `\"\"`")),
"description": z.optional(z.string().default("").describe("A short description of the status. The maximum description length is 140 characters.")),
"environment": z.optional(z.string().describe("Name for the target deployment environment, which can be changed when setting a deploy status. For example, `production`, `staging`, or `qa`. If not defined, the environment of the previous status on the deployment will be used, if it exists. Otherwise, the environment of the deployment will be used.")),
"environment_url": z.optional(z.string().default("").describe("Sets the URL for accessing your environment. Default: `\"\"`")),
"auto_inactive": z.optional(z.boolean().describe("Adds a new `inactive` status to all prior non-transient, non-production environment deployments with the same repository and `environment` name as the created status's deployment. An `inactive` status is only added to deployments that had a `success` state. Default: `true`"))
    })

export const reposCreateDeploymentStatusMutationResponseSchema = reposCreateDeploymentStatus201Schema

export const reposGetDeploymentStatusPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"deployment_id": z.coerce.number().int().describe("deployment_id parameter"),
"status_id": z.coerce.number().int()
    })

/**
 * @description Response
 */
export const reposGetDeploymentStatus200Schema = deploymentStatusSchema.describe("The status of a deployment.")

/**
 * @description Resource not found
 */
export const reposGetDeploymentStatus404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetDeploymentStatusQueryResponseSchema = reposGetDeploymentStatus200Schema

export const reposCreateDispatchEventPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposCreateDispatchEvent204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposCreateDispatchEvent404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposCreateDispatchEvent422Schema = validationErrorSchema.describe("Validation Error")

export const reposCreateDispatchEventMutationRequestSchema = z.object({
    "event_type": z.string().min(1).max(100).describe("A custom webhook event name. Must be 100 characters or fewer."),
"client_payload": z.optional(z.object({
    
    }).catchall(z.unknown()).describe("JSON payload with extra information about the webhook event that your action or workflow may use. The maximum number of top-level properties is 10. The total size of the JSON payload must be less than 64KB."))
    })

export const reposCreateDispatchEventMutationResponseSchema = reposCreateDispatchEvent204Schema

export const reposGetAllEnvironmentsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposGetAllEnvironmentsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposGetAllEnvironments200Schema = z.object({
    "total_count": z.optional(z.int().describe("The number of environments in this repository")),
get "environments"(){
                return z.array(environmentSchema.describe("Details of a deployment environment")).optional()
              }
    })

export const reposGetAllEnvironmentsQueryResponseSchema = reposGetAllEnvironments200Schema

export const reposGetEnvironmentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.")
    })

/**
 * @description Response
 */
export const reposGetEnvironment200Schema = environmentSchema.describe("Details of a deployment environment")

export const reposGetEnvironmentQueryResponseSchema = reposGetEnvironment200Schema

export const reposCreateOrUpdateEnvironmentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.")
    })

/**
 * @description Response
 */
export const reposCreateOrUpdateEnvironment200Schema = environmentSchema.describe("Details of a deployment environment")

/**
 * @description Validation error when the environment name is invalid or when `protected_branches` and `custom_branch_policies` in `deployment_branch_policy` are set to the same value
 */
export const reposCreateOrUpdateEnvironment422Schema = basicErrorSchema.describe("Basic Error")

export const reposCreateOrUpdateEnvironmentMutationRequestSchema = z.object({
    get "wait_timer"(){
                return waitTimerSchema.describe("The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days).").optional()
              },
get "prevent_self_review"(){
                return preventSelfReviewSchema.describe("Whether or not a user who created the job is prevented from approving their own job.").optional()
              },
"reviewers": z.array(z.object({
    get "type"(){
                return deploymentReviewerTypeSchema.describe("The type of reviewer.").optional()
              },
"id": z.optional(z.int().describe("The id of the user or team who can review the deployment"))
    })).describe("The people or teams that may review jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.").nullish(),
get "deployment_branch_policy"(){
                return deploymentBranchPolicySettingsSchema.describe("The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.").optional()
              }
    }).nullable()

export const reposCreateOrUpdateEnvironmentMutationResponseSchema = reposCreateOrUpdateEnvironment200Schema

export const reposDeleteAnEnvironmentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.")
    })

/**
 * @description Default response
 */
export const reposDeleteAnEnvironment204Schema = z.unknown()

export const reposDeleteAnEnvironmentMutationResponseSchema = reposDeleteAnEnvironment204Schema

export const reposListDeploymentBranchPoliciesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.")
    })

export const reposListDeploymentBranchPoliciesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListDeploymentBranchPolicies200Schema = z.object({
    "total_count": z.int().describe("The number of deployment branch policies for the environment."),
get "branch_policies"(){
                return z.array(deploymentBranchPolicySchema.describe("Details of a deployment branch or tag policy."))
              }
    })

export const reposListDeploymentBranchPoliciesQueryResponseSchema = reposListDeploymentBranchPolicies200Schema

export const reposCreateDeploymentBranchPolicyPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.")
    })

/**
 * @description Response
 */
export const reposCreateDeploymentBranchPolicy200Schema = deploymentBranchPolicySchema.describe("Details of a deployment branch or tag policy.")

/**
 * @description Response if the same branch name pattern already exists
 */
export const reposCreateDeploymentBranchPolicy303Schema = z.unknown()

/**
 * @description Not Found or `deployment_branch_policy.custom_branch_policies` property for the environment is set to false
 */
export const reposCreateDeploymentBranchPolicy404Schema = z.unknown()

export const reposCreateDeploymentBranchPolicyMutationRequestSchema = deploymentBranchPolicyNamePatternWithTypeSchema

export const reposCreateDeploymentBranchPolicyMutationResponseSchema = reposCreateDeploymentBranchPolicy200Schema

export const reposGetDeploymentBranchPolicyPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`."),
"branch_policy_id": z.coerce.number().int().describe("The unique identifier of the branch policy.")
    })

/**
 * @description Response
 */
export const reposGetDeploymentBranchPolicy200Schema = deploymentBranchPolicySchema.describe("Details of a deployment branch or tag policy.")

export const reposGetDeploymentBranchPolicyQueryResponseSchema = reposGetDeploymentBranchPolicy200Schema

export const reposUpdateDeploymentBranchPolicyPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`."),
"branch_policy_id": z.coerce.number().int().describe("The unique identifier of the branch policy.")
    })

/**
 * @description Response
 */
export const reposUpdateDeploymentBranchPolicy200Schema = deploymentBranchPolicySchema.describe("Details of a deployment branch or tag policy.")

export const reposUpdateDeploymentBranchPolicyMutationRequestSchema = deploymentBranchPolicyNamePatternSchema

export const reposUpdateDeploymentBranchPolicyMutationResponseSchema = reposUpdateDeploymentBranchPolicy200Schema

export const reposDeleteDeploymentBranchPolicyPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`."),
"branch_policy_id": z.coerce.number().int().describe("The unique identifier of the branch policy.")
    })

/**
 * @description Response
 */
export const reposDeleteDeploymentBranchPolicy204Schema = z.unknown()

export const reposDeleteDeploymentBranchPolicyMutationResponseSchema = reposDeleteDeploymentBranchPolicy204Schema

export const reposGetAllDeploymentProtectionRulesPathParamsSchema = z.object({
    "environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"owner": z.string().describe("The account owner of the repository. The name is not case sensitive.")
    })

/**
 * @description List of deployment protection rules
 */
export const reposGetAllDeploymentProtectionRules200Schema = z.object({
    "total_count": z.optional(z.int().describe("The number of enabled custom deployment protection rules for this environment")),
get "custom_deployment_protection_rules"(){
                return z.array(deploymentProtectionRuleSchema.describe("Deployment protection rule")).optional()
              }
    })

export const reposGetAllDeploymentProtectionRulesQueryResponseSchema = reposGetAllDeploymentProtectionRules200Schema

export const reposCreateDeploymentProtectionRulePathParamsSchema = z.object({
    "environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"owner": z.string().describe("The account owner of the repository. The name is not case sensitive.")
    })

/**
 * @description The enabled custom deployment protection rule
 */
export const reposCreateDeploymentProtectionRule201Schema = deploymentProtectionRuleSchema.describe("Deployment protection rule")

export const reposCreateDeploymentProtectionRuleMutationRequestSchema = z.object({
    "integration_id": z.optional(z.int().describe("The ID of the custom app that will be enabled on the environment."))
    })

export const reposCreateDeploymentProtectionRuleMutationResponseSchema = reposCreateDeploymentProtectionRule201Schema

export const reposListCustomDeploymentRuleIntegrationsPathParamsSchema = z.object({
    "environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"owner": z.string().describe("The account owner of the repository. The name is not case sensitive.")
    })

export const reposListCustomDeploymentRuleIntegrationsQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description A list of custom deployment rule integrations available for this environment.
 */
export const reposListCustomDeploymentRuleIntegrations200Schema = z.object({
    "total_count": z.optional(z.int().describe("The total number of custom deployment protection rule integrations available for this environment.")),
get "available_custom_deployment_protection_rule_integrations"(){
                return z.array(customDeploymentRuleAppSchema.describe("A GitHub App that is providing a custom deployment protection rule.")).optional()
              }
    })

export const reposListCustomDeploymentRuleIntegrationsQueryResponseSchema = reposListCustomDeploymentRuleIntegrations200Schema

export const reposGetCustomDeploymentProtectionRulePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`."),
"protection_rule_id": z.coerce.number().int().describe("The unique identifier of the protection rule.")
    })

/**
 * @description Response
 */
export const reposGetCustomDeploymentProtectionRule200Schema = deploymentProtectionRuleSchema.describe("Deployment protection rule")

export const reposGetCustomDeploymentProtectionRuleQueryResponseSchema = reposGetCustomDeploymentProtectionRule200Schema

export const reposDisableDeploymentProtectionRulePathParamsSchema = z.object({
    "environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"protection_rule_id": z.coerce.number().int().describe("The unique identifier of the protection rule.")
    })

/**
 * @description Response
 */
export const reposDisableDeploymentProtectionRule204Schema = z.unknown()

export const reposDisableDeploymentProtectionRuleMutationResponseSchema = reposDisableDeploymentProtectionRule204Schema

export const actionsListEnvironmentSecretsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.")
    })

export const actionsListEnvironmentSecretsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListEnvironmentSecrets200Schema = z.object({
    "total_count": z.int(),
get "secrets"(){
                return z.array(actionsSecretSchema.describe("Set secrets for GitHub Actions."))
              }
    })

export const actionsListEnvironmentSecretsQueryResponseSchema = actionsListEnvironmentSecrets200Schema

export const actionsGetEnvironmentPublicKeyPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.")
    })

/**
 * @description Response
 */
export const actionsGetEnvironmentPublicKey200Schema = actionsPublicKeySchema.describe("The public key used for setting Actions Secrets.")

export const actionsGetEnvironmentPublicKeyQueryResponseSchema = actionsGetEnvironmentPublicKey200Schema

export const actionsGetEnvironmentSecretPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const actionsGetEnvironmentSecret200Schema = actionsSecretSchema.describe("Set secrets for GitHub Actions.")

export const actionsGetEnvironmentSecretQueryResponseSchema = actionsGetEnvironmentSecret200Schema

export const actionsCreateOrUpdateEnvironmentSecretPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response when creating a secret
 */
export const actionsCreateOrUpdateEnvironmentSecret201Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Response when updating a secret
 */
export const actionsCreateOrUpdateEnvironmentSecret204Schema = z.unknown()

export const actionsCreateOrUpdateEnvironmentSecretMutationRequestSchema = z.object({
    "encrypted_value": z.string().regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$/).describe("Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an environment public key](https://docs.github.com/rest/actions/secrets#get-an-environment-public-key) endpoint."),
"key_id": z.string().describe("ID of the key you used to encrypt the secret.")
    })

export const actionsCreateOrUpdateEnvironmentSecretMutationResponseSchema = z.union([actionsCreateOrUpdateEnvironmentSecret201Schema, actionsCreateOrUpdateEnvironmentSecret204Schema])

export const actionsDeleteEnvironmentSecretPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`."),
"secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Default response
 */
export const actionsDeleteEnvironmentSecret204Schema = z.unknown()

export const actionsDeleteEnvironmentSecretMutationResponseSchema = actionsDeleteEnvironmentSecret204Schema

export const actionsListEnvironmentVariablesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.")
    })

export const actionsListEnvironmentVariablesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(10).describe("The number of results per page (max 30). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const actionsListEnvironmentVariables200Schema = z.object({
    "total_count": z.int(),
get "variables"(){
                return z.array(actionsVariableSchema)
              }
    })

export const actionsListEnvironmentVariablesQueryResponseSchema = actionsListEnvironmentVariables200Schema

export const actionsCreateEnvironmentVariablePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.")
    })

/**
 * @description Response
 */
export const actionsCreateEnvironmentVariable201Schema = emptyObjectSchema.describe("An object without any properties.")

export const actionsCreateEnvironmentVariableMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the variable."),
"value": z.string().describe("The value of the variable.")
    })

export const actionsCreateEnvironmentVariableMutationResponseSchema = actionsCreateEnvironmentVariable201Schema

export const actionsGetEnvironmentVariablePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`."),
"name": z.string().describe("The name of the variable.")
    })

/**
 * @description Response
 */
export const actionsGetEnvironmentVariable200Schema = actionsVariableSchema

export const actionsGetEnvironmentVariableQueryResponseSchema = actionsGetEnvironmentVariable200Schema

export const actionsUpdateEnvironmentVariablePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"name": z.string().describe("The name of the variable."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.")
    })

/**
 * @description Response
 */
export const actionsUpdateEnvironmentVariable204Schema = z.unknown()

export const actionsUpdateEnvironmentVariableMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("The name of the variable.")),
"value": z.optional(z.string().describe("The value of the variable."))
    })

export const actionsUpdateEnvironmentVariableMutationResponseSchema = actionsUpdateEnvironmentVariable204Schema

export const actionsDeleteEnvironmentVariablePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"name": z.string().describe("The name of the variable."),
"environment_name": z.string().describe("The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.")
    })

/**
 * @description Response
 */
export const actionsDeleteEnvironmentVariable204Schema = z.unknown()

export const actionsDeleteEnvironmentVariableMutationResponseSchema = actionsDeleteEnvironmentVariable204Schema

export const activityListRepoEventsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const activityListRepoEventsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListRepoEvents200Schema = z.array(eventSchema.describe("Event"))

export const activityListRepoEventsQueryResponseSchema = activityListRepoEvents200Schema

export const reposListForksPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposListForksQueryParamsSchema = z.object({
    "sort": z.enum(["newest", "oldest", "stargazers", "watchers"]).default("newest").describe("The sort order. `stargazers` will sort by star count."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListForks200Schema = z.array(minimalRepositorySchema.describe("Minimal Repository"))

/**
 * @description Bad Request
 */
export const reposListForks400Schema = basicErrorSchema.describe("Basic Error")

export const reposListForksQueryResponseSchema = reposListForks200Schema

export const reposCreateForkPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposCreateFork202Schema = fullRepositorySchema.describe("Full Repository")

/**
 * @description Bad Request
 */
export const reposCreateFork400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const reposCreateFork403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposCreateFork404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposCreateFork422Schema = validationErrorSchema.describe("Validation Error")

export const reposCreateForkMutationRequestSchema = z.object({
    "organization": z.optional(z.string().describe("Optional parameter to specify the organization name if forking into an organization.")),
"name": z.optional(z.string().describe("When forking from an existing repository, a new name for the fork.")),
"default_branch_only": z.optional(z.boolean().describe("When forking from an existing repository, fork with only the default branch."))
    }).nullable()

export const reposCreateForkMutationResponseSchema = reposCreateFork202Schema

export const gitCreateBlobPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const gitCreateBlob201Schema = shortBlobSchema.describe("Short Blob")

/**
 * @description Forbidden
 */
export const gitCreateBlob403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const gitCreateBlob404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const gitCreateBlob409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed
 */
export const gitCreateBlob422Schema = z.union([validationErrorSchema, repositoryRuleViolationErrorSchema])

export const gitCreateBlobMutationRequestSchema = z.object({
    "content": z.string().describe("The new blob's content."),
"encoding": z.optional(z.string().default("utf-8").describe("The encoding used for `content`. Currently, `\"utf-8\"` and `\"base64\"` are supported."))
    })

export const gitCreateBlobMutationResponseSchema = gitCreateBlob201Schema

export const gitGetBlobPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"file_sha": z.string()
    })

/**
 * @description Response
 */
export const gitGetBlob200Schema = blobSchema.describe("Blob")

/**
 * @description Forbidden
 */
export const gitGetBlob403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const gitGetBlob404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const gitGetBlob409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const gitGetBlob422Schema = validationErrorSchema.describe("Validation Error")

export const gitGetBlobQueryResponseSchema = gitGetBlob200Schema

export const gitCreateCommitPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const gitCreateCommit201Schema = gitCommitSchema.describe("Low-level Git commit operations within a repository")

/**
 * @description Resource not found
 */
export const gitCreateCommit404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const gitCreateCommit409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const gitCreateCommit422Schema = validationErrorSchema.describe("Validation Error")

export const gitCreateCommitMutationRequestSchema = z.object({
    "message": z.string().describe("The commit message"),
"tree": z.string().describe("The SHA of the tree object this commit points to"),
"parents": z.optional(z.array(z.string()).describe("The full SHAs of the commits that were the parents of this commit. If omitted or empty, the commit will be written as a root commit. For a single parent, an array of one SHA should be provided; for a merge commit, an array of more than one should be provided.")),
"author": z.optional(z.object({
    "name": z.string().describe("The name of the author (or committer) of the commit"),
"email": z.string().describe("The email of the author (or committer) of the commit"),
"date": z.optional(z.iso.datetime({ offset: true }).describe("Indicates when this commit was authored (or committed). This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."))
    }).describe("Information about the author of the commit. By default, the `author` will be the authenticated user and the current date. See the `author` and `committer` object below for details.")),
"committer": z.optional(z.object({
    "name": z.optional(z.string().describe("The name of the author (or committer) of the commit")),
"email": z.optional(z.string().describe("The email of the author (or committer) of the commit")),
"date": z.optional(z.iso.datetime({ offset: true }).describe("Indicates when this commit was authored (or committed). This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."))
    }).describe("Information about the person who is making the commit. By default, `committer` will use the information set in `author`. See the `author` and `committer` object below for details.")),
"signature": z.optional(z.string().describe("The [PGP signature](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) of the commit. GitHub adds the signature to the `gpgsig` header of the created commit. For a commit signature to be verifiable by Git or GitHub, it must be an ASCII-armored detached PGP signature over the string commit as it would be written to the object database. To pass a `signature` parameter, you need to first manually create a valid PGP signature, which can be complicated. You may find it easier to [use the command line](https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work) to create signed commits."))
    })

export const gitCreateCommitMutationResponseSchema = gitCreateCommit201Schema

export const gitGetCommitPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"commit_sha": z.string().describe("The SHA of the commit.")
    })

/**
 * @description Response
 */
export const gitGetCommit200Schema = gitCommitSchema.describe("Low-level Git commit operations within a repository")

/**
 * @description Resource not found
 */
export const gitGetCommit404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const gitGetCommit409Schema = basicErrorSchema.describe("Basic Error")

export const gitGetCommitQueryResponseSchema = gitGetCommit200Schema

export const gitListMatchingRefsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ref": z.string().describe("The Git reference. For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.")
    })

/**
 * @description Response
 */
export const gitListMatchingRefs200Schema = z.array(gitRefSchema.describe("Git references within a repository"))

/**
 * @description Conflict
 */
export const gitListMatchingRefs409Schema = basicErrorSchema.describe("Basic Error")

export const gitListMatchingRefsQueryResponseSchema = gitListMatchingRefs200Schema

export const gitGetRefPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ref": z.string().describe("The Git reference. For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.")
    })

/**
 * @description Response
 */
export const gitGetRef200Schema = gitRefSchema.describe("Git references within a repository")

/**
 * @description Resource not found
 */
export const gitGetRef404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const gitGetRef409Schema = basicErrorSchema.describe("Basic Error")

export const gitGetRefQueryResponseSchema = gitGetRef200Schema

export const gitCreateRefPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const gitCreateRef201Schema = gitRefSchema.describe("Git references within a repository")

/**
 * @description Conflict
 */
export const gitCreateRef409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const gitCreateRef422Schema = validationErrorSchema.describe("Validation Error")

export const gitCreateRefMutationRequestSchema = z.object({
    "ref": z.string().describe("The name of the fully qualified reference (ie: `refs/heads/master`). If it doesn't start with 'refs' and have at least two slashes, it will be rejected."),
"sha": z.string().describe("The SHA1 value for this reference.")
    })

export const gitCreateRefMutationResponseSchema = gitCreateRef201Schema

export const gitUpdateRefPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ref": z.string().describe("The Git reference. For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.")
    })

/**
 * @description Response
 */
export const gitUpdateRef200Schema = gitRefSchema.describe("Git references within a repository")

/**
 * @description Conflict
 */
export const gitUpdateRef409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const gitUpdateRef422Schema = validationErrorSchema.describe("Validation Error")

export const gitUpdateRefMutationRequestSchema = z.object({
    "sha": z.string().describe("The SHA1 value to set this reference to"),
"force": z.optional(z.boolean().default(false).describe("Indicates whether to force the update or to make sure the update is a fast-forward update. Leaving this out or setting it to `false` will make sure you're not overwriting work."))
    })

export const gitUpdateRefMutationResponseSchema = gitUpdateRef200Schema

export const gitDeleteRefPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ref": z.string().describe("The Git reference. For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.")
    })

/**
 * @description Response
 */
export const gitDeleteRef204Schema = z.unknown()

/**
 * @description Conflict
 */
export const gitDeleteRef409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, an attempt was made to delete the default branch, or the endpoint has been spammed.
 */
export const gitDeleteRef422Schema = z.unknown()

export const gitDeleteRefMutationResponseSchema = gitDeleteRef204Schema

export const gitCreateTagPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const gitCreateTag201Schema = gitTagSchema.describe("Metadata for a Git tag")

/**
 * @description Conflict
 */
export const gitCreateTag409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const gitCreateTag422Schema = validationErrorSchema.describe("Validation Error")

export const gitCreateTagMutationRequestSchema = z.object({
    "tag": z.string().describe("The tag's name. This is typically a version (e.g., \"v0.0.1\")."),
"message": z.string().describe("The tag message."),
"object": z.string().describe("The SHA of the git object this is tagging."),
"type": z.enum(["commit", "tree", "blob"]).describe("The type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`."),
"tagger": z.optional(z.object({
    "name": z.string().describe("The name of the author of the tag"),
"email": z.string().describe("The email of the author of the tag"),
"date": z.optional(z.iso.datetime({ offset: true }).describe("When this object was tagged. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."))
    }).describe("An object with information about the individual creating the tag."))
    })

export const gitCreateTagMutationResponseSchema = gitCreateTag201Schema

export const gitGetTagPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"tag_sha": z.string()
    })

/**
 * @description Response
 */
export const gitGetTag200Schema = gitTagSchema.describe("Metadata for a Git tag")

/**
 * @description Resource not found
 */
export const gitGetTag404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const gitGetTag409Schema = basicErrorSchema.describe("Basic Error")

export const gitGetTagQueryResponseSchema = gitGetTag200Schema

export const gitCreateTreePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const gitCreateTree201Schema = gitTreeSchema.describe("The hierarchy between files in a Git repository.")

/**
 * @description Forbidden
 */
export const gitCreateTree403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const gitCreateTree404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const gitCreateTree409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const gitCreateTree422Schema = validationErrorSchema.describe("Validation Error")

export const gitCreateTreeMutationRequestSchema = z.object({
    "tree": z.array(z.object({
    "path": z.optional(z.string().describe("The file referenced in the tree.")),
"mode": z.optional(z.enum(["100644", "100755", "040000", "160000", "120000"]).describe("The file mode; one of `100644` for file (blob), `100755` for executable (blob), `040000` for subdirectory (tree), `160000` for submodule (commit), or `120000` for a blob that specifies the path of a symlink.")),
"type": z.optional(z.enum(["blob", "tree", "commit"]).describe("Either `blob`, `tree`, or `commit`.")),
"sha": z.string().describe("The SHA1 checksum ID of the object in the tree. Also called `tree.sha`. If the value is `null` then the file will be deleted.  \n  \n**Note:** Use either `tree.sha` or `content` to specify the contents of the entry. Using both `tree.sha` and `content` will return an error.").nullish(),
"content": z.optional(z.string().describe("The content you want this file to have. GitHub will write this blob out and use that SHA for this entry. Use either this, or `tree.sha`.  \n  \n**Note:** Use either `tree.sha` or `content` to specify the contents of the entry. Using both `tree.sha` and `content` will return an error."))
    })).describe("Objects (of `path`, `mode`, `type`, and `sha`) specifying a tree structure."),
"base_tree": z.optional(z.string().describe("The SHA1 of an existing Git tree object which will be used as the base for the new tree. If provided, a new Git tree object will be created from entries in the Git tree object pointed to by `base_tree` and entries defined in the `tree` parameter. Entries defined in the `tree` parameter will overwrite items from `base_tree` with the same `path`. If you're creating new changes on a branch, then normally you'd set `base_tree` to the SHA1 of the Git tree object of the current latest commit on the branch you're working on.\nIf not provided, GitHub will create a new Git tree object from only the entries defined in the `tree` parameter. If you create a new commit pointing to such a tree, then all files which were a part of the parent commit's tree and were not defined in the `tree` parameter will be listed as deleted by the new commit."))
    })

export const gitCreateTreeMutationResponseSchema = gitCreateTree201Schema

export const gitGetTreePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"tree_sha": z.string().describe("The SHA1 value or ref (branch or tag) name of the tree.")
    })

export const gitGetTreeQueryParamsSchema = z.object({
    "recursive": z.optional(z.string().describe("Setting this parameter to any value returns the objects or subtrees referenced by the tree specified in `:tree_sha`. For example, setting `recursive` to any of the following will enable returning objects or subtrees: `0`, `1`, `\"true\"`, and `\"false\"`. Omit this parameter to prevent recursively returning objects or subtrees."))
    }).optional()

/**
 * @description Response
 */
export const gitGetTree200Schema = gitTreeSchema.describe("The hierarchy between files in a Git repository.")

/**
 * @description Resource not found
 */
export const gitGetTree404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const gitGetTree409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const gitGetTree422Schema = validationErrorSchema.describe("Validation Error")

export const gitGetTreeQueryResponseSchema = gitGetTree200Schema

export const reposListWebhooksPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposListWebhooksQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListWebhooks200Schema = z.array(hookSchema.describe("Webhooks for repositories."))

/**
 * @description Resource not found
 */
export const reposListWebhooks404Schema = basicErrorSchema.describe("Basic Error")

export const reposListWebhooksQueryResponseSchema = reposListWebhooks200Schema

export const reposCreateWebhookPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposCreateWebhook201Schema = hookSchema.describe("Webhooks for repositories.")

/**
 * @description Forbidden
 */
export const reposCreateWebhook403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposCreateWebhook404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposCreateWebhook422Schema = validationErrorSchema.describe("Validation Error")

export const reposCreateWebhookMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("Use `web` to create a webhook. Default: `web`. This parameter only accepts the value `web`.")),
"config": z.optional(z.object({
    get "url"(){
                return webhookConfigUrlSchema.describe("The URL to which the payloads will be delivered.").optional()
              },
get "content_type"(){
                return webhookConfigContentTypeSchema.describe("The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.").optional()
              },
get "secret"(){
                return webhookConfigSecretSchema.describe("If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).").optional()
              },
get "insecure_ssl"(){
                return webhookConfigInsecureSslSchema.optional()
              }
    }).describe("Key/value pairs to provide settings for this webhook.")),
"events": z.optional(z.array(z.string()).describe("Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.")),
"active": z.optional(z.boolean().default(true).describe("Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications."))
    }).nullable()

export const reposCreateWebhookMutationResponseSchema = reposCreateWebhook201Schema

export const reposGetWebhookPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.")
    })

/**
 * @description Response
 */
export const reposGetWebhook200Schema = hookSchema.describe("Webhooks for repositories.")

/**
 * @description Resource not found
 */
export const reposGetWebhook404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetWebhookQueryResponseSchema = reposGetWebhook200Schema

export const reposUpdateWebhookPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.")
    })

/**
 * @description Response
 */
export const reposUpdateWebhook200Schema = hookSchema.describe("Webhooks for repositories.")

/**
 * @description Resource not found
 */
export const reposUpdateWebhook404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposUpdateWebhook422Schema = validationErrorSchema.describe("Validation Error")

export const reposUpdateWebhookMutationRequestSchema = z.object({
    get "config"(){
                return webhookConfigSchema.describe("Configuration object of the webhook").optional()
              },
"events": z.optional(z.array(z.string()).describe("Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. This replaces the entire array of events.")),
"add_events": z.optional(z.array(z.string()).describe("Determines a list of events to be added to the list of events that the Hook triggers for.")),
"remove_events": z.optional(z.array(z.string()).describe("Determines a list of events to be removed from the list of events that the Hook triggers for.")),
"active": z.optional(z.boolean().default(true).describe("Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications."))
    })

export const reposUpdateWebhookMutationResponseSchema = reposUpdateWebhook200Schema

export const reposDeleteWebhookPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.")
    })

/**
 * @description Response
 */
export const reposDeleteWebhook204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposDeleteWebhook404Schema = basicErrorSchema.describe("Basic Error")

export const reposDeleteWebhookMutationResponseSchema = reposDeleteWebhook204Schema

export const reposGetWebhookConfigForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.")
    })

/**
 * @description Response
 */
export const reposGetWebhookConfigForRepo200Schema = webhookConfigSchema.describe("Configuration object of the webhook")

export const reposGetWebhookConfigForRepoQueryResponseSchema = reposGetWebhookConfigForRepo200Schema

export const reposUpdateWebhookConfigForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.")
    })

/**
 * @description Response
 */
export const reposUpdateWebhookConfigForRepo200Schema = webhookConfigSchema.describe("Configuration object of the webhook")

export const reposUpdateWebhookConfigForRepoMutationRequestSchema = z.object({
    get "url"(){
                return webhookConfigUrlSchema.describe("The URL to which the payloads will be delivered.").optional()
              },
get "content_type"(){
                return webhookConfigContentTypeSchema.describe("The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.").optional()
              },
get "secret"(){
                return webhookConfigSecretSchema.describe("If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).").optional()
              },
get "insecure_ssl"(){
                return webhookConfigInsecureSslSchema.optional()
              }
    })

export const reposUpdateWebhookConfigForRepoMutationResponseSchema = reposUpdateWebhookConfigForRepo200Schema

export const reposListWebhookDeliveriesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.")
    })

export const reposListWebhookDeliveriesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"cursor": z.optional(z.string().describe("Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors."))
    })

/**
 * @description Response
 */
export const reposListWebhookDeliveries200Schema = z.array(hookDeliveryItemSchema.describe("Delivery made by a webhook, without request and response information."))

/**
 * @description Bad Request
 */
export const reposListWebhookDeliveries400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposListWebhookDeliveries422Schema = validationErrorSchema.describe("Validation Error")

export const reposListWebhookDeliveriesQueryResponseSchema = reposListWebhookDeliveries200Schema

export const reposGetWebhookDeliveryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery."),
"delivery_id": z.coerce.number().int()
    })

/**
 * @description Response
 */
export const reposGetWebhookDelivery200Schema = hookDeliverySchema.describe("Delivery made by a webhook.")

/**
 * @description Bad Request
 */
export const reposGetWebhookDelivery400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposGetWebhookDelivery422Schema = validationErrorSchema.describe("Validation Error")

export const reposGetWebhookDeliveryQueryResponseSchema = reposGetWebhookDelivery200Schema

export const reposRedeliverWebhookDeliveryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery."),
"delivery_id": z.coerce.number().int()
    })

/**
 * @description Accepted
 */
export const reposRedeliverWebhookDelivery202Schema = z.object({
    
    })

/**
 * @description Bad Request
 */
export const reposRedeliverWebhookDelivery400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposRedeliverWebhookDelivery422Schema = validationErrorSchema.describe("Validation Error")

export const reposRedeliverWebhookDeliveryMutationResponseSchema = reposRedeliverWebhookDelivery202Schema

export const reposPingWebhookPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.")
    })

/**
 * @description Response
 */
export const reposPingWebhook204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposPingWebhook404Schema = basicErrorSchema.describe("Basic Error")

export const reposPingWebhookMutationResponseSchema = reposPingWebhook204Schema

export const reposTestPushWebhookPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"hook_id": z.coerce.number().int().describe("The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.")
    })

/**
 * @description Response
 */
export const reposTestPushWebhook204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposTestPushWebhook404Schema = basicErrorSchema.describe("Basic Error")

export const reposTestPushWebhookMutationResponseSchema = reposTestPushWebhook204Schema

export const reposCheckImmutableReleasesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response if immutable releases are enabled
 */
export const reposCheckImmutableReleases200Schema = checkImmutableReleasesSchema.describe("Check immutable releases")

/**
 * @description Not Found if immutable releases are not enabled for the repository
 */
export const reposCheckImmutableReleases404Schema = z.unknown()

export const reposCheckImmutableReleasesQueryResponseSchema = reposCheckImmutableReleases200Schema

export const reposEnableImmutableReleasesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description A header with no content is returned.
 */
export const reposEnableImmutableReleases204Schema = z.unknown()

/**
 * @description Conflict
 */
export const reposEnableImmutableReleases409Schema = basicErrorSchema.describe("Basic Error")

export const reposEnableImmutableReleasesMutationResponseSchema = reposEnableImmutableReleases204Schema

export const reposDisableImmutableReleasesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description A header with no content is returned.
 */
export const reposDisableImmutableReleases204Schema = z.unknown()

/**
 * @description Conflict
 */
export const reposDisableImmutableReleases409Schema = basicErrorSchema.describe("Basic Error")

export const reposDisableImmutableReleasesMutationResponseSchema = reposDisableImmutableReleases204Schema

export const migrationsGetImportStatusPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const migrationsGetImportStatus200Schema = importSchema.describe("A repository import from an external source.")

/**
 * @description Resource not found
 */
export const migrationsGetImportStatus404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Unavailable due to service under maintenance.
 */
export const migrationsGetImportStatus503Schema = basicErrorSchema.describe("Basic Error")

export const migrationsGetImportStatusQueryResponseSchema = migrationsGetImportStatus200Schema

export const migrationsStartImportPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const migrationsStartImport201Schema = importSchema.describe("A repository import from an external source.")

/**
 * @description Resource not found
 */
export const migrationsStartImport404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const migrationsStartImport422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Unavailable due to service under maintenance.
 */
export const migrationsStartImport503Schema = basicErrorSchema.describe("Basic Error")

export const migrationsStartImportMutationRequestSchema = z.object({
    "vcs_url": z.string().describe("The URL of the originating repository."),
"vcs": z.optional(z.enum(["subversion", "git", "mercurial", "tfvc"]).describe("The originating VCS type. Without this parameter, the import job will take additional time to detect the VCS type before beginning the import. This detection step will be reflected in the response.")),
"vcs_username": z.optional(z.string().describe("If authentication is required, the username to provide to `vcs_url`.")),
"vcs_password": z.optional(z.string().describe("If authentication is required, the password to provide to `vcs_url`.")),
"tfvc_project": z.optional(z.string().describe("For a tfvc import, the name of the project that is being imported."))
    })

export const migrationsStartImportMutationResponseSchema = migrationsStartImport201Schema

export const migrationsUpdateImportPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const migrationsUpdateImport200Schema = importSchema.describe("A repository import from an external source.")

/**
 * @description Unavailable due to service under maintenance.
 */
export const migrationsUpdateImport503Schema = basicErrorSchema.describe("Basic Error")

export const migrationsUpdateImportMutationRequestSchema = z.object({
    "vcs_username": z.optional(z.string().describe("The username to provide to the originating repository.")),
"vcs_password": z.optional(z.string().describe("The password to provide to the originating repository.")),
"vcs": z.optional(z.enum(["subversion", "tfvc", "git", "mercurial"]).describe("The type of version control system you are migrating from.")),
"tfvc_project": z.optional(z.string().describe("For a tfvc import, the name of the project that is being imported."))
    }).nullable()

export const migrationsUpdateImportMutationResponseSchema = migrationsUpdateImport200Schema

export const migrationsCancelImportPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const migrationsCancelImport204Schema = z.unknown()

/**
 * @description Unavailable due to service under maintenance.
 */
export const migrationsCancelImport503Schema = basicErrorSchema.describe("Basic Error")

export const migrationsCancelImportMutationResponseSchema = migrationsCancelImport204Schema

export const migrationsGetCommitAuthorsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const migrationsGetCommitAuthorsQueryParamsSchema = z.object({
    "since": z.optional(z.coerce.number().int().describe("A user ID. Only return users with an ID greater than this ID."))
    }).optional()

/**
 * @description Response
 */
export const migrationsGetCommitAuthors200Schema = z.array(porterAuthorSchema.describe("Porter Author"))

/**
 * @description Resource not found
 */
export const migrationsGetCommitAuthors404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Unavailable due to service under maintenance.
 */
export const migrationsGetCommitAuthors503Schema = basicErrorSchema.describe("Basic Error")

export const migrationsGetCommitAuthorsQueryResponseSchema = migrationsGetCommitAuthors200Schema

export const migrationsMapCommitAuthorPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"author_id": z.coerce.number().int()
    })

/**
 * @description Response
 */
export const migrationsMapCommitAuthor200Schema = porterAuthorSchema.describe("Porter Author")

/**
 * @description Resource not found
 */
export const migrationsMapCommitAuthor404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const migrationsMapCommitAuthor422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Unavailable due to service under maintenance.
 */
export const migrationsMapCommitAuthor503Schema = basicErrorSchema.describe("Basic Error")

export const migrationsMapCommitAuthorMutationRequestSchema = z.object({
    "email": z.optional(z.string().describe("The new Git author email.")),
"name": z.optional(z.string().describe("The new Git author name."))
    })

export const migrationsMapCommitAuthorMutationResponseSchema = migrationsMapCommitAuthor200Schema

export const migrationsGetLargeFilesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const migrationsGetLargeFiles200Schema = z.array(porterLargeFileSchema.describe("Porter Large File"))

/**
 * @description Unavailable due to service under maintenance.
 */
export const migrationsGetLargeFiles503Schema = basicErrorSchema.describe("Basic Error")

export const migrationsGetLargeFilesQueryResponseSchema = migrationsGetLargeFiles200Schema

export const migrationsSetLfsPreferencePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const migrationsSetLfsPreference200Schema = importSchema.describe("A repository import from an external source.")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const migrationsSetLfsPreference422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Unavailable due to service under maintenance.
 */
export const migrationsSetLfsPreference503Schema = basicErrorSchema.describe("Basic Error")

export const migrationsSetLfsPreferenceMutationRequestSchema = z.object({
    "use_lfs": z.enum(["opt_in", "opt_out"]).describe("Whether to store large files during the import. `opt_in` means large files will be stored using Git LFS. `opt_out` means large files will be removed during the import.")
    })

export const migrationsSetLfsPreferenceMutationResponseSchema = migrationsSetLfsPreference200Schema

export const appsGetRepoInstallationPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const appsGetRepoInstallation200Schema = installationSchema.describe("Installation")

/**
 * @description Moved permanently
 */
export const appsGetRepoInstallation301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const appsGetRepoInstallation404Schema = basicErrorSchema.describe("Basic Error")

export const appsGetRepoInstallationQueryResponseSchema = appsGetRepoInstallation200Schema

export const interactionsGetRestrictionsForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const interactionsGetRestrictionsForRepo200Schema = z.union([interactionLimitResponseSchema, z.object({
    
    })])

export const interactionsGetRestrictionsForRepoQueryResponseSchema = interactionsGetRestrictionsForRepo200Schema

export const interactionsSetRestrictionsForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const interactionsSetRestrictionsForRepo200Schema = interactionLimitResponseSchema.describe("Interaction limit settings.")

/**
 * @description Response
 */
export const interactionsSetRestrictionsForRepo409Schema = z.unknown()

export const interactionsSetRestrictionsForRepoMutationRequestSchema = interactionLimitSchema.describe("Limit interactions to a specific type of user for a specified duration")

export const interactionsSetRestrictionsForRepoMutationResponseSchema = interactionsSetRestrictionsForRepo200Schema

export const interactionsRemoveRestrictionsForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const interactionsRemoveRestrictionsForRepo204Schema = z.unknown()

/**
 * @description Response
 */
export const interactionsRemoveRestrictionsForRepo409Schema = z.unknown()

export const interactionsRemoveRestrictionsForRepoMutationResponseSchema = interactionsRemoveRestrictionsForRepo204Schema

export const reposListInvitationsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposListInvitationsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListInvitations200Schema = z.array(repositoryInvitationSchema.describe("Repository invitations let you manage who you collaborate with."))

export const reposListInvitationsQueryResponseSchema = reposListInvitations200Schema

export const reposUpdateInvitationPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"invitation_id": z.coerce.number().int().describe("The unique identifier of the invitation.")
    })

/**
 * @description Response
 */
export const reposUpdateInvitation200Schema = repositoryInvitationSchema.describe("Repository invitations let you manage who you collaborate with.")

export const reposUpdateInvitationMutationRequestSchema = z.object({
    "permissions": z.optional(z.enum(["read", "write", "maintain", "triage", "admin"]).describe("The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`."))
    })

export const reposUpdateInvitationMutationResponseSchema = reposUpdateInvitation200Schema

export const reposDeleteInvitationPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"invitation_id": z.coerce.number().int().describe("The unique identifier of the invitation.")
    })

/**
 * @description Response
 */
export const reposDeleteInvitation204Schema = z.unknown()

export const reposDeleteInvitationMutationResponseSchema = reposDeleteInvitation204Schema

export const issuesListForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const issuesListForRepoQueryParamsSchema = z.object({
    "milestone": z.optional(z.string().describe("If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*` is passed, issues with any milestone are accepted. If the string `none` is passed, issues without milestones are returned.")),
"state": z.enum(["open", "closed", "all"]).default("open").describe("Indicates the state of the issues to return."),
"assignee": z.optional(z.string().describe("Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues assigned to any user.")),
"type": z.optional(z.string().describe("Can be the name of an issue type. If the string `*` is passed, issues with any type are accepted. If the string `none` is passed, issues without type are returned.")),
"creator": z.optional(z.string().describe("The user that created the issue.")),
"mentioned": z.optional(z.string().describe("A user that's mentioned in the issue.")),
"labels": z.optional(z.string().describe("A list of comma separated label names. Example: `bug,ui,@high`")),
"sort": z.enum(["created", "updated", "comments"]).default("created").describe("What to sort results by."),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"since": z.optional(z.iso.datetime({ offset: true }).describe("Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesListForRepo200Schema = z.array(issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects."))

/**
 * @description Moved permanently
 */
export const issuesListForRepo301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesListForRepo404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const issuesListForRepo422Schema = validationErrorSchema.describe("Validation Error")

export const issuesListForRepoQueryResponseSchema = issuesListForRepo200Schema

export const issuesCreatePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const issuesCreate201Schema = issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")

/**
 * @description Bad Request
 */
export const issuesCreate400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const issuesCreate403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesCreate404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesCreate410Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const issuesCreate422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Service unavailable
 */
export const issuesCreate503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const issuesCreateMutationRequestSchema = z.object({
    "title": z.union([z.int(), z.string()]).describe("The title of the issue."),
"body": z.optional(z.string().describe("The contents of the issue.")),
"assignee": z.string().describe("Login for the user that this issue should be assigned to. _NOTE: Only users with push access can set the assignee for new issues. The assignee is silently dropped otherwise. **This field is closing down.**_").nullish(),
"milestone": z.union([z.int(), z.string()]).nullish(),
"labels": z.optional(z.array(z.union([z.string(), z.object({
    "id": z.optional(z.int()),
"name": z.optional(z.string()),
"description": z.string().nullish(),
"color": z.string().nullish()
    })])).describe("Labels to associate with this issue. _NOTE: Only users with push access can set labels for new issues. Labels are silently dropped otherwise._")),
"assignees": z.optional(z.array(z.string()).describe("Logins for Users to assign to this issue. _NOTE: Only users with push access can set assignees for new issues. Assignees are silently dropped otherwise._")),
"type": z.string().describe("The name of the issue type to associate with this issue. _NOTE: Only users with push access can set the type for new issues. The type is silently dropped otherwise._").nullish()
    })

export const issuesCreateMutationResponseSchema = issuesCreate201Schema

export const issuesListCommentsForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const issuesListCommentsForRepoQueryParamsSchema = z.object({
    "sort": z.enum(["created", "updated"]).default("created").describe("The property to sort the results by."),
"direction": z.optional(z.enum(["asc", "desc"]).describe("Either `asc` or `desc`. Ignored without the `sort` parameter.")),
"since": z.optional(z.iso.datetime({ offset: true }).describe("Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesListCommentsForRepo200Schema = z.array(issueCommentSchema.describe("Comments provide a way for people to collaborate on an issue."))

/**
 * @description Resource not found
 */
export const issuesListCommentsForRepo404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const issuesListCommentsForRepo422Schema = validationErrorSchema.describe("Validation Error")

export const issuesListCommentsForRepoQueryResponseSchema = issuesListCommentsForRepo200Schema

export const issuesGetCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

/**
 * @description Response
 */
export const issuesGetComment200Schema = issueCommentSchema.describe("Comments provide a way for people to collaborate on an issue.")

/**
 * @description Resource not found
 */
export const issuesGetComment404Schema = basicErrorSchema.describe("Basic Error")

export const issuesGetCommentQueryResponseSchema = issuesGetComment200Schema

export const issuesUpdateCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

/**
 * @description Response
 */
export const issuesUpdateComment200Schema = issueCommentSchema.describe("Comments provide a way for people to collaborate on an issue.")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const issuesUpdateComment422Schema = validationErrorSchema.describe("Validation Error")

export const issuesUpdateCommentMutationRequestSchema = z.object({
    "body": z.string().describe("The contents of the comment.")
    })

export const issuesUpdateCommentMutationResponseSchema = issuesUpdateComment200Schema

export const issuesDeleteCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

/**
 * @description Response
 */
export const issuesDeleteComment204Schema = z.unknown()

export const issuesDeleteCommentMutationResponseSchema = issuesDeleteComment204Schema

export const reactionsListForIssueCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

export const reactionsListForIssueCommentQueryParamsSchema = z.object({
    "content": z.optional(z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to an issue comment.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reactionsListForIssueComment200Schema = z.array(reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively."))

/**
 * @description Resource not found
 */
export const reactionsListForIssueComment404Schema = basicErrorSchema.describe("Basic Error")

export const reactionsListForIssueCommentQueryResponseSchema = reactionsListForIssueComment200Schema

export const reactionsCreateForIssueCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

/**
 * @description Reaction exists
 */
export const reactionsCreateForIssueComment200Schema = reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

/**
 * @description Reaction created
 */
export const reactionsCreateForIssueComment201Schema = reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reactionsCreateForIssueComment422Schema = validationErrorSchema.describe("Validation Error")

export const reactionsCreateForIssueCommentMutationRequestSchema = z.object({
    "content": z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the issue comment.")
    })

export const reactionsCreateForIssueCommentMutationResponseSchema = z.union([reactionsCreateForIssueComment200Schema, reactionsCreateForIssueComment201Schema])

export const reactionsDeleteForIssueCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment."),
"reaction_id": z.coerce.number().int().describe("The unique identifier of the reaction.")
    })

/**
 * @description Response
 */
export const reactionsDeleteForIssueComment204Schema = z.unknown()

export const reactionsDeleteForIssueCommentMutationResponseSchema = reactionsDeleteForIssueComment204Schema

export const issuesListEventsForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const issuesListEventsForRepoQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesListEventsForRepo200Schema = z.array(issueEventSchema.describe("Issue Event"))

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const issuesListEventsForRepo422Schema = validationErrorSchema.describe("Validation Error")

export const issuesListEventsForRepoQueryResponseSchema = issuesListEventsForRepo200Schema

export const issuesGetEventPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"event_id": z.coerce.number().int()
    })

/**
 * @description Response
 */
export const issuesGetEvent200Schema = issueEventSchema.describe("Issue Event")

/**
 * @description Forbidden
 */
export const issuesGetEvent403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesGetEvent404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesGetEvent410Schema = basicErrorSchema.describe("Basic Error")

export const issuesGetEventQueryResponseSchema = issuesGetEvent200Schema

export const issuesGetPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

/**
 * @description Response
 */
export const issuesGet200Schema = issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")

/**
 * @description Moved permanently
 */
export const issuesGet301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Not modified
 */
export const issuesGet304Schema = z.unknown()

/**
 * @description Resource not found
 */
export const issuesGet404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesGet410Schema = basicErrorSchema.describe("Basic Error")

export const issuesGetQueryResponseSchema = issuesGet200Schema

export const issuesUpdatePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

/**
 * @description Response
 */
export const issuesUpdate200Schema = issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")

/**
 * @description Moved permanently
 */
export const issuesUpdate301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const issuesUpdate403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesUpdate404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesUpdate410Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const issuesUpdate422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Service unavailable
 */
export const issuesUpdate503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const issuesUpdateMutationRequestSchema = z.object({
    "title": z.union([z.int(), z.string()]).describe("The title of the issue.").nullish(),
"body": z.string().describe("The contents of the issue.").nullish(),
"assignee": z.string().describe("Username to assign to this issue. **This field is closing down.**").nullish(),
"state": z.optional(z.enum(["open", "closed"]).describe("The open or closed state of the issue.")),
"state_reason": z.enum(["completed", "not_planned", "duplicate", "reopened"]).describe("The reason for the state change. Ignored unless `state` is changed.").nullish(),
"milestone": z.union([z.int(), z.string()]).nullish(),
"labels": z.optional(z.array(z.union([z.string(), z.object({
    "id": z.optional(z.int()),
"name": z.optional(z.string()),
"description": z.string().nullish(),
"color": z.string().nullish()
    })])).describe("Labels to associate with this issue. Pass one or more labels to _replace_ the set of labels on this issue. Send an empty array (`[]`) to clear all labels from the issue. Only users with push access can set labels for issues. Without push access to the repository, label changes are silently dropped.")),
"assignees": z.optional(z.array(z.string()).describe("Usernames to assign to this issue. Pass one or more user logins to _replace_ the set of assignees on this issue. Send an empty array (`[]`) to clear all assignees from the issue. Only users with push access can set assignees for new issues. Without push access to the repository, assignee changes are silently dropped.")),
"type": z.string().describe("The name of the issue type to associate with this issue or use `null` to remove the current issue type. Only users with push access can set the type for issues. Without push access to the repository, type changes are silently dropped.").nullish()
    })

export const issuesUpdateMutationResponseSchema = issuesUpdate200Schema

export const issuesAddAssigneesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

/**
 * @description Response
 */
export const issuesAddAssignees201Schema = issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")

export const issuesAddAssigneesMutationRequestSchema = z.object({
    "assignees": z.optional(z.array(z.string()).describe("Usernames of people to assign this issue to. _NOTE: Only users with push access can add assignees to an issue. Assignees are silently ignored otherwise._"))
    })

export const issuesAddAssigneesMutationResponseSchema = issuesAddAssignees201Schema

export const issuesRemoveAssigneesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

/**
 * @description Response
 */
export const issuesRemoveAssignees200Schema = issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")

export const issuesRemoveAssigneesMutationRequestSchema = z.object({
    "assignees": z.optional(z.array(z.string()).describe("Usernames of assignees to remove from an issue. _NOTE: Only users with push access can remove assignees from an issue. Assignees are silently ignored otherwise._"))
    })

export const issuesRemoveAssigneesMutationResponseSchema = issuesRemoveAssignees200Schema

export const issuesCheckUserCanBeAssignedToIssuePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue."),
"assignee": z.string()
    })

/**
 * @description Response if `assignee` can be assigned to `issue_number`
 */
export const issuesCheckUserCanBeAssignedToIssue204Schema = z.unknown()

/**
 * @description Response if `assignee` can not be assigned to `issue_number`
 */
export const issuesCheckUserCanBeAssignedToIssue404Schema = basicErrorSchema.describe("Basic Error")

export const issuesCheckUserCanBeAssignedToIssueQueryResponseSchema = issuesCheckUserCanBeAssignedToIssue204Schema

export const issuesListCommentsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

export const issuesListCommentsQueryParamsSchema = z.object({
    "since": z.optional(z.iso.datetime({ offset: true }).describe("Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesListComments200Schema = z.array(issueCommentSchema.describe("Comments provide a way for people to collaborate on an issue."))

/**
 * @description Resource not found
 */
export const issuesListComments404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesListComments410Schema = basicErrorSchema.describe("Basic Error")

export const issuesListCommentsQueryResponseSchema = issuesListComments200Schema

export const issuesCreateCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

/**
 * @description Response
 */
export const issuesCreateComment201Schema = issueCommentSchema.describe("Comments provide a way for people to collaborate on an issue.")

/**
 * @description Forbidden
 */
export const issuesCreateComment403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesCreateComment404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesCreateComment410Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const issuesCreateComment422Schema = validationErrorSchema.describe("Validation Error")

export const issuesCreateCommentMutationRequestSchema = z.object({
    "body": z.string().describe("The contents of the comment.")
    })

export const issuesCreateCommentMutationResponseSchema = issuesCreateComment201Schema

export const issuesListDependenciesBlockedByPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

export const issuesListDependenciesBlockedByQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesListDependenciesBlockedBy200Schema = z.array(issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects."))

/**
 * @description Moved permanently
 */
export const issuesListDependenciesBlockedBy301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesListDependenciesBlockedBy404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesListDependenciesBlockedBy410Schema = basicErrorSchema.describe("Basic Error")

export const issuesListDependenciesBlockedByQueryResponseSchema = issuesListDependenciesBlockedBy200Schema

export const issuesAddBlockedByDependencyPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

/**
 * @description Response
 */
export const issuesAddBlockedByDependency201Schema = issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")

/**
 * @description Moved permanently
 */
export const issuesAddBlockedByDependency301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const issuesAddBlockedByDependency403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesAddBlockedByDependency404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesAddBlockedByDependency410Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const issuesAddBlockedByDependency422Schema = validationErrorSchema.describe("Validation Error")

export const issuesAddBlockedByDependencyMutationRequestSchema = z.object({
    "issue_id": z.int().describe("The id of the issue that blocks the current issue")
    })

export const issuesAddBlockedByDependencyMutationResponseSchema = issuesAddBlockedByDependency201Schema

export const issuesRemoveDependencyBlockedByPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue."),
"issue_id": z.coerce.number().int().describe("The id of the blocking issue to remove as a dependency")
    })

/**
 * @description Response
 */
export const issuesRemoveDependencyBlockedBy200Schema = issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")

/**
 * @description Moved permanently
 */
export const issuesRemoveDependencyBlockedBy301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Bad Request
 */
export const issuesRemoveDependencyBlockedBy400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Requires authentication
 */
export const issuesRemoveDependencyBlockedBy401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const issuesRemoveDependencyBlockedBy403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesRemoveDependencyBlockedBy404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesRemoveDependencyBlockedBy410Schema = basicErrorSchema.describe("Basic Error")

export const issuesRemoveDependencyBlockedByMutationResponseSchema = issuesRemoveDependencyBlockedBy200Schema

export const issuesListDependenciesBlockingPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

export const issuesListDependenciesBlockingQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesListDependenciesBlocking200Schema = z.array(issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects."))

/**
 * @description Moved permanently
 */
export const issuesListDependenciesBlocking301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesListDependenciesBlocking404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesListDependenciesBlocking410Schema = basicErrorSchema.describe("Basic Error")

export const issuesListDependenciesBlockingQueryResponseSchema = issuesListDependenciesBlocking200Schema

export const issuesListEventsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

export const issuesListEventsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesListEvents200Schema = z.array(issueEventForIssueSchema.describe("Issue Event for Issue"))

/**
 * @description Gone
 */
export const issuesListEvents410Schema = basicErrorSchema.describe("Basic Error")

export const issuesListEventsQueryResponseSchema = issuesListEvents200Schema

export const issuesListLabelsOnIssuePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

export const issuesListLabelsOnIssueQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesListLabelsOnIssue200Schema = z.array(labelSchema.describe("Color-coded labels help you categorize and filter your issues (just like labels in Gmail)."))

/**
 * @description Moved permanently
 */
export const issuesListLabelsOnIssue301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesListLabelsOnIssue404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesListLabelsOnIssue410Schema = basicErrorSchema.describe("Basic Error")

export const issuesListLabelsOnIssueQueryResponseSchema = issuesListLabelsOnIssue200Schema

export const issuesAddLabelsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

/**
 * @description Response
 */
export const issuesAddLabels200Schema = z.array(labelSchema.describe("Color-coded labels help you categorize and filter your issues (just like labels in Gmail)."))

/**
 * @description Moved permanently
 */
export const issuesAddLabels301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesAddLabels404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesAddLabels410Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const issuesAddLabels422Schema = validationErrorSchema.describe("Validation Error")

export const issuesAddLabelsMutationRequestSchema = z.union([z.array(z.string()).min(1), z.array(z.object({
    "name": z.string()
    })).min(1), z.string(), z.object({
    "labels": z.optional(z.array(z.string()).min(1).describe("The names of the labels to add to the issue's existing labels. You can pass an empty array to remove all labels. Alternatively, you can pass a single label as a `string` or an `array` of labels directly, but GitHub recommends passing an object with the `labels` key. You can also replace all of the labels for an issue. For more information, see \"[Set labels for an issue](https://docs.github.com/rest/issues/labels#set-labels-for-an-issue).\""))
    }), z.object({
    "labels": z.optional(z.array(z.object({
    "name": z.string()
    })).min(1))
    })])

export const issuesAddLabelsMutationResponseSchema = issuesAddLabels200Schema

export const issuesSetLabelsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

/**
 * @description Response
 */
export const issuesSetLabels200Schema = z.array(labelSchema.describe("Color-coded labels help you categorize and filter your issues (just like labels in Gmail)."))

/**
 * @description Moved permanently
 */
export const issuesSetLabels301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesSetLabels404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesSetLabels410Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const issuesSetLabels422Schema = validationErrorSchema.describe("Validation Error")

export const issuesSetLabelsMutationRequestSchema = z.union([z.array(z.string()).min(1), z.array(z.object({
    "name": z.string()
    })).min(1), z.string(), z.object({
    "labels": z.optional(z.array(z.string()).min(1).describe("The names of the labels to set for the issue. The labels you set replace any existing labels. You can pass an empty array to remove all labels. Alternatively, you can pass a single label as a `string` or an `array` of labels directly, but GitHub recommends passing an object with the `labels` key. You can also add labels to the existing labels for an issue. For more information, see \"[Add labels to an issue](https://docs.github.com/rest/issues/labels#add-labels-to-an-issue).\""))
    }), z.object({
    "labels": z.optional(z.array(z.object({
    "name": z.string()
    })).min(1))
    })])

export const issuesSetLabelsMutationResponseSchema = issuesSetLabels200Schema

export const issuesRemoveAllLabelsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

/**
 * @description Response
 */
export const issuesRemoveAllLabels204Schema = z.unknown()

/**
 * @description Moved permanently
 */
export const issuesRemoveAllLabels301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesRemoveAllLabels404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesRemoveAllLabels410Schema = basicErrorSchema.describe("Basic Error")

export const issuesRemoveAllLabelsMutationResponseSchema = issuesRemoveAllLabels204Schema

export const issuesRemoveLabelPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue."),
"name": z.string()
    })

/**
 * @description Response
 */
export const issuesRemoveLabel200Schema = z.array(labelSchema.describe("Color-coded labels help you categorize and filter your issues (just like labels in Gmail)."))

/**
 * @description Moved permanently
 */
export const issuesRemoveLabel301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesRemoveLabel404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesRemoveLabel410Schema = basicErrorSchema.describe("Basic Error")

export const issuesRemoveLabelMutationResponseSchema = issuesRemoveLabel200Schema

export const issuesLockPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

/**
 * @description Response
 */
export const issuesLock204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const issuesLock403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesLock404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesLock410Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const issuesLock422Schema = validationErrorSchema.describe("Validation Error")

export const issuesLockMutationRequestSchema = z.object({
    "lock_reason": z.optional(z.enum(["off-topic", "too heated", "resolved", "spam"]).describe("The reason for locking the issue or pull request conversation. Lock will fail if you don't use one of these reasons:  \n * `off-topic`  \n * `too heated`  \n * `resolved`  \n * `spam`"))
    }).nullable()

export const issuesLockMutationResponseSchema = issuesLock204Schema

export const issuesUnlockPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

/**
 * @description Response
 */
export const issuesUnlock204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const issuesUnlock403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesUnlock404Schema = basicErrorSchema.describe("Basic Error")

export const issuesUnlockMutationResponseSchema = issuesUnlock204Schema

export const issuesGetParentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

/**
 * @description Response
 */
export const issuesGetParent200Schema = issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")

/**
 * @description Moved permanently
 */
export const issuesGetParent301Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesGetParent404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesGetParent410Schema = basicErrorSchema.describe("Basic Error")

export const issuesGetParentQueryResponseSchema = issuesGetParent200Schema

export const reactionsListForIssuePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

export const reactionsListForIssueQueryParamsSchema = z.object({
    "content": z.optional(z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to an issue.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reactionsListForIssue200Schema = z.array(reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively."))

/**
 * @description Resource not found
 */
export const reactionsListForIssue404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const reactionsListForIssue410Schema = basicErrorSchema.describe("Basic Error")

export const reactionsListForIssueQueryResponseSchema = reactionsListForIssue200Schema

export const reactionsCreateForIssuePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

/**
 * @description Response
 */
export const reactionsCreateForIssue200Schema = reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

/**
 * @description Response
 */
export const reactionsCreateForIssue201Schema = reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reactionsCreateForIssue422Schema = validationErrorSchema.describe("Validation Error")

export const reactionsCreateForIssueMutationRequestSchema = z.object({
    "content": z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the issue.")
    })

export const reactionsCreateForIssueMutationResponseSchema = z.union([reactionsCreateForIssue200Schema, reactionsCreateForIssue201Schema])

export const reactionsDeleteForIssuePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue."),
"reaction_id": z.coerce.number().int().describe("The unique identifier of the reaction.")
    })

/**
 * @description Response
 */
export const reactionsDeleteForIssue204Schema = z.unknown()

export const reactionsDeleteForIssueMutationResponseSchema = reactionsDeleteForIssue204Schema

export const issuesRemoveSubIssuePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

/**
 * @description Response
 */
export const issuesRemoveSubIssue200Schema = issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")

/**
 * @description Bad Request
 */
export const issuesRemoveSubIssue400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesRemoveSubIssue404Schema = basicErrorSchema.describe("Basic Error")

export const issuesRemoveSubIssueMutationRequestSchema = z.object({
    "sub_issue_id": z.int().describe("The id of the sub-issue to remove")
    })

export const issuesRemoveSubIssueMutationResponseSchema = issuesRemoveSubIssue200Schema

export const issuesListSubIssuesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

export const issuesListSubIssuesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesListSubIssues200Schema = z.array(issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects."))

/**
 * @description Resource not found
 */
export const issuesListSubIssues404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesListSubIssues410Schema = basicErrorSchema.describe("Basic Error")

export const issuesListSubIssuesQueryResponseSchema = issuesListSubIssues200Schema

export const issuesAddSubIssuePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

/**
 * @description Response
 */
export const issuesAddSubIssue201Schema = issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")

/**
 * @description Forbidden
 */
export const issuesAddSubIssue403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesAddSubIssue404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesAddSubIssue410Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const issuesAddSubIssue422Schema = validationErrorSchema.describe("Validation Error")

export const issuesAddSubIssueMutationRequestSchema = z.object({
    "sub_issue_id": z.int().describe("The id of the sub-issue to add. The sub-issue must belong to the same repository owner as the parent issue"),
"replace_parent": z.optional(z.boolean().describe("Option that, when true, instructs the operation to replace the sub-issues current parent issue"))
    })

export const issuesAddSubIssueMutationResponseSchema = issuesAddSubIssue201Schema

export const issuesReprioritizeSubIssuePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

/**
 * @description Response
 */
export const issuesReprioritizeSubIssue200Schema = issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.")

/**
 * @description Forbidden
 */
export const issuesReprioritizeSubIssue403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const issuesReprioritizeSubIssue404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const issuesReprioritizeSubIssue422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

/**
 * @description Service unavailable
 */
export const issuesReprioritizeSubIssue503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const issuesReprioritizeSubIssueMutationRequestSchema = z.object({
    "sub_issue_id": z.int().describe("The id of the sub-issue to reprioritize"),
"after_id": z.optional(z.int().describe("The id of the sub-issue to be prioritized after (either positional argument after OR before should be specified).")),
"before_id": z.optional(z.int().describe("The id of the sub-issue to be prioritized before (either positional argument after OR before should be specified)."))
    })

export const issuesReprioritizeSubIssueMutationResponseSchema = issuesReprioritizeSubIssue200Schema

export const issuesListEventsForTimelinePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"issue_number": z.coerce.number().int().describe("The number that identifies the issue.")
    })

export const issuesListEventsForTimelineQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesListEventsForTimeline200Schema = z.array(timelineIssueEventsSchema.describe("Timeline Event"))

/**
 * @description Resource not found
 */
export const issuesListEventsForTimeline404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const issuesListEventsForTimeline410Schema = basicErrorSchema.describe("Basic Error")

export const issuesListEventsForTimelineQueryResponseSchema = issuesListEventsForTimeline200Schema

export const reposListDeployKeysPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposListDeployKeysQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListDeployKeys200Schema = z.array(deployKeySchema.describe("An SSH key granting access to a single repository."))

export const reposListDeployKeysQueryResponseSchema = reposListDeployKeys200Schema

export const reposCreateDeployKeyPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposCreateDeployKey201Schema = deployKeySchema.describe("An SSH key granting access to a single repository.")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposCreateDeployKey422Schema = validationErrorSchema.describe("Validation Error")

export const reposCreateDeployKeyMutationRequestSchema = z.object({
    "title": z.optional(z.string().describe("A name for the key.")),
"key": z.string().describe("The contents of the key."),
"read_only": z.optional(z.boolean().describe("If `true`, the key will only be able to read repository contents. Otherwise, the key will be able to read and write.  \n  \nDeploy keys with write access can perform the same actions as an organization member with admin access, or a collaborator on a personal repository. For more information, see \"[Repository permission levels for an organization](https://docs.github.com/articles/repository-permission-levels-for-an-organization/)\" and \"[Permission levels for a user account repository](https://docs.github.com/articles/permission-levels-for-a-user-account-repository/).\""))
    })

export const reposCreateDeployKeyMutationResponseSchema = reposCreateDeployKey201Schema

export const reposGetDeployKeyPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"key_id": z.coerce.number().int().describe("The unique identifier of the key.")
    })

/**
 * @description Response
 */
export const reposGetDeployKey200Schema = deployKeySchema.describe("An SSH key granting access to a single repository.")

/**
 * @description Resource not found
 */
export const reposGetDeployKey404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetDeployKeyQueryResponseSchema = reposGetDeployKey200Schema

export const reposDeleteDeployKeyPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"key_id": z.coerce.number().int().describe("The unique identifier of the key.")
    })

/**
 * @description Response
 */
export const reposDeleteDeployKey204Schema = z.unknown()

export const reposDeleteDeployKeyMutationResponseSchema = reposDeleteDeployKey204Schema

export const issuesListLabelsForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const issuesListLabelsForRepoQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesListLabelsForRepo200Schema = z.array(labelSchema.describe("Color-coded labels help you categorize and filter your issues (just like labels in Gmail)."))

/**
 * @description Resource not found
 */
export const issuesListLabelsForRepo404Schema = basicErrorSchema.describe("Basic Error")

export const issuesListLabelsForRepoQueryResponseSchema = issuesListLabelsForRepo200Schema

export const issuesCreateLabelPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const issuesCreateLabel201Schema = labelSchema.describe("Color-coded labels help you categorize and filter your issues (just like labels in Gmail).")

/**
 * @description Resource not found
 */
export const issuesCreateLabel404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const issuesCreateLabel422Schema = validationErrorSchema.describe("Validation Error")

export const issuesCreateLabelMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png \":strawberry:\"). For a full list of available emoji and codes, see \"[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet).\""),
"color": z.optional(z.string().describe("The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.")),
"description": z.optional(z.string().describe("A short description of the label. Must be 100 characters or fewer."))
    })

export const issuesCreateLabelMutationResponseSchema = issuesCreateLabel201Schema

export const issuesGetLabelPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"name": z.string()
    })

/**
 * @description Response
 */
export const issuesGetLabel200Schema = labelSchema.describe("Color-coded labels help you categorize and filter your issues (just like labels in Gmail).")

/**
 * @description Resource not found
 */
export const issuesGetLabel404Schema = basicErrorSchema.describe("Basic Error")

export const issuesGetLabelQueryResponseSchema = issuesGetLabel200Schema

export const issuesUpdateLabelPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"name": z.string()
    })

/**
 * @description Response
 */
export const issuesUpdateLabel200Schema = labelSchema.describe("Color-coded labels help you categorize and filter your issues (just like labels in Gmail).")

export const issuesUpdateLabelMutationRequestSchema = z.object({
    "new_name": z.optional(z.string().describe("The new name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png \":strawberry:\"). For a full list of available emoji and codes, see \"[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet).\"")),
"color": z.optional(z.string().describe("The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.")),
"description": z.optional(z.string().describe("A short description of the label. Must be 100 characters or fewer."))
    })

export const issuesUpdateLabelMutationResponseSchema = issuesUpdateLabel200Schema

export const issuesDeleteLabelPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"name": z.string()
    })

/**
 * @description Response
 */
export const issuesDeleteLabel204Schema = z.unknown()

export const issuesDeleteLabelMutationResponseSchema = issuesDeleteLabel204Schema

export const reposListLanguagesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposListLanguages200Schema = languageSchema.describe("Language")

export const reposListLanguagesQueryResponseSchema = reposListLanguages200Schema

export const licensesGetForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const licensesGetForRepoQueryParamsSchema = z.object({
    get "ref"(){
                return codeScanningRefSchema.describe("The Git reference, formatted as `refs/pull/<number>/merge`, `refs/pull/<number>/head`,\n`refs/heads/<branch name>` or simply `<branch name>`.").optional()
              }
    }).optional()

/**
 * @description Response
 */
export const licensesGetForRepo200Schema = licenseContentSchema.describe("License Content")

/**
 * @description Resource not found
 */
export const licensesGetForRepo404Schema = basicErrorSchema.describe("Basic Error")

export const licensesGetForRepoQueryResponseSchema = licensesGetForRepo200Schema

export const reposMergeUpstreamPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description The branch has been successfully synced with the upstream repository
 */
export const reposMergeUpstream200Schema = mergedUpstreamSchema.describe("Results of a successful merge upstream request")

/**
 * @description The branch could not be synced because of a merge conflict
 */
export const reposMergeUpstream409Schema = z.unknown()

/**
 * @description The branch could not be synced for some other reason
 */
export const reposMergeUpstream422Schema = z.unknown()

export const reposMergeUpstreamMutationRequestSchema = z.object({
    "branch": z.string().describe("The name of the branch which should be updated to match upstream.")
    })

export const reposMergeUpstreamMutationResponseSchema = reposMergeUpstream200Schema

export const reposMergePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Successful Response (The resulting merge commit)
 */
export const reposMerge201Schema = commitSchema.describe("Commit")

/**
 * @description Response when already merged
 */
export const reposMerge204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const reposMerge403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Not Found when the base or head does not exist
 */
export const reposMerge404Schema = z.unknown()

/**
 * @description Conflict when there is a merge conflict
 */
export const reposMerge409Schema = z.unknown()

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposMerge422Schema = validationErrorSchema.describe("Validation Error")

export const reposMergeMutationRequestSchema = z.object({
    "base": z.string().describe("The name of the base branch that the head will be merged into."),
"head": z.string().describe("The head to merge. This can be a branch name or a commit SHA1."),
"commit_message": z.optional(z.string().describe("Commit message to use for the merge commit. If omitted, a default message will be used."))
    })

export const reposMergeMutationResponseSchema = z.union([reposMerge201Schema, reposMerge204Schema])

export const issuesListMilestonesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const issuesListMilestonesQueryParamsSchema = z.object({
    "state": z.enum(["open", "closed", "all"]).default("open").describe("The state of the milestone. Either `open`, `closed`, or `all`."),
"sort": z.enum(["due_on", "completeness"]).default("due_on").describe("What to sort results by. Either `due_on` or `completeness`."),
"direction": z.enum(["asc", "desc"]).default("asc").describe("The direction of the sort. Either `asc` or `desc`."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesListMilestones200Schema = z.array(milestoneSchema.describe("A collection of related issues and pull requests."))

/**
 * @description Resource not found
 */
export const issuesListMilestones404Schema = basicErrorSchema.describe("Basic Error")

export const issuesListMilestonesQueryResponseSchema = issuesListMilestones200Schema

export const issuesCreateMilestonePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const issuesCreateMilestone201Schema = milestoneSchema.describe("A collection of related issues and pull requests.")

/**
 * @description Resource not found
 */
export const issuesCreateMilestone404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const issuesCreateMilestone422Schema = validationErrorSchema.describe("Validation Error")

export const issuesCreateMilestoneMutationRequestSchema = z.object({
    "title": z.string().describe("The title of the milestone."),
"state": z.optional(z.enum(["open", "closed"]).default("open").describe("The state of the milestone. Either `open` or `closed`.")),
"description": z.optional(z.string().describe("A description of the milestone.")),
"due_on": z.optional(z.iso.datetime({ offset: true }).describe("The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."))
    })

export const issuesCreateMilestoneMutationResponseSchema = issuesCreateMilestone201Schema

export const issuesGetMilestonePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"milestone_number": z.coerce.number().int().describe("The number that identifies the milestone.")
    })

/**
 * @description Response
 */
export const issuesGetMilestone200Schema = milestoneSchema.describe("A collection of related issues and pull requests.")

/**
 * @description Resource not found
 */
export const issuesGetMilestone404Schema = basicErrorSchema.describe("Basic Error")

export const issuesGetMilestoneQueryResponseSchema = issuesGetMilestone200Schema

export const issuesUpdateMilestonePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"milestone_number": z.coerce.number().int().describe("The number that identifies the milestone.")
    })

/**
 * @description Response
 */
export const issuesUpdateMilestone200Schema = milestoneSchema.describe("A collection of related issues and pull requests.")

export const issuesUpdateMilestoneMutationRequestSchema = z.object({
    "title": z.optional(z.string().describe("The title of the milestone.")),
"state": z.optional(z.enum(["open", "closed"]).default("open").describe("The state of the milestone. Either `open` or `closed`.")),
"description": z.optional(z.string().describe("A description of the milestone.")),
"due_on": z.optional(z.iso.datetime({ offset: true }).describe("The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."))
    })

export const issuesUpdateMilestoneMutationResponseSchema = issuesUpdateMilestone200Schema

export const issuesDeleteMilestonePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"milestone_number": z.coerce.number().int().describe("The number that identifies the milestone.")
    })

/**
 * @description Response
 */
export const issuesDeleteMilestone204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const issuesDeleteMilestone404Schema = basicErrorSchema.describe("Basic Error")

export const issuesDeleteMilestoneMutationResponseSchema = issuesDeleteMilestone204Schema

export const issuesListLabelsForMilestonePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"milestone_number": z.coerce.number().int().describe("The number that identifies the milestone.")
    })

export const issuesListLabelsForMilestoneQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesListLabelsForMilestone200Schema = z.array(labelSchema.describe("Color-coded labels help you categorize and filter your issues (just like labels in Gmail)."))

export const issuesListLabelsForMilestoneQueryResponseSchema = issuesListLabelsForMilestone200Schema

export const activityListRepoNotificationsForAuthenticatedUserPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const activityListRepoNotificationsForAuthenticatedUserQueryParamsSchema = z.object({
    "all": z.boolean().default(false).describe("If `true`, show notifications marked as read."),
"participating": z.boolean().default(false).describe("If `true`, only shows notifications in which the user is directly participating or mentioned."),
"since": z.optional(z.iso.datetime({ offset: true }).describe("Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"before": z.optional(z.iso.datetime({ offset: true }).describe("Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListRepoNotificationsForAuthenticatedUser200Schema = z.array(threadSchema.describe("Thread"))

export const activityListRepoNotificationsForAuthenticatedUserQueryResponseSchema = activityListRepoNotificationsForAuthenticatedUser200Schema

export const activityMarkRepoNotificationsAsReadPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const activityMarkRepoNotificationsAsRead202Schema = z.object({
    "message": z.optional(z.string()),
"url": z.optional(z.string())
    })

/**
 * @description Reset Content
 */
export const activityMarkRepoNotificationsAsRead205Schema = z.unknown()

export const activityMarkRepoNotificationsAsReadMutationRequestSchema = z.object({
    "last_read_at": z.optional(z.iso.datetime({ offset: true }).describe("Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp."))
    })

export const activityMarkRepoNotificationsAsReadMutationResponseSchema = z.union([activityMarkRepoNotificationsAsRead202Schema, activityMarkRepoNotificationsAsRead205Schema])

export const reposGetPagesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposGetPages200Schema = pageSchema.describe("The configuration for GitHub Pages for a repository.")

/**
 * @description Resource not found
 */
export const reposGetPages404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetPagesQueryResponseSchema = reposGetPages200Schema

export const reposCreatePagesSitePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposCreatePagesSite201Schema = pageSchema.describe("The configuration for GitHub Pages for a repository.")

/**
 * @description Conflict
 */
export const reposCreatePagesSite409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposCreatePagesSite422Schema = validationErrorSchema.describe("Validation Error")

export const reposCreatePagesSiteMutationRequestSchema = .describe("The source branch and directory used to publish your Pages site.").nullable()

export const reposCreatePagesSiteMutationResponseSchema = reposCreatePagesSite201Schema

export const reposUpdateInformationAboutPagesSitePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposUpdateInformationAboutPagesSite204Schema = z.unknown()

/**
 * @description Bad Request
 */
export const reposUpdateInformationAboutPagesSite400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const reposUpdateInformationAboutPagesSite409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposUpdateInformationAboutPagesSite422Schema = validationErrorSchema.describe("Validation Error")

export const reposUpdateInformationAboutPagesSiteMutationRequestSchema = z.unknown()

export const reposUpdateInformationAboutPagesSiteMutationResponseSchema = reposUpdateInformationAboutPagesSite204Schema

export const reposDeletePagesSitePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposDeletePagesSite204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposDeletePagesSite404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const reposDeletePagesSite409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposDeletePagesSite422Schema = validationErrorSchema.describe("Validation Error")

export const reposDeletePagesSiteMutationResponseSchema = reposDeletePagesSite204Schema

export const reposListPagesBuildsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposListPagesBuildsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListPagesBuilds200Schema = z.array(pageBuildSchema.describe("Page Build"))

export const reposListPagesBuildsQueryResponseSchema = reposListPagesBuilds200Schema

export const reposRequestPagesBuildPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposRequestPagesBuild201Schema = pageBuildStatusSchema.describe("Page Build Status")

export const reposRequestPagesBuildMutationResponseSchema = reposRequestPagesBuild201Schema

export const reposGetLatestPagesBuildPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposGetLatestPagesBuild200Schema = pageBuildSchema.describe("Page Build")

export const reposGetLatestPagesBuildQueryResponseSchema = reposGetLatestPagesBuild200Schema

export const reposGetPagesBuildPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"build_id": z.coerce.number().int()
    })

/**
 * @description Response
 */
export const reposGetPagesBuild200Schema = pageBuildSchema.describe("Page Build")

export const reposGetPagesBuildQueryResponseSchema = reposGetPagesBuild200Schema

export const reposCreatePagesDeploymentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposCreatePagesDeployment200Schema = pageDeploymentSchema.describe("The GitHub Pages deployment status.")

/**
 * @description Bad Request
 */
export const reposCreatePagesDeployment400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposCreatePagesDeployment404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposCreatePagesDeployment422Schema = validationErrorSchema.describe("Validation Error")

export const reposCreatePagesDeploymentMutationRequestSchema = z.object({
    "artifact_id": z.optional(z.number().describe("The ID of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.")),
"artifact_url": z.optional(z.string().describe("The URL of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.")),
"environment": z.optional(z.string().default("github-pages").describe("The target environment for this GitHub Pages deployment.")),
"pages_build_version": z.string().default("GITHUB_SHA").describe("A unique string that represents the version of the build for this deployment."),
"oidc_token": z.string().describe("The OIDC token issued by GitHub Actions certifying the origin of the deployment.")
    }).describe("The object used to create GitHub Pages deployment")

export const reposCreatePagesDeploymentMutationResponseSchema = reposCreatePagesDeployment200Schema

export const reposGetPagesDeploymentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pages_deployment_id": z.union([z.coerce.number().int(), z.string()]).describe("The ID of the Pages deployment. You can also give the commit SHA of the deployment.")
    })

/**
 * @description Response
 */
export const reposGetPagesDeployment200Schema = pagesDeploymentStatusSchema

/**
 * @description Resource not found
 */
export const reposGetPagesDeployment404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetPagesDeploymentQueryResponseSchema = reposGetPagesDeployment200Schema

export const reposCancelPagesDeploymentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pages_deployment_id": z.union([z.coerce.number().int(), z.string()]).describe("The ID of the Pages deployment. You can also give the commit SHA of the deployment.")
    })

/**
 * @description A header with no content is returned.
 */
export const reposCancelPagesDeployment204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposCancelPagesDeployment404Schema = basicErrorSchema.describe("Basic Error")

export const reposCancelPagesDeploymentMutationResponseSchema = reposCancelPagesDeployment204Schema

export const reposGetPagesHealthCheckPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposGetPagesHealthCheck200Schema = pagesHealthCheckSchema.describe("Pages Health Check Status")

/**
 * @description Empty response
 */
export const reposGetPagesHealthCheck202Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Custom domains are not available for GitHub Pages
 */
export const reposGetPagesHealthCheck400Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposGetPagesHealthCheck404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description There isn\'t a CNAME for this page
 */
export const reposGetPagesHealthCheck422Schema = z.unknown()

export const reposGetPagesHealthCheckQueryResponseSchema = z.union([reposGetPagesHealthCheck200Schema, reposGetPagesHealthCheck202Schema])

export const reposCheckPrivateVulnerabilityReportingPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Private vulnerability reporting status
 */
export const reposCheckPrivateVulnerabilityReporting200Schema = z.object({
    "enabled": z.boolean().describe("Whether or not private vulnerability reporting is enabled for the repository.")
    })

/**
 * @description Bad Request
 */
export const reposCheckPrivateVulnerabilityReporting422Schema = basicErrorSchema.describe("Basic Error")

export const reposCheckPrivateVulnerabilityReportingQueryResponseSchema = reposCheckPrivateVulnerabilityReporting200Schema

export const reposEnablePrivateVulnerabilityReportingPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description A header with no content is returned.
 */
export const reposEnablePrivateVulnerabilityReporting204Schema = z.unknown()

/**
 * @description Bad Request
 */
export const reposEnablePrivateVulnerabilityReporting422Schema = basicErrorSchema.describe("Basic Error")

export const reposEnablePrivateVulnerabilityReportingMutationResponseSchema = reposEnablePrivateVulnerabilityReporting204Schema

export const reposDisablePrivateVulnerabilityReportingPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description A header with no content is returned.
 */
export const reposDisablePrivateVulnerabilityReporting204Schema = z.unknown()

/**
 * @description Bad Request
 */
export const reposDisablePrivateVulnerabilityReporting422Schema = basicErrorSchema.describe("Basic Error")

export const reposDisablePrivateVulnerabilityReportingMutationResponseSchema = reposDisablePrivateVulnerabilityReporting204Schema

export const projectsClassicListForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const projectsClassicListForRepoQueryParamsSchema = z.object({
    "state": z.enum(["open", "closed", "all"]).default("open").describe("Indicates the state of the projects to return."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const projectsClassicListForRepo200Schema = z.array(projectSchema.describe("Projects are a way to organize columns and cards of work."))

/**
 * @description Requires authentication
 */
export const projectsClassicListForRepo401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicListForRepo403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const projectsClassicListForRepo404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const projectsClassicListForRepo410Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const projectsClassicListForRepo422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const projectsClassicListForRepoQueryResponseSchema = projectsClassicListForRepo200Schema

export const projectsClassicCreateForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const projectsClassicCreateForRepo201Schema = projectSchema.describe("Projects are a way to organize columns and cards of work.")

/**
 * @description Requires authentication
 */
export const projectsClassicCreateForRepo401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicCreateForRepo403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const projectsClassicCreateForRepo404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Gone
 */
export const projectsClassicCreateForRepo410Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const projectsClassicCreateForRepo422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const projectsClassicCreateForRepoMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the project."),
"body": z.optional(z.string().describe("The description of the project."))
    })

export const projectsClassicCreateForRepoMutationResponseSchema = projectsClassicCreateForRepo201Schema

export const reposCustomPropertiesForReposGetRepositoryValuesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposCustomPropertiesForReposGetRepositoryValues200Schema = z.array(customPropertyValueSchema.describe("Custom property name and associated value"))

/**
 * @description Forbidden
 */
export const reposCustomPropertiesForReposGetRepositoryValues403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposCustomPropertiesForReposGetRepositoryValues404Schema = basicErrorSchema.describe("Basic Error")

export const reposCustomPropertiesForReposGetRepositoryValuesQueryResponseSchema = reposCustomPropertiesForReposGetRepositoryValues200Schema

export const reposCustomPropertiesForReposCreateOrUpdateRepositoryValuesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description No Content when custom property values are successfully created or updated
 */
export const reposCustomPropertiesForReposCreateOrUpdateRepositoryValues204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const reposCustomPropertiesForReposCreateOrUpdateRepositoryValues403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposCustomPropertiesForReposCreateOrUpdateRepositoryValues404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposCustomPropertiesForReposCreateOrUpdateRepositoryValues422Schema = validationErrorSchema.describe("Validation Error")

export const reposCustomPropertiesForReposCreateOrUpdateRepositoryValuesMutationRequestSchema = z.object({
    get "properties"(){
                return z.array(customPropertyValueSchema.describe("Custom property name and associated value")).describe("A list of custom property names and associated values to apply to the repositories.")
              }
    })

export const reposCustomPropertiesForReposCreateOrUpdateRepositoryValuesMutationResponseSchema = reposCustomPropertiesForReposCreateOrUpdateRepositoryValues204Schema

export const pullsListPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const pullsListQueryParamsSchema = z.object({
    "state": z.enum(["open", "closed", "all"]).default("open").describe("Either `open`, `closed`, or `all` to filter by state."),
"head": z.optional(z.string().describe("Filter pulls by head user or head organization and branch name in the format of `user:ref-name` or `organization:ref-name`. For example: `github:new-script-format` or `octocat:test-branch`.")),
"base": z.optional(z.string().describe("Filter pulls by base branch name. Example: `gh-pages`.")),
"sort": z.enum(["created", "updated", "popularity", "long-running"]).default("created").describe("What to sort results by. `popularity` will sort by the number of comments. `long-running` will sort by date created and will limit the results to pull requests that have been open for more than a month and have had activity within the past month."),
"direction": z.optional(z.enum(["asc", "desc"]).describe("The direction of the sort. Default: `desc` when sort is `created` or sort is not specified, otherwise `asc`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const pullsList200Schema = z.array(pullRequestSimpleSchema.describe("Pull Request Simple"))

/**
 * @description Not modified
 */
export const pullsList304Schema = z.unknown()

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const pullsList422Schema = validationErrorSchema.describe("Validation Error")

export const pullsListQueryResponseSchema = pullsList200Schema

export const pullsCreatePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const pullsCreate201Schema = pullRequestSchema.describe("Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.")

/**
 * @description Forbidden
 */
export const pullsCreate403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const pullsCreate422Schema = validationErrorSchema.describe("Validation Error")

export const pullsCreateMutationRequestSchema = z.object({
    "title": z.optional(z.string().describe("The title of the new pull request. Required unless `issue` is specified.")),
"head": z.string().describe("The name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace `head` with a user like this: `username:branch`."),
"head_repo": z.optional(z.string().describe("The name of the repository where the changes in the pull request were made. This field is required for cross-repository pull requests if both repositories are owned by the same organization.")),
"base": z.string().describe("The name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository."),
"body": z.optional(z.string().describe("The contents of the pull request.")),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.")),
"draft": z.optional(z.boolean().describe("Indicates whether the pull request is a draft. See \"[Draft Pull Requests](https://docs.github.com/articles/about-pull-requests#draft-pull-requests)\" in the GitHub Help documentation to learn more.")),
"issue": z.optional(z.int().describe("An issue in the repository to convert to a pull request. The issue title, body, and comments will become the title, body, and comments on the new pull request. Required unless `title` is specified."))
    })

export const pullsCreateMutationResponseSchema = pullsCreate201Schema

export const pullsListReviewCommentsForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const pullsListReviewCommentsForRepoQueryParamsSchema = z.object({
    "sort": z.optional(z.enum(["created", "updated", "created_at"])),
"direction": z.optional(z.enum(["asc", "desc"]).describe("The direction to sort results. Ignored without `sort` parameter.")),
"since": z.optional(z.iso.datetime({ offset: true }).describe("Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const pullsListReviewCommentsForRepo200Schema = z.array(pullRequestReviewCommentSchema.describe("Pull Request Review Comments are comments on a portion of the Pull Request's diff."))

export const pullsListReviewCommentsForRepoQueryResponseSchema = pullsListReviewCommentsForRepo200Schema

export const pullsGetReviewCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

/**
 * @description Response
 */
export const pullsGetReviewComment200Schema = pullRequestReviewCommentSchema.describe("Pull Request Review Comments are comments on a portion of the Pull Request's diff.")

/**
 * @description Resource not found
 */
export const pullsGetReviewComment404Schema = basicErrorSchema.describe("Basic Error")

export const pullsGetReviewCommentQueryResponseSchema = pullsGetReviewComment200Schema

export const pullsUpdateReviewCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

/**
 * @description Response
 */
export const pullsUpdateReviewComment200Schema = pullRequestReviewCommentSchema.describe("Pull Request Review Comments are comments on a portion of the Pull Request's diff.")

export const pullsUpdateReviewCommentMutationRequestSchema = z.object({
    "body": z.string().describe("The text of the reply to the review comment.")
    })

export const pullsUpdateReviewCommentMutationResponseSchema = pullsUpdateReviewComment200Schema

export const pullsDeleteReviewCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

/**
 * @description Response
 */
export const pullsDeleteReviewComment204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const pullsDeleteReviewComment404Schema = basicErrorSchema.describe("Basic Error")

export const pullsDeleteReviewCommentMutationResponseSchema = pullsDeleteReviewComment204Schema

export const reactionsListForPullRequestReviewCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

export const reactionsListForPullRequestReviewCommentQueryParamsSchema = z.object({
    "content": z.optional(z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a pull request review comment.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reactionsListForPullRequestReviewComment200Schema = z.array(reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively."))

/**
 * @description Resource not found
 */
export const reactionsListForPullRequestReviewComment404Schema = basicErrorSchema.describe("Basic Error")

export const reactionsListForPullRequestReviewCommentQueryResponseSchema = reactionsListForPullRequestReviewComment200Schema

export const reactionsCreateForPullRequestReviewCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

/**
 * @description Reaction exists
 */
export const reactionsCreateForPullRequestReviewComment200Schema = reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

/**
 * @description Reaction created
 */
export const reactionsCreateForPullRequestReviewComment201Schema = reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reactionsCreateForPullRequestReviewComment422Schema = validationErrorSchema.describe("Validation Error")

export const reactionsCreateForPullRequestReviewCommentMutationRequestSchema = z.object({
    "content": z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the pull request review comment.")
    })

export const reactionsCreateForPullRequestReviewCommentMutationResponseSchema = z.union([reactionsCreateForPullRequestReviewComment200Schema, reactionsCreateForPullRequestReviewComment201Schema])

export const reactionsDeleteForPullRequestCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment."),
"reaction_id": z.coerce.number().int().describe("The unique identifier of the reaction.")
    })

/**
 * @description Response
 */
export const reactionsDeleteForPullRequestComment204Schema = z.unknown()

export const reactionsDeleteForPullRequestCommentMutationResponseSchema = reactionsDeleteForPullRequestComment204Schema

export const pullsGetPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request.")
    })

/**
 * @description Pass the appropriate [media type](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types) to fetch diff and patch formats.
 */
export const pullsGet200Schema = pullRequestSchema.describe("Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.")

/**
 * @description Not modified
 */
export const pullsGet304Schema = z.unknown()

/**
 * @description Resource not found
 */
export const pullsGet404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Unacceptable
 */
export const pullsGet406Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const pullsGet500Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const pullsGet503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const pullsGetQueryResponseSchema = pullsGet200Schema

export const pullsUpdatePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request.")
    })

/**
 * @description Response
 */
export const pullsUpdate200Schema = pullRequestSchema.describe("Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.")

/**
 * @description Forbidden
 */
export const pullsUpdate403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const pullsUpdate422Schema = validationErrorSchema.describe("Validation Error")

export const pullsUpdateMutationRequestSchema = z.object({
    "title": z.optional(z.string().describe("The title of the pull request.")),
"body": z.optional(z.string().describe("The contents of the pull request.")),
"state": z.optional(z.enum(["open", "closed"]).describe("State of this Pull Request. Either `open` or `closed`.")),
"base": z.optional(z.string().describe("The name of the branch you want your changes pulled into. This should be an existing branch on the current repository. You cannot update the base branch on a pull request to point to another repository.")),
"maintainer_can_modify": z.optional(z.boolean().describe("Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request."))
    })

export const pullsUpdateMutationResponseSchema = pullsUpdate200Schema

export const codespacesCreateWithPrForAuthenticatedUserPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request.")
    })

/**
 * @description Response when the codespace was successfully created
 */
export const codespacesCreateWithPrForAuthenticatedUser201Schema = codespaceSchema.describe("A codespace.")

/**
 * @description Response when the codespace creation partially failed but is being retried in the background
 */
export const codespacesCreateWithPrForAuthenticatedUser202Schema = codespaceSchema.describe("A codespace.")

/**
 * @description Requires authentication
 */
export const codespacesCreateWithPrForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesCreateWithPrForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesCreateWithPrForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codespacesCreateWithPrForAuthenticatedUser503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codespacesCreateWithPrForAuthenticatedUserMutationRequestSchema = z.object({
    "location": z.optional(z.string().describe("The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.")),
"geo": z.optional(z.enum(["EuropeWest", "SoutheastAsia", "UsEast", "UsWest"]).describe("The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down.")),
"client_ip": z.optional(z.string().describe("IP for location auto-detection when proxying a request")),
"machine": z.optional(z.string().describe("Machine type to use for this codespace")),
"devcontainer_path": z.optional(z.string().describe("Path to devcontainer.json config to use for this codespace")),
"multi_repo_permissions_opt_out": z.optional(z.boolean().describe("Whether to authorize requested permissions from devcontainer.json")),
"working_directory": z.optional(z.string().describe("Working directory for this codespace")),
"idle_timeout_minutes": z.optional(z.int().describe("Time in minutes before codespace stops from inactivity")),
"display_name": z.optional(z.string().describe("Display name for this codespace")),
"retention_period_minutes": z.optional(z.int().describe("Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days)."))
    }).nullable()

export const codespacesCreateWithPrForAuthenticatedUserMutationResponseSchema = z.union([codespacesCreateWithPrForAuthenticatedUser201Schema, codespacesCreateWithPrForAuthenticatedUser202Schema])

export const pullsListReviewCommentsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request.")
    })

export const pullsListReviewCommentsQueryParamsSchema = z.object({
    "sort": z.enum(["created", "updated"]).default("created").describe("The property to sort the results by."),
"direction": z.optional(z.enum(["asc", "desc"]).describe("The direction to sort results. Ignored without `sort` parameter.")),
"since": z.optional(z.iso.datetime({ offset: true }).describe("Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const pullsListReviewComments200Schema = z.array(pullRequestReviewCommentSchema.describe("Pull Request Review Comments are comments on a portion of the Pull Request's diff."))

export const pullsListReviewCommentsQueryResponseSchema = pullsListReviewComments200Schema

export const pullsCreateReviewCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request.")
    })

/**
 * @description Response
 */
export const pullsCreateReviewComment201Schema = pullRequestReviewCommentSchema.describe("Pull Request Review Comments are comments on a portion of the Pull Request's diff.")

/**
 * @description Forbidden
 */
export const pullsCreateReviewComment403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const pullsCreateReviewComment422Schema = validationErrorSchema.describe("Validation Error")

export const pullsCreateReviewCommentMutationRequestSchema = z.object({
    "body": z.string().describe("The text of the review comment."),
"commit_id": z.string().describe("The SHA of the commit needing a comment. Not using the latest commit SHA may render your comment outdated if a subsequent commit modifies the line you specify as the `position`."),
"path": z.string().describe("The relative path to the file that necessitates a comment."),
"position": z.optional(z.int().describe("**This parameter is closing down. Use `line` instead**. The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. The position value equals the number of lines down from the first \"@@\" hunk header in the file you want to add a comment. The line just below the \"@@\" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.")),
"side": z.optional(z.enum(["LEFT", "RIGHT"]).describe("In a split diff view, the side of the diff that the pull request's changes appear on. Can be `LEFT` or `RIGHT`. Use `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear in green or unchanged lines that appear in white and are shown for context. For a multi-line comment, side represents whether the last line of the comment range is a deletion or addition. For more information, see \"[Diff view options](https://docs.github.com/articles/about-comparing-branches-in-pull-requests#diff-view-options)\" in the GitHub Help documentation.")),
"line": z.optional(z.int().describe("**Required unless using `subject_type:file`**. The line of the blob in the pull request diff that the comment applies to. For a multi-line comment, the last line of the range that your comment applies to.")),
"start_line": z.optional(z.int().describe("**Required when using multi-line comments unless using `in_reply_to`**. The `start_line` is the first line in the pull request diff that your multi-line comment applies to. To learn more about multi-line comments, see \"[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)\" in the GitHub Help documentation.")),
"start_side": z.optional(z.enum(["LEFT", "RIGHT", "side"]).describe("**Required when using multi-line comments unless using `in_reply_to`**. The `start_side` is the starting side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn more about multi-line comments, see \"[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)\" in the GitHub Help documentation. See `side` in this table for additional context.")),
"in_reply_to": z.optional(z.int().describe("The ID of the review comment to reply to. To find the ID of a review comment with [\"List review comments on a pull request\"](#list-review-comments-on-a-pull-request). When specified, all parameters other than `body` in the request body are ignored.")),
"subject_type": z.optional(z.enum(["line", "file"]).describe("The level at which the comment is targeted."))
    })

export const pullsCreateReviewCommentMutationResponseSchema = pullsCreateReviewComment201Schema

export const pullsCreateReplyForReviewCommentPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request."),
"comment_id": z.coerce.number().int().describe("The unique identifier of the comment.")
    })

/**
 * @description Response
 */
export const pullsCreateReplyForReviewComment201Schema = pullRequestReviewCommentSchema.describe("Pull Request Review Comments are comments on a portion of the Pull Request's diff.")

/**
 * @description Resource not found
 */
export const pullsCreateReplyForReviewComment404Schema = basicErrorSchema.describe("Basic Error")

export const pullsCreateReplyForReviewCommentMutationRequestSchema = z.object({
    "body": z.string().describe("The text of the review comment.")
    })

export const pullsCreateReplyForReviewCommentMutationResponseSchema = pullsCreateReplyForReviewComment201Schema

export const pullsListCommitsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request.")
    })

export const pullsListCommitsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const pullsListCommits200Schema = z.array(commitSchema.describe("Commit"))

export const pullsListCommitsQueryResponseSchema = pullsListCommits200Schema

export const pullsListFilesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request.")
    })

export const pullsListFilesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const pullsListFiles200Schema = z.array(diffEntrySchema.describe("Diff Entry"))

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const pullsListFiles422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Internal Error
 */
export const pullsListFiles500Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const pullsListFiles503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const pullsListFilesQueryResponseSchema = pullsListFiles200Schema

export const pullsCheckIfMergedPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request.")
    })

/**
 * @description Response if pull request has been merged
 */
export const pullsCheckIfMerged204Schema = z.unknown()

/**
 * @description Not Found if pull request has not been merged
 */
export const pullsCheckIfMerged404Schema = z.unknown()

export const pullsCheckIfMergedQueryResponseSchema = pullsCheckIfMerged204Schema

export const pullsMergePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request.")
    })

/**
 * @description if merge was successful
 */
export const pullsMerge200Schema = pullRequestMergeResultSchema.describe("Pull Request Merge Result")

/**
 * @description Forbidden
 */
export const pullsMerge403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const pullsMerge404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Method Not Allowed if merge cannot be performed
 */
export const pullsMerge405Schema = z.object({
    "message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

/**
 * @description Conflict if sha was provided and pull request head did not match
 */
export const pullsMerge409Schema = z.object({
    "message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const pullsMerge422Schema = validationErrorSchema.describe("Validation Error")

export const pullsMergeMutationRequestSchema = z.object({
    "commit_title": z.optional(z.string().describe("Title for the automatic commit message.")),
"commit_message": z.optional(z.string().describe("Extra detail to append to automatic commit message.")),
"sha": z.optional(z.string().describe("SHA that pull request head must match to allow merge.")),
"merge_method": z.optional(z.enum(["merge", "squash", "rebase"]).describe("The merge method to use."))
    }).nullable()

export const pullsMergeMutationResponseSchema = pullsMerge200Schema

export const pullsListRequestedReviewersPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request.")
    })

/**
 * @description Response
 */
export const pullsListRequestedReviewers200Schema = pullRequestReviewRequestSchema.describe("Pull Request Review Request")

export const pullsListRequestedReviewersQueryResponseSchema = pullsListRequestedReviewers200Schema

export const pullsRequestReviewersPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request.")
    })

/**
 * @description Response
 */
export const pullsRequestReviewers201Schema = pullRequestSimpleSchema.describe("Pull Request Simple")

/**
 * @description Forbidden
 */
export const pullsRequestReviewers403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Unprocessable Entity if user is not a collaborator
 */
export const pullsRequestReviewers422Schema = z.unknown()

export const pullsRequestReviewersMutationRequestSchema = z.unknown()

export const pullsRequestReviewersMutationResponseSchema = pullsRequestReviewers201Schema

export const pullsRemoveRequestedReviewersPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request.")
    })

/**
 * @description Response
 */
export const pullsRemoveRequestedReviewers200Schema = pullRequestSimpleSchema.describe("Pull Request Simple")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const pullsRemoveRequestedReviewers422Schema = validationErrorSchema.describe("Validation Error")

export const pullsRemoveRequestedReviewersMutationRequestSchema = z.object({
    "reviewers": z.array(z.string()).describe("An array of user `login`s that will be removed."),
"team_reviewers": z.optional(z.array(z.string()).describe("An array of team `slug`s that will be removed."))
    })

export const pullsRemoveRequestedReviewersMutationResponseSchema = pullsRemoveRequestedReviewers200Schema

export const pullsListReviewsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request.")
    })

export const pullsListReviewsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description The list of reviews returns in chronological order.
 */
export const pullsListReviews200Schema = z.array(pullRequestReviewSchema.describe("Pull Request Reviews are reviews on pull requests."))

export const pullsListReviewsQueryResponseSchema = pullsListReviews200Schema

export const pullsCreateReviewPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request.")
    })

/**
 * @description Response
 */
export const pullsCreateReview200Schema = pullRequestReviewSchema.describe("Pull Request Reviews are reviews on pull requests.")

/**
 * @description Forbidden
 */
export const pullsCreateReview403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const pullsCreateReview422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const pullsCreateReviewMutationRequestSchema = z.object({
    "commit_id": z.optional(z.string().describe("The SHA of the commit that needs a review. Not using the latest commit SHA may render your review comment outdated if a subsequent commit modifies the line you specify as the `position`. Defaults to the most recent commit in the pull request when you do not specify a value.")),
"body": z.optional(z.string().describe("**Required** when using `REQUEST_CHANGES` or `COMMENT` for the `event` parameter. The body text of the pull request review.")),
"event": z.optional(z.enum(["APPROVE", "REQUEST_CHANGES", "COMMENT"]).describe("The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review action state to `PENDING`, which means you will need to [submit the pull request review](https://docs.github.com/rest/pulls/reviews#submit-a-review-for-a-pull-request) when you are ready.")),
"comments": z.optional(z.array(z.object({
    "path": z.string().describe("The relative path to the file that necessitates a review comment."),
"position": z.optional(z.int().describe("The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. The `position` value equals the number of lines down from the first \"@@\" hunk header in the file you want to add a comment. The line just below the \"@@\" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.")),
"body": z.string().describe("Text of the review comment."),
"line": z.optional(z.int()),
"side": z.optional(z.string()),
"start_line": z.optional(z.int()),
"start_side": z.optional(z.string())
    })).describe("Use the following table to specify the location, destination, and contents of the draft review comment."))
    })

export const pullsCreateReviewMutationResponseSchema = pullsCreateReview200Schema

export const pullsGetReviewPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request."),
"review_id": z.coerce.number().int().describe("The unique identifier of the review.")
    })

/**
 * @description Response
 */
export const pullsGetReview200Schema = pullRequestReviewSchema.describe("Pull Request Reviews are reviews on pull requests.")

/**
 * @description Resource not found
 */
export const pullsGetReview404Schema = basicErrorSchema.describe("Basic Error")

export const pullsGetReviewQueryResponseSchema = pullsGetReview200Schema

export const pullsUpdateReviewPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request."),
"review_id": z.coerce.number().int().describe("The unique identifier of the review.")
    })

/**
 * @description Response
 */
export const pullsUpdateReview200Schema = pullRequestReviewSchema.describe("Pull Request Reviews are reviews on pull requests.")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const pullsUpdateReview422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const pullsUpdateReviewMutationRequestSchema = z.object({
    "body": z.string().describe("The body text of the pull request review.")
    })

export const pullsUpdateReviewMutationResponseSchema = pullsUpdateReview200Schema

export const pullsDeletePendingReviewPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request."),
"review_id": z.coerce.number().int().describe("The unique identifier of the review.")
    })

/**
 * @description Response
 */
export const pullsDeletePendingReview200Schema = pullRequestReviewSchema.describe("Pull Request Reviews are reviews on pull requests.")

/**
 * @description Resource not found
 */
export const pullsDeletePendingReview404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const pullsDeletePendingReview422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const pullsDeletePendingReviewMutationResponseSchema = pullsDeletePendingReview200Schema

export const pullsListCommentsForReviewPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request."),
"review_id": z.coerce.number().int().describe("The unique identifier of the review.")
    })

export const pullsListCommentsForReviewQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const pullsListCommentsForReview200Schema = z.array(reviewCommentSchema.describe("Legacy Review Comment"))

/**
 * @description Resource not found
 */
export const pullsListCommentsForReview404Schema = basicErrorSchema.describe("Basic Error")

export const pullsListCommentsForReviewQueryResponseSchema = pullsListCommentsForReview200Schema

export const pullsDismissReviewPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request."),
"review_id": z.coerce.number().int().describe("The unique identifier of the review.")
    })

/**
 * @description Response
 */
export const pullsDismissReview200Schema = pullRequestReviewSchema.describe("Pull Request Reviews are reviews on pull requests.")

/**
 * @description Resource not found
 */
export const pullsDismissReview404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const pullsDismissReview422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const pullsDismissReviewMutationRequestSchema = z.object({
    "message": z.string().describe("The message for the pull request review dismissal"),
"event": z.optional(z.enum(["DISMISS"]))
    })

export const pullsDismissReviewMutationResponseSchema = pullsDismissReview200Schema

export const pullsSubmitReviewPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request."),
"review_id": z.coerce.number().int().describe("The unique identifier of the review.")
    })

/**
 * @description Response
 */
export const pullsSubmitReview200Schema = pullRequestReviewSchema.describe("Pull Request Reviews are reviews on pull requests.")

/**
 * @description Forbidden
 */
export const pullsSubmitReview403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const pullsSubmitReview404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const pullsSubmitReview422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const pullsSubmitReviewMutationRequestSchema = z.object({
    "body": z.optional(z.string().describe("The body text of the pull request review")),
"event": z.enum(["APPROVE", "REQUEST_CHANGES", "COMMENT"]).describe("The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns _HTTP 422 (Unrecognizable entity)_ and sets the review action state to `PENDING`, which means you will need to re-submit the pull request review using a review action.")
    })

export const pullsSubmitReviewMutationResponseSchema = pullsSubmitReview200Schema

export const pullsUpdateBranchPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"pull_number": z.coerce.number().int().describe("The number that identifies the pull request.")
    })

/**
 * @description Response
 */
export const pullsUpdateBranch202Schema = z.object({
    "message": z.optional(z.string()),
"url": z.optional(z.string())
    })

/**
 * @description Forbidden
 */
export const pullsUpdateBranch403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const pullsUpdateBranch422Schema = validationErrorSchema.describe("Validation Error")

export const pullsUpdateBranchMutationRequestSchema = z.object({
    "expected_head_sha": z.optional(z.string().describe("The expected SHA of the pull request's HEAD ref. This is the most recent commit on the pull request's branch. If the expected SHA does not match the pull request's HEAD, you will receive a `422 Unprocessable Entity` status. You can use the \"[List commits](https://docs.github.com/rest/commits/commits#list-commits)\" endpoint to find the most recent commit SHA. Default: SHA of the pull request's current HEAD ref."))
    }).nullable()

export const pullsUpdateBranchMutationResponseSchema = pullsUpdateBranch202Schema

export const reposGetReadmePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposGetReadmeQueryParamsSchema = z.object({
    "ref": z.optional(z.string().describe("The name of the commit/branch/tag. Default: the repositorys default branch."))
    }).optional()

/**
 * @description Response
 */
export const reposGetReadme200Schema = contentFileSchema.describe("Content File")

/**
 * @description Not modified
 */
export const reposGetReadme304Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposGetReadme404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposGetReadme422Schema = validationErrorSchema.describe("Validation Error")

export const reposGetReadmeQueryResponseSchema = reposGetReadme200Schema

export const reposGetReadmeInDirectoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"dir": z.string().describe("The alternate path to look for a README file")
    })

export const reposGetReadmeInDirectoryQueryParamsSchema = z.object({
    "ref": z.optional(z.string().describe("The name of the commit/branch/tag. Default: the repositorys default branch."))
    }).optional()

/**
 * @description Response
 */
export const reposGetReadmeInDirectory200Schema = contentFileSchema.describe("Content File")

/**
 * @description Resource not found
 */
export const reposGetReadmeInDirectory404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposGetReadmeInDirectory422Schema = validationErrorSchema.describe("Validation Error")

export const reposGetReadmeInDirectoryQueryResponseSchema = reposGetReadmeInDirectory200Schema

export const reposListReleasesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposListReleasesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListReleases200Schema = z.array(releaseSchema.describe("A release."))

/**
 * @description Resource not found
 */
export const reposListReleases404Schema = basicErrorSchema.describe("Basic Error")

export const reposListReleasesQueryResponseSchema = reposListReleases200Schema

export const reposCreateReleasePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposCreateRelease201Schema = releaseSchema.describe("A release.")

/**
 * @description Not Found if the discussion category name is invalid
 */
export const reposCreateRelease404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposCreateRelease422Schema = validationErrorSchema.describe("Validation Error")

export const reposCreateReleaseMutationRequestSchema = z.object({
    "tag_name": z.string().describe("The name of the tag."),
"target_commitish": z.optional(z.string().describe("Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch.")),
"name": z.optional(z.string().describe("The name of the release.")),
"body": z.optional(z.string().describe("Text describing the contents of the tag.")),
"draft": z.optional(z.boolean().default(false).describe("`true` to create a draft (unpublished) release, `false` to create a published one.")),
"prerelease": z.optional(z.boolean().default(false).describe("`true` to identify the release as a prerelease. `false` to identify the release as a full release.")),
"discussion_category_name": z.optional(z.string().describe("If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. For more information, see \"[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository).\"")),
"generate_release_notes": z.optional(z.boolean().default(false).describe("Whether to automatically generate the name and body for this release. If `name` is specified, the specified name will be used; otherwise, a name will be automatically generated. If `body` is specified, the body will be pre-pended to the automatically generated notes.")),
"make_latest": z.optional(z.enum(["true", "false", "legacy"]).default("true").describe("Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version."))
    })

export const reposCreateReleaseMutationResponseSchema = reposCreateRelease201Schema

export const reposGetReleaseAssetPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"asset_id": z.coerce.number().int().describe("The unique identifier of the asset.")
    })

/**
 * @description Response
 */
export const reposGetReleaseAsset200Schema = releaseAssetSchema.describe("Data related to a release.")

/**
 * @description Found
 */
export const reposGetReleaseAsset302Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposGetReleaseAsset404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetReleaseAssetQueryResponseSchema = reposGetReleaseAsset200Schema

export const reposUpdateReleaseAssetPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"asset_id": z.coerce.number().int().describe("The unique identifier of the asset.")
    })

/**
 * @description Response
 */
export const reposUpdateReleaseAsset200Schema = releaseAssetSchema.describe("Data related to a release.")

export const reposUpdateReleaseAssetMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("The file name of the asset.")),
"label": z.optional(z.string().describe("An alternate short description of the asset. Used in place of the filename.")),
"state": z.optional(z.string())
    })

export const reposUpdateReleaseAssetMutationResponseSchema = reposUpdateReleaseAsset200Schema

export const reposDeleteReleaseAssetPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"asset_id": z.coerce.number().int().describe("The unique identifier of the asset.")
    })

/**
 * @description Response
 */
export const reposDeleteReleaseAsset204Schema = z.unknown()

export const reposDeleteReleaseAssetMutationResponseSchema = reposDeleteReleaseAsset204Schema

export const reposGenerateReleaseNotesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Name and body of generated release notes
 */
export const reposGenerateReleaseNotes200Schema = releaseNotesContentSchema.describe("Generated name and body describing a release")

/**
 * @description Resource not found
 */
export const reposGenerateReleaseNotes404Schema = basicErrorSchema.describe("Basic Error")

export const reposGenerateReleaseNotesMutationRequestSchema = z.object({
    "tag_name": z.string().describe("The tag name for the release. This can be an existing tag or a new one."),
"target_commitish": z.optional(z.string().describe("Specifies the commitish value that will be the target for the release's tag. Required if the supplied tag_name does not reference an existing tag. Ignored if the tag_name already exists.")),
"previous_tag_name": z.optional(z.string().describe("The name of the previous tag to use as the starting point for the release notes. Use to manually specify the range for the set of changes considered as part this release.")),
"configuration_file_path": z.optional(z.string().describe("Specifies a path to a file in the repository containing configuration settings used for generating the release notes. If unspecified, the configuration file located in the repository at '.github/release.yml' or '.github/release.yaml' will be used. If that is not present, the default configuration will be used."))
    })

export const reposGenerateReleaseNotesMutationResponseSchema = reposGenerateReleaseNotes200Schema

export const reposGetLatestReleasePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposGetLatestRelease200Schema = releaseSchema.describe("A release.")

export const reposGetLatestReleaseQueryResponseSchema = reposGetLatestRelease200Schema

export const reposGetReleaseByTagPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"tag": z.string().describe("tag parameter")
    })

/**
 * @description Response
 */
export const reposGetReleaseByTag200Schema = releaseSchema.describe("A release.")

/**
 * @description Resource not found
 */
export const reposGetReleaseByTag404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetReleaseByTagQueryResponseSchema = reposGetReleaseByTag200Schema

export const reposGetReleasePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"release_id": z.coerce.number().int().describe("The unique identifier of the release.")
    })

/**
 * @description **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a hypermedia resource. For more information, see \"[Getting started with the REST API](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia).\"
 */
export const reposGetRelease200Schema = releaseSchema.describe("A release.")

/**
 * @description Unauthorized
 */
export const reposGetRelease401Schema = z.unknown()

export const reposGetReleaseQueryResponseSchema = reposGetRelease200Schema

export const reposUpdateReleasePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"release_id": z.coerce.number().int().describe("The unique identifier of the release.")
    })

/**
 * @description Response
 */
export const reposUpdateRelease200Schema = releaseSchema.describe("A release.")

/**
 * @description Not Found if the discussion category name is invalid
 */
export const reposUpdateRelease404Schema = basicErrorSchema.describe("Basic Error")

export const reposUpdateReleaseMutationRequestSchema = z.object({
    "tag_name": z.optional(z.string().describe("The name of the tag.")),
"target_commitish": z.optional(z.string().describe("Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch.")),
"name": z.optional(z.string().describe("The name of the release.")),
"body": z.optional(z.string().describe("Text describing the contents of the tag.")),
"draft": z.optional(z.boolean().describe("`true` makes the release a draft, and `false` publishes the release.")),
"prerelease": z.optional(z.boolean().describe("`true` to identify the release as a prerelease, `false` to identify the release as a full release.")),
"make_latest": z.optional(z.enum(["true", "false", "legacy"]).default(true).describe("Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.")),
"discussion_category_name": z.optional(z.string().describe("If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. If there is already a discussion linked to the release, this parameter is ignored. For more information, see \"[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository).\""))
    })

export const reposUpdateReleaseMutationResponseSchema = reposUpdateRelease200Schema

export const reposDeleteReleasePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"release_id": z.coerce.number().int().describe("The unique identifier of the release.")
    })

/**
 * @description Response
 */
export const reposDeleteRelease204Schema = z.unknown()

export const reposDeleteReleaseMutationResponseSchema = reposDeleteRelease204Schema

export const reposListReleaseAssetsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"release_id": z.coerce.number().int().describe("The unique identifier of the release.")
    })

export const reposListReleaseAssetsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListReleaseAssets200Schema = z.array(releaseAssetSchema.describe("Data related to a release."))

export const reposListReleaseAssetsQueryResponseSchema = reposListReleaseAssets200Schema

export const reposUploadReleaseAssetPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"release_id": z.coerce.number().int().describe("The unique identifier of the release.")
    })

export const reposUploadReleaseAssetQueryParamsSchema = z.object({
    "name": z.string(),
"label": z.optional(z.string())
    })

/**
 * @description Response for successful upload
 */
export const reposUploadReleaseAsset201Schema = releaseAssetSchema.describe("Data related to a release.")

/**
 * @description Response if you upload an asset with the same filename as another uploaded asset
 */
export const reposUploadReleaseAsset422Schema = z.unknown()

export const reposUploadReleaseAssetMutationRequestSchema = z.instanceof(File).describe("The raw file data")

export const reposUploadReleaseAssetMutationResponseSchema = reposUploadReleaseAsset201Schema

export const reactionsListForReleasePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"release_id": z.coerce.number().int().describe("The unique identifier of the release.")
    })

export const reactionsListForReleaseQueryParamsSchema = z.object({
    "content": z.optional(z.enum(["+1", "laugh", "heart", "hooray", "rocket", "eyes"]).describe("Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a release.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reactionsListForRelease200Schema = z.array(reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively."))

/**
 * @description Resource not found
 */
export const reactionsListForRelease404Schema = basicErrorSchema.describe("Basic Error")

export const reactionsListForReleaseQueryResponseSchema = reactionsListForRelease200Schema

export const reactionsCreateForReleasePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"release_id": z.coerce.number().int().describe("The unique identifier of the release.")
    })

/**
 * @description Reaction exists
 */
export const reactionsCreateForRelease200Schema = reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

/**
 * @description Reaction created
 */
export const reactionsCreateForRelease201Schema = reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reactionsCreateForRelease422Schema = validationErrorSchema.describe("Validation Error")

export const reactionsCreateForReleaseMutationRequestSchema = z.object({
    "content": z.enum(["+1", "laugh", "heart", "hooray", "rocket", "eyes"]).describe("The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the release.")
    })

export const reactionsCreateForReleaseMutationResponseSchema = z.union([reactionsCreateForRelease200Schema, reactionsCreateForRelease201Schema])

export const reactionsDeleteForReleasePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"release_id": z.coerce.number().int().describe("The unique identifier of the release."),
"reaction_id": z.coerce.number().int().describe("The unique identifier of the reaction.")
    })

/**
 * @description Response
 */
export const reactionsDeleteForRelease204Schema = z.unknown()

export const reactionsDeleteForReleaseMutationResponseSchema = reactionsDeleteForRelease204Schema

export const reposGetBranchRulesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"branch": z.string().describe("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")
    })

export const reposGetBranchRulesQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposGetBranchRules200Schema = z.array(repositoryRuleDetailedSchema.describe("A repository rule with ruleset details."))

export const reposGetBranchRulesQueryResponseSchema = reposGetBranchRules200Schema

export const reposGetRepoRulesetsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposGetRepoRulesetsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"includes_parents": z.boolean().default(true).describe("Include rulesets configured at higher levels that apply to this repository"),
"targets": z.optional(z.string().describe("A comma-separated list of rule targets to filter by.\nIf provided, only rulesets that apply to the specified targets will be returned.\nFor example, `branch,tag,push`.\n"))
    })

/**
 * @description Response
 */
export const reposGetRepoRulesets200Schema = z.array(repositoryRulesetSchema.describe("A set of rules to apply when specified conditions are met."))

/**
 * @description Resource not found
 */
export const reposGetRepoRulesets404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposGetRepoRulesets500Schema = basicErrorSchema.describe("Basic Error")

export const reposGetRepoRulesetsQueryResponseSchema = reposGetRepoRulesets200Schema

export const reposCreateRepoRulesetPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposCreateRepoRuleset201Schema = repositoryRulesetSchema.describe("A set of rules to apply when specified conditions are met.")

/**
 * @description Resource not found
 */
export const reposCreateRepoRuleset404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposCreateRepoRuleset500Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Request body
 */
export const reposCreateRepoRulesetMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the ruleset."),
"target": z.optional(z.enum(["branch", "tag", "push"]).default("branch").describe("The target of the ruleset")),
get "enforcement"(){
                return repositoryRuleEnforcementSchema.describe("The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).")
              },
get "bypass_actors"(){
                return z.array(repositoryRulesetBypassActorSchema.describe("An actor that can bypass rules in a ruleset")).describe("The actors that can bypass the rules in this ruleset").optional()
              },
get "conditions"(){
                return repositoryRulesetConditionsSchema.describe("Parameters for a repository ruleset ref name condition").optional()
              },
get "rules"(){
                return z.array(repositoryRuleSchema.describe("A repository rule.")).describe("An array of rules within the ruleset.").optional()
              }
    })

export const reposCreateRepoRulesetMutationResponseSchema = reposCreateRepoRuleset201Schema

export const reposGetRepoRuleSuitesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposGetRepoRuleSuitesQueryParamsSchema = z.object({
    "ref": z.optional(z.string().describe("The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.")),
"time_period": z.enum(["hour", "day", "week", "month"]).default("day").describe("The time period to filter by.\n\nFor example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for rule suites that occurred in the past 7 days (168 hours)."),
"actor_name": z.optional(z.string().describe("The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.")),
"rule_suite_result": z.enum(["pass", "fail", "bypass", "all"]).default("all").describe("The rule suite results to filter on. When specified, only suites with this result will be returned."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposGetRepoRuleSuites200Schema = ruleSuitesSchema.describe("Response")

/**
 * @description Resource not found
 */
export const reposGetRepoRuleSuites404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposGetRepoRuleSuites500Schema = basicErrorSchema.describe("Basic Error")

export const reposGetRepoRuleSuitesQueryResponseSchema = reposGetRepoRuleSuites200Schema

export const reposGetRepoRuleSuitePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"rule_suite_id": z.coerce.number().int().describe("The unique identifier of the rule suite result.\nTo get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)\nfor repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites)\nfor organizations.")
    })

/**
 * @description Response
 */
export const reposGetRepoRuleSuite200Schema = ruleSuiteSchema.describe("Response")

/**
 * @description Resource not found
 */
export const reposGetRepoRuleSuite404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposGetRepoRuleSuite500Schema = basicErrorSchema.describe("Basic Error")

export const reposGetRepoRuleSuiteQueryResponseSchema = reposGetRepoRuleSuite200Schema

export const reposGetRepoRulesetPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ruleset_id": z.coerce.number().int().describe("The ID of the ruleset.")
    })

export const reposGetRepoRulesetQueryParamsSchema = z.object({
    "includes_parents": z.boolean().default(true).describe("Include rulesets configured at higher levels that apply to this repository")
    })

/**
 * @description Response
 */
export const reposGetRepoRuleset200Schema = repositoryRulesetSchema.describe("A set of rules to apply when specified conditions are met.")

/**
 * @description Resource not found
 */
export const reposGetRepoRuleset404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposGetRepoRuleset500Schema = basicErrorSchema.describe("Basic Error")

export const reposGetRepoRulesetQueryResponseSchema = reposGetRepoRuleset200Schema

export const reposUpdateRepoRulesetPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ruleset_id": z.coerce.number().int().describe("The ID of the ruleset.")
    })

/**
 * @description Response
 */
export const reposUpdateRepoRuleset200Schema = repositoryRulesetSchema.describe("A set of rules to apply when specified conditions are met.")

/**
 * @description Resource not found
 */
export const reposUpdateRepoRuleset404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposUpdateRepoRuleset500Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Request body
 */
export const reposUpdateRepoRulesetMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("The name of the ruleset.")),
"target": z.optional(z.enum(["branch", "tag", "push"]).describe("The target of the ruleset")),
get "enforcement"(){
                return repositoryRuleEnforcementSchema.describe("The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).").optional()
              },
get "bypass_actors"(){
                return z.array(repositoryRulesetBypassActorSchema.describe("An actor that can bypass rules in a ruleset")).describe("The actors that can bypass the rules in this ruleset").optional()
              },
get "conditions"(){
                return repositoryRulesetConditionsSchema.describe("Parameters for a repository ruleset ref name condition").optional()
              },
get "rules"(){
                return z.array(repositoryRuleSchema.describe("A repository rule.")).describe("An array of rules within the ruleset.").optional()
              }
    })

export const reposUpdateRepoRulesetMutationResponseSchema = reposUpdateRepoRuleset200Schema

export const reposDeleteRepoRulesetPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ruleset_id": z.coerce.number().int().describe("The ID of the ruleset.")
    })

/**
 * @description Response
 */
export const reposDeleteRepoRuleset204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const reposDeleteRepoRuleset404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposDeleteRepoRuleset500Schema = basicErrorSchema.describe("Basic Error")

export const reposDeleteRepoRulesetMutationResponseSchema = reposDeleteRepoRuleset204Schema

export const reposGetRepoRulesetHistoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ruleset_id": z.coerce.number().int().describe("The ID of the ruleset.")
    })

export const reposGetRepoRulesetHistoryQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposGetRepoRulesetHistory200Schema = z.array(rulesetVersionSchema.describe("The historical version of a ruleset"))

/**
 * @description Resource not found
 */
export const reposGetRepoRulesetHistory404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposGetRepoRulesetHistory500Schema = basicErrorSchema.describe("Basic Error")

export const reposGetRepoRulesetHistoryQueryResponseSchema = reposGetRepoRulesetHistory200Schema

export const reposGetRepoRulesetVersionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ruleset_id": z.coerce.number().int().describe("The ID of the ruleset."),
"version_id": z.coerce.number().int().describe("The ID of the version")
    })

/**
 * @description Response
 */
export const reposGetRepoRulesetVersion200Schema = rulesetVersionWithStateSchema

/**
 * @description Resource not found
 */
export const reposGetRepoRulesetVersion404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const reposGetRepoRulesetVersion500Schema = basicErrorSchema.describe("Basic Error")

export const reposGetRepoRulesetVersionQueryResponseSchema = reposGetRepoRulesetVersion200Schema

export const secretScanningListAlertsForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const secretScanningListAlertsForRepoQueryParamsSchema = z.object({
    "state": z.optional(z.enum(["open", "resolved"]).describe("Set to `open` or `resolved` to only list secret scanning alerts in a specific state.")),
"secret_type": z.optional(z.string().describe("A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter. See \"[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)\" for a complete list of secret types.")),
"resolution": z.optional(z.string().describe("A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.")),
"sort": z.enum(["created", "updated"]).default("created").describe("The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved."),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty \"before\" query string.")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty \"after\" query string.")),
"validity": z.optional(z.string().describe("A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.")),
"is_publicly_leaked": z.boolean().default(false).describe("A boolean value representing whether or not to filter alerts by the publicly-leaked tag being present."),
"is_multi_repo": z.boolean().default(false).describe("A boolean value representing whether or not to filter alerts by the multi-repo tag being present."),
"hide_secret": z.boolean().default(false).describe("A boolean value representing whether or not to hide literal secrets in the results.")
    })

/**
 * @description Response
 */
export const secretScanningListAlertsForRepo200Schema = z.array(secretScanningAlertSchema)

/**
 * @description Repository is public or secret scanning is disabled for the repository
 */
export const secretScanningListAlertsForRepo404Schema = z.unknown()

/**
 * @description Service unavailable
 */
export const secretScanningListAlertsForRepo503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const secretScanningListAlertsForRepoQueryResponseSchema = secretScanningListAlertsForRepo200Schema

export const secretScanningGetAlertPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
get "alert_number"(){
                return alertNumberSchema.describe("The security alert number.")
              }
    })

export const secretScanningGetAlertQueryParamsSchema = z.object({
    "hide_secret": z.boolean().default(false).describe("A boolean value representing whether or not to hide literal secrets in the results.")
    })

/**
 * @description Response
 */
export const secretScanningGetAlert200Schema = secretScanningAlertSchema

/**
 * @description Not modified
 */
export const secretScanningGetAlert304Schema = z.unknown()

/**
 * @description Repository is public, or secret scanning is disabled for the repository, or the resource is not found
 */
export const secretScanningGetAlert404Schema = z.unknown()

/**
 * @description Service unavailable
 */
export const secretScanningGetAlert503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const secretScanningGetAlertQueryResponseSchema = secretScanningGetAlert200Schema

export const secretScanningUpdateAlertPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
get "alert_number"(){
                return alertNumberSchema.describe("The security alert number.")
              }
    })

/**
 * @description Response
 */
export const secretScanningUpdateAlert200Schema = secretScanningAlertSchema

/**
 * @description Bad request, resolution comment is invalid or the resolution was not changed.
 */
export const secretScanningUpdateAlert400Schema = z.unknown()

/**
 * @description Repository is public, or secret scanning is disabled for the repository, or the resource is not found
 */
export const secretScanningUpdateAlert404Schema = z.unknown()

/**
 * @description State does not match the resolution or resolution comment
 */
export const secretScanningUpdateAlert422Schema = z.unknown()

/**
 * @description Service unavailable
 */
export const secretScanningUpdateAlert503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const secretScanningUpdateAlertMutationRequestSchema = z.object({
    get "state"(){
                return secretScanningAlertStateSchema.describe("Sets the state of the secret scanning alert. You must provide `resolution` when you set the state to `resolved`.")
              },
get "resolution"(){
                return secretScanningAlertResolutionSchema.describe("**Required when the `state` is `resolved`.** The reason for resolving the alert.").optional()
              },
get "resolution_comment"(){
                return secretScanningAlertResolutionCommentSchema.describe("An optional comment when closing or reopening an alert. Cannot be updated or deleted.").optional()
              }
    })

export const secretScanningUpdateAlertMutationResponseSchema = secretScanningUpdateAlert200Schema

export const secretScanningListLocationsForAlertPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
get "alert_number"(){
                return alertNumberSchema.describe("The security alert number.")
              }
    })

export const secretScanningListLocationsForAlertQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const secretScanningListLocationsForAlert200Schema = z.array(secretScanningLocationSchema).describe("List of locations where the secret was detected")

/**
 * @description Repository is public, or secret scanning is disabled for the repository, or the resource is not found
 */
export const secretScanningListLocationsForAlert404Schema = z.unknown()

/**
 * @description Service unavailable
 */
export const secretScanningListLocationsForAlert503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const secretScanningListLocationsForAlertQueryResponseSchema = secretScanningListLocationsForAlert200Schema

export const secretScanningCreatePushProtectionBypassPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const secretScanningCreatePushProtectionBypass200Schema = secretScanningPushProtectionBypassSchema

/**
 * @description User does not have enough permissions to perform this action.
 */
export const secretScanningCreatePushProtectionBypass403Schema = z.unknown()

/**
 * @description Placeholder ID not found, or push protection is disabled on this repository.
 */
export const secretScanningCreatePushProtectionBypass404Schema = z.unknown()

/**
 * @description Bad request, input data missing or incorrect.
 */
export const secretScanningCreatePushProtectionBypass422Schema = z.unknown()

/**
 * @description Service unavailable
 */
export const secretScanningCreatePushProtectionBypass503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const secretScanningCreatePushProtectionBypassMutationRequestSchema = z.object({
    get "reason"(){
                return secretScanningPushProtectionBypassReasonSchema.describe("The reason for bypassing push protection.")
              },
get "placeholder_id"(){
                return secretScanningPushProtectionBypassPlaceholderIdSchema.describe("The ID of the push protection bypass placeholder. This value is returned on any push protected routes.")
              }
    })

export const secretScanningCreatePushProtectionBypassMutationResponseSchema = secretScanningCreatePushProtectionBypass200Schema

export const secretScanningGetScanHistoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const secretScanningGetScanHistory200Schema = secretScanningScanHistorySchema

/**
 * @description Repository does not have GitHub Advanced Security or secret scanning enabled
 */
export const secretScanningGetScanHistory404Schema = z.unknown()

/**
 * @description Service unavailable
 */
export const secretScanningGetScanHistory503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const secretScanningGetScanHistoryQueryResponseSchema = secretScanningGetScanHistory200Schema

export const securityAdvisoriesListRepositoryAdvisoriesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const securityAdvisoriesListRepositoryAdvisoriesQueryParamsSchema = z.object({
    "direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"sort": z.enum(["created", "updated", "published"]).default("created").describe("The property to sort the results by."),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"per_page": z.coerce.number().int().min(1).max(100).default(30).describe("The number of advisories to return per page. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"state": z.optional(z.enum(["triage", "draft", "published", "closed"]).describe("Filter by state of the repository advisories. Only advisories of this state will be returned."))
    })

/**
 * @description Response
 */
export const securityAdvisoriesListRepositoryAdvisories200Schema = z.array(repositoryAdvisorySchema.describe("A repository security advisory."))

/**
 * @description Bad Request
 */
export const securityAdvisoriesListRepositoryAdvisories400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const securityAdvisoriesListRepositoryAdvisories404Schema = basicErrorSchema.describe("Basic Error")

export const securityAdvisoriesListRepositoryAdvisoriesQueryResponseSchema = securityAdvisoriesListRepositoryAdvisories200Schema

export const securityAdvisoriesCreateRepositoryAdvisoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const securityAdvisoriesCreateRepositoryAdvisory201Schema = repositoryAdvisorySchema.describe("A repository security advisory.")

/**
 * @description Forbidden
 */
export const securityAdvisoriesCreateRepositoryAdvisory403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const securityAdvisoriesCreateRepositoryAdvisory404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const securityAdvisoriesCreateRepositoryAdvisory422Schema = validationErrorSchema.describe("Validation Error")

export const securityAdvisoriesCreateRepositoryAdvisoryMutationRequestSchema = repositoryAdvisoryCreateSchema

export const securityAdvisoriesCreateRepositoryAdvisoryMutationResponseSchema = securityAdvisoriesCreateRepositoryAdvisory201Schema

export const securityAdvisoriesCreatePrivateVulnerabilityReportPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const securityAdvisoriesCreatePrivateVulnerabilityReport201Schema = repositoryAdvisorySchema.describe("A repository security advisory.")

/**
 * @description Forbidden
 */
export const securityAdvisoriesCreatePrivateVulnerabilityReport403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const securityAdvisoriesCreatePrivateVulnerabilityReport404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const securityAdvisoriesCreatePrivateVulnerabilityReport422Schema = validationErrorSchema.describe("Validation Error")

export const securityAdvisoriesCreatePrivateVulnerabilityReportMutationRequestSchema = privateVulnerabilityReportCreateSchema

export const securityAdvisoriesCreatePrivateVulnerabilityReportMutationResponseSchema = securityAdvisoriesCreatePrivateVulnerabilityReport201Schema

export const securityAdvisoriesGetRepositoryAdvisoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ghsa_id": z.string().describe("The GHSA (GitHub Security Advisory) identifier of the advisory.")
    })

/**
 * @description Response
 */
export const securityAdvisoriesGetRepositoryAdvisory200Schema = repositoryAdvisorySchema.describe("A repository security advisory.")

/**
 * @description Forbidden
 */
export const securityAdvisoriesGetRepositoryAdvisory403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const securityAdvisoriesGetRepositoryAdvisory404Schema = basicErrorSchema.describe("Basic Error")

export const securityAdvisoriesGetRepositoryAdvisoryQueryResponseSchema = securityAdvisoriesGetRepositoryAdvisory200Schema

export const securityAdvisoriesUpdateRepositoryAdvisoryPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ghsa_id": z.string().describe("The GHSA (GitHub Security Advisory) identifier of the advisory.")
    })

/**
 * @description Response
 */
export const securityAdvisoriesUpdateRepositoryAdvisory200Schema = repositoryAdvisorySchema.describe("A repository security advisory.")

/**
 * @description Forbidden
 */
export const securityAdvisoriesUpdateRepositoryAdvisory403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const securityAdvisoriesUpdateRepositoryAdvisory404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const securityAdvisoriesUpdateRepositoryAdvisory422Schema = validationErrorSchema.describe("Validation Error")

export const securityAdvisoriesUpdateRepositoryAdvisoryMutationRequestSchema = repositoryAdvisoryUpdateSchema

export const securityAdvisoriesUpdateRepositoryAdvisoryMutationResponseSchema = securityAdvisoriesUpdateRepositoryAdvisory200Schema

export const securityAdvisoriesCreateRepositoryAdvisoryCveRequestPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ghsa_id": z.string().describe("The GHSA (GitHub Security Advisory) identifier of the advisory.")
    })

/**
 * @description Accepted
 */
export const securityAdvisoriesCreateRepositoryAdvisoryCveRequest202Schema = z.object({
    
    })

/**
 * @description Bad Request
 */
export const securityAdvisoriesCreateRepositoryAdvisoryCveRequest400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const securityAdvisoriesCreateRepositoryAdvisoryCveRequest403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const securityAdvisoriesCreateRepositoryAdvisoryCveRequest404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const securityAdvisoriesCreateRepositoryAdvisoryCveRequest422Schema = validationErrorSchema.describe("Validation Error")

export const securityAdvisoriesCreateRepositoryAdvisoryCveRequestMutationResponseSchema = securityAdvisoriesCreateRepositoryAdvisoryCveRequest202Schema

export const securityAdvisoriesCreateForkPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ghsa_id": z.string().describe("The GHSA (GitHub Security Advisory) identifier of the advisory.")
    })

/**
 * @description Response
 */
export const securityAdvisoriesCreateFork202Schema = fullRepositorySchema.describe("Full Repository")

/**
 * @description Bad Request
 */
export const securityAdvisoriesCreateFork400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const securityAdvisoriesCreateFork403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const securityAdvisoriesCreateFork404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const securityAdvisoriesCreateFork422Schema = validationErrorSchema.describe("Validation Error")

export const securityAdvisoriesCreateForkMutationResponseSchema = securityAdvisoriesCreateFork202Schema

export const activityListStargazersForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const activityListStargazersForRepoQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListStargazersForRepo200Schema = z.union([z.array(simpleUserSchema.describe("A GitHub user.")), z.array(stargazerSchema.describe("Stargazer"))])

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const activityListStargazersForRepo422Schema = validationErrorSchema.describe("Validation Error")

export const activityListStargazersForRepoQueryResponseSchema = activityListStargazersForRepo200Schema

export const reposGetCodeFrequencyStatsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
 */
export const reposGetCodeFrequencyStats200Schema = z.array(codeFrequencyStatSchema.describe("Code Frequency Stat"))

/**
 * @description Accepted
 */
export const reposGetCodeFrequencyStats202Schema = z.object({
    
    })

/**
 * @description A header with no content is returned.
 */
export const reposGetCodeFrequencyStats204Schema = z.unknown()

/**
 * @description Repository contains more than 10,000 commits
 */
export const reposGetCodeFrequencyStats422Schema = z.unknown()

export const reposGetCodeFrequencyStatsQueryResponseSchema = z.union([reposGetCodeFrequencyStats200Schema, reposGetCodeFrequencyStats202Schema, reposGetCodeFrequencyStats204Schema])

export const reposGetCommitActivityStatsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposGetCommitActivityStats200Schema = z.array(commitActivitySchema.describe("Commit Activity"))

/**
 * @description Accepted
 */
export const reposGetCommitActivityStats202Schema = z.object({
    
    })

/**
 * @description A header with no content is returned.
 */
export const reposGetCommitActivityStats204Schema = z.unknown()

export const reposGetCommitActivityStatsQueryResponseSchema = z.union([reposGetCommitActivityStats200Schema, reposGetCommitActivityStats202Schema, reposGetCommitActivityStats204Schema])

export const reposGetContributorsStatsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposGetContributorsStats200Schema = z.array(contributorActivitySchema.describe("Contributor Activity"))

/**
 * @description Accepted
 */
export const reposGetContributorsStats202Schema = z.object({
    
    })

/**
 * @description A header with no content is returned.
 */
export const reposGetContributorsStats204Schema = z.unknown()

export const reposGetContributorsStatsQueryResponseSchema = z.union([reposGetContributorsStats200Schema, reposGetContributorsStats202Schema, reposGetContributorsStats204Schema])

export const reposGetParticipationStatsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description The array order is oldest week (index 0) to most recent week.
 */
export const reposGetParticipationStats200Schema = participationStatsSchema

/**
 * @description Resource not found
 */
export const reposGetParticipationStats404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetParticipationStatsQueryResponseSchema = reposGetParticipationStats200Schema

export const reposGetPunchCardStatsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits.
 */
export const reposGetPunchCardStats200Schema = z.array(codeFrequencyStatSchema.describe("Code Frequency Stat"))

/**
 * @description A header with no content is returned.
 */
export const reposGetPunchCardStats204Schema = z.unknown()

export const reposGetPunchCardStatsQueryResponseSchema = z.union([reposGetPunchCardStats200Schema, reposGetPunchCardStats204Schema])

export const reposCreateCommitStatusPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"sha": z.string()
    })

/**
 * @description Response
 */
export const reposCreateCommitStatus201Schema = statusSchema.describe("The status of a commit.")

export const reposCreateCommitStatusMutationRequestSchema = z.object({
    "state": z.enum(["error", "failure", "pending", "success"]).describe("The state of the status."),
"target_url": z.string().describe("The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the source of the status.  \nFor example, if your continuous integration system is posting build status, you would want to provide the deep link for the build output for this specific SHA:  \n`http://ci.example.com/user/repo/build/sha`").nullish(),
"description": z.string().describe("A short description of the status.").nullish(),
"context": z.optional(z.string().default("default").describe("A string label to differentiate this status from the status of other systems. This field is case-insensitive."))
    })

export const reposCreateCommitStatusMutationResponseSchema = reposCreateCommitStatus201Schema

export const activityListWatchersForRepoPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const activityListWatchersForRepoQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListWatchersForRepo200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

export const activityListWatchersForRepoQueryResponseSchema = activityListWatchersForRepo200Schema

export const activityGetRepoSubscriptionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description if you subscribe to the repository
 */
export const activityGetRepoSubscription200Schema = repositorySubscriptionSchema.describe("Repository invitations let you manage who you collaborate with.")

/**
 * @description Forbidden
 */
export const activityGetRepoSubscription403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Not Found if you don\'t subscribe to the repository
 */
export const activityGetRepoSubscription404Schema = z.unknown()

export const activityGetRepoSubscriptionQueryResponseSchema = activityGetRepoSubscription200Schema

export const activitySetRepoSubscriptionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const activitySetRepoSubscription200Schema = repositorySubscriptionSchema.describe("Repository invitations let you manage who you collaborate with.")

export const activitySetRepoSubscriptionMutationRequestSchema = z.object({
    "subscribed": z.optional(z.boolean().describe("Determines if notifications should be received from this repository.")),
"ignored": z.optional(z.boolean().describe("Determines if all notifications should be blocked from this repository."))
    })

export const activitySetRepoSubscriptionMutationResponseSchema = activitySetRepoSubscription200Schema

export const activityDeleteRepoSubscriptionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const activityDeleteRepoSubscription204Schema = z.unknown()

export const activityDeleteRepoSubscriptionMutationResponseSchema = activityDeleteRepoSubscription204Schema

export const reposListTagsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposListTagsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListTags200Schema = z.array(tagSchema.describe("Tag"))

export const reposListTagsQueryResponseSchema = reposListTags200Schema

export const reposListTagProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposListTagProtection200Schema = z.array(tagProtectionSchema.describe("Tag protection"))

/**
 * @description Forbidden
 */
export const reposListTagProtection403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposListTagProtection404Schema = basicErrorSchema.describe("Basic Error")

export const reposListTagProtectionQueryResponseSchema = reposListTagProtection200Schema

export const reposCreateTagProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposCreateTagProtection201Schema = tagProtectionSchema.describe("Tag protection")

/**
 * @description Forbidden
 */
export const reposCreateTagProtection403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposCreateTagProtection404Schema = basicErrorSchema.describe("Basic Error")

export const reposCreateTagProtectionMutationRequestSchema = z.object({
    "pattern": z.string().describe("An optional glob pattern to match against when enforcing tag protection.")
    })

export const reposCreateTagProtectionMutationResponseSchema = reposCreateTagProtection201Schema

export const reposDeleteTagProtectionPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"tag_protection_id": z.coerce.number().int().describe("The unique identifier of the tag protection.")
    })

/**
 * @description Response
 */
export const reposDeleteTagProtection204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const reposDeleteTagProtection403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposDeleteTagProtection404Schema = basicErrorSchema.describe("Basic Error")

export const reposDeleteTagProtectionMutationResponseSchema = reposDeleteTagProtection204Schema

export const reposDownloadTarballArchivePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ref": z.string()
    })

/**
 * @description Response
 */
export const reposDownloadTarballArchive302Schema = z.unknown()

export const reposDownloadTarballArchiveQueryResponseSchema = z.unknown()

export const reposListTeamsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposListTeamsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListTeams200Schema = z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories."))

/**
 * @description Resource not found
 */
export const reposListTeams404Schema = basicErrorSchema.describe("Basic Error")

export const reposListTeamsQueryResponseSchema = reposListTeams200Schema

export const reposGetAllTopicsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposGetAllTopicsQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposGetAllTopics200Schema = topicSchema.describe("A topic aggregates entities that are related to a subject.")

/**
 * @description Resource not found
 */
export const reposGetAllTopics404Schema = basicErrorSchema.describe("Basic Error")

export const reposGetAllTopicsQueryResponseSchema = reposGetAllTopics200Schema

export const reposReplaceAllTopicsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposReplaceAllTopics200Schema = topicSchema.describe("A topic aggregates entities that are related to a subject.")

/**
 * @description Resource not found
 */
export const reposReplaceAllTopics404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposReplaceAllTopics422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const reposReplaceAllTopicsMutationRequestSchema = z.object({
    "names": z.array(z.string()).describe("An array of topics to add to the repository. Pass one or more topics to _replace_ the set of existing topics. Send an empty array (`[]`) to clear all topics from the repository. **Note:** Topic `names` will be saved as lowercase.")
    })

export const reposReplaceAllTopicsMutationResponseSchema = reposReplaceAllTopics200Schema

export const reposGetClonesPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposGetClonesQueryParamsSchema = z.object({
    "per": z.enum(["day", "week"]).default("day").describe("The time frame to display results for.")
    })

/**
 * @description Response
 */
export const reposGetClones200Schema = cloneTrafficSchema.describe("Clone Traffic")

/**
 * @description Forbidden
 */
export const reposGetClones403Schema = basicErrorSchema.describe("Basic Error")

export const reposGetClonesQueryResponseSchema = reposGetClones200Schema

export const reposGetTopPathsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposGetTopPaths200Schema = z.array(contentTrafficSchema.describe("Content Traffic"))

/**
 * @description Forbidden
 */
export const reposGetTopPaths403Schema = basicErrorSchema.describe("Basic Error")

export const reposGetTopPathsQueryResponseSchema = reposGetTopPaths200Schema

export const reposGetTopReferrersPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposGetTopReferrers200Schema = z.array(referrerTrafficSchema.describe("Referrer Traffic"))

/**
 * @description Forbidden
 */
export const reposGetTopReferrers403Schema = basicErrorSchema.describe("Basic Error")

export const reposGetTopReferrersQueryResponseSchema = reposGetTopReferrers200Schema

export const reposGetViewsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

export const reposGetViewsQueryParamsSchema = z.object({
    "per": z.enum(["day", "week"]).default("day").describe("The time frame to display results for.")
    })

/**
 * @description Response
 */
export const reposGetViews200Schema = viewTrafficSchema.describe("View Traffic")

/**
 * @description Forbidden
 */
export const reposGetViews403Schema = basicErrorSchema.describe("Basic Error")

export const reposGetViewsQueryResponseSchema = reposGetViews200Schema

export const reposTransferPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposTransfer202Schema = minimalRepositorySchema.describe("Minimal Repository")

export const reposTransferMutationRequestSchema = z.object({
    "new_owner": z.string().describe("The username or organization name the repository will be transferred to."),
"new_name": z.optional(z.string().describe("The new name to be given to the repository.")),
"team_ids": z.optional(z.array(z.int()).describe("ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories."))
    })

export const reposTransferMutationResponseSchema = reposTransfer202Schema

export const reposCheckVulnerabilityAlertsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response if repository is enabled with vulnerability alerts
 */
export const reposCheckVulnerabilityAlerts204Schema = z.unknown()

/**
 * @description Not Found if repository is not enabled with vulnerability alerts
 */
export const reposCheckVulnerabilityAlerts404Schema = z.unknown()

export const reposCheckVulnerabilityAlertsQueryResponseSchema = reposCheckVulnerabilityAlerts204Schema

export const reposEnableVulnerabilityAlertsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposEnableVulnerabilityAlerts204Schema = z.unknown()

export const reposEnableVulnerabilityAlertsMutationResponseSchema = reposEnableVulnerabilityAlerts204Schema

export const reposDisableVulnerabilityAlertsPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposDisableVulnerabilityAlerts204Schema = z.unknown()

export const reposDisableVulnerabilityAlertsMutationResponseSchema = reposDisableVulnerabilityAlerts204Schema

export const reposDownloadZipballArchivePathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive."),
"ref": z.string()
    })

/**
 * @description Response
 */
export const reposDownloadZipballArchive302Schema = z.unknown()

export const reposDownloadZipballArchiveQueryResponseSchema = z.unknown()

export const reposCreateUsingTemplatePathParamsSchema = z.object({
    "template_owner": z.string().describe("The account owner of the template repository. The name is not case sensitive."),
"template_repo": z.string().describe("The name of the template repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const reposCreateUsingTemplate201Schema = fullRepositorySchema.describe("Full Repository")

export const reposCreateUsingTemplateMutationRequestSchema = z.object({
    "owner": z.optional(z.string().describe("The organization or person who will own the new repository. To create a new repository in an organization, the authenticated user must be a member of the specified organization.")),
"name": z.string().describe("The name of the new repository."),
"description": z.optional(z.string().describe("A short description of the new repository.")),
"include_all_branches": z.optional(z.boolean().default(false).describe("Set to `true` to include the directory structure and files from all branches in the template repository, and not just the default branch. Default: `false`.")),
"private": z.optional(z.boolean().default(false).describe("Either `true` to create a new private repository or `false` to create a new public one."))
    })

export const reposCreateUsingTemplateMutationResponseSchema = reposCreateUsingTemplate201Schema

export const reposListPublicQueryParamsSchema = z.object({
    "since": z.optional(z.coerce.number().int().describe("A repository ID. Only return repositories with an ID greater than this ID."))
    }).optional()

/**
 * @description Response
 */
export const reposListPublic200Schema = z.array(minimalRepositorySchema.describe("Minimal Repository"))

/**
 * @description Not modified
 */
export const reposListPublic304Schema = z.unknown()

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposListPublic422Schema = validationErrorSchema.describe("Validation Error")

export const reposListPublicQueryResponseSchema = reposListPublic200Schema

export const searchCodeQueryParamsSchema = z.object({
    "q": z.string().describe("The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See \"[Searching code](https://docs.github.com/search-github/searching-on-github/searching-code)\" for a detailed list of qualifiers."),
"sort": z.optional(z.enum(["indexed"]).describe("**This field is closing down.** Sorts the results of your query. Can only be `indexed`, which indicates how recently a file has been indexed by the GitHub search infrastructure. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)")),
"order": z.optional(z.enum(["desc", "asc"]).default("desc").describe("**This field is closing down.** Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. ")),
"per_page": z.optional(z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"page": z.optional(z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""))
    })

/**
 * @description Response
 */
export const searchCode200Schema = z.object({
    "total_count": z.int(),
"incomplete_results": z.boolean(),
get "items"(){
                return z.array(codeSearchResultItemSchema.describe("Code Search Result Item"))
              }
    })

/**
 * @description Not modified
 */
export const searchCode304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const searchCode403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const searchCode422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Service unavailable
 */
export const searchCode503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const searchCodeQueryResponseSchema = searchCode200Schema

export const searchCommitsQueryParamsSchema = z.object({
    "q": z.string().describe("The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See \"[Searching commits](https://docs.github.com/search-github/searching-on-github/searching-commits)\" for a detailed list of qualifiers."),
"sort": z.optional(z.enum(["author-date", "committer-date"]).describe("Sorts the results of your query by `author-date` or `committer-date`. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)")),
"order": z.optional(z.enum(["desc", "asc"]).default("desc").describe("Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.")),
"per_page": z.optional(z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"page": z.optional(z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""))
    })

/**
 * @description Response
 */
export const searchCommits200Schema = z.object({
    "total_count": z.int(),
"incomplete_results": z.boolean(),
get "items"(){
                return z.array(commitSearchResultItemSchema.describe("Commit Search Result Item"))
              }
    })

/**
 * @description Not modified
 */
export const searchCommits304Schema = z.unknown()

export const searchCommitsQueryResponseSchema = searchCommits200Schema

export const searchIssuesAndPullRequestsQueryParamsSchema = z.object({
    "q": z.string().describe("The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See \"[Searching issues and pull requests](https://docs.github.com/search-github/searching-on-github/searching-issues-and-pull-requests)\" for a detailed list of qualifiers."),
"sort": z.optional(z.enum(["comments", "reactions", "reactions-+1", "reactions--1", "reactions-smile", "reactions-thinking_face", "reactions-heart", "reactions-tada", "interactions", "created", "updated"]).describe("Sorts the results of your query by the number of `comments`, `reactions`, `reactions-+1`, `reactions--1`, `reactions-smile`, `reactions-thinking_face`, `reactions-heart`, `reactions-tada`, or `interactions`. You can also sort results by how recently the items were `created` or `updated`, Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)")),
"order": z.optional(z.enum(["desc", "asc"]).default("desc").describe("Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.")),
"per_page": z.optional(z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"page": z.optional(z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"advanced_search": z.optional(z.string().describe("Set to `true` to use advanced search.\nExample: `http://api.github.com/search/issues?q={query}&advanced_search=true`"))
    })

/**
 * @description Response
 */
export const searchIssuesAndPullRequests200Schema = z.object({
    "total_count": z.int(),
"incomplete_results": z.boolean(),
get "items"(){
                return z.array(issueSearchResultItemSchema.describe("Issue Search Result Item"))
              }
    })

/**
 * @description Not modified
 */
export const searchIssuesAndPullRequests304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const searchIssuesAndPullRequests403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const searchIssuesAndPullRequests422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Service unavailable
 */
export const searchIssuesAndPullRequests503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const searchIssuesAndPullRequestsQueryResponseSchema = searchIssuesAndPullRequests200Schema

export const searchLabelsQueryParamsSchema = z.object({
    "repository_id": z.coerce.number().int().describe("The id of the repository."),
"q": z.string().describe("The search keywords. This endpoint does not accept qualifiers in the query. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query)."),
"sort": z.optional(z.enum(["created", "updated"]).describe("Sorts the results of your query by when the label was `created` or `updated`. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)")),
"order": z.optional(z.enum(["desc", "asc"]).default("desc").describe("Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.")),
"per_page": z.optional(z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"page": z.optional(z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""))
    })

/**
 * @description Response
 */
export const searchLabels200Schema = z.object({
    "total_count": z.int(),
"incomplete_results": z.boolean(),
get "items"(){
                return z.array(labelSearchResultItemSchema.describe("Label Search Result Item"))
              }
    })

/**
 * @description Not modified
 */
export const searchLabels304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const searchLabels403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const searchLabels404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const searchLabels422Schema = validationErrorSchema.describe("Validation Error")

export const searchLabelsQueryResponseSchema = searchLabels200Schema

export const searchReposQueryParamsSchema = z.object({
    "q": z.string().describe("The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See \"[Searching for repositories](https://docs.github.com/articles/searching-for-repositories/)\" for a detailed list of qualifiers."),
"sort": z.optional(z.enum(["stars", "forks", "help-wanted-issues", "updated"]).describe("Sorts the results of your query by number of `stars`, `forks`, or `help-wanted-issues` or how recently the items were `updated`. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)")),
"order": z.optional(z.enum(["desc", "asc"]).default("desc").describe("Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.")),
"per_page": z.optional(z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"page": z.optional(z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""))
    })

/**
 * @description Response
 */
export const searchRepos200Schema = z.object({
    "total_count": z.int(),
"incomplete_results": z.boolean(),
get "items"(){
                return z.array(repoSearchResultItemSchema.describe("Repo Search Result Item"))
              }
    })

/**
 * @description Not modified
 */
export const searchRepos304Schema = z.unknown()

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const searchRepos422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Service unavailable
 */
export const searchRepos503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const searchReposQueryResponseSchema = searchRepos200Schema

export const searchTopicsQueryParamsSchema = z.object({
    "q": z.string().describe("The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query)."),
"per_page": z.optional(z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"page": z.optional(z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""))
    })

/**
 * @description Response
 */
export const searchTopics200Schema = z.object({
    "total_count": z.int(),
"incomplete_results": z.boolean(),
get "items"(){
                return z.array(topicSearchResultItemSchema.describe("Topic Search Result Item"))
              }
    })

/**
 * @description Not modified
 */
export const searchTopics304Schema = z.unknown()

export const searchTopicsQueryResponseSchema = searchTopics200Schema

export const searchUsersQueryParamsSchema = z.object({
    "q": z.string().describe("The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See \"[Searching users](https://docs.github.com/search-github/searching-on-github/searching-users)\" for a detailed list of qualifiers."),
"sort": z.optional(z.enum(["followers", "repositories", "joined"]).describe("Sorts the results of your query by number of `followers` or `repositories`, or when the person `joined` GitHub. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)")),
"order": z.optional(z.enum(["desc", "asc"]).default("desc").describe("Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.")),
"per_page": z.optional(z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"page": z.optional(z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""))
    })

/**
 * @description Response
 */
export const searchUsers200Schema = z.object({
    "total_count": z.int(),
"incomplete_results": z.boolean(),
get "items"(){
                return z.array(userSearchResultItemSchema.describe("User Search Result Item"))
              }
    })

/**
 * @description Not modified
 */
export const searchUsers304Schema = z.unknown()

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const searchUsers422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Service unavailable
 */
export const searchUsers503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const searchUsersQueryResponseSchema = searchUsers200Schema

export const teamsGetLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team.")
    })

/**
 * @description Response
 */
export const teamsGetLegacy200Schema = teamFullSchema.describe("Groups of organization members that gives permissions on specified repositories.")

/**
 * @description Resource not found
 */
export const teamsGetLegacy404Schema = basicErrorSchema.describe("Basic Error")

export const teamsGetLegacyQueryResponseSchema = teamsGetLegacy200Schema

export const teamsUpdateLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team.")
    })

/**
 * @description Response when the updated information already exists
 */
export const teamsUpdateLegacy200Schema = teamFullSchema.describe("Groups of organization members that gives permissions on specified repositories.")

/**
 * @description Response
 */
export const teamsUpdateLegacy201Schema = teamFullSchema.describe("Groups of organization members that gives permissions on specified repositories.")

/**
 * @description Forbidden
 */
export const teamsUpdateLegacy403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const teamsUpdateLegacy404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const teamsUpdateLegacy422Schema = validationErrorSchema.describe("Validation Error")

export const teamsUpdateLegacyMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the team."),
"description": z.optional(z.string().describe("The description of the team.")),
"privacy": z.optional(z.enum(["secret", "closed"]).describe("The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. The options are:  \n**For a non-nested team:**  \n * `secret` - only visible to organization owners and members of this team.  \n * `closed` - visible to all members of this organization.  \n**For a parent or child team:**  \n * `closed` - visible to all members of this organization.")),
"notification_setting": z.optional(z.enum(["notifications_enabled", "notifications_disabled"]).describe("The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are: \n * `notifications_enabled` - team members receive notifications when the team is @mentioned.  \n * `notifications_disabled` - no one receives notifications.")),
"permission": z.optional(z.enum(["pull", "push", "admin"]).default("pull").describe("**Closing down notice**. The permission that new repositories will be added to the team with when none is specified.")),
"parent_team_id": z.int().describe("The ID of a team to set as the parent team.").nullish()
    })

export const teamsUpdateLegacyMutationResponseSchema = z.union([teamsUpdateLegacy200Schema, teamsUpdateLegacy201Schema])

export const teamsDeleteLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team.")
    })

/**
 * @description Response
 */
export const teamsDeleteLegacy204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const teamsDeleteLegacy404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const teamsDeleteLegacy422Schema = validationErrorSchema.describe("Validation Error")

export const teamsDeleteLegacyMutationResponseSchema = teamsDeleteLegacy204Schema

export const teamsListDiscussionsLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team.")
    })

export const teamsListDiscussionsLegacyQueryParamsSchema = z.object({
    "direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const teamsListDiscussionsLegacy200Schema = z.array(teamDiscussionSchema.describe("A team discussion is a persistent record of a free-form conversation within a team."))

export const teamsListDiscussionsLegacyQueryResponseSchema = teamsListDiscussionsLegacy200Schema

export const teamsCreateDiscussionLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team.")
    })

/**
 * @description Response
 */
export const teamsCreateDiscussionLegacy201Schema = teamDiscussionSchema.describe("A team discussion is a persistent record of a free-form conversation within a team.")

export const teamsCreateDiscussionLegacyMutationRequestSchema = z.object({
    "title": z.string().describe("The discussion post's title."),
"body": z.string().describe("The discussion post's body text."),
"private": z.optional(z.boolean().default(false).describe("Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post."))
    })

export const teamsCreateDiscussionLegacyMutationResponseSchema = teamsCreateDiscussionLegacy201Schema

export const teamsGetDiscussionLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion.")
    })

/**
 * @description Response
 */
export const teamsGetDiscussionLegacy200Schema = teamDiscussionSchema.describe("A team discussion is a persistent record of a free-form conversation within a team.")

export const teamsGetDiscussionLegacyQueryResponseSchema = teamsGetDiscussionLegacy200Schema

export const teamsUpdateDiscussionLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion.")
    })

/**
 * @description Response
 */
export const teamsUpdateDiscussionLegacy200Schema = teamDiscussionSchema.describe("A team discussion is a persistent record of a free-form conversation within a team.")

export const teamsUpdateDiscussionLegacyMutationRequestSchema = z.object({
    "title": z.optional(z.string().describe("The discussion post's title.")),
"body": z.optional(z.string().describe("The discussion post's body text."))
    })

export const teamsUpdateDiscussionLegacyMutationResponseSchema = teamsUpdateDiscussionLegacy200Schema

export const teamsDeleteDiscussionLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion.")
    })

/**
 * @description Response
 */
export const teamsDeleteDiscussionLegacy204Schema = z.unknown()

export const teamsDeleteDiscussionLegacyMutationResponseSchema = teamsDeleteDiscussionLegacy204Schema

export const teamsListDiscussionCommentsLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion.")
    })

export const teamsListDiscussionCommentsLegacyQueryParamsSchema = z.object({
    "direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const teamsListDiscussionCommentsLegacy200Schema = z.array(teamDiscussionCommentSchema.describe("A reply to a discussion within a team."))

export const teamsListDiscussionCommentsLegacyQueryResponseSchema = teamsListDiscussionCommentsLegacy200Schema

export const teamsCreateDiscussionCommentLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion.")
    })

/**
 * @description Response
 */
export const teamsCreateDiscussionCommentLegacy201Schema = teamDiscussionCommentSchema.describe("A reply to a discussion within a team.")

export const teamsCreateDiscussionCommentLegacyMutationRequestSchema = z.object({
    "body": z.string().describe("The discussion comment's body text.")
    })

export const teamsCreateDiscussionCommentLegacyMutationResponseSchema = teamsCreateDiscussionCommentLegacy201Schema

export const teamsGetDiscussionCommentLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion."),
"comment_number": z.coerce.number().int().describe("The number that identifies the comment.")
    })

/**
 * @description Response
 */
export const teamsGetDiscussionCommentLegacy200Schema = teamDiscussionCommentSchema.describe("A reply to a discussion within a team.")

export const teamsGetDiscussionCommentLegacyQueryResponseSchema = teamsGetDiscussionCommentLegacy200Schema

export const teamsUpdateDiscussionCommentLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion."),
"comment_number": z.coerce.number().int().describe("The number that identifies the comment.")
    })

/**
 * @description Response
 */
export const teamsUpdateDiscussionCommentLegacy200Schema = teamDiscussionCommentSchema.describe("A reply to a discussion within a team.")

export const teamsUpdateDiscussionCommentLegacyMutationRequestSchema = z.object({
    "body": z.string().describe("The discussion comment's body text.")
    })

export const teamsUpdateDiscussionCommentLegacyMutationResponseSchema = teamsUpdateDiscussionCommentLegacy200Schema

export const teamsDeleteDiscussionCommentLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion."),
"comment_number": z.coerce.number().int().describe("The number that identifies the comment.")
    })

/**
 * @description Response
 */
export const teamsDeleteDiscussionCommentLegacy204Schema = z.unknown()

export const teamsDeleteDiscussionCommentLegacyMutationResponseSchema = teamsDeleteDiscussionCommentLegacy204Schema

export const reactionsListForTeamDiscussionCommentLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion."),
"comment_number": z.coerce.number().int().describe("The number that identifies the comment.")
    })

export const reactionsListForTeamDiscussionCommentLegacyQueryParamsSchema = z.object({
    "content": z.optional(z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion comment.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reactionsListForTeamDiscussionCommentLegacy200Schema = z.array(reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively."))

export const reactionsListForTeamDiscussionCommentLegacyQueryResponseSchema = reactionsListForTeamDiscussionCommentLegacy200Schema

export const reactionsCreateForTeamDiscussionCommentLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion."),
"comment_number": z.coerce.number().int().describe("The number that identifies the comment.")
    })

/**
 * @description Response
 */
export const reactionsCreateForTeamDiscussionCommentLegacy201Schema = reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

export const reactionsCreateForTeamDiscussionCommentLegacyMutationRequestSchema = z.object({
    "content": z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion comment.")
    })

export const reactionsCreateForTeamDiscussionCommentLegacyMutationResponseSchema = reactionsCreateForTeamDiscussionCommentLegacy201Schema

export const reactionsListForTeamDiscussionLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion.")
    })

export const reactionsListForTeamDiscussionLegacyQueryParamsSchema = z.object({
    "content": z.optional(z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reactionsListForTeamDiscussionLegacy200Schema = z.array(reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively."))

export const reactionsListForTeamDiscussionLegacyQueryResponseSchema = reactionsListForTeamDiscussionLegacy200Schema

export const reactionsCreateForTeamDiscussionLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"discussion_number": z.coerce.number().int().describe("The number that identifies the discussion.")
    })

/**
 * @description Response
 */
export const reactionsCreateForTeamDiscussionLegacy201Schema = reactionSchema.describe("Reactions to conversations provide a way to help people express their feelings more simply and effectively.")

export const reactionsCreateForTeamDiscussionLegacyMutationRequestSchema = z.object({
    "content": z.enum(["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"]).describe("The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion.")
    })

export const reactionsCreateForTeamDiscussionLegacyMutationResponseSchema = reactionsCreateForTeamDiscussionLegacy201Schema

export const teamsListPendingInvitationsLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team.")
    })

export const teamsListPendingInvitationsLegacyQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const teamsListPendingInvitationsLegacy200Schema = z.array(organizationInvitationSchema.describe("Organization Invitation"))

export const teamsListPendingInvitationsLegacyQueryResponseSchema = teamsListPendingInvitationsLegacy200Schema

export const teamsListMembersLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team.")
    })

export const teamsListMembersLegacyQueryParamsSchema = z.object({
    "role": z.enum(["member", "maintainer", "all"]).default("all").describe("Filters members returned by their role in the team."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const teamsListMembersLegacy200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

/**
 * @description Resource not found
 */
export const teamsListMembersLegacy404Schema = basicErrorSchema.describe("Basic Error")

export const teamsListMembersLegacyQueryResponseSchema = teamsListMembersLegacy200Schema

export const teamsGetMemberLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description if user is a member
 */
export const teamsGetMemberLegacy204Schema = z.unknown()

/**
 * @description if user is not a member
 */
export const teamsGetMemberLegacy404Schema = z.unknown()

export const teamsGetMemberLegacyQueryResponseSchema = teamsGetMemberLegacy204Schema

export const teamsAddMemberLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const teamsAddMemberLegacy204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const teamsAddMemberLegacy403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Not Found if team synchronization is set up
 */
export const teamsAddMemberLegacy404Schema = z.unknown()

/**
 * @description Unprocessable Entity if you attempt to add an organization to a team or you attempt to add a user to a team when they are not a member of at least one other team in the same organization
 */
export const teamsAddMemberLegacy422Schema = z.unknown()

export const teamsAddMemberLegacyMutationResponseSchema = teamsAddMemberLegacy204Schema

export const teamsRemoveMemberLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const teamsRemoveMemberLegacy204Schema = z.unknown()

/**
 * @description Not Found if team synchronization is setup
 */
export const teamsRemoveMemberLegacy404Schema = z.unknown()

export const teamsRemoveMemberLegacyMutationResponseSchema = teamsRemoveMemberLegacy204Schema

export const teamsGetMembershipForUserLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const teamsGetMembershipForUserLegacy200Schema = teamMembershipSchema.describe("Team Membership")

/**
 * @description Resource not found
 */
export const teamsGetMembershipForUserLegacy404Schema = basicErrorSchema.describe("Basic Error")

export const teamsGetMembershipForUserLegacyQueryResponseSchema = teamsGetMembershipForUserLegacy200Schema

export const teamsAddOrUpdateMembershipForUserLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const teamsAddOrUpdateMembershipForUserLegacy200Schema = teamMembershipSchema.describe("Team Membership")

/**
 * @description Forbidden if team synchronization is set up
 */
export const teamsAddOrUpdateMembershipForUserLegacy403Schema = z.unknown()

/**
 * @description Resource not found
 */
export const teamsAddOrUpdateMembershipForUserLegacy404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Unprocessable Entity if you attempt to add an organization to a team
 */
export const teamsAddOrUpdateMembershipForUserLegacy422Schema = z.unknown()

export const teamsAddOrUpdateMembershipForUserLegacyMutationRequestSchema = z.object({
    "role": z.optional(z.enum(["member", "maintainer"]).default("member").describe("The role that this user should have in the team."))
    })

export const teamsAddOrUpdateMembershipForUserLegacyMutationResponseSchema = teamsAddOrUpdateMembershipForUserLegacy200Schema

export const teamsRemoveMembershipForUserLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const teamsRemoveMembershipForUserLegacy204Schema = z.unknown()

/**
 * @description if team synchronization is set up
 */
export const teamsRemoveMembershipForUserLegacy403Schema = z.unknown()

export const teamsRemoveMembershipForUserLegacyMutationResponseSchema = teamsRemoveMembershipForUserLegacy204Schema

export const teamsListProjectsLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team.")
    })

export const teamsListProjectsLegacyQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const teamsListProjectsLegacy200Schema = z.array(teamProjectSchema.describe("A team's access to a project."))

/**
 * @description Resource not found
 */
export const teamsListProjectsLegacy404Schema = basicErrorSchema.describe("Basic Error")

export const teamsListProjectsLegacyQueryResponseSchema = teamsListProjectsLegacy200Schema

export const teamsCheckPermissionsForProjectLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"project_id": z.coerce.number().int().describe("The unique identifier of the project.")
    })

/**
 * @description Response
 */
export const teamsCheckPermissionsForProjectLegacy200Schema = teamProjectSchema.describe("A team's access to a project.")

/**
 * @description Not Found if project is not managed by this team
 */
export const teamsCheckPermissionsForProjectLegacy404Schema = z.unknown()

export const teamsCheckPermissionsForProjectLegacyQueryResponseSchema = teamsCheckPermissionsForProjectLegacy200Schema

export const teamsAddOrUpdateProjectPermissionsLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"project_id": z.coerce.number().int().describe("The unique identifier of the project.")
    })

/**
 * @description Response
 */
export const teamsAddOrUpdateProjectPermissionsLegacy204Schema = z.unknown()

/**
 * @description Forbidden if the project is not owned by the organization
 */
export const teamsAddOrUpdateProjectPermissionsLegacy403Schema = z.object({
    "message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

/**
 * @description Resource not found
 */
export const teamsAddOrUpdateProjectPermissionsLegacy404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const teamsAddOrUpdateProjectPermissionsLegacy422Schema = validationErrorSchema.describe("Validation Error")

export const teamsAddOrUpdateProjectPermissionsLegacyMutationRequestSchema = z.object({
    "permission": z.optional(z.enum(["read", "write", "admin"]).describe("The permission to grant to the team for this project. Default: the team's `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling this endpoint. For more information, see \"[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).\""))
    })

export const teamsAddOrUpdateProjectPermissionsLegacyMutationResponseSchema = teamsAddOrUpdateProjectPermissionsLegacy204Schema

export const teamsRemoveProjectLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"project_id": z.coerce.number().int().describe("The unique identifier of the project.")
    })

/**
 * @description Response
 */
export const teamsRemoveProjectLegacy204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const teamsRemoveProjectLegacy404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const teamsRemoveProjectLegacy422Schema = validationErrorSchema.describe("Validation Error")

export const teamsRemoveProjectLegacyMutationResponseSchema = teamsRemoveProjectLegacy204Schema

export const teamsListReposLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team.")
    })

export const teamsListReposLegacyQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const teamsListReposLegacy200Schema = z.array(minimalRepositorySchema.describe("Minimal Repository"))

/**
 * @description Resource not found
 */
export const teamsListReposLegacy404Schema = basicErrorSchema.describe("Basic Error")

export const teamsListReposLegacyQueryResponseSchema = teamsListReposLegacy200Schema

export const teamsCheckPermissionsForRepoLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Alternative response with extra repository information
 */
export const teamsCheckPermissionsForRepoLegacy200Schema = teamRepositorySchema.describe("A team's access to a repository.")

/**
 * @description Response if repository is managed by this team
 */
export const teamsCheckPermissionsForRepoLegacy204Schema = z.unknown()

/**
 * @description Not Found if repository is not managed by this team
 */
export const teamsCheckPermissionsForRepoLegacy404Schema = z.unknown()

export const teamsCheckPermissionsForRepoLegacyQueryResponseSchema = z.union([teamsCheckPermissionsForRepoLegacy200Schema, teamsCheckPermissionsForRepoLegacy204Schema])

export const teamsAddOrUpdateRepoPermissionsLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const teamsAddOrUpdateRepoPermissionsLegacy204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const teamsAddOrUpdateRepoPermissionsLegacy403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const teamsAddOrUpdateRepoPermissionsLegacy422Schema = validationErrorSchema.describe("Validation Error")

export const teamsAddOrUpdateRepoPermissionsLegacyMutationRequestSchema = z.object({
    "permission": z.optional(z.enum(["pull", "push", "admin"]).describe("The permission to grant the team on this repository. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository."))
    })

export const teamsAddOrUpdateRepoPermissionsLegacyMutationResponseSchema = teamsAddOrUpdateRepoPermissionsLegacy204Schema

export const teamsRemoveRepoLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team."),
"owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const teamsRemoveRepoLegacy204Schema = z.unknown()

export const teamsRemoveRepoLegacyMutationResponseSchema = teamsRemoveRepoLegacy204Schema

export const teamsListChildLegacyPathParamsSchema = z.object({
    "team_id": z.coerce.number().int().describe("The unique identifier of the team.")
    })

export const teamsListChildLegacyQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description if child teams exist
 */
export const teamsListChildLegacy200Schema = z.array(teamSchema.describe("Groups of organization members that gives permissions on specified repositories."))

/**
 * @description Forbidden
 */
export const teamsListChildLegacy403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const teamsListChildLegacy404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const teamsListChildLegacy422Schema = validationErrorSchema.describe("Validation Error")

export const teamsListChildLegacyQueryResponseSchema = teamsListChildLegacy200Schema

/**
 * @description Response
 */
export const usersGetAuthenticated200Schema = z.union([publicUserSchema.and(z.object({
    "user_view_type": z.literal("public")
    })), privateUserSchema.and(z.object({
    "user_view_type": z.literal("private")
    }))])

/**
 * @description Not modified
 */
export const usersGetAuthenticated304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersGetAuthenticated401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersGetAuthenticated403Schema = basicErrorSchema.describe("Basic Error")

export const usersGetAuthenticatedQueryResponseSchema = usersGetAuthenticated200Schema

/**
 * @description Response
 */
export const usersUpdateAuthenticated200Schema = privateUserSchema.describe("Private User")

/**
 * @description Not modified
 */
export const usersUpdateAuthenticated304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersUpdateAuthenticated401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersUpdateAuthenticated403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersUpdateAuthenticated404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const usersUpdateAuthenticated422Schema = validationErrorSchema.describe("Validation Error")

export const usersUpdateAuthenticatedMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("The new name of the user.")),
"email": z.optional(z.string().describe("The publicly visible email address of the user.")),
"blog": z.optional(z.string().describe("The new blog URL of the user.")),
"twitter_username": z.string().describe("The new Twitter username of the user.").nullish(),
"company": z.optional(z.string().describe("The new company of the user.")),
"location": z.optional(z.string().describe("The new location of the user.")),
"hireable": z.optional(z.boolean().describe("The new hiring availability of the user.")),
"bio": z.optional(z.string().describe("The new short biography of the user."))
    })

export const usersUpdateAuthenticatedMutationResponseSchema = usersUpdateAuthenticated200Schema

export const usersListBlockedByAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const usersListBlockedByAuthenticatedUser200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

/**
 * @description Not modified
 */
export const usersListBlockedByAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersListBlockedByAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersListBlockedByAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersListBlockedByAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const usersListBlockedByAuthenticatedUserQueryResponseSchema = usersListBlockedByAuthenticatedUser200Schema

export const usersCheckBlockedPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description If the user is blocked
 */
export const usersCheckBlocked204Schema = z.unknown()

/**
 * @description Not modified
 */
export const usersCheckBlocked304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersCheckBlocked401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersCheckBlocked403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description If the user is not blocked
 */
export const usersCheckBlocked404Schema = basicErrorSchema.describe("Basic Error")

export const usersCheckBlockedQueryResponseSchema = usersCheckBlocked204Schema

export const usersBlockPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const usersBlock204Schema = z.unknown()

/**
 * @description Not modified
 */
export const usersBlock304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersBlock401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersBlock403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersBlock404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const usersBlock422Schema = validationErrorSchema.describe("Validation Error")

export const usersBlockMutationResponseSchema = usersBlock204Schema

export const usersUnblockPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const usersUnblock204Schema = z.unknown()

/**
 * @description Not modified
 */
export const usersUnblock304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersUnblock401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersUnblock403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersUnblock404Schema = basicErrorSchema.describe("Basic Error")

export const usersUnblockMutationResponseSchema = usersUnblock204Schema

export const codespacesListForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"repository_id": z.optional(z.coerce.number().int().describe("ID of the Repository to filter on"))
    })

/**
 * @description Response
 */
export const codespacesListForAuthenticatedUser200Schema = z.object({
    "total_count": z.int(),
get "codespaces"(){
                return z.array(codespaceSchema.describe("A codespace."))
              }
    })

/**
 * @description Not modified
 */
export const codespacesListForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const codespacesListForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesListForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesListForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesListForAuthenticatedUser500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesListForAuthenticatedUserQueryResponseSchema = codespacesListForAuthenticatedUser200Schema

/**
 * @description Response when the codespace was successfully created
 */
export const codespacesCreateForAuthenticatedUser201Schema = codespaceSchema.describe("A codespace.")

/**
 * @description Response when the codespace creation partially failed but is being retried in the background
 */
export const codespacesCreateForAuthenticatedUser202Schema = codespaceSchema.describe("A codespace.")

/**
 * @description Requires authentication
 */
export const codespacesCreateForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesCreateForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesCreateForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const codespacesCreateForAuthenticatedUser503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const codespacesCreateForAuthenticatedUserMutationRequestSchema = z.union([z.object({
    "repository_id": z.int().describe("Repository id for this codespace"),
"ref": z.optional(z.string().describe("Git ref (typically a branch name) for this codespace")),
"location": z.optional(z.string().describe("The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.")),
"geo": z.optional(z.enum(["EuropeWest", "SoutheastAsia", "UsEast", "UsWest"]).describe("The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down.")),
"client_ip": z.optional(z.string().describe("IP for location auto-detection when proxying a request")),
"machine": z.optional(z.string().describe("Machine type to use for this codespace")),
"devcontainer_path": z.optional(z.string().describe("Path to devcontainer.json config to use for this codespace")),
"multi_repo_permissions_opt_out": z.optional(z.boolean().describe("Whether to authorize requested permissions from devcontainer.json")),
"working_directory": z.optional(z.string().describe("Working directory for this codespace")),
"idle_timeout_minutes": z.optional(z.int().describe("Time in minutes before codespace stops from inactivity")),
"display_name": z.optional(z.string().describe("Display name for this codespace")),
"retention_period_minutes": z.optional(z.int().describe("Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days)."))
    }), z.object({
    "pull_request": z.object({
    "pull_request_number": z.int().describe("Pull request number"),
"repository_id": z.int().describe("Repository id for this codespace")
    }).describe("Pull request number for this codespace"),
"location": z.optional(z.string().describe("The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.")),
"geo": z.optional(z.enum(["EuropeWest", "SoutheastAsia", "UsEast", "UsWest"]).describe("The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down.")),
"machine": z.optional(z.string().describe("Machine type to use for this codespace")),
"devcontainer_path": z.optional(z.string().describe("Path to devcontainer.json config to use for this codespace")),
"working_directory": z.optional(z.string().describe("Working directory for this codespace")),
"idle_timeout_minutes": z.optional(z.int().describe("Time in minutes before codespace stops from inactivity"))
    })])

export const codespacesCreateForAuthenticatedUserMutationResponseSchema = z.union([codespacesCreateForAuthenticatedUser201Schema, codespacesCreateForAuthenticatedUser202Schema])

export const codespacesListSecretsForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const codespacesListSecretsForAuthenticatedUser200Schema = z.object({
    "total_count": z.int(),
get "secrets"(){
                return z.array(codespacesSecretSchema.describe("Secrets for a GitHub Codespace."))
              }
    })

export const codespacesListSecretsForAuthenticatedUserQueryResponseSchema = codespacesListSecretsForAuthenticatedUser200Schema

/**
 * @description Response
 */
export const codespacesGetPublicKeyForAuthenticatedUser200Schema = codespacesUserPublicKeySchema.describe("The public key used for setting user Codespaces' Secrets.")

export const codespacesGetPublicKeyForAuthenticatedUserQueryResponseSchema = codespacesGetPublicKeyForAuthenticatedUser200Schema

export const codespacesGetSecretForAuthenticatedUserPathParamsSchema = z.object({
    "secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const codespacesGetSecretForAuthenticatedUser200Schema = codespacesSecretSchema.describe("Secrets for a GitHub Codespace.")

export const codespacesGetSecretForAuthenticatedUserQueryResponseSchema = codespacesGetSecretForAuthenticatedUser200Schema

export const codespacesCreateOrUpdateSecretForAuthenticatedUserPathParamsSchema = z.object({
    "secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response after successfully creating a secret
 */
export const codespacesCreateOrUpdateSecretForAuthenticatedUser201Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Response after successfully updating a secret
 */
export const codespacesCreateOrUpdateSecretForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const codespacesCreateOrUpdateSecretForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const codespacesCreateOrUpdateSecretForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const codespacesCreateOrUpdateSecretForAuthenticatedUserMutationRequestSchema = z.object({
    "encrypted_value": z.optional(z.string().regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$/).describe("Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get the public key for the authenticated user](https://docs.github.com/rest/codespaces/secrets#get-public-key-for-the-authenticated-user) endpoint.")),
"key_id": z.string().describe("ID of the key you used to encrypt the secret."),
"selected_repository_ids": z.optional(z.array(z.union([z.int(), z.string()])).describe("An array of repository ids that can access the user secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#list-selected-repositories-for-a-user-secret), [Set selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#set-selected-repositories-for-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/codespaces/secrets#remove-a-selected-repository-from-a-user-secret) endpoints."))
    })

export const codespacesCreateOrUpdateSecretForAuthenticatedUserMutationResponseSchema = z.union([codespacesCreateOrUpdateSecretForAuthenticatedUser201Schema, codespacesCreateOrUpdateSecretForAuthenticatedUser204Schema])

export const codespacesDeleteSecretForAuthenticatedUserPathParamsSchema = z.object({
    "secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const codespacesDeleteSecretForAuthenticatedUser204Schema = z.unknown()

export const codespacesDeleteSecretForAuthenticatedUserMutationResponseSchema = codespacesDeleteSecretForAuthenticatedUser204Schema

export const codespacesListRepositoriesForSecretForAuthenticatedUserPathParamsSchema = z.object({
    "secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description Response
 */
export const codespacesListRepositoriesForSecretForAuthenticatedUser200Schema = z.object({
    "total_count": z.int(),
get "repositories"(){
                return z.array(minimalRepositorySchema.describe("Minimal Repository"))
              }
    })

/**
 * @description Requires authentication
 */
export const codespacesListRepositoriesForSecretForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesListRepositoriesForSecretForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesListRepositoriesForSecretForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesListRepositoriesForSecretForAuthenticatedUser500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesListRepositoriesForSecretForAuthenticatedUserQueryResponseSchema = codespacesListRepositoriesForSecretForAuthenticatedUser200Schema

export const codespacesSetRepositoriesForSecretForAuthenticatedUserPathParamsSchema = z.object({
    "secret_name": z.string().describe("The name of the secret.")
    })

/**
 * @description No Content when repositories were added to the selected list
 */
export const codespacesSetRepositoriesForSecretForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const codespacesSetRepositoriesForSecretForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesSetRepositoriesForSecretForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesSetRepositoriesForSecretForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesSetRepositoriesForSecretForAuthenticatedUser500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesSetRepositoriesForSecretForAuthenticatedUserMutationRequestSchema = z.object({
    "selected_repository_ids": z.array(z.int()).describe("An array of repository ids for which a codespace can access the secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#list-selected-repositories-for-a-user-secret), [Add a selected repository to a user secret](https://docs.github.com/rest/codespaces/secrets#add-a-selected-repository-to-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/codespaces/secrets#remove-a-selected-repository-from-a-user-secret) endpoints.")
    })

export const codespacesSetRepositoriesForSecretForAuthenticatedUserMutationResponseSchema = codespacesSetRepositoriesForSecretForAuthenticatedUser204Schema

export const codespacesAddRepositoryForSecretForAuthenticatedUserPathParamsSchema = z.object({
    "secret_name": z.string().describe("The name of the secret."),
"repository_id": z.coerce.number().int()
    })

/**
 * @description No Content when repository was added to the selected list
 */
export const codespacesAddRepositoryForSecretForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const codespacesAddRepositoryForSecretForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesAddRepositoryForSecretForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesAddRepositoryForSecretForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesAddRepositoryForSecretForAuthenticatedUser500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesAddRepositoryForSecretForAuthenticatedUserMutationResponseSchema = codespacesAddRepositoryForSecretForAuthenticatedUser204Schema

export const codespacesRemoveRepositoryForSecretForAuthenticatedUserPathParamsSchema = z.object({
    "secret_name": z.string().describe("The name of the secret."),
"repository_id": z.coerce.number().int()
    })

/**
 * @description No Content when repository was removed from the selected list
 */
export const codespacesRemoveRepositoryForSecretForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const codespacesRemoveRepositoryForSecretForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesRemoveRepositoryForSecretForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesRemoveRepositoryForSecretForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesRemoveRepositoryForSecretForAuthenticatedUser500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesRemoveRepositoryForSecretForAuthenticatedUserMutationResponseSchema = codespacesRemoveRepositoryForSecretForAuthenticatedUser204Schema

export const codespacesGetForAuthenticatedUserPathParamsSchema = z.object({
    "codespace_name": z.string().describe("The name of the codespace.")
    })

/**
 * @description Response
 */
export const codespacesGetForAuthenticatedUser200Schema = codespaceSchema.describe("A codespace.")

/**
 * @description Not modified
 */
export const codespacesGetForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const codespacesGetForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesGetForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesGetForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesGetForAuthenticatedUser500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesGetForAuthenticatedUserQueryResponseSchema = codespacesGetForAuthenticatedUser200Schema

export const codespacesUpdateForAuthenticatedUserPathParamsSchema = z.object({
    "codespace_name": z.string().describe("The name of the codespace.")
    })

/**
 * @description Response
 */
export const codespacesUpdateForAuthenticatedUser200Schema = codespaceSchema.describe("A codespace.")

/**
 * @description Requires authentication
 */
export const codespacesUpdateForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesUpdateForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesUpdateForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const codespacesUpdateForAuthenticatedUserMutationRequestSchema = z.object({
    "machine": z.optional(z.string().describe("A valid machine to transition this codespace to.")),
"display_name": z.optional(z.string().describe("Display name for this codespace")),
"recent_folders": z.optional(z.array(z.string()).describe("Recently opened folders inside the codespace. It is currently used by the clients to determine the folder path to load the codespace in."))
    })

export const codespacesUpdateForAuthenticatedUserMutationResponseSchema = codespacesUpdateForAuthenticatedUser200Schema

export const codespacesDeleteForAuthenticatedUserPathParamsSchema = z.object({
    "codespace_name": z.string().describe("The name of the codespace.")
    })

/**
 * @description Accepted
 */
export const codespacesDeleteForAuthenticatedUser202Schema = z.object({
    
    })

/**
 * @description Not modified
 */
export const codespacesDeleteForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const codespacesDeleteForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesDeleteForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesDeleteForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesDeleteForAuthenticatedUser500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesDeleteForAuthenticatedUserMutationResponseSchema = codespacesDeleteForAuthenticatedUser202Schema

export const codespacesExportForAuthenticatedUserPathParamsSchema = z.object({
    "codespace_name": z.string().describe("The name of the codespace.")
    })

/**
 * @description Response
 */
export const codespacesExportForAuthenticatedUser202Schema = codespaceExportDetailsSchema.describe("An export of a codespace. Also, latest export details for a codespace can be fetched with id = latest")

/**
 * @description Requires authentication
 */
export const codespacesExportForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesExportForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesExportForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const codespacesExportForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Internal Error
 */
export const codespacesExportForAuthenticatedUser500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesExportForAuthenticatedUserMutationResponseSchema = codespacesExportForAuthenticatedUser202Schema

export const codespacesGetExportDetailsForAuthenticatedUserPathParamsSchema = z.object({
    "codespace_name": z.string().describe("The name of the codespace."),
"export_id": z.string().describe("The ID of the export operation, or `latest`. Currently only `latest` is currently supported.")
    })

/**
 * @description Response
 */
export const codespacesGetExportDetailsForAuthenticatedUser200Schema = codespaceExportDetailsSchema.describe("An export of a codespace. Also, latest export details for a codespace can be fetched with id = latest")

/**
 * @description Resource not found
 */
export const codespacesGetExportDetailsForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const codespacesGetExportDetailsForAuthenticatedUserQueryResponseSchema = codespacesGetExportDetailsForAuthenticatedUser200Schema

export const codespacesCodespaceMachinesForAuthenticatedUserPathParamsSchema = z.object({
    "codespace_name": z.string().describe("The name of the codespace.")
    })

/**
 * @description Response
 */
export const codespacesCodespaceMachinesForAuthenticatedUser200Schema = z.object({
    "total_count": z.int(),
get "machines"(){
                return z.array(codespaceMachineSchema.describe("A description of the machine powering a codespace."))
              }
    })

/**
 * @description Not modified
 */
export const codespacesCodespaceMachinesForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const codespacesCodespaceMachinesForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesCodespaceMachinesForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesCodespaceMachinesForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesCodespaceMachinesForAuthenticatedUser500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesCodespaceMachinesForAuthenticatedUserQueryResponseSchema = codespacesCodespaceMachinesForAuthenticatedUser200Schema

export const codespacesPublishForAuthenticatedUserPathParamsSchema = z.object({
    "codespace_name": z.string().describe("The name of the codespace.")
    })

/**
 * @description Response
 */
export const codespacesPublishForAuthenticatedUser201Schema = codespaceWithFullRepositorySchema.describe("A codespace.")

/**
 * @description Requires authentication
 */
export const codespacesPublishForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesPublishForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesPublishForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const codespacesPublishForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const codespacesPublishForAuthenticatedUserMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("A name for the new repository.")),
"private": z.optional(z.boolean().default(false).describe("Whether the new repository should be private."))
    })

export const codespacesPublishForAuthenticatedUserMutationResponseSchema = codespacesPublishForAuthenticatedUser201Schema

export const codespacesStartForAuthenticatedUserPathParamsSchema = z.object({
    "codespace_name": z.string().describe("The name of the codespace.")
    })

/**
 * @description Response
 */
export const codespacesStartForAuthenticatedUser200Schema = codespaceSchema.describe("A codespace.")

/**
 * @description Not modified
 */
export const codespacesStartForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Bad Request
 */
export const codespacesStartForAuthenticatedUser400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Requires authentication
 */
export const codespacesStartForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Payment required
 */
export const codespacesStartForAuthenticatedUser402Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesStartForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesStartForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const codespacesStartForAuthenticatedUser409Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesStartForAuthenticatedUser500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesStartForAuthenticatedUserMutationResponseSchema = codespacesStartForAuthenticatedUser200Schema

export const codespacesStopForAuthenticatedUserPathParamsSchema = z.object({
    "codespace_name": z.string().describe("The name of the codespace.")
    })

/**
 * @description Response
 */
export const codespacesStopForAuthenticatedUser200Schema = codespaceSchema.describe("A codespace.")

/**
 * @description Requires authentication
 */
export const codespacesStopForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const codespacesStopForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const codespacesStopForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const codespacesStopForAuthenticatedUser500Schema = basicErrorSchema.describe("Basic Error")

export const codespacesStopForAuthenticatedUserMutationResponseSchema = codespacesStopForAuthenticatedUser200Schema

/**
 * @description Response
 */
export const packagesListDockerMigrationConflictingPackagesForAuthenticatedUser200Schema = z.array(packageSchema.describe("A software package"))

export const packagesListDockerMigrationConflictingPackagesForAuthenticatedUserQueryResponseSchema = packagesListDockerMigrationConflictingPackagesForAuthenticatedUser200Schema

/**
 * @description Response
 */
export const usersSetPrimaryEmailVisibilityForAuthenticatedUser200Schema = z.array(emailSchema.describe("Email"))

/**
 * @description Not modified
 */
export const usersSetPrimaryEmailVisibilityForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersSetPrimaryEmailVisibilityForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersSetPrimaryEmailVisibilityForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersSetPrimaryEmailVisibilityForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const usersSetPrimaryEmailVisibilityForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const usersSetPrimaryEmailVisibilityForAuthenticatedUserMutationRequestSchema = z.object({
    "visibility": z.enum(["public", "private"]).describe("Denotes whether an email is publicly visible.")
    })

export const usersSetPrimaryEmailVisibilityForAuthenticatedUserMutationResponseSchema = usersSetPrimaryEmailVisibilityForAuthenticatedUser200Schema

export const usersListEmailsForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const usersListEmailsForAuthenticatedUser200Schema = z.array(emailSchema.describe("Email"))

/**
 * @description Not modified
 */
export const usersListEmailsForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersListEmailsForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersListEmailsForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersListEmailsForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const usersListEmailsForAuthenticatedUserQueryResponseSchema = usersListEmailsForAuthenticatedUser200Schema

/**
 * @description Response
 */
export const usersAddEmailForAuthenticatedUser201Schema = z.array(emailSchema.describe("Email"))

/**
 * @description Not modified
 */
export const usersAddEmailForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersAddEmailForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersAddEmailForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersAddEmailForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const usersAddEmailForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const usersAddEmailForAuthenticatedUserMutationRequestSchema = z.union([z.array(z.string()).min(1), z.string(), z.object({
    "emails": z.array(z.string()).min(1).describe("Adds one or more email addresses to your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key.")
    })])

export const usersAddEmailForAuthenticatedUserMutationResponseSchema = usersAddEmailForAuthenticatedUser201Schema

/**
 * @description Response
 */
export const usersDeleteEmailForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Not modified
 */
export const usersDeleteEmailForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersDeleteEmailForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersDeleteEmailForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersDeleteEmailForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const usersDeleteEmailForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const usersDeleteEmailForAuthenticatedUserMutationRequestSchema = z.union([z.array(z.string()).min(1), z.string(), z.object({
    "emails": z.array(z.string()).min(1).describe("Email addresses associated with the GitHub user account.")
    })])

export const usersDeleteEmailForAuthenticatedUserMutationResponseSchema = usersDeleteEmailForAuthenticatedUser204Schema

export const usersListFollowersForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const usersListFollowersForAuthenticatedUser200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

/**
 * @description Not modified
 */
export const usersListFollowersForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersListFollowersForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersListFollowersForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

export const usersListFollowersForAuthenticatedUserQueryResponseSchema = usersListFollowersForAuthenticatedUser200Schema

export const usersListFollowedByAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const usersListFollowedByAuthenticatedUser200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

/**
 * @description Not modified
 */
export const usersListFollowedByAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersListFollowedByAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersListFollowedByAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

export const usersListFollowedByAuthenticatedUserQueryResponseSchema = usersListFollowedByAuthenticatedUser200Schema

export const usersCheckPersonIsFollowedByAuthenticatedPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description if the person is followed by the authenticated user
 */
export const usersCheckPersonIsFollowedByAuthenticated204Schema = z.unknown()

/**
 * @description Not modified
 */
export const usersCheckPersonIsFollowedByAuthenticated304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersCheckPersonIsFollowedByAuthenticated401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersCheckPersonIsFollowedByAuthenticated403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description if the person is not followed by the authenticated user
 */
export const usersCheckPersonIsFollowedByAuthenticated404Schema = basicErrorSchema.describe("Basic Error")

export const usersCheckPersonIsFollowedByAuthenticatedQueryResponseSchema = usersCheckPersonIsFollowedByAuthenticated204Schema

export const usersFollowPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const usersFollow204Schema = z.unknown()

/**
 * @description Not modified
 */
export const usersFollow304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersFollow401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersFollow403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersFollow404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const usersFollow422Schema = validationErrorSchema.describe("Validation Error")

export const usersFollowMutationResponseSchema = usersFollow204Schema

export const usersUnfollowPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const usersUnfollow204Schema = z.unknown()

/**
 * @description Not modified
 */
export const usersUnfollow304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersUnfollow401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersUnfollow403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersUnfollow404Schema = basicErrorSchema.describe("Basic Error")

export const usersUnfollowMutationResponseSchema = usersUnfollow204Schema

export const usersListGpgKeysForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const usersListGpgKeysForAuthenticatedUser200Schema = z.array(gpgKeySchema.describe("A unique encryption key"))

/**
 * @description Not modified
 */
export const usersListGpgKeysForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersListGpgKeysForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersListGpgKeysForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersListGpgKeysForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const usersListGpgKeysForAuthenticatedUserQueryResponseSchema = usersListGpgKeysForAuthenticatedUser200Schema

/**
 * @description Response
 */
export const usersCreateGpgKeyForAuthenticatedUser201Schema = gpgKeySchema.describe("A unique encryption key")

/**
 * @description Not modified
 */
export const usersCreateGpgKeyForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersCreateGpgKeyForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersCreateGpgKeyForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersCreateGpgKeyForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const usersCreateGpgKeyForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const usersCreateGpgKeyForAuthenticatedUserMutationRequestSchema = z.object({
    "name": z.optional(z.string().describe("A descriptive name for the new key.")),
"armored_public_key": z.string().describe("A GPG key in ASCII-armored format.")
    })

export const usersCreateGpgKeyForAuthenticatedUserMutationResponseSchema = usersCreateGpgKeyForAuthenticatedUser201Schema

export const usersGetGpgKeyForAuthenticatedUserPathParamsSchema = z.object({
    "gpg_key_id": z.coerce.number().int().describe("The unique identifier of the GPG key.")
    })

/**
 * @description Response
 */
export const usersGetGpgKeyForAuthenticatedUser200Schema = gpgKeySchema.describe("A unique encryption key")

/**
 * @description Not modified
 */
export const usersGetGpgKeyForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersGetGpgKeyForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersGetGpgKeyForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersGetGpgKeyForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const usersGetGpgKeyForAuthenticatedUserQueryResponseSchema = usersGetGpgKeyForAuthenticatedUser200Schema

export const usersDeleteGpgKeyForAuthenticatedUserPathParamsSchema = z.object({
    "gpg_key_id": z.coerce.number().int().describe("The unique identifier of the GPG key.")
    })

/**
 * @description Response
 */
export const usersDeleteGpgKeyForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Not modified
 */
export const usersDeleteGpgKeyForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersDeleteGpgKeyForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersDeleteGpgKeyForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersDeleteGpgKeyForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const usersDeleteGpgKeyForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const usersDeleteGpgKeyForAuthenticatedUserMutationResponseSchema = usersDeleteGpgKeyForAuthenticatedUser204Schema

export const appsListInstallationsForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description You can find the permissions for the installation under the `permissions` key.
 */
export const appsListInstallationsForAuthenticatedUser200Schema = z.object({
    "total_count": z.int(),
get "installations"(){
                return z.array(installationSchema.describe("Installation"))
              }
    })

/**
 * @description Not modified
 */
export const appsListInstallationsForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const appsListInstallationsForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const appsListInstallationsForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

export const appsListInstallationsForAuthenticatedUserQueryResponseSchema = appsListInstallationsForAuthenticatedUser200Schema

export const appsListInstallationReposForAuthenticatedUserPathParamsSchema = z.object({
    "installation_id": z.coerce.number().int().describe("The unique identifier of the installation.")
    })

export const appsListInstallationReposForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description The access the user has to each repository is included in the hash under the `permissions` key.
 */
export const appsListInstallationReposForAuthenticatedUser200Schema = z.object({
    "total_count": z.int(),
"repository_selection": z.optional(z.string()),
get "repositories"(){
                return z.array(repositorySchema.describe("A repository on GitHub."))
              }
    })

/**
 * @description Not modified
 */
export const appsListInstallationReposForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const appsListInstallationReposForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const appsListInstallationReposForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const appsListInstallationReposForAuthenticatedUserQueryResponseSchema = appsListInstallationReposForAuthenticatedUser200Schema

export const appsAddRepoToInstallationForAuthenticatedUserPathParamsSchema = z.object({
    "installation_id": z.coerce.number().int().describe("The unique identifier of the installation."),
"repository_id": z.coerce.number().int().describe("The unique identifier of the repository.")
    })

/**
 * @description Response
 */
export const appsAddRepoToInstallationForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Not modified
 */
export const appsAddRepoToInstallationForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const appsAddRepoToInstallationForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const appsAddRepoToInstallationForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const appsAddRepoToInstallationForAuthenticatedUserMutationResponseSchema = appsAddRepoToInstallationForAuthenticatedUser204Schema

export const appsRemoveRepoFromInstallationForAuthenticatedUserPathParamsSchema = z.object({
    "installation_id": z.coerce.number().int().describe("The unique identifier of the installation."),
"repository_id": z.coerce.number().int().describe("The unique identifier of the repository.")
    })

/**
 * @description Response
 */
export const appsRemoveRepoFromInstallationForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Not modified
 */
export const appsRemoveRepoFromInstallationForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const appsRemoveRepoFromInstallationForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const appsRemoveRepoFromInstallationForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Returned when the application is installed on `all` repositories in the organization, or if this request would remove the last repository that the application has access to in the organization.
 */
export const appsRemoveRepoFromInstallationForAuthenticatedUser422Schema = z.unknown()

export const appsRemoveRepoFromInstallationForAuthenticatedUserMutationResponseSchema = appsRemoveRepoFromInstallationForAuthenticatedUser204Schema

/**
 * @description Default response
 */
export const interactionsGetRestrictionsForAuthenticatedUser200Schema = z.union([interactionLimitResponseSchema, z.object({
    
    })])

/**
 * @description Response when there are no restrictions
 */
export const interactionsGetRestrictionsForAuthenticatedUser204Schema = z.unknown()

export const interactionsGetRestrictionsForAuthenticatedUserQueryResponseSchema = z.union([interactionsGetRestrictionsForAuthenticatedUser200Schema, interactionsGetRestrictionsForAuthenticatedUser204Schema])

/**
 * @description Response
 */
export const interactionsSetRestrictionsForAuthenticatedUser200Schema = interactionLimitResponseSchema.describe("Interaction limit settings.")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const interactionsSetRestrictionsForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const interactionsSetRestrictionsForAuthenticatedUserMutationRequestSchema = interactionLimitSchema.describe("Limit interactions to a specific type of user for a specified duration")

export const interactionsSetRestrictionsForAuthenticatedUserMutationResponseSchema = interactionsSetRestrictionsForAuthenticatedUser200Schema

/**
 * @description Response
 */
export const interactionsRemoveRestrictionsForAuthenticatedUser204Schema = z.unknown()

export const interactionsRemoveRestrictionsForAuthenticatedUserMutationResponseSchema = interactionsRemoveRestrictionsForAuthenticatedUser204Schema

export const issuesListForAuthenticatedUserQueryParamsSchema = z.object({
    "filter": z.enum(["assigned", "created", "mentioned", "subscribed", "repos", "all"]).default("assigned").describe("Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation."),
"state": z.enum(["open", "closed", "all"]).default("open").describe("Indicates the state of the issues to return."),
"labels": z.optional(z.string().describe("A list of comma separated label names. Example: `bug,ui,@high`")),
"sort": z.enum(["created", "updated", "comments"]).default("created").describe("What to sort results by."),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"since": z.optional(z.iso.datetime({ offset: true }).describe("Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const issuesListForAuthenticatedUser200Schema = z.array(issueSchema.describe("Issues are a great way to keep track of tasks, enhancements, and bugs for your projects."))

/**
 * @description Not modified
 */
export const issuesListForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Resource not found
 */
export const issuesListForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const issuesListForAuthenticatedUserQueryResponseSchema = issuesListForAuthenticatedUser200Schema

export const usersListPublicSshKeysForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const usersListPublicSshKeysForAuthenticatedUser200Schema = z.array(keySchema.describe("Key"))

/**
 * @description Not modified
 */
export const usersListPublicSshKeysForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersListPublicSshKeysForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersListPublicSshKeysForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersListPublicSshKeysForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const usersListPublicSshKeysForAuthenticatedUserQueryResponseSchema = usersListPublicSshKeysForAuthenticatedUser200Schema

/**
 * @description Response
 */
export const usersCreatePublicSshKeyForAuthenticatedUser201Schema = keySchema.describe("Key")

/**
 * @description Not modified
 */
export const usersCreatePublicSshKeyForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersCreatePublicSshKeyForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersCreatePublicSshKeyForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersCreatePublicSshKeyForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const usersCreatePublicSshKeyForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const usersCreatePublicSshKeyForAuthenticatedUserMutationRequestSchema = z.object({
    "title": z.optional(z.string().describe("A descriptive name for the new key.")),
"key": z.string().regex(/^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) /).describe("The public SSH key to add to your GitHub account.")
    })

export const usersCreatePublicSshKeyForAuthenticatedUserMutationResponseSchema = usersCreatePublicSshKeyForAuthenticatedUser201Schema

export const usersGetPublicSshKeyForAuthenticatedUserPathParamsSchema = z.object({
    "key_id": z.coerce.number().int().describe("The unique identifier of the key.")
    })

/**
 * @description Response
 */
export const usersGetPublicSshKeyForAuthenticatedUser200Schema = keySchema.describe("Key")

/**
 * @description Not modified
 */
export const usersGetPublicSshKeyForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersGetPublicSshKeyForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersGetPublicSshKeyForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersGetPublicSshKeyForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const usersGetPublicSshKeyForAuthenticatedUserQueryResponseSchema = usersGetPublicSshKeyForAuthenticatedUser200Schema

export const usersDeletePublicSshKeyForAuthenticatedUserPathParamsSchema = z.object({
    "key_id": z.coerce.number().int().describe("The unique identifier of the key.")
    })

/**
 * @description Response
 */
export const usersDeletePublicSshKeyForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Not modified
 */
export const usersDeletePublicSshKeyForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersDeletePublicSshKeyForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersDeletePublicSshKeyForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersDeletePublicSshKeyForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const usersDeletePublicSshKeyForAuthenticatedUserMutationResponseSchema = usersDeletePublicSshKeyForAuthenticatedUser204Schema

export const appsListSubscriptionsForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const appsListSubscriptionsForAuthenticatedUser200Schema = z.array(userMarketplacePurchaseSchema.describe("User Marketplace Purchase"))

/**
 * @description Not modified
 */
export const appsListSubscriptionsForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const appsListSubscriptionsForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const appsListSubscriptionsForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const appsListSubscriptionsForAuthenticatedUserQueryResponseSchema = appsListSubscriptionsForAuthenticatedUser200Schema

export const appsListSubscriptionsForAuthenticatedUserStubbedQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const appsListSubscriptionsForAuthenticatedUserStubbed200Schema = z.array(userMarketplacePurchaseSchema.describe("User Marketplace Purchase"))

/**
 * @description Not modified
 */
export const appsListSubscriptionsForAuthenticatedUserStubbed304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const appsListSubscriptionsForAuthenticatedUserStubbed401Schema = basicErrorSchema.describe("Basic Error")

export const appsListSubscriptionsForAuthenticatedUserStubbedQueryResponseSchema = appsListSubscriptionsForAuthenticatedUserStubbed200Schema

export const orgsListMembershipsForAuthenticatedUserQueryParamsSchema = z.object({
    "state": z.optional(z.enum(["active", "pending"]).describe("Indicates the state of the memberships to return. If not specified, the API returns both active and pending memberships.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const orgsListMembershipsForAuthenticatedUser200Schema = z.array(orgMembershipSchema.describe("Org Membership"))

/**
 * @description Not modified
 */
export const orgsListMembershipsForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const orgsListMembershipsForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const orgsListMembershipsForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsListMembershipsForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const orgsListMembershipsForAuthenticatedUserQueryResponseSchema = orgsListMembershipsForAuthenticatedUser200Schema

export const orgsGetMembershipForAuthenticatedUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const orgsGetMembershipForAuthenticatedUser200Schema = orgMembershipSchema.describe("Org Membership")

/**
 * @description Forbidden
 */
export const orgsGetMembershipForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsGetMembershipForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const orgsGetMembershipForAuthenticatedUserQueryResponseSchema = orgsGetMembershipForAuthenticatedUser200Schema

export const orgsUpdateMembershipForAuthenticatedUserPathParamsSchema = z.object({
    "org": z.string().describe("The organization name. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const orgsUpdateMembershipForAuthenticatedUser200Schema = orgMembershipSchema.describe("Org Membership")

/**
 * @description Forbidden
 */
export const orgsUpdateMembershipForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const orgsUpdateMembershipForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const orgsUpdateMembershipForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const orgsUpdateMembershipForAuthenticatedUserMutationRequestSchema = z.object({
    "state": z.enum(["active"]).describe("The state that the membership should be in. Only `\"active\"` will be accepted.")
    })

export const orgsUpdateMembershipForAuthenticatedUserMutationResponseSchema = orgsUpdateMembershipForAuthenticatedUser200Schema

export const migrationsListForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const migrationsListForAuthenticatedUser200Schema = z.array(migrationSchema.describe("A migration."))

/**
 * @description Not modified
 */
export const migrationsListForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const migrationsListForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const migrationsListForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

export const migrationsListForAuthenticatedUserQueryResponseSchema = migrationsListForAuthenticatedUser200Schema

/**
 * @description Response
 */
export const migrationsStartForAuthenticatedUser201Schema = migrationSchema.describe("A migration.")

/**
 * @description Not modified
 */
export const migrationsStartForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const migrationsStartForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const migrationsStartForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const migrationsStartForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const migrationsStartForAuthenticatedUserMutationRequestSchema = z.object({
    "lock_repositories": z.optional(z.boolean().describe("Lock the repositories being migrated at the start of the migration")),
"exclude_metadata": z.optional(z.boolean().describe("Indicates whether metadata should be excluded and only git source should be included for the migration.")),
"exclude_git_data": z.optional(z.boolean().describe("Indicates whether the repository git data should be excluded from the migration.")),
"exclude_attachments": z.optional(z.boolean().describe("Do not include attachments in the migration")),
"exclude_releases": z.optional(z.boolean().describe("Do not include releases in the migration")),
"exclude_owner_projects": z.optional(z.boolean().describe("Indicates whether projects owned by the organization or users should be excluded.")),
"org_metadata_only": z.optional(z.boolean().default(false).describe("Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags).")),
"exclude": z.optional(z.array(z.enum(["repositories"]).describe("Allowed values that can be passed to the exclude param.")).describe("Exclude attributes from the API response to improve performance")),
"repositories": z.array(z.string().describe("Repository path, owner and name"))
    })

export const migrationsStartForAuthenticatedUserMutationResponseSchema = migrationsStartForAuthenticatedUser201Schema

export const migrationsGetStatusForAuthenticatedUserPathParamsSchema = z.object({
    "migration_id": z.coerce.number().int().describe("The unique identifier of the migration.")
    })

export const migrationsGetStatusForAuthenticatedUserQueryParamsSchema = z.object({
    "exclude": z.optional(z.array(z.string()))
    }).optional()

/**
 * @description Response
 */
export const migrationsGetStatusForAuthenticatedUser200Schema = migrationSchema.describe("A migration.")

/**
 * @description Not modified
 */
export const migrationsGetStatusForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const migrationsGetStatusForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const migrationsGetStatusForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const migrationsGetStatusForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const migrationsGetStatusForAuthenticatedUserQueryResponseSchema = migrationsGetStatusForAuthenticatedUser200Schema

export const migrationsGetArchiveForAuthenticatedUserPathParamsSchema = z.object({
    "migration_id": z.coerce.number().int().describe("The unique identifier of the migration.")
    })

/**
 * @description Response
 */
export const migrationsGetArchiveForAuthenticatedUser302Schema = z.unknown()

/**
 * @description Not modified
 */
export const migrationsGetArchiveForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const migrationsGetArchiveForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const migrationsGetArchiveForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

export const migrationsGetArchiveForAuthenticatedUserQueryResponseSchema = z.unknown()

export const migrationsDeleteArchiveForAuthenticatedUserPathParamsSchema = z.object({
    "migration_id": z.coerce.number().int().describe("The unique identifier of the migration.")
    })

/**
 * @description Response
 */
export const migrationsDeleteArchiveForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Not modified
 */
export const migrationsDeleteArchiveForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const migrationsDeleteArchiveForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const migrationsDeleteArchiveForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const migrationsDeleteArchiveForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const migrationsDeleteArchiveForAuthenticatedUserMutationResponseSchema = migrationsDeleteArchiveForAuthenticatedUser204Schema

export const migrationsUnlockRepoForAuthenticatedUserPathParamsSchema = z.object({
    "migration_id": z.coerce.number().int().describe("The unique identifier of the migration."),
"repo_name": z.string().describe("repo_name parameter")
    })

/**
 * @description Response
 */
export const migrationsUnlockRepoForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Not modified
 */
export const migrationsUnlockRepoForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const migrationsUnlockRepoForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const migrationsUnlockRepoForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const migrationsUnlockRepoForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const migrationsUnlockRepoForAuthenticatedUserMutationResponseSchema = migrationsUnlockRepoForAuthenticatedUser204Schema

export const migrationsListReposForAuthenticatedUserPathParamsSchema = z.object({
    "migration_id": z.coerce.number().int().describe("The unique identifier of the migration.")
    })

export const migrationsListReposForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const migrationsListReposForAuthenticatedUser200Schema = z.array(minimalRepositorySchema.describe("Minimal Repository"))

/**
 * @description Resource not found
 */
export const migrationsListReposForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const migrationsListReposForAuthenticatedUserQueryResponseSchema = migrationsListReposForAuthenticatedUser200Schema

export const orgsListForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const orgsListForAuthenticatedUser200Schema = z.array(organizationSimpleSchema.describe("A GitHub organization."))

/**
 * @description Not modified
 */
export const orgsListForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const orgsListForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const orgsListForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

export const orgsListForAuthenticatedUserQueryResponseSchema = orgsListForAuthenticatedUser200Schema

export const packagesListPackagesForAuthenticatedUserQueryParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"visibility": z.optional(z.enum(["public", "private", "internal"]).describe("The selected visibility of the packages.  This parameter is optional and only filters an existing result set.\n\nThe `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.\nFor the list of GitHub Packages registries that support granular permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"")),
"page": z.optional(z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"per_page": z.optional(z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""))
    })

/**
 * @description Response
 */
export const packagesListPackagesForAuthenticatedUser200Schema = z.array(packageSchema.describe("A software package"))

/**
 * @description The value of `per_page` multiplied by `page` cannot be greater than 10000.
 */
export const packagesListPackagesForAuthenticatedUser400Schema = z.unknown()

export const packagesListPackagesForAuthenticatedUserQueryResponseSchema = packagesListPackagesForAuthenticatedUser200Schema

export const packagesGetPackageForAuthenticatedUserPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package.")
    })

/**
 * @description Response
 */
export const packagesGetPackageForAuthenticatedUser200Schema = packageSchema.describe("A software package")

export const packagesGetPackageForAuthenticatedUserQueryResponseSchema = packagesGetPackageForAuthenticatedUser200Schema

export const packagesDeletePackageForAuthenticatedUserPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package.")
    })

/**
 * @description Response
 */
export const packagesDeletePackageForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const packagesDeletePackageForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesDeletePackageForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const packagesDeletePackageForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const packagesDeletePackageForAuthenticatedUserMutationResponseSchema = packagesDeletePackageForAuthenticatedUser204Schema

export const packagesRestorePackageForAuthenticatedUserPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package.")
    })

export const packagesRestorePackageForAuthenticatedUserQueryParamsSchema = z.object({
    "token": z.optional(z.string().describe("package token"))
    }).optional()

/**
 * @description Response
 */
export const packagesRestorePackageForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const packagesRestorePackageForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesRestorePackageForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const packagesRestorePackageForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const packagesRestorePackageForAuthenticatedUserMutationResponseSchema = packagesRestorePackageForAuthenticatedUser204Schema

export const packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package.")
    })

export const packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQueryParamsSchema = z.object({
    "page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"state": z.enum(["active", "deleted"]).default("active").describe("The state of the package, either active or deleted.")
    })

/**
 * @description Response
 */
export const packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser200Schema = z.array(packageVersionSchema.describe("A version of a software package"))

/**
 * @description Requires authentication
 */
export const packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQueryResponseSchema = packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser200Schema

export const packagesGetPackageVersionForAuthenticatedUserPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"package_version_id": z.coerce.number().int().describe("Unique identifier of the package version.")
    })

/**
 * @description Response
 */
export const packagesGetPackageVersionForAuthenticatedUser200Schema = packageVersionSchema.describe("A version of a software package")

export const packagesGetPackageVersionForAuthenticatedUserQueryResponseSchema = packagesGetPackageVersionForAuthenticatedUser200Schema

export const packagesDeletePackageVersionForAuthenticatedUserPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"package_version_id": z.coerce.number().int().describe("Unique identifier of the package version.")
    })

/**
 * @description Response
 */
export const packagesDeletePackageVersionForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const packagesDeletePackageVersionForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesDeletePackageVersionForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const packagesDeletePackageVersionForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const packagesDeletePackageVersionForAuthenticatedUserMutationResponseSchema = packagesDeletePackageVersionForAuthenticatedUser204Schema

export const packagesRestorePackageVersionForAuthenticatedUserPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"package_version_id": z.coerce.number().int().describe("Unique identifier of the package version.")
    })

/**
 * @description Response
 */
export const packagesRestorePackageVersionForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const packagesRestorePackageVersionForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesRestorePackageVersionForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const packagesRestorePackageVersionForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const packagesRestorePackageVersionForAuthenticatedUserMutationResponseSchema = packagesRestorePackageVersionForAuthenticatedUser204Schema

/**
 * @description Response
 */
export const projectsClassicCreateForAuthenticatedUser201Schema = projectSchema.describe("Projects are a way to organize columns and cards of work.")

/**
 * @description Not modified
 */
export const projectsClassicCreateForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsClassicCreateForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsClassicCreateForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const projectsClassicCreateForAuthenticatedUser422Schema = validationErrorSimpleSchema.describe("Validation Error Simple")

export const projectsClassicCreateForAuthenticatedUserMutationRequestSchema = z.object({
    "name": z.string().describe("Name of the project"),
"body": z.string().describe("Body of the project").nullish()
    })

export const projectsClassicCreateForAuthenticatedUserMutationResponseSchema = projectsClassicCreateForAuthenticatedUser201Schema

export const usersListPublicEmailsForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const usersListPublicEmailsForAuthenticatedUser200Schema = z.array(emailSchema.describe("Email"))

/**
 * @description Not modified
 */
export const usersListPublicEmailsForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersListPublicEmailsForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersListPublicEmailsForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersListPublicEmailsForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const usersListPublicEmailsForAuthenticatedUserQueryResponseSchema = usersListPublicEmailsForAuthenticatedUser200Schema

export const reposListForAuthenticatedUserQueryParamsSchema = z.object({
    "visibility": z.enum(["all", "public", "private"]).default("all").describe("Limit results to repositories with the specified visibility."),
"affiliation": z.string().default("owner,collaborator,organization_member").describe("Comma-separated list of values. Can include:  \n * `owner`: Repositories that are owned by the authenticated user.  \n * `collaborator`: Repositories that the user has been added to as a collaborator.  \n * `organization_member`: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on."),
"type": z.enum(["all", "owner", "public", "private", "member"]).default("all").describe("Limit results to repositories of the specified type. Will cause a `422` error if used in the same request as **visibility** or **affiliation**."),
"sort": z.enum(["created", "updated", "pushed", "full_name"]).default("full_name").describe("The property to sort the results by."),
"direction": z.optional(z.enum(["asc", "desc"]).describe("The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"since": z.optional(z.iso.datetime({ offset: true }).describe("Only show repositories updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"before": z.optional(z.iso.datetime({ offset: true }).describe("Only show repositories updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."))
    })

/**
 * @description Response
 */
export const reposListForAuthenticatedUser200Schema = z.array(repositorySchema.describe("A repository on GitHub."))

/**
 * @description Not modified
 */
export const reposListForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const reposListForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const reposListForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposListForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const reposListForAuthenticatedUserQueryResponseSchema = reposListForAuthenticatedUser200Schema

/**
 * @description Response
 */
export const reposCreateForAuthenticatedUser201Schema = fullRepositorySchema.describe("Full Repository")

/**
 * @description Not modified
 */
export const reposCreateForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Bad Request
 */
export const reposCreateForAuthenticatedUser400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Requires authentication
 */
export const reposCreateForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const reposCreateForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposCreateForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const reposCreateForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const reposCreateForAuthenticatedUserMutationRequestSchema = z.object({
    "name": z.string().describe("The name of the repository."),
"description": z.optional(z.string().describe("A short description of the repository.")),
"homepage": z.optional(z.string().describe("A URL with more information about the repository.")),
"private": z.optional(z.boolean().default(false).describe("Whether the repository is private.")),
"has_issues": z.optional(z.boolean().default(true).describe("Whether issues are enabled.")),
"has_projects": z.optional(z.boolean().default(true).describe("Whether projects are enabled.")),
"has_wiki": z.optional(z.boolean().default(true).describe("Whether the wiki is enabled.")),
"has_discussions": z.optional(z.boolean().default(false).describe("Whether discussions are enabled.")),
"team_id": z.optional(z.int().describe("The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.")),
"auto_init": z.optional(z.boolean().default(false).describe("Whether the repository is initialized with a minimal README.")),
"gitignore_template": z.optional(z.string().describe("The desired language or platform to apply to the .gitignore.")),
"license_template": z.optional(z.string().describe("The license keyword of the open source license for this repository.")),
"allow_squash_merge": z.optional(z.boolean().default(true).describe("Whether to allow squash merges for pull requests.")),
"allow_merge_commit": z.optional(z.boolean().default(true).describe("Whether to allow merge commits for pull requests.")),
"allow_rebase_merge": z.optional(z.boolean().default(true).describe("Whether to allow rebase merges for pull requests.")),
"allow_auto_merge": z.optional(z.boolean().default(false).describe("Whether to allow Auto-merge to be used on pull requests.")),
"delete_branch_on_merge": z.optional(z.boolean().default(false).describe("Whether to delete head branches when pull requests are merged")),
"squash_merge_commit_title": z.optional(z.enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"]).describe("Required when using `squash_merge_commit_message`.\n\nThe default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")),
"squash_merge_commit_message": z.optional(z.enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"]).describe("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")),
"merge_commit_title": z.optional(z.enum(["PR_TITLE", "MERGE_MESSAGE"]).describe("Required when using `merge_commit_message`.\n\nThe default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")),
"merge_commit_message": z.optional(z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).describe("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")),
"has_downloads": z.optional(z.boolean().default(true).describe("Whether downloads are enabled.")),
"is_template": z.optional(z.boolean().default(false).describe("Whether this repository acts as a template that can be used to generate new repositories."))
    })

export const reposCreateForAuthenticatedUserMutationResponseSchema = reposCreateForAuthenticatedUser201Schema

export const reposListInvitationsForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListInvitationsForAuthenticatedUser200Schema = z.array(repositoryInvitationSchema.describe("Repository invitations let you manage who you collaborate with."))

/**
 * @description Not modified
 */
export const reposListInvitationsForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const reposListInvitationsForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const reposListInvitationsForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposListInvitationsForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const reposListInvitationsForAuthenticatedUserQueryResponseSchema = reposListInvitationsForAuthenticatedUser200Schema

export const reposAcceptInvitationForAuthenticatedUserPathParamsSchema = z.object({
    "invitation_id": z.coerce.number().int().describe("The unique identifier of the invitation.")
    })

/**
 * @description Response
 */
export const reposAcceptInvitationForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Not modified
 */
export const reposAcceptInvitationForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const reposAcceptInvitationForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposAcceptInvitationForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const reposAcceptInvitationForAuthenticatedUser409Schema = basicErrorSchema.describe("Basic Error")

export const reposAcceptInvitationForAuthenticatedUserMutationResponseSchema = reposAcceptInvitationForAuthenticatedUser204Schema

export const reposDeclineInvitationForAuthenticatedUserPathParamsSchema = z.object({
    "invitation_id": z.coerce.number().int().describe("The unique identifier of the invitation.")
    })

/**
 * @description Response
 */
export const reposDeclineInvitationForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Not modified
 */
export const reposDeclineInvitationForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const reposDeclineInvitationForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const reposDeclineInvitationForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Conflict
 */
export const reposDeclineInvitationForAuthenticatedUser409Schema = basicErrorSchema.describe("Basic Error")

export const reposDeclineInvitationForAuthenticatedUserMutationResponseSchema = reposDeclineInvitationForAuthenticatedUser204Schema

export const usersListSocialAccountsForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const usersListSocialAccountsForAuthenticatedUser200Schema = z.array(socialAccountSchema.describe("Social media account"))

/**
 * @description Not modified
 */
export const usersListSocialAccountsForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersListSocialAccountsForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersListSocialAccountsForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersListSocialAccountsForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const usersListSocialAccountsForAuthenticatedUserQueryResponseSchema = usersListSocialAccountsForAuthenticatedUser200Schema

/**
 * @description Response
 */
export const usersAddSocialAccountForAuthenticatedUser201Schema = z.array(socialAccountSchema.describe("Social media account"))

/**
 * @description Not modified
 */
export const usersAddSocialAccountForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersAddSocialAccountForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersAddSocialAccountForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersAddSocialAccountForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const usersAddSocialAccountForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const usersAddSocialAccountForAuthenticatedUserMutationRequestSchema = z.object({
    "account_urls": z.array(z.string()).describe("Full URLs for the social media profiles to add.")
    })

export const usersAddSocialAccountForAuthenticatedUserMutationResponseSchema = usersAddSocialAccountForAuthenticatedUser201Schema

/**
 * @description Response
 */
export const usersDeleteSocialAccountForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Not modified
 */
export const usersDeleteSocialAccountForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersDeleteSocialAccountForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersDeleteSocialAccountForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersDeleteSocialAccountForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const usersDeleteSocialAccountForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const usersDeleteSocialAccountForAuthenticatedUserMutationRequestSchema = z.object({
    "account_urls": z.array(z.string()).describe("Full URLs for the social media profiles to delete.")
    })

export const usersDeleteSocialAccountForAuthenticatedUserMutationResponseSchema = usersDeleteSocialAccountForAuthenticatedUser204Schema

export const usersListSshSigningKeysForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const usersListSshSigningKeysForAuthenticatedUser200Schema = z.array(sshSigningKeySchema.describe("A public SSH key used to sign Git commits"))

/**
 * @description Not modified
 */
export const usersListSshSigningKeysForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersListSshSigningKeysForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersListSshSigningKeysForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersListSshSigningKeysForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const usersListSshSigningKeysForAuthenticatedUserQueryResponseSchema = usersListSshSigningKeysForAuthenticatedUser200Schema

/**
 * @description Response
 */
export const usersCreateSshSigningKeyForAuthenticatedUser201Schema = sshSigningKeySchema.describe("A public SSH key used to sign Git commits")

/**
 * @description Not modified
 */
export const usersCreateSshSigningKeyForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersCreateSshSigningKeyForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersCreateSshSigningKeyForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersCreateSshSigningKeyForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const usersCreateSshSigningKeyForAuthenticatedUser422Schema = validationErrorSchema.describe("Validation Error")

export const usersCreateSshSigningKeyForAuthenticatedUserMutationRequestSchema = z.object({
    "title": z.optional(z.string().describe("A descriptive name for the new key.")),
"key": z.string().regex(/^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) |^(sk-ssh-ed25519|sk-ecdsa-sha2-nistp256)@openssh.com /).describe("The public SSH key to add to your GitHub account. For more information, see \"[Checking for existing SSH keys](https://docs.github.com/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys).\"")
    })

export const usersCreateSshSigningKeyForAuthenticatedUserMutationResponseSchema = usersCreateSshSigningKeyForAuthenticatedUser201Schema

export const usersGetSshSigningKeyForAuthenticatedUserPathParamsSchema = z.object({
    "ssh_signing_key_id": z.coerce.number().int().describe("The unique identifier of the SSH signing key.")
    })

/**
 * @description Response
 */
export const usersGetSshSigningKeyForAuthenticatedUser200Schema = sshSigningKeySchema.describe("A public SSH key used to sign Git commits")

/**
 * @description Not modified
 */
export const usersGetSshSigningKeyForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersGetSshSigningKeyForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersGetSshSigningKeyForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersGetSshSigningKeyForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const usersGetSshSigningKeyForAuthenticatedUserQueryResponseSchema = usersGetSshSigningKeyForAuthenticatedUser200Schema

export const usersDeleteSshSigningKeyForAuthenticatedUserPathParamsSchema = z.object({
    "ssh_signing_key_id": z.coerce.number().int().describe("The unique identifier of the SSH signing key.")
    })

/**
 * @description Response
 */
export const usersDeleteSshSigningKeyForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Not modified
 */
export const usersDeleteSshSigningKeyForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const usersDeleteSshSigningKeyForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const usersDeleteSshSigningKeyForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersDeleteSshSigningKeyForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const usersDeleteSshSigningKeyForAuthenticatedUserMutationResponseSchema = usersDeleteSshSigningKeyForAuthenticatedUser204Schema

export const activityListReposStarredByAuthenticatedUserQueryParamsSchema = z.object({
    "sort": z.enum(["created", "updated"]).default("created").describe("The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to."),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListReposStarredByAuthenticatedUser200Schema = z.array(repositorySchema.describe("A repository on GitHub."))

/**
 * @description Not modified
 */
export const activityListReposStarredByAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const activityListReposStarredByAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const activityListReposStarredByAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

export const activityListReposStarredByAuthenticatedUserQueryResponseSchema = activityListReposStarredByAuthenticatedUser200Schema

export const activityCheckRepoIsStarredByAuthenticatedUserPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response if this repository is starred by you
 */
export const activityCheckRepoIsStarredByAuthenticatedUser204Schema = z.unknown()

/**
 * @description Not modified
 */
export const activityCheckRepoIsStarredByAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const activityCheckRepoIsStarredByAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const activityCheckRepoIsStarredByAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Not Found if this repository is not starred by you
 */
export const activityCheckRepoIsStarredByAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const activityCheckRepoIsStarredByAuthenticatedUserQueryResponseSchema = activityCheckRepoIsStarredByAuthenticatedUser204Schema

export const activityStarRepoForAuthenticatedUserPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const activityStarRepoForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Not modified
 */
export const activityStarRepoForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const activityStarRepoForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const activityStarRepoForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const activityStarRepoForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const activityStarRepoForAuthenticatedUserMutationResponseSchema = activityStarRepoForAuthenticatedUser204Schema

export const activityUnstarRepoForAuthenticatedUserPathParamsSchema = z.object({
    "owner": z.string().describe("The account owner of the repository. The name is not case sensitive."),
"repo": z.string().describe("The name of the repository without the `.git` extension. The name is not case sensitive.")
    })

/**
 * @description Response
 */
export const activityUnstarRepoForAuthenticatedUser204Schema = z.unknown()

/**
 * @description Not modified
 */
export const activityUnstarRepoForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const activityUnstarRepoForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const activityUnstarRepoForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const activityUnstarRepoForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const activityUnstarRepoForAuthenticatedUserMutationResponseSchema = activityUnstarRepoForAuthenticatedUser204Schema

export const activityListWatchedReposForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListWatchedReposForAuthenticatedUser200Schema = z.array(minimalRepositorySchema.describe("Minimal Repository"))

/**
 * @description Not modified
 */
export const activityListWatchedReposForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const activityListWatchedReposForAuthenticatedUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const activityListWatchedReposForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

export const activityListWatchedReposForAuthenticatedUserQueryResponseSchema = activityListWatchedReposForAuthenticatedUser200Schema

export const teamsListForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const teamsListForAuthenticatedUser200Schema = z.array(teamFullSchema.describe("Groups of organization members that gives permissions on specified repositories."))

/**
 * @description Not modified
 */
export const teamsListForAuthenticatedUser304Schema = z.unknown()

/**
 * @description Forbidden
 */
export const teamsListForAuthenticatedUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const teamsListForAuthenticatedUser404Schema = basicErrorSchema.describe("Basic Error")

export const teamsListForAuthenticatedUserQueryResponseSchema = teamsListForAuthenticatedUser200Schema

export const usersGetByIdPathParamsSchema = z.object({
    "account_id": z.coerce.number().int().describe("account_id parameter")
    })

/**
 * @description Response
 */
export const usersGetById200Schema = z.union([publicUserSchema.and(z.object({
    "user_view_type": z.literal("public")
    })), privateUserSchema.and(z.object({
    "user_view_type": z.literal("private")
    }))])

/**
 * @description Resource not found
 */
export const usersGetById404Schema = basicErrorSchema.describe("Basic Error")

export const usersGetByIdQueryResponseSchema = usersGetById200Schema

export const usersListQueryParamsSchema = z.object({
    "since": z.optional(z.coerce.number().int().describe("A user ID. Only return users with an ID greater than this ID.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const usersList200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

/**
 * @description Not modified
 */
export const usersList304Schema = z.unknown()

export const usersListQueryResponseSchema = usersList200Schema

export const usersGetByUsernamePathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const usersGetByUsername200Schema = z.union([publicUserSchema.and(z.object({
    "user_view_type": z.literal("public")
    })), privateUserSchema.and(z.object({
    "user_view_type": z.literal("private")
    }))])

/**
 * @description Resource not found
 */
export const usersGetByUsername404Schema = basicErrorSchema.describe("Basic Error")

export const usersGetByUsernameQueryResponseSchema = usersGetByUsername200Schema

export const usersListAttestationsBulkPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const usersListAttestationsBulkQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""))
    })

/**
 * @description Response
 */
export const usersListAttestationsBulk200Schema = z.object({
    "attestations_subject_digests": z.optional(z.object({
    
    }).catchall(z.array(z.object({
    "bundle": z.optional(z.object({
    "mediaType": z.optional(z.string()),
"verificationMaterial": z.optional(z.object({
    
    }).catchall(z.unknown())),
"dsseEnvelope": z.optional(z.object({
    
    }).catchall(z.unknown()))
    }).describe("The bundle of the attestation.")),
"repository_id": z.optional(z.int()),
"bundle_url": z.optional(z.string())
    })).nullable()).describe("Mapping of subject digest to bundles.")),
"page_info": z.optional(z.object({
    "has_next": z.optional(z.boolean().describe("Indicates whether there is a next page.")),
"has_previous": z.optional(z.boolean().describe("Indicates whether there is a previous page.")),
"next": z.optional(z.string().describe("The cursor to the next page.")),
"previous": z.optional(z.string().describe("The cursor to the previous page."))
    }).describe("Information about the current page."))
    })

export const usersListAttestationsBulkMutationRequestSchema = z.object({
    "subject_digests": z.array(z.string()).min(1).max(1024).describe("List of subject digests to fetch attestations for."),
"predicate_type": z.optional(z.string().describe("Optional filter for fetching attestations with a given predicate type.\nThis option accepts `provenance`, `sbom`, `release`, or freeform text\nfor custom predicate types."))
    })

export const usersListAttestationsBulkMutationResponseSchema = usersListAttestationsBulk200Schema

export const usersDeleteAttestationsBulkPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const usersDeleteAttestationsBulk200Schema = z.unknown()

/**
 * @description Resource not found
 */
export const usersDeleteAttestationsBulk404Schema = basicErrorSchema.describe("Basic Error")

export const usersDeleteAttestationsBulkMutationRequestSchema = z.union([z.object({
    "subject_digests": z.array(z.string()).min(1).max(1024).describe("List of subject digests associated with the artifact attestations to delete.")
    }), z.object({
    "attestation_ids": z.array(z.int()).min(1).max(1024).describe("List of unique IDs associated with the artifact attestations to delete.")
    })]).describe("The request body must include either `subject_digests` or `attestation_ids`, but not both.")

export const usersDeleteAttestationsBulkMutationResponseSchema = usersDeleteAttestationsBulk200Schema

export const usersDeleteAttestationsBySubjectDigestPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account."),
"subject_digest": z.string().describe("Subject Digest")
    })

/**
 * @description Response
 */
export const usersDeleteAttestationsBySubjectDigest200Schema = z.unknown()

/**
 * @description Response
 */
export const usersDeleteAttestationsBySubjectDigest204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const usersDeleteAttestationsBySubjectDigest404Schema = basicErrorSchema.describe("Basic Error")

export const usersDeleteAttestationsBySubjectDigestMutationResponseSchema = z.union([usersDeleteAttestationsBySubjectDigest200Schema, usersDeleteAttestationsBySubjectDigest204Schema])

export const usersDeleteAttestationsByIdPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account."),
"attestation_id": z.coerce.number().int().describe("Attestation ID")
    })

/**
 * @description Response
 */
export const usersDeleteAttestationsById200Schema = z.unknown()

/**
 * @description Response
 */
export const usersDeleteAttestationsById204Schema = z.unknown()

/**
 * @description Forbidden
 */
export const usersDeleteAttestationsById403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const usersDeleteAttestationsById404Schema = basicErrorSchema.describe("Basic Error")

export const usersDeleteAttestationsByIdMutationResponseSchema = z.union([usersDeleteAttestationsById200Schema, usersDeleteAttestationsById204Schema])

export const usersListAttestationsPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account."),
"subject_digest": z.string().describe("Subject Digest")
    })

export const usersListAttestationsQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"predicate_type": z.optional(z.string().describe("Optional filter for fetching attestations with a given predicate type.\nThis option accepts `provenance`, `sbom`, `release`, or freeform text\nfor custom predicate types."))
    })

/**
 * @description Response
 */
export const usersListAttestations200Schema = z.object({
    "attestations": z.optional(z.array(z.object({
    "bundle": z.optional(z.object({
    "mediaType": z.optional(z.string()),
"verificationMaterial": z.optional(z.object({
    
    }).catchall(z.unknown())),
"dsseEnvelope": z.optional(z.object({
    
    }).catchall(z.unknown()))
    }).describe("The attestation's Sigstore Bundle.\nRefer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information.")),
"repository_id": z.optional(z.int()),
"bundle_url": z.optional(z.string()),
"initiator": z.optional(z.string())
    })))
    })

/**
 * @description Response
 */
export const usersListAttestations201Schema = emptyObjectSchema.describe("An object without any properties.")

/**
 * @description Response
 */
export const usersListAttestations204Schema = z.unknown()

/**
 * @description Resource not found
 */
export const usersListAttestations404Schema = basicErrorSchema.describe("Basic Error")

export const usersListAttestationsQueryResponseSchema = z.union([usersListAttestations200Schema, usersListAttestations201Schema, usersListAttestations204Schema])

export const packagesListDockerMigrationConflictingPackagesForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const packagesListDockerMigrationConflictingPackagesForUser200Schema = z.array(packageSchema.describe("A software package"))

/**
 * @description Requires authentication
 */
export const packagesListDockerMigrationConflictingPackagesForUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesListDockerMigrationConflictingPackagesForUser403Schema = basicErrorSchema.describe("Basic Error")

export const packagesListDockerMigrationConflictingPackagesForUserQueryResponseSchema = packagesListDockerMigrationConflictingPackagesForUser200Schema

export const activityListEventsForAuthenticatedUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const activityListEventsForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListEventsForAuthenticatedUser200Schema = z.array(eventSchema.describe("Event"))

export const activityListEventsForAuthenticatedUserQueryResponseSchema = activityListEventsForAuthenticatedUser200Schema

export const activityListOrgEventsForAuthenticatedUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account."),
"org": z.string().describe("The organization name. The name is not case sensitive.")
    })

export const activityListOrgEventsForAuthenticatedUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListOrgEventsForAuthenticatedUser200Schema = z.array(eventSchema.describe("Event"))

export const activityListOrgEventsForAuthenticatedUserQueryResponseSchema = activityListOrgEventsForAuthenticatedUser200Schema

export const activityListPublicEventsForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const activityListPublicEventsForUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListPublicEventsForUser200Schema = z.array(eventSchema.describe("Event"))

export const activityListPublicEventsForUserQueryResponseSchema = activityListPublicEventsForUser200Schema

export const usersListFollowersForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const usersListFollowersForUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const usersListFollowersForUser200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

export const usersListFollowersForUserQueryResponseSchema = usersListFollowersForUser200Schema

export const usersListFollowingForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const usersListFollowingForUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const usersListFollowingForUser200Schema = z.array(simpleUserSchema.describe("A GitHub user."))

export const usersListFollowingForUserQueryResponseSchema = usersListFollowingForUser200Schema

export const usersCheckFollowingForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account."),
"target_user": z.string()
    })

/**
 * @description if the user follows the target user
 */
export const usersCheckFollowingForUser204Schema = z.unknown()

/**
 * @description if the user does not follow the target user
 */
export const usersCheckFollowingForUser404Schema = z.unknown()

export const usersCheckFollowingForUserQueryResponseSchema = usersCheckFollowingForUser204Schema

export const gistsListForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const gistsListForUserQueryParamsSchema = z.object({
    "since": z.optional(z.iso.datetime({ offset: true }).describe("Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const gistsListForUser200Schema = z.array(baseGistSchema.describe("Base Gist"))

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const gistsListForUser422Schema = validationErrorSchema.describe("Validation Error")

export const gistsListForUserQueryResponseSchema = gistsListForUser200Schema

export const usersListGpgKeysForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const usersListGpgKeysForUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const usersListGpgKeysForUser200Schema = z.array(gpgKeySchema.describe("A unique encryption key"))

export const usersListGpgKeysForUserQueryResponseSchema = usersListGpgKeysForUser200Schema

export const usersGetContextForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const usersGetContextForUserQueryParamsSchema = z.object({
    "subject_type": z.optional(z.enum(["organization", "repository", "issue", "pull_request"]).describe("Identifies which additional information you'd like to receive about the person's hovercard. Can be `organization`, `repository`, `issue`, `pull_request`. **Required** when using `subject_id`.")),
"subject_id": z.optional(z.string().describe("Uses the ID for the `subject_type` you specified. **Required** when using `subject_type`."))
    }).optional()

/**
 * @description Response
 */
export const usersGetContextForUser200Schema = hovercardSchema.describe("Hovercard")

/**
 * @description Resource not found
 */
export const usersGetContextForUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const usersGetContextForUser422Schema = validationErrorSchema.describe("Validation Error")

export const usersGetContextForUserQueryResponseSchema = usersGetContextForUser200Schema

export const appsGetUserInstallationPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const appsGetUserInstallation200Schema = installationSchema.describe("Installation")

export const appsGetUserInstallationQueryResponseSchema = appsGetUserInstallation200Schema

export const usersListPublicKeysForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const usersListPublicKeysForUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const usersListPublicKeysForUser200Schema = z.array(keySimpleSchema.describe("Key Simple"))

export const usersListPublicKeysForUserQueryResponseSchema = usersListPublicKeysForUser200Schema

export const orgsListForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const orgsListForUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const orgsListForUser200Schema = z.array(organizationSimpleSchema.describe("A GitHub organization."))

export const orgsListForUserQueryResponseSchema = orgsListForUser200Schema

export const packagesListPackagesForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const packagesListPackagesForUserQueryParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"visibility": z.optional(z.enum(["public", "private", "internal"]).describe("The selected visibility of the packages.  This parameter is optional and only filters an existing result set.\n\nThe `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.\nFor the list of GitHub Packages registries that support granular permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"")),
"page": z.optional(z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"per_page": z.optional(z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""))
    })

/**
 * @description Response
 */
export const packagesListPackagesForUser200Schema = z.array(packageSchema.describe("A software package"))

/**
 * @description The value of `per_page` multiplied by `page` cannot be greater than 10000.
 */
export const packagesListPackagesForUser400Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const packagesListPackagesForUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesListPackagesForUser403Schema = basicErrorSchema.describe("Basic Error")

export const packagesListPackagesForUserQueryResponseSchema = packagesListPackagesForUser200Schema

export const packagesGetPackageForUserPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const packagesGetPackageForUser200Schema = packageSchema.describe("A software package")

export const packagesGetPackageForUserQueryResponseSchema = packagesGetPackageForUser200Schema

export const packagesDeletePackageForUserPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const packagesDeletePackageForUser204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const packagesDeletePackageForUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesDeletePackageForUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const packagesDeletePackageForUser404Schema = basicErrorSchema.describe("Basic Error")

export const packagesDeletePackageForUserMutationResponseSchema = packagesDeletePackageForUser204Schema

export const packagesRestorePackageForUserPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

export const packagesRestorePackageForUserQueryParamsSchema = z.object({
    "token": z.optional(z.string().describe("package token"))
    }).optional()

/**
 * @description Response
 */
export const packagesRestorePackageForUser204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const packagesRestorePackageForUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesRestorePackageForUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const packagesRestorePackageForUser404Schema = basicErrorSchema.describe("Basic Error")

export const packagesRestorePackageForUserMutationResponseSchema = packagesRestorePackageForUser204Schema

export const packagesGetAllPackageVersionsForPackageOwnedByUserPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const packagesGetAllPackageVersionsForPackageOwnedByUser200Schema = z.array(packageVersionSchema.describe("A version of a software package"))

/**
 * @description Requires authentication
 */
export const packagesGetAllPackageVersionsForPackageOwnedByUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesGetAllPackageVersionsForPackageOwnedByUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const packagesGetAllPackageVersionsForPackageOwnedByUser404Schema = basicErrorSchema.describe("Basic Error")

export const packagesGetAllPackageVersionsForPackageOwnedByUserQueryResponseSchema = packagesGetAllPackageVersionsForPackageOwnedByUser200Schema

export const packagesGetPackageVersionForUserPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"package_version_id": z.coerce.number().int().describe("Unique identifier of the package version."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const packagesGetPackageVersionForUser200Schema = packageVersionSchema.describe("A version of a software package")

export const packagesGetPackageVersionForUserQueryResponseSchema = packagesGetPackageVersionForUser200Schema

export const packagesDeletePackageVersionForUserPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"username": z.string().describe("The handle for the GitHub user account."),
"package_version_id": z.coerce.number().int().describe("Unique identifier of the package version.")
    })

/**
 * @description Response
 */
export const packagesDeletePackageVersionForUser204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const packagesDeletePackageVersionForUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesDeletePackageVersionForUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const packagesDeletePackageVersionForUser404Schema = basicErrorSchema.describe("Basic Error")

export const packagesDeletePackageVersionForUserMutationResponseSchema = packagesDeletePackageVersionForUser204Schema

export const packagesRestorePackageVersionForUserPathParamsSchema = z.object({
    "package_type": z.enum(["npm", "maven", "rubygems", "docker", "nuget", "container"]).describe("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry."),
"package_name": z.string().describe("The name of the package."),
"username": z.string().describe("The handle for the GitHub user account."),
"package_version_id": z.coerce.number().int().describe("Unique identifier of the package version.")
    })

/**
 * @description Response
 */
export const packagesRestorePackageVersionForUser204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const packagesRestorePackageVersionForUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const packagesRestorePackageVersionForUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const packagesRestorePackageVersionForUser404Schema = basicErrorSchema.describe("Basic Error")

export const packagesRestorePackageVersionForUserMutationResponseSchema = packagesRestorePackageVersionForUser204Schema

export const projectsClassicListForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const projectsClassicListForUserQueryParamsSchema = z.object({
    "state": z.enum(["open", "closed", "all"]).default("open").describe("Indicates the state of the projects to return."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const projectsClassicListForUser200Schema = z.array(projectSchema.describe("Projects are a way to organize columns and cards of work."))

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const projectsClassicListForUser422Schema = validationErrorSchema.describe("Validation Error")

export const projectsClassicListForUserQueryResponseSchema = projectsClassicListForUser200Schema

export const projectsListForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const projectsListForUserQueryParamsSchema = z.object({
    "q": z.optional(z.string().describe("Limit results to projects of the specified type.")),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const projectsListForUser200Schema = z.array(projectsV2Schema.describe("A projects v2 project"))

/**
 * @description Not modified
 */
export const projectsListForUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsListForUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsListForUser403Schema = basicErrorSchema.describe("Basic Error")

export const projectsListForUserQueryResponseSchema = projectsListForUser200Schema

export const projectsGetForUserPathParamsSchema = z.object({
    "project_number": z.coerce.number().int().describe("The project's number."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const projectsGetForUser200Schema = projectsV2Schema.describe("A projects v2 project")

/**
 * @description Not modified
 */
export const projectsGetForUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsGetForUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsGetForUser403Schema = basicErrorSchema.describe("Basic Error")

export const projectsGetForUserQueryResponseSchema = projectsGetForUser200Schema

export const projectsListFieldsForUserPathParamsSchema = z.object({
    "project_number": z.coerce.number().int().describe("The project's number."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

export const projectsListFieldsForUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""))
    })

/**
 * @description Response
 */
export const projectsListFieldsForUser200Schema = z.array(projectsV2FieldSchema.describe("A field inside a projects v2 project"))

/**
 * @description Not modified
 */
export const projectsListFieldsForUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsListFieldsForUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsListFieldsForUser403Schema = basicErrorSchema.describe("Basic Error")

export const projectsListFieldsForUserQueryResponseSchema = projectsListFieldsForUser200Schema

export const projectsGetFieldForUserPathParamsSchema = z.object({
    "project_number": z.coerce.number().int().describe("The project's number."),
"field_id": z.coerce.number().int().describe("The unique identifier of the field."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const projectsGetFieldForUser200Schema = projectsV2FieldSchema.describe("A field inside a projects v2 project")

/**
 * @description Not modified
 */
export const projectsGetFieldForUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsGetFieldForUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsGetFieldForUser403Schema = basicErrorSchema.describe("Basic Error")

export const projectsGetFieldForUserQueryResponseSchema = projectsGetFieldForUser200Schema

export const projectsListItemsForUserPathParamsSchema = z.object({
    "project_number": z.coerce.number().int().describe("The project's number."),
"username": z.string().describe("The handle for the GitHub user account.")
    })

export const projectsListItemsForUserQueryParamsSchema = z.object({
    "before": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"after": z.optional(z.string().describe("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"q": z.optional(z.string().describe("Search query to filter items, see [Filtering projects](https://docs.github.com/issues/planning-and-tracking-with-projects/customizing-views-in-your-project/filtering-projects) for more information.")),
"fields": z.optional(z.union([z.array(z.string()).max(50), z.string()]).describe("Limit results to specific fields, by their IDs. If not specified, the title field will be returned.\n\nExample: `fields[]=123&fields[]=456&fields[]=789` or `fields=123,456,789`"))
    })

/**
 * @description Response
 */
export const projectsListItemsForUser200Schema = z.array(projectsV2ItemWithContentSchema.describe("An item belonging to a project"))

/**
 * @description Not modified
 */
export const projectsListItemsForUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsListItemsForUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsListItemsForUser403Schema = basicErrorSchema.describe("Basic Error")

export const projectsListItemsForUserQueryResponseSchema = projectsListItemsForUser200Schema

export const projectsAddItemForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account."),
"project_number": z.coerce.number().int().describe("The project's number.")
    })

/**
 * @description Response
 */
export const projectsAddItemForUser201Schema = projectsV2ItemSimpleSchema.describe("An item belonging to a project")

/**
 * @description Not modified
 */
export const projectsAddItemForUser304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsAddItemForUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsAddItemForUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Details of the item to add to the project.
 */
export const projectsAddItemForUserMutationRequestSchema = z.object({
    "type": z.enum(["Issue", "PullRequest"]).describe("The type of item to add to the project. Must be either Issue or PullRequest."),
"id": z.int().describe("The numeric ID of the issue or pull request to add to the project.")
    })

export const projectsAddItemForUserMutationResponseSchema = projectsAddItemForUser201Schema

export const projectsGetUserItemPathParamsSchema = z.object({
    "project_number": z.coerce.number().int().describe("The project's number."),
"username": z.string().describe("The handle for the GitHub user account."),
"item_id": z.coerce.number().int().describe("The unique identifier of the project item.")
    })

export const projectsGetUserItemQueryParamsSchema = z.object({
    "fields": z.optional(z.union([z.array(z.string()).max(50), z.string()]).describe("Limit results to specific fields, by their IDs. If not specified, the title field will be returned.\n\nExample: fields[]=123&fields[]=456&fields[]=789 or fields=123,456,789"))
    }).optional()

/**
 * @description Response
 */
export const projectsGetUserItem200Schema = projectsV2ItemWithContentSchema.describe("An item belonging to a project")

/**
 * @description Not modified
 */
export const projectsGetUserItem304Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsGetUserItem401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsGetUserItem403Schema = basicErrorSchema.describe("Basic Error")

export const projectsGetUserItemQueryResponseSchema = projectsGetUserItem200Schema

export const projectsUpdateItemForUserPathParamsSchema = z.object({
    "project_number": z.coerce.number().int().describe("The project's number."),
"username": z.string().describe("The handle for the GitHub user account."),
"item_id": z.coerce.number().int().describe("The unique identifier of the project item.")
    })

/**
 * @description Response
 */
export const projectsUpdateItemForUser200Schema = projectsV2ItemWithContentSchema.describe("An item belonging to a project")

/**
 * @description Requires authentication
 */
export const projectsUpdateItemForUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsUpdateItemForUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const projectsUpdateItemForUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Validation failed, or the endpoint has been spammed.
 */
export const projectsUpdateItemForUser422Schema = validationErrorSchema.describe("Validation Error")

/**
 * @description Field updates to apply to the project item. Only text, number, date, single select, and iteration fields are supported.
 */
export const projectsUpdateItemForUserMutationRequestSchema = z.object({
    "fields": z.array(z.object({
    "id": z.int().describe("The ID of the project field to update."),
"value": z.nullable(z.union([z.string(), z.number()]).describe("The new value for the field:\n- For text, number, and date fields, provide the new value directly.\n- For single select and iteration fields, provide the ID of the option or iteration.\n- To clear the field, set this to null."))
    })).describe("A list of field updates to apply.")
    })

export const projectsUpdateItemForUserMutationResponseSchema = projectsUpdateItemForUser200Schema

export const projectsDeleteItemForUserPathParamsSchema = z.object({
    "project_number": z.coerce.number().int().describe("The project's number."),
"username": z.string().describe("The handle for the GitHub user account."),
"item_id": z.coerce.number().int().describe("The unique identifier of the project item.")
    })

/**
 * @description Response
 */
export const projectsDeleteItemForUser204Schema = z.unknown()

/**
 * @description Requires authentication
 */
export const projectsDeleteItemForUser401Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const projectsDeleteItemForUser403Schema = basicErrorSchema.describe("Basic Error")

export const projectsDeleteItemForUserMutationResponseSchema = projectsDeleteItemForUser204Schema

export const activityListReceivedEventsForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const activityListReceivedEventsForUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListReceivedEventsForUser200Schema = z.array(eventSchema.describe("Event"))

export const activityListReceivedEventsForUserQueryResponseSchema = activityListReceivedEventsForUser200Schema

export const activityListReceivedPublicEventsForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const activityListReceivedPublicEventsForUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListReceivedPublicEventsForUser200Schema = z.array(eventSchema.describe("Event"))

export const activityListReceivedPublicEventsForUserQueryResponseSchema = activityListReceivedPublicEventsForUser200Schema

export const reposListForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const reposListForUserQueryParamsSchema = z.object({
    "type": z.enum(["all", "owner", "member"]).default("owner").describe("Limit results to repositories of the specified type."),
"sort": z.enum(["created", "updated", "pushed", "full_name"]).default("full_name").describe("The property to sort the results by."),
"direction": z.optional(z.enum(["asc", "desc"]).describe("The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.")),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const reposListForUser200Schema = z.array(minimalRepositorySchema.describe("Minimal Repository"))

export const reposListForUserQueryResponseSchema = reposListForUser200Schema

export const billingGetGithubActionsBillingUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const billingGetGithubActionsBillingUser200Schema = actionsBillingUsageSchema

export const billingGetGithubActionsBillingUserQueryResponseSchema = billingGetGithubActionsBillingUser200Schema

export const billingGetGithubPackagesBillingUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const billingGetGithubPackagesBillingUser200Schema = packagesBillingUsageSchema

export const billingGetGithubPackagesBillingUserQueryResponseSchema = billingGetGithubPackagesBillingUser200Schema

export const billingGetGithubBillingPremiumRequestUsageReportUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const billingGetGithubBillingPremiumRequestUsageReportUserQueryParamsSchema = z.object({
    "year": z.optional(z.coerce.number().int().describe("If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year.")),
"month": z.optional(z.coerce.number().int().describe("If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. Default value is the current month. If no year is specified the default `year` is used.")),
"day": z.optional(z.coerce.number().int().describe("If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used.")),
"model": z.optional(z.string().describe("The model name to query usage for. The name is not case sensitive.")),
"product": z.optional(z.string().describe("The product name to query usage for. The name is not case sensitive."))
    }).optional()

/**
 * @description Response when getting a billing premium request usage report
 */
export const billingGetGithubBillingPremiumRequestUsageReportUser200Schema = billingPremiumRequestUsageReportUserSchema

/**
 * @description Bad Request
 */
export const billingGetGithubBillingPremiumRequestUsageReportUser400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const billingGetGithubBillingPremiumRequestUsageReportUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Resource not found
 */
export const billingGetGithubBillingPremiumRequestUsageReportUser404Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const billingGetGithubBillingPremiumRequestUsageReportUser500Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const billingGetGithubBillingPremiumRequestUsageReportUser503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const billingGetGithubBillingPremiumRequestUsageReportUserQueryResponseSchema = billingGetGithubBillingPremiumRequestUsageReportUser200Schema

export const billingGetSharedStorageBillingUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

/**
 * @description Response
 */
export const billingGetSharedStorageBillingUser200Schema = combinedBillingUsageSchema

export const billingGetSharedStorageBillingUserQueryResponseSchema = billingGetSharedStorageBillingUser200Schema

export const billingGetGithubBillingUsageReportUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const billingGetGithubBillingUsageReportUserQueryParamsSchema = z.object({
    "year": z.optional(z.coerce.number().int().describe("If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year.")),
"month": z.optional(z.coerce.number().int().describe("If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. If no year is specified the default `year` is used.")),
"day": z.optional(z.coerce.number().int().describe("If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used.")),
"hour": z.optional(z.coerce.number().int().describe("If specified, only return results for a single hour. The value of `hour` is an integer between `0` and `23`. If no `year`, `month`, or `day` is specified, the default `year`, `month`, and `day` are used."))
    }).optional()

/**
 * @description Response when getting a billing usage report
 */
export const billingGetGithubBillingUsageReportUser200Schema = billingUsageReportUserSchema

/**
 * @description Bad Request
 */
export const billingGetGithubBillingUsageReportUser400Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Forbidden
 */
export const billingGetGithubBillingUsageReportUser403Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Internal Error
 */
export const billingGetGithubBillingUsageReportUser500Schema = basicErrorSchema.describe("Basic Error")

/**
 * @description Service unavailable
 */
export const billingGetGithubBillingUsageReportUser503Schema = z.object({
    "code": z.optional(z.string()),
"message": z.optional(z.string()),
"documentation_url": z.optional(z.string())
    })

export const billingGetGithubBillingUsageReportUserQueryResponseSchema = billingGetGithubBillingUsageReportUser200Schema

export const usersListSocialAccountsForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const usersListSocialAccountsForUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const usersListSocialAccountsForUser200Schema = z.array(socialAccountSchema.describe("Social media account"))

export const usersListSocialAccountsForUserQueryResponseSchema = usersListSocialAccountsForUser200Schema

export const usersListSshSigningKeysForUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const usersListSshSigningKeysForUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const usersListSshSigningKeysForUser200Schema = z.array(sshSigningKeySchema.describe("A public SSH key used to sign Git commits"))

export const usersListSshSigningKeysForUserQueryResponseSchema = usersListSshSigningKeysForUser200Schema

export const activityListReposStarredByUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const activityListReposStarredByUserQueryParamsSchema = z.object({
    "sort": z.enum(["created", "updated"]).default("created").describe("The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to."),
"direction": z.enum(["asc", "desc"]).default("desc").describe("The direction to sort the results by."),
"per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListReposStarredByUser200Schema = z.union([z.array(starredRepositorySchema.describe("Starred Repository")), z.array(repositorySchema.describe("A repository on GitHub."))])

export const activityListReposStarredByUserQueryResponseSchema = activityListReposStarredByUser200Schema

export const activityListReposWatchedByUserPathParamsSchema = z.object({
    "username": z.string().describe("The handle for the GitHub user account.")
    })

export const activityListReposWatchedByUserQueryParamsSchema = z.object({
    "per_page": z.coerce.number().int().default(30).describe("The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""),
"page": z.coerce.number().int().default(1).describe("The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"")
    })

/**
 * @description Response
 */
export const activityListReposWatchedByUser200Schema = z.array(minimalRepositorySchema.describe("Minimal Repository"))

export const activityListReposWatchedByUserQueryResponseSchema = activityListReposWatchedByUser200Schema

/**
 * @description Response
 */
export const metaGetAllVersions200Schema = z.array(z.iso.date())

/**
 * @description Resource not found
 */
export const metaGetAllVersions404Schema = basicErrorSchema.describe("Basic Error")

export const metaGetAllVersionsQueryResponseSchema = metaGetAllVersions200Schema

/**
 * @description Response
 */
export const metaGetZen200Schema = z.string()

export const metaGetZenQueryResponseSchema = metaGetZen200Schema